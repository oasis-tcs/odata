[
  {
    "title": "Calculate Custom Aggregates from Aggregated Instances",
    "body": "A CustomAggregate annotation defines a dynamic property that can be used in the aggregate transformation. The current document states in [6.2.3 Custom Aggregates](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016600), second paragraph: “When applied to a structured type, the annotation specifies custom aggregates that are available for collections of _instances of that structured type_.”\n\nThis also means that a custom aggregate cannot be applied to an intermediate, already aggregated result produced by $apply transformations. Such a result consists of aggregated instances that are based on the structure of the instances from which they have been calculated ([4        Representation of Aggregated Instances](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016593)) and some properties from the originating type have been aggregated away.\n\nThis limits the applicability of custom aggregates and prevents requests for use cases like this example: For a custom aggregate “Amount”, determine the total amount for countries with a sales amount greater than X:\n\n`GET ~/Sales?$apply=groupby((Country),aggregate(Amount))/filter(Amount gt X)/aggregate(Amount)`\n\nThis can be a valid request under the assumption that `Amount` can be calculated for a set of aggregated instances each having a value for the `Amount` property.\n\n### Proposal\n\nInterpretation of this statement is too strict; it is actually intended to allow custom aggregates on intermediate results.\n\nState more precisely that custom aggregates are also available for aggregated instances created from the defining structure:\n\n“When applied to a structured type, the annotation specifies custom aggregates that are available for collections of instances of that structured type _or of aggregated instances resulting from these instances_.”\n\nImported from [ODATA-1349](https://issues.oasis-open.org/browse/ODATA-1349)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "CSDL MaxLength is ill-defined",
    "body": "7.2.2 MaxLength\n\n  \"A positive integer value specifying the maximum length of a binary, stream or string value. For binary or stream values this is the octet length of the binary data, for string values it is the character length.\"\n\nWhat does character mean here? (Unicode specs don't define character in any normative text).\n\n3.3 Primitive Types\n\n\"Edm.String Sequence of UTF-8 characters\"\n\nIf we combine 7.2.2 and 3.3, we might reasonably infer that MaxLength is the maximum valid length of a String value in UTF-8 encoding.\n\nIs this what the spec intended, in which case 7.2.2 should be clarified, or was it intended that 7.2.2 refer to UTF-16 code points or Unicode code points?\n\nSee also: https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n\nWhy does any of this matter? Consider a client, that wants to create an offline cache of data from a server (in a database, where columns need a specified maximum length). Or consider some other intermediary, which wants to allocate space for a buffer (e.g. malloc MaxLength+1 for a buffer to hold a Property value in a C program). It is important for such apps to be able to determine how much space to set aside to avoid accidental truncation of values. \n\nAdditionally, any client or other agent wishing to do validation of a Property value according to MaxLength, it makes huge difference whether this is done by UTF-8, UTF-16 or Unicode code points.\n\n\n### Proposal\n\nSection 3.3: replace \"UTF-8 characters\" with \"Unicode code points\" in table line for Edm.String.\n\nSection 7.2.2: replace \"character length\" with \"number of Unicode code points\".\n\nSections 7.2.5, 15.1 and 15.2: replace all (four) occurrences of \"Unicode character\" with \"Unicode code point\".\n\n \n\nImported from [ODATA-1348](https://issues.oasis-open.org/browse/ODATA-1348)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add an example showing a delta link and nested next link in the same response payload",
    "body": "Add an example showing a delta link and nested next link in the same response payload.\n\n### Proposal\n\n```json\n{\n  \"@context\": \"http://host/service/$metadata#Customers/$entity/$delta\",\n  ...\n  \"Orders@count\": 42,\n  \"Orders\": [ ... ],\n  \"Orders@nextLink\": \"...\",\n  ...\n  \"@deltaLink\": \"Customers?$deltatoken=...\",\n}\n```\n \n\nImported from [ODATA-1347](https://issues.oasis-open.org/browse/ODATA-1347)",
    "labels": [
      "JSON Format",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify handling of delta with $expand",
    "body": "Section [11.3.1 Delta Links](https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html#sec_DeltaLinks) describes handling of delta queries in combination with $expand, the relevant text is attached below. The highlighted sentence seems contradictory and should be clarified. It demands that the delta response must include changes to the expanded entities also for navigation properties expanded with $ref, whereas the following paragraph states that a delta query with a $ref expansion will ignore changes to changes to related entities.\n\n\"If the defining query includes expanded relationships, the delta link MUST return changes, additions, or deletions to the expanded entities, as well as added or deleted links to expanded entities or nested collections representing current membership. *This is independent of whether related entity themselves or only references to related entities were requested.* \n\nNavigation properties specified in the [$select](https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html#sec_SystemQueryOptionselect) list of a defining query are not used to define the scope or contents of the items being tracked. Clients can specify /$ref in [$expand](https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html#sec_SystemQueryOptionexpand) in order to specify interest in the set of related entities without interest in changes to the content of those related entities.“\n\n### Proposal\n\nchange the wording of the first cited paragraph to:\n\nIf the defining query includes expanded relationships, the delta link MUST return changes, additions, or deletions to the expanded entities, as well as added or deleted links to expanded entities or nested collections representing current membership. If the defining query includes expanded references, then the delta link MUST return changes to the membership in the set of expanded references.\n\nImported from [ODATA-1346](https://issues.oasis-open.org/browse/ODATA-1346)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Issues with ContextUrl",
    "body": "There are some issues and ambiguities in how we represent the request in the ContextUrl.\n\n1) From 10.9, \"If the context URL includes only expanded navigation properties (i.e., only navigation properties suffixed with parentheses), then all structural properties are implicitly selected (same as if there were no properties listed in the select-list).\"\n As a result, there is no way to say that a result contains only the expanded content and no selected properties.  This is not a huge issue, as our syntax today doesn't allow requesting only expanded properties, but it seems like it should.\n\n2) In 4.01 we say that, for expanded navigation properties with no expand options, the context URL contains the name of the navigation property suffixed with empty parens, and that this *MAY* be omitted in 4.0.  However, the 4.0 grammar prohibits the use of empty parens.\n\n\n### Proposal\n\nChange current text: \n\"For a 4.0 response, the expanded navigation property suffixed with parentheses MAY be omitted from the select-list if it does not contain a nested $select or $expand, but MUST still be present, without a suffix, if it is explicitly selected.\"\nto:\n\"For a 4.0 response, the expanded navigation property suffixed with parentheses is omitted from the select-list if it does not contain a nested $select or $expand, but MUST still be present, without a suffix, if it is explicitly selected.\"\n\n\nImported from [ODATA-1345](https://issues.oasis-open.org/browse/ODATA-1345)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove leftover wording regarding $expand within $select",
    "body": "Sections 10.7 and 10.8 describe the ContextURL for projected (collections of) entities.\n\nBoth sections include the wording \"... expands nested within $select are represented the same as expands outside of $select.\"\n\nThis is leftover wording from when we supported nesting $expand within $select. However, we removed such capability with [ODATA-1328](https://issues.oasis-open.org/browse/ODATA-1328), partially to avoid such ambiguity.\n\n### Proposal\n\nRemove old wording to avoid confusion. Since the described scenario can never happen, removing the sentence is a non-material, editorial change that helps avoid confusion, and can be addressed in an errata.\n\nImported from [ODATA-1344](https://issues.oasis-open.org/browse/ODATA-1344)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Multipart Batch Request Body example is missing required CRLF before first occurrence of boundary",
    "body": "In protocol spec v4.01, section 11.7.7.1 Multipart Batch Request Body example...\n\nAfter:\n\nContent-Length: ###\n\nthere is a single blank line (which is required to terminate the HTTP headers).\n\nNow RFC2046 states:\n\n   \"The boundary delimiter MUST occur at the beginning of a line, i.e.,\n   following a CRLF, and the initial CRLF is considered to be attached\n   to the boundary delimiter line rather than part of the preceding\n   part.  \"\n\nSo after the Content-Length: ### in the example should appear two blank lines (i.e. two CRLF pairs). The second CRLF pair will be the beginning of the first boundary occurrence.\n\nSimilarly after:\n\nContent-Type: multipart/mixed; boundary=changeset_77162fcd-b8da-41ac-a9f8-9357efbbd\n\nthere should be another blank line (CRLF pair), since one is required to end the headers and one is required to begin the boundary.\n\nand we must interpret that the CRLF pair after each of the two <JSON representation of XXX> occurrences in the example actually belongs to the boundary, not the JSON encoding.\n\nAlthough the examples are non-normative, they of course still need to be corrected.\n\nThe example shows two adjacent lines:\n\n--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd--\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\n\nwhich also should have a blank line between them.\n\nSimilar issues of missing CRLF pairs are apparent in all of the other batch request/response examples.\n\nAnd even missing in the multipart/alternative example in RFC2046 (see page 26 in https://tools.ietf.org/html/rfc2046).\n\nGiven that these examples appear in similar form in OData 4.0 spec as well as OData 4.01, there appears to be considerable scope for interoperability issues if existing 4.0 agents (which may be coded in accordance with the examples) are fixed in accordance with the RFC2046 prose.\n\nExamples in OData 2.0 spec are also missing a few CRLF pairs.\n\n\n### Proposal\n\nExample 103\n- Add additional empty line after GET header block, before delimiter line\n- Add closing delimiter line\n\nImported from [ODATA-1343](https://issues.oasis-open.org/browse/ODATA-1343)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Core.Ordered: mention \"Term\" in AppliesTo",
    "body": "Collection-valued terms may assign meaning to the order of items in the annotation value, e.g. a \"DefaultSortOrder\" term may describe the default sort order of a collection if no $orderby is specified. \n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1342](https://issues.oasis-open.org/browse/ODATA-1342)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that nested next links can appear on the same page as a delta link",
    "body": "In the protocol document we specify that a delta link can only appear on the last page of a result set indicating that a top level next link and delta link cannot be returned on the same page.  However, we don't say anything about nested next links.\n\nWe should clarify that nested next links are allowed on all pages but a delta link should only be returned for the top level query.\n\n### Proposal\n\nClarify that each page of results within a response can have either a nextlink or a deltalink but not both. Probably best to avoid the use of the word \"page\" as it is ambiguous. Maybe something like \"The delta payload, and each nested collection within the delta payload, may be paged. The delta link appears on the last page of each collection in place of the nextlink.\"\n\nAlso clarify that following nested next links within a delta payload typically doesn't result in a delta at the end-the delta is tracked by the top level response. Clients MAY request the delta link when requesting the nested content and, since it's a preference, the service MAY ignore it.\n\nThis should be a non-normative clarification.\n\nImported from [ODATA-1341](https://issues.oasis-open.org/browse/ODATA-1341)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make examples 8 (entity type) and 86 (record expression) consistent",
    "body": "Example 86 for record expressions wants to point out that there's no representation difference between structural properties and navigation properties. It does this so successfully that only the specification authors can tell which of the four properties are structural, and which are navigation :-)\n\nWe should give readers a hint.\n\n### Proposal\n\nExample 8: \n- Add navigation property \"CostCenter\"\n\nExample 86:\n- Reference example 8 in the example headline\n- Rename property \"GivenName\" to \"FirstName\" (FirstName is used in other examples)\n- Rename property \"SurName\" to \"LastName\" (LastName is used in another example)\n\nNote: this is a non-material change that only affects non-normative examples.\n\nImported from [ODATA-1339](https://issues.oasis-open.org/browse/ODATA-1339)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Additional representation of entity references using (alternate) key properties",
    "body": "Entity references are currently represented as a JSON object containing an `@id` member, e.g.\n```java\n{\n  \"@context\": \"https://foo/bar/$metadata#$ref\",\n  \"@id\": \"Orders(10643)\"\n}\n```\nAn easier-to-create and also easier-to-digest representation would be to include instead all properties from either the primary key or one of the [declared alternate keys](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AlternateKeys)):\n```java\n{\n  \"@context\": \"https://foo/bar/$metadata#Orders(quux)/$entity\",\n  \"quux\": 10643\n}\n```\nThis is similar to the V4.01 format for [deleted entities](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_DeletedEntity) in delta payloads. If properties other than the key properties are supplied, these are ignored - a reference is _not_ an implicit update.\n\n### Proposal\n\nAllow entity references to contain all key fields instead of `@id`.\n\nImported from [ODATA-1338](https://issues.oasis-open.org/browse/ODATA-1338)",
    "labels": [
      "JSON Format"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify use of @Core.ContentId in delta update",
    "body": "We added the @Core.ContentId annotation in order to enable annotating instances in an insert request to be correlated with results in the returned response.  We specifically call out its use in deep insert and deep update requests in [Protocol], but omit mentioning it in bulk (delta) update requests. \n\nIt's use in these cases is implied through deep insert and deep update, and from the description of the annotation, but we should add the same text to the delta update section.\n\n### Proposal\n\nAdd the same text to \"Update a Collection\", where we describe delta updates, as we currently have in sections describing deep insert and deep update.\n\nNote that the DeepInsert and DeepUpdate capabilities that describe support for ContentId should be relevant within a delta update request.\n\nProposed wording:\nClients MAY associate an id with individual nested entities in the request by using the Core.ContentID term defined in [OData-VocCore]. Services that respond with 200 OK SHOULD annotate the entities in the response using the same Core.ContentID value as specified in the request. \n\nServices SHOULD advertise support for updating a collection using a delta payload using the DeltaUpdateSupported property of the Capabilities.UpdateRestrictions vocabulary term, and SHOULD advertise support for returning the Core.ContentID in the response to a delta update through the Capabilities.DeepUpdateSupport term, both defined in [OData-VocCap]. \n\nImported from [ODATA-1337](https://issues.oasis-open.org/browse/ODATA-1337)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ABNF Does not allow selecting instance annotations",
    "body": "In the URL conventions document in section 5.1.4 it mentions in the text that $select can be used to select instance annotations.  However, the ABNF does not appear to allow this.\n\nAlso, the bulleted list in section 5.1.4 is missing mention of instance annotations.  The first bullet point should be updated to include instance annotations.\n\nImported from [ODATA-1335](https://issues.oasis-open.org/browse/ODATA-1335)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Mismatch in ModificationException term naming",
    "body": "In our last F2F we added a new term for annotating failed data modifications within a bulk (i.e., delta) payload. We went back and forth on the naming, and ended up with different names between the vocabulary and the protocol document.\n\nThe protocol document, in section 11.4.12, Update a Collection of Entities, refers to the \"Core.DataModificationException\".  However, the Core vocabulary defines \"ModificationException\" along with \"ModificationExceptionType\" and \"ModificationOperationKind\".\n\n### Proposal\n\na. Update the protocol document to refer to \"Core.ModificationException\", or\nb. Update the Core.Vocabulary to prefix \"Data\" to \"ModificationException\", \"ModificationExceptionType\", and \"ModificationOperationKind\"\n\nI kinda prefer the prefixed name (b), although it is slightly longer. However, the vocabulary changes are \"live\" where-as the protocol document has not yet been finalized, so b) would technically be a breaking change to anyone using the new vocabulary term, although it could be argued that it's unlikely that people are already using that term.\n\nImported from [ODATA-1334](https://issues.oasis-open.org/browse/ODATA-1334)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support augmenting entities with aggregated values from related entities",
    "body": "For a collection of entities having navigation paths to related entities, adding an aggregated value from the related entities to each entity in the collection today requires a first argument to groupby listing all properties. For example, to retrieve all products together with their total sales amount:\n\n`GET ~/Products?$apply=groupby((<key property>,<all other properties of type Product...>),aggregate(Sales/Amount with sum as TotalAmount))`\n\nreturns all entities from the Products entity collection whose structure now also includes a dynamic property TotalAmount. If the underlying type comprises many properties, this approach becomes rather clumsy.\n\nOptions to describe this request in a leaner way could be:\n A) Do the aggregation inside an expand transformation with a nested compute argument that operates on the entities of the navigation target. The determined result is then added to the result as expanded navigation property:\n `GET ~/Products?$apply=expand(Sales,compute(aggregate(Amount with sum) as TotalAmount))&$select=*,Sales/TotalAmount`\n\nreturns\n```java\n{  \n  \"@odata.context\": \"$metadata#Products\",  \n  \"value\": [\n    { \"ID\": ..., \"Name\": ...\", ...\n      \"Sales\": [{ \"TotalAmount\": ... }] },\n    ...\n  ]\n}\n```\n(this option requires an extension of expand to allow applying `compute` to related entities)\n\nB) Allow $it as first argument to groupby meaning that each entity of the input set becomes a separate subset on its own:\n `GET ~/Products?$appy=groupby($it,aggregate(Sales/Amount with sum as TotalAmount))`\n\nreturns\n```java\n{  \n  \"@odata.context\": \"$metadata#Products\",  \n  \"value\": [\n    { \"ID\": ..., \"Name\": ...\", ...\n      \"TotalAmount\": ... },\n    ...\n  ]\n}\n```\n\nImported from [ODATA-1332](https://issues.oasis-open.org/browse/ODATA-1332)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Override entity set when extending an entity container (public comment)",
    "body": "See [https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/odata-discussion/5g3mk2A7yG8/tluOLeO2AgAJ]\n \nWhat is the expected behavior when an Entity Container extends another Entity Container and there is an Entity Set with the same name in both? \nThe spec says: \"All children of the “base” entity container are added to the “extending” entity container.\" and \"An entity set is identified by its name, a simple identifier that MUST be unique within its entity container.\"\n \nDoes that mean this case is invalid?\n \nIIUC, 4.01 adds covariance, i.e., the ability for Structural Types to redeclare Properties defined in the base Structural Type with a subtype. It would be nice if the same were possible for Entity Containers, i.e., if an Entity Container that extends another Entity Container could redeclare Entity Sets with a subtype\n\n### Proposal\n\nSupport covariance in extending an entity container.  Existing entity sets/singletons can be redefined using types derived from the type defined in the extended entity container.\n\nImported from [ODATA-1331](https://issues.oasis-open.org/browse/ODATA-1331)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON Batch: explicitly state that continue-on-error=true is the default",
    "body": "In [19.4 Processing a Batch Request](https://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd05/odata-json-format-v4.01-csprd05.html#sec_ProcessingaBatchRequest) we state that\n> Clients [...] MAY specify the preference `continue-on-error=false`\n> \n\nThis sort of implies that the default is `true`. Better to explicitly say so.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1330](https://issues.oasis-open.org/browse/ODATA-1330)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON Batch: explicitly state that continue-on-error=true is the default",
    "body": "In [19.4 Processing a Batch Request](https://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd05/odata-json-format-v4.01-csprd05.html#sec_ProcessingaBatchRequest) we state that clients can specify the preference `continue-on-error=false`. This sort of implies that `true` is the default, but it doesn't explicitly say so.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1329](https://issues.oasis-open.org/browse/ODATA-1329)",
    "labels": [
      "JSON Format",
      "V4.01_CS02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Simplify query rules by removing $expand select option",
    "body": "In OData-1105 we added support for simplifying the syntax for selecting multiple fields from a complex type by introducing $select options, consistent with nested expand options. This also allowed us to specify other select options for collections, such as top, skip, count, and filter. \n\nUnfortunately, we also introduced $expand as a nested select option. Providing the ability to expand inside a select provides multiple ways to express the same thing in the same request, requiring rules to validate the combination of nested expands and regular expands that add complexity to the system with no added benefit.\n\n### Proposal\n\nRemove $expand from the set of allowable $select options.\n\nImported from [ODATA-1328](https://issues.oasis-open.org/browse/ODATA-1328)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Extend applicability of Core.MediaType and Core.AcceptableMediaTypes to non-stream (string/binary) properties and terms",
    "body": "We have some cases where the value of a String-typed Term may be expected to contain JSON, XML or SQL (i.e. the annotation values have a constrained media type).\n\nIt would be helpful if we could change the description of Core.MediaType and Core.AcceptableMediaTypes to state that it is also applicable to regular (non-stream) properties of type Edm.Binary or Edm.String, as well as changing the AppliesTo so those terms can be applicable to Term elements of type Edm.Binary or Edm.String.\n\n### Proposal\n\nChange the description of Core.MediaType and Core.AcceptableMediaTypes to state that it is also applicable to regular (non-stream) properties of type Edm.Binary or Edm.String, and change the AppliesTo so those terms can be applicable to Term elements of type Edm.Binary or Edm.String.\n\nImported from [ODATA-1327](https://issues.oasis-open.org/browse/ODATA-1327)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enhance syntax of term Validation.OpenPropertyTypeConstraint",
    "body": "Term [Validation.OpenPropertyTypeConstraint](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Validation.V1.md#OpenPropertyTypeConstraint) is of type `Collection(Core.QualifiedTypeName)`.\n\nThis is too restrictive, I'd also be able to specify that a dynamic property of an open type can be collection-valued.\n\n### Proposal\n\nAlso allow strings with `Collection(...)` as values of this term, where `...` is the qualified name of a type is scope.\n\nNote: this \"rhymes\" with the syntax of the `Type` attribute of CSDL XML, less so with the syntax of CSDL JSON.\n\nNote: resolved with [ODATA-1523](https://issues.oasis-open.org/browse/ODATA-1523)\n\nImported from [ODATA-1326](https://issues.oasis-open.org/browse/ODATA-1326)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Explicitly state server behaviour when a client uses $select/$expand for an update response",
    "body": "Clients need a guaranteed way to get certain information in the response to PATCH/PUT such as an updated ETag.  Clarify that if the client specifies a $select and/or $expand for the response of a PATCH/PUT request, that the server MUST respond with a a response body including the ETag.\n\n### Proposal\n\nClarify that if the client specifies a $select and/or $expand for the response of a PATCH/PUT request, that the server MUST respond with a a response body. If the service uses ETags for optimistic concurrency, the entities in the response MUST include ETags.\n\nImported from [ODATA-1325](https://issues.oasis-open.org/browse/ODATA-1325)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Incorrect text about mediaEditLink control information",
    "body": "In section 4.5.12 in JSON format doc, the text says that the mediaEditLink control information needs to be included if it differs from the id.  It should be if it differs from the conventional URL of the media stream.\n\n### Proposal\n\nReword to say that the mediaEditLink control information needs to be included if it differs from the conventional URL of the media stream.\n\nImported from [ODATA-1324](https://issues.oasis-open.org/browse/ODATA-1324)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify representation of GEO literals and streams in annotations (XML, JSON)",
    "body": "Section 14.3 Constant Expression defines representations for primitive constant values in annotations, with two exceptions:\n- Edm.Stream\n- Edm.Geo*\n\nWe currently have no concrete use cases for either, but it's a gap.\n\n\n### Proposal\n\nIn CSDL JSON a constant annotation (property) value is the type-specific JSON representation of that value, see [OData-JSON].\n - For Edm.Geo* this is the GeoJSON value\n - For properties of type Edm.Stream this is\n -- native JSON for streams of media type application/json or one of its subtypes, optionally with format parameters\n -- a string containing the plain text for streams of media types text/*\n -- a string containing the base64url-encoded value for all other media types (same as Edm.Binary)\n\nIn CSDL XML a constant annotation (property) value is represented according to the appropriate alternative in the `primitiveValue` rule defined in [OData‑ABNF], using element or attribute notation:\n - a constant string expression for Edm.Geo* whose value is the appropriate `full_Xxx_Literal` for Edm.Geo*, e.g. `fullPointLiteral` for Edm.GeometryPoint and Edm.GeographyPoint\n - a constant string expression for Edm.Stream with media types application/json or text/*\n - a constant binary expression for Edm.Stream for all other media types\n\nFor stream values the annotation (property) MUST be annotated with term `Core.MediaType` and the media type of the stream as its value.\n\nServices SHOULD only return these annotation values in CSDL documents with Version 4.02 or later.\n\nClients SHOULD already ignore unknown annotations. This now extends to annotations containing literal Edm.Stream and Edm.Geo* values.\n\nImported from [ODATA-1323](https://issues.oasis-open.org/browse/ODATA-1323)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add odata. prefix to omit-values preference",
    "body": "In the last TC call it was decided that we should register the \"odata.\" prefixed versions of the OData preferences with IANA.  The omit-values preference is new to OData 4.01 and therefore never had an \"odata.\" prefixed version of the preference.  Should an the preference name \"odata.omit-values\" be added as an alternate name for the preference? \n\n### Proposal\n\nAdd \"odata.omit-values\" as an alternate name for the omit-values preference\n\nImported from [ODATA-1322](https://issues.oasis-open.org/browse/ODATA-1322)",
    "labels": [
      "Protocol",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Prefer:respond-async on individual requests within a batch request",
    "body": "Part 1: Protocol states in [8.2.8.8 Preference `respond-async`](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_Preferencerespondasync) that\n> \n> The respond-async preference MAY be used for batch requests, but the service MUST ignore the respond-async preference for individual requests within a batch request.\n> \n\n\nHowever, JSON Format states in [19.6 Asynchronous Batch Requests](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_AsynchronousBatchRequests) that\n> \n> In addition to the above interaction pattern individual requests within a batch MAY be executed asynchronously if they specify the respond-async preference and if the service responds with a JSON batch response.\n> \n\n\nApparently the restriction in Part 1: Protocol only applies to multi-part batch requests or responses.\n\n### Proposal\n\nIn Protocol: preference respond-async, remove references to use for single requests within a batch; clarify that use on a batch applies to the entire batch:\n\"The respond-async preference MAY be used for batch requests, in which case it applies to the batch request as a whole and not to individual requests within the batch.\"\n\nIn description of multipart batch, prohibit use of respond-async for individual requests within a batch\n\nIn JSON Format, allow use of respond-async for individual requests as long as they are not within an atomicity group. If a request depends on a request that is executed asynchronously, then it SHOULD fail with 424 failed dependency.\n\nImported from [ODATA-1321](https://issues.oasis-open.org/browse/ODATA-1321)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "edm.xsd: attribute edm:Annotations/@Target does not cover all allowed targets",
    "body": "The pattern for simple type TTarget does not cover all allowed target path expressions with segment /$ReturnType to address the return type of an action/function overload.\n\nIt also allows one parentheses too many after the overload signature.\n\n### Proposal\n\nSee summary and resolution\n\nImported from [ODATA-1320](https://issues.oasis-open.org/browse/ODATA-1320)",
    "labels": [
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify format parameter IEEE754Compatible with requests",
    "body": "Section 3.3 states that *payloads* that format Edm.Int64 and Edm.Decimal values as strings MUST specify the IEEE754Compatible=true format parameter, however section 4.1 only mentions responses.\n\n### Proposal\n\nChange fourth paragraph of [4.1 Header Content-Type](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_HeaderContentType) to (new text in green)\n> R{color:#14892c}equests and r{color}esponses MUST include the IEEE754Compatible parameter if Edm.Int64 and Edm.Decimal numbers are represented as strings.\n> \n\n\nNote: this is a non-material change as section 3.3 already required this for all payloads, which includes request payloads.\n\nImported from [ODATA-1319](https://issues.oasis-open.org/browse/ODATA-1319)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should support multiple permissions for read/write",
    "body": "Authentication schemes define scopes that govern the permissions that an authenticated client has when accessing the service. \n\nA service may support multiple different schemes for authentication. \n\nThis is well supported today in our authentication vocabulary.\n\nHowever, access to an individual resource today is specified through a PermissionType, which specifies a set of scopes from a single authentication scheme. If the service supports multiple authentication schemes, then any of the supported authentication schemes may control access to the resource.\n\nWhere controlling access to a resource, the capabilities vocabulary should specify a collection of PermissionTypes (required scopes from a particular authentication scheme) that can be used to access a resource.\n\n### Proposal\n\nChange the \"Permission\" property to \"Permissions\", and \"PermissionType\" to \"Collection(PermissionType)\", where used in the capabilities vocabulary.\n\nImported from [ODATA-1316](https://issues.oasis-open.org/browse/ODATA-1316)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce CollectionAnnotation control information for JSON",
    "body": "We don't have a way to annotate members of a primitive collection in JSON.\n\n### Proposal\n\nAdd a new JSON control information item, \"collectionAnnotations\".\n Value is a complex type containing an integer \"index\" property and any annotations associated with the indexed item.\n\nusage:\n\nmyList@odata.collectionAnnotations : [\n {\n \"index\": 2,\n \"@Core.ValueException\" :\n\n{ \"value\", \"9223372036854775807\"}\n\n\"@custom.ProvidedBy\" : \"Bill\"\n },\n\n{ \"index\": 5, \"@custom.NotAuthorized\" : true }\n\n],\n myList : [\n 3,\n 9223372036854776000,\n 47,\n 0,\n null,\n 12\n ]\n  \n\nImported from [ODATA-1315](https://issues.oasis-open.org/browse/ODATA-1315)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "odata.mediaContentType control information for embedded stream properties",
    "body": "JSON Batch represents JSON message bodies as \"inlined JSON\" and textual media types as JSON strings (with JSON string quoting/escaping), everything else is base64url-encoded and then packed into a JSON string.\n\nThe rules for expanded/inlined stream properties are slightly different, which is inconsistent.\n\n### Proposal\n\nSame rules for JSON Batch message bodies and inlined/expanded streams:\n- Streams of media type application/json and subtypes are represented as \"inlined JSON\".\n- Streams of media type text/* are represented as JSON strings (quoted/escaped accordingly.\n- Streams of all other content types are base64url-encoded and represented as JSON strings. \n\nControl information mediaContentType MUST be present for inlined streams.\n\nImported from [ODATA-1314](https://issues.oasis-open.org/browse/ODATA-1314)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify $batch atomicity group processing",
    "body": "Current specification requires all but the failing request in an atomicity group to return a 424 failed dependency status code. This impedes stream processing of $batch requests with large atomicity groups.\n\n### Proposal\n\nAllow request in an atomicity group to report the actual status of executing that request while continuing to allow requests to return a 424 failed dependency which would then typically be used for those requests that haven't been attempted due to a failed request.\n\nImported from [ODATA-1313](https://issues.oasis-open.org/browse/ODATA-1313)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add $compute to supported $select query options",
    "body": "4.01 adds support for $select options such as nested $select and $expand and, for collection-valued properties, $top, $skip, $orderby, and $count.\n\nAs pre ABNF and URL Conventions, we also allow $compute as a $select option, that is missing from the section on $select in the Protocol document, which states:\n\n{color:#000000}\"...Allowed system query options are {color}[$select](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionselect){color:#000000} and {color}{color:#000000}$expand{color}{color:#000000}, plus {color}[$filter](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionfilter){color:#000000}, {color}[$search](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionsearch){color:#000000}, {color}[$count](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptioncount){color:#000000}, {color}[$orderby](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionorderby){color:#000000}, {color}[$skip](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionskip){color:#000000}, and {color}[$top](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptiontop){color:#000000} for collection-valued properties.\"{color}**++\n\n### Proposal\n\nSupport $compute as a select option for collection/complex type valued structural properties.\n\nImported from [ODATA-1312](https://issues.oasis-open.org/browse/ODATA-1312)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Edm.AnyPropertyPath: no corresponding path expression",
    "body": "[ODATA-516](https://issues.oasis-open.org/browse/ODATA-516) introduced Edm.AnyPropertyPath and Edm.AnyPath (later renamed to Edm.ModelElementPath).\n\nWhile we added a dynamic annotation expression for ModelElementPath, we did not add one for Edm.AnyPropertyPath.\n\n### Proposal\n\nRemove type Edm.AnyPropertyPath.\n\nVocabulary designers can use Edm.ModelElementPath instead, and can annotate the term or term property with Validation.DerivedTypeConstraint to restrict it to just Edm.PropertyPath and Edm.NavigationPropertyPath.\n\nImported from [ODATA-1311](https://issues.oasis-open.org/browse/ODATA-1311)",
    "labels": [
      "CSDL JSON",
      "Data Aggregation",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "\"Long\" numbers in response payloads without IEEE754Compatible=true",
    "body": "Section [3.2 Controlling the Representation of Numbers](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_ControllingtheRepresentationofNumber) currently states:\n> \n> If not specified, or specified as `IEEE754Compatible=false`, all numbers MUST be serialized as JSON numbers.\n\n\n\n\n### Proposal\n\nKeep the rules for requesting and sending representations of numbers.\n\nAllow services to represent \"overly long\" numbers in responses without format parameter `IEEE754Compatible=true` as an instance annotation on the numeric property with term `Core.ValueException` containing the exact value as a string. The service MAY also include the numeric property with a rounded/inexact value as a JSON number.\n\nThis is not supported in request payloads, clients can use format parameter `IEEE754Compatible=true` and pass all Int64 and Decimal values as strings.\n\nImported from [ODATA-1310](https://issues.oasis-open.org/browse/ODATA-1310)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON Batch: clarify \"Textual media types\" and their string representation",
    "body": "Question from implementation team:\n> \"Textual media types\" are represented as a string: what exactly are \"textual media types\"?\n\n\n\n### Proposal\n\n\"Textual media types\" are all and only the media types `text/*`, i.e. top-level type `text`.\n\nSame rule for inlined stream properties: `application/json` and `text/*` are represented \"naturally\", everything else is base64url-encoded, see [ODATA-1314](https://issues.oasis-open.org/browse/ODATA-1314).\n\nImported from [ODATA-1309](https://issues.oasis-open.org/browse/ODATA-1309)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Errors in Example 34: products with aggregated sales",
    "body": "Example 34 in “3.17 Evaluating $apply as an Expand Option” ([http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016591](https://nam06.safelinks.protection.outlook.com/?url=http%3A%2F%2Fdocs.oasis-open.org%2Fodata%2Fodata-data-aggregation-ext%2Fv4.0%2Fcs02%2Fodata-data-aggregation-ext-v4.0-cs02.html%23_Toc435016591&data=04%7C01%7Cmikep%40microsoft.com%7C69c4d0d17ebe430ca45d08d6e9dfa7ff%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636953544148230845%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C-1&sdata=SelBZPN1ChRzKcLeJWO4aaap5ZizR3iCopsZmtFXM%2Bo%3D&reserved=0)) says  that for following query:\n\nGET Products?$expand=Sales($apply=aggregate(Amount with sum as Total))\n\n @odata.context in result should look like:\n\n\"@odata.context\":\"$metadata#Poducts(Salees(Amount)\",\n\n There appear to be a few errors with the context:\n- Typos in Products and Sales\n- Amount instead of Total that is part of output\n- Missing closing parens\n\n I believe the context should be:\n\n\"@odata.context\":\"$metadata#Products(Sales(Total))\",\n\n### Proposal\n\nUpdate the context in the example as described.\n\nImported from [ODATA-1307](https://issues.oasis-open.org/browse/ODATA-1307)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Align conformance clauses with normative text",
    "body": "The prose text contains MUST requirements for features that are called out as being optional for certain conformance levels, e.g. section 11.1.2 [Metadata Document Request](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_MetadataDocumentRequest) says that\n> OData services MUST expose a metadata document [...]\n> \n\nwhereas 13.1.1 [OData 4.0 Minimal Conformance Level](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_OData40MinimalConformanceLevel) says\n> \n> 13.  SHOULD publish metadata [...]\n> \n\n\n### Proposal\n\nChange first sentence of fourth paragraph to \n> OData services +can+-MUST- expose a metadata document that describes the data model exposed by the service.\n> \n\n\nImported from [ODATA-1306](https://issues.oasis-open.org/browse/ODATA-1306)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify ranges of minute, hour, and second functions",
    "body": "The headlines of the examples for the hour, minute, and second function may suggest that the result ranges of these functions start with 1.\n\n### Proposal\n\nExplicitly state the result ranges 0..23 for hour, 0..59 for minute, and 0..60 for second - to allow for leap seconds.\n\nAdapt the example headlines to be less misleading.\n\nImported from [ODATA-1305](https://issues.oasis-open.org/browse/ODATA-1305)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve descriptions on Capabilities.NavigationRestrictionsType",
    "body": "\n\n### Proposal\n\nFor Navigability on the entityset/singleton, change description to: \n\"Default navigability for all navigation properties on the annotated target. Individual navigation properties can override this value via RestrictedProperties.\"\n\nFor Navigability on individual navigation property, change description to:\n\"Supported navigability of this navigation property\"\n\nImported from [ODATA-1304](https://issues.oasis-open.org/browse/ODATA-1304)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether schemas traversed in path expressions must be in scope",
    "body": "Assume service A references service B, which in turn references service C.\n\nIf I annotate an entity type in service A with a path expression using cross-service navigation to services B and C, do I need to reference/include the corresponding schemas of B an C, or is it sufficient to only reference/include the schema of service A containing the targeted entity type?\n\nExample\n```xml\n<Annotations Target=\"SchemaServiceA.SomeEntityType\">\n  <Annotation Term=\"SomeVocab.SomeTerm\" Path=\"NavPropToServiceB/NavPropToServiceC/ServiceCProperty\"/>\n</Annotations>\n```\n \n\n### Proposal\n\nIt is sufficient to reference service B from service A.\n\nA client/validator needs to read the metadata of service B anyway to find out whether the referenced entity type from service B has a navigation property NavPropToServiceC. Then it can use the references within service B's metadata to figure out where NavPropToServiceC points to, and if necessary follow a reference from service B to service C for the next step of validation.\n\nThis is true for all path traversal (i.e., in URL) and is in contrast to directly referencing a type defined in service C's schema from service A (which requires a direct reference to service c's schema) \n\nImported from [ODATA-1303](https://issues.oasis-open.org/browse/ODATA-1303)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support PUT to replace a collection of entities",
    "body": "In 4.01 we added support for doing a deep update by doing a PUT against an entity with an inline set of objects; the semantics are that, at the end of the operation, the entity contains exactly the entities specified in the payload; any entities not specified are removed (and, for containment or if an integrity constraint exists, deleted).  This is the same semantics as doing a PUT with a nested collection of primitive or complex types.\n\nWe do not, however, currently support the same semantics against the path that specifies the same collection.  That is, a PUT to customers(1) that contains nested orders replaces the orders for customer 1, but a PUT to customers(1)/orders is not currently specified if orders is a collection of entities (though it is if orders is a collection of complex types). \n\n### Proposal\n\nSupport PUT to a resource path that identifies a collection of entities with the same replace semantics as if the collection were a collection of primitive or complex types, or a collection of entities in a deep update.\n\nImported from [ODATA-1302](https://issues.oasis-open.org/browse/ODATA-1302)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Can nullable singletons be deleted or created?",
    "body": "[ODATA-1183](https://issues.oasis-open.org/browse/ODATA-1183) introduced nullable singletons:\n- Can they be created if they are currently null?\n- Can they be deleted if they are currently not null?\n\nProtocol section 11.4.5 Delete an Entity currently states that singletons cannot be deleted.\n\n### Proposal\n\nNullable singleton should have identical semantics to a nullable single-value contained navigation property.\n\nIf a singleton is null, a service may support upserting it via PATCH or PUT, and can announce  this with annotation `Capabilities.UpdateRestrictions/Upsertable:true`, see [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005).\n\nIf a singleton is nullable, a service may support deleting it via DELETE. By default nullable singletons are deletable, and the service can announce that it is _not_ deletable with annotation `Capabilities.DeleteRestrictions/Deletable:false`, see [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005). (Note: the default for this annotation is `Deletable:true` because it also applies to entity sets and has been around for some time.)\n\nImported from [ODATA-1301](https://issues.oasis-open.org/browse/ODATA-1301)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities: clarify CountRestrictions and ExpandRestrictions",
    "body": "The complex type `NavigationPropertyRestriction` has properties for all capability annotations that can be directly applied to an entity set or singleton and allows applying the same restrictions to a (containment) navigation property.\n\nWith two exceptions: currently there are no properties `CountRestrictions` and `ExpandRestrictions` corresponding to the identically named terms. Instead these terms have lists of NonXxxableProperties.\n\nDo we want to keep this difference in style, or do we want to harmonize that with `NavigationRestrictions/RestrictedProperties`?\n\n### Proposal\n\n`ExpandRestrictionsType`:\n- Add property `NonExpandableStreamProperties` of type `Collection(Edm.PropertyPath)`\n\n`CountRestrictionsType`:\n- Applies also to `Singleton`\n- Adjust descriptions accordingly\n\nImported from [ODATA-1300](https://issues.oasis-open.org/browse/ODATA-1300)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Continue-on-Error for Collection requests",
    "body": "In a GET against a collection of entities, it is possible that an entity returns an error, for example if a connection to the provider of the entity is lost.\n\nThe proposal is to allow a Continue-On-Error preference or a $Continue-On-Error query option for a GET against a collection.\n\nIn the event of an error returned by an entity being retrieved, the effect of Continue-On-Error,  would be to stop the current page, returning both the entities up to the error and an Error result for the element that returned the error and, if there are additional elements following, a nextLink for use in retrieving the remaining entities in the collection.\n\nNote for discussion, the first result could be split, first returning entities up to but not including the failed entity, with a nextLink to retrieve the error result for the failing entity, And finally more entities, if the last returned a nextLink. \n\n \n\n \n\n### Proposal\n\nChanges:\n 1. Define Core.ExceptionType\n\n  -optional info property of type MessageType\n\n2. (re) Define Core.ValueExceptionType : ExceptionType\n\n  -optional value property of type string\n\n3. Define Core.ResourceException:ExceptionType to mark a resource or collection within a success payload as in error.\n       -optional retryLink\n\n4. Define Core.ModificationException of type DataModificationException : ExceptionType\n      -failedOperation (insert, update, upsert, delete, invoke, addlink, removelink)\n      -optional responseCode (i.e., 424 for failed dependency)\n\nClarifications:\n\n1. (non-key) Properties within tombstones in update payloads are effectively ignored\n\nScenarios:\n 1. Error retrieving a value within a structured resource (does not require continueonerror)\n a) Annotate property with the new Core.ValueException\n  \n 2. Error retrieving a resource within a collection (any collection, with continueonerror)\n a) Annotate resource within collection with Core.NestedItemException\n  \n 3. Error retrieving part of a collection (with continueonerror)\n a) Return a NextLink\n  \n 4. Error retrieving entire collection within a resource (with continueonerror)\n a) Annotate collection property with Core.NestedItemException\n\n5. Applying a delta update\n a) Return=representation response is a Delta response that is 1:1 with delta request\n b) Entities within the response have current persisted values\n c) Don’t support $select, $filter, $expand, $orderby, $search, $count, etc…\n d) If continue-on-error\n i) Failed deletes are returned as entities/entity references, annotated with DataModificationException (operation=delete or unlink)\n ii) Failed inserts are returned as tombstones with DataModificationException (operation=insert)\n iii) Failed updates may be annotated with DataModificationException (operation=update)\n iv) Failed addedlinks returned as deletedlink with DataModificationException (operation=link)\n v) Failed deletedlinks returned as addedlink with DataModificationException (operation=unlink)\n e) If the delta update contains a nested full representation, the response contains the full nested representation of the after-image.\n\ng) If the update of a nested resource fails, the update to the parent (and siblings) may fail\n i) Operation is the operation attempted at the resource that is annotated (i.e., update)\n ii) May return 424 Failed Dependency as status for related resources\n i) Unlike batch, if it is not annotated with failed, it is success\n h) If return=minimal + ContinueOnError, service MUST return at least the things in error\n i) perhaps as a flattened delta payload\n  \n 6. Applying a deep update/insert\n a) Don't support continue-on-error for deep inserts/updates\n b) Deep updates can support delta collections and inline full representations. Deep inserts are not extended to support updating - the client can do a delta update against the collection with the single entity to be inserted, including nested information to be updated.\n\nc) Response is the same shape as the deep update/insert in the request\n d) Entities within the response have current persisted values\n  \n 7. Applying a set-based update\n a) Response (if specified by return=representation) is the delta response showing current values (after-image) of the set of things identified by the input collection (i.e., after any filter segment). Note that specifying return=representation may remove any implementation optimizations around doing the set operation.\n b) Note: may be deep update (including nested collection/delta collection, in which case above rules apply)\n c) Don’t specify support for query options\n d) If continue-on-error\n i) Failed updates may be annotated with DataModificationException (operation=update)\n ii) If return=minimal + continue on error, MUST return at least the things in error (perhaps flattened)\n  \n 8. Applying a set-based delete\n a) Response (if specified by return=representation) is the delta response showing tombstones for the set of things identified by the input collection (i.e., after any filter segment). Note that specifying return=representation may remove any implementation optimizations around doing the set operation.\n b) Don't specify support for query options\n c) If continue-on-error\n i) Failed deletes returned as entity/entity reference with DataModificationException (operation=delete)\n ii) If return=minimal + continue on error, MUST return at least failures\n\n9. Applying a set-based action invocation\na) Clarify that (if specified by return=representation) the result of a set-based action invocation is a collection of the individual action responses as if they had been invoked separately (including any value wrapper for collections or primitives).\nc) Support for query options is not specified, but apply to each individual action response\nd) If continue-on-error\ni) Response objects returned from failed invocations may be annotated with DataModificationException (operation=invoke)\nii) If return=minimal + continue on error, MUST return at least the things in error\n\nImported from [ODATA-1299](https://issues.oasis-open.org/browse/ODATA-1299)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify creation choreography for media entities, recommend stream properties",
    "body": "Media entities are a somewhat obscure heirloom from AtomPub, and the \"atomic pair\" nature of a media resource and its media entity is not clearly explained and not very intuitive.\n\nFor example implementations differ in how they treat the `content-type:application/json`  in POST requests to a media entity set:\n - some implementations create a media _entity_ using the POST body and do not create a media resource\n - some implementations create a JSON media resource using the POST body, plus a media entity pointing to that JSON media resource\n\nWe should give guidance on when to use media entities and when to use \"normal\" entities with stream properties.\n\n### Proposal\n\nAdd\n- as a second paragraph to Protocol, section 11.2.3 Requesting the Media Stream of a Media Entity using $value, and\n- after the second sentence to first paragraph of CSDL JSON/XML, section 6.4 Media Entity Type\n\nthe following guidance\n> Use a media entity if the out-of-band stream is the main topic of interest and the media entity is just structured additional information attached to the stream. Use a normal entity with one or more stream properties if the structured data of the entity is the main topic of interest and the stream data is just additional non-structured information attached to the structured data.\n> \n\nAdd *{color:#14892c}green text{color}* to first paragraph of Protocol, section 11.4.7.1 Create a Media Entity\n> A POST request to a media entity's entity set creates a new media entity. The request body MUST contain the media value (for example, the photograph) whose media type MUST be specified in a Content-Type header. *{color:#14892c}The request body is always interpreted as the media value, even if it has the media type of an OData format supported by the service, such as `application/json`. It is not possible to set the structural properties of the media entity when creating the media entity.{color}*\n> \n\n\nImported from [ODATA-1298](https://issues.oasis-open.org/browse/ODATA-1298)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON Batch: clarify values of body property, context URL, batch in batch, continue-on-error",
    "body": "Clarify:\n1. Can the `body` property in request/response object have the value `null`? If yes, does this mean \"empty body\" or \"no body\"? See also next question.\n1. Can responses with `status:204` have a `body`?\n1. \"Textual media types\" are represented as a string: what exactly are \"textual media types\"?\n1. [RFC 7230](https://tools.ietf.org/html/rfc7230) distinguishes between \"message body\" and \"payload body\": which one is `body`, i.e. can a `Transfer-Encoding` (gzip, chunked, ...) be applied?\n1. What is the context URL of a JSON batch request or JSON batch response?\n1. Can a request object within a JSON batch request be itself a (JSON) batch request?\n1. Why do we allow the preference `continue-on-error=false` at all? The client can specify explicit dependencies with `dependsOn` if it wants certain dependency chains to stop at first error. \n\n### Proposal\n\nFrom 2019-6-6 discussion:\n\nResponses for all except #3 seem straightforward. We'll open a separate issue for #3. The rest are as proposed:\n1. Yes, `\"body\":null` and omitting the `body` property both mean \"no body\"\n1. Yes, `\"body\":null`\n\n3. issue [ODATA-1309](https://issues.oasis-open.org/browse/ODATA-1309) created to track this issue.\n\n4. body content can be compressed/chunked if correctly reflected in `Transfer-Encoding` header\n 5. explicitly mention that these don't have a context URL\n 6. Part 1: Protocol clearly defines which requests can be inside a batch request, and batch is not listed:\n> Batch requests allow grouping multiple individual requests into a single HTTP request payload. An individual request in the context of a batch request is a [Metadata Request](#sec_MetadataRequests), [Data Request](#sec_RequestingData), [Data Modification Request](#sec_DataModification), [Action invocation](#sec_InvokinganAction) request, or [Function invocation](#sec_InvokingaFunction) request.\n> \n\n7. If processing stops on error the batch response can be incomplete, whereas with `dependsOn` the batch response would contain a response for each individual request which has status:412 if the request has been skipped due to a failed dependency\n\nImported from [ODATA-1297](https://issues.oasis-open.org/browse/ODATA-1297)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow all non-whitespace characters in a search word, and allow unbalanced quotes and parentheses",
    "body": "The ABNF rule for [searchWord](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L356) is overly restrictive, allowing only Unicode letters, numbers, and some punctuation characters. Character sequences with other characters need to be enclosed in double-quotes to pass the ABNF, i.e. be formulated as a searchPhrase.\n\nHowever double-quoted \"phrases\" typically have special meaning for search engines, e.g. use exact, non-fuzzy match, meaning that `$search=word` and `$search=\"word\"` have different results.\n\nAlso when used for type-ahead the search expression will typically be incomplete while the user is typing, and the user's expectation is to already see matching proposals while typing. All these search requests should give a search result and none of them should lead to an error:\n```java\n$search=\"\n$search=\"b\n$search=\"bl\n$search=\"blu\n$search=\"blue\n$search=\"blue%20\n$search=\"blue%20p\n$search=\"blue%20pi\n$search=\"blue%20pil\n$search=\"blue%20pill\n$search=\"blue%20pill\"\n```\n Same for unbalanced parentheses.\n\n \n\n### Proposal\n\nClients can send unbalanced expressions in $search to simplify type-ahead use cases if these unbalanced expressions are sent as OData string literals, i.e. enclosed in single quotes, and single quotes within the string need to be doubled to escape them.\n\nServices can announce this feature via term property Capabilities.SearchRestrictions/AllowUnbalancedExpressions (boolean, default false).\n\nImported from [ODATA-1296](https://issues.oasis-open.org/browse/ODATA-1296)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether new annotation target syntax requires Version=4.01",
    "body": "With [ODATA-1178](https://issues.oasis-open.org/browse/ODATA-1178) we added the possibility to target individual action/function overloads by appending their signature to the action/function name.\n\nClarify whether this already requires to use Version=4.01, or whether this is just \"string content\" for the Target attribute and can be used with Version=4.0\n\n### Proposal\n\nDo not require Version=4.01 or OData-Version:4.01 for these new targets.\n\nRationale: we already require in [CSDL Version 4.0 Errata 03](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part3-csdl/odata-v4.0-errata03-os-part3-csdl-complete.html#_Toc453752619) that (minus the blue text)\n> {color:#59afe1}*Unknown or invalid annotations should never result in an error, as long as the payload remains well-formed.* {color}Clients SHOULD ignore *{color:#59afe1}invalid or{color}* unknown terms and *{color:#14892c}silently treat unexpected or invalid values{color}* (including invalid type, invalid literal expression, {color:#59afe1}*invalid targets,*{color} etc.) as an unknown value for the term.\n> \n\nSo worst case clients the annotation on the overload.\n\nAdd the blue text to make this unambiguously clear.\n\nImported from [ODATA-1295](https://issues.oasis-open.org/browse/ODATA-1295)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state what is returned on create and update",
    "body": "Section 11.4.2 Create an Entity does not explicitly state what is returned in a 201 response.\n\nSection 11.4.3 Update an Entity does not explicitly state what is returned in a 200 response.\n\n### Proposal\n\nChange text in 11.4.2 to (new text in green)\n> {color:#333333}Upon successful completion the service MUST respond with either [201 Created](#sec_ResponseCode201Created) {color}{color:#14892c}and a representation of the created entity{color}{color:#333333}, or [204 No Content](#sec_ResponseCode204NoContent) if the request included a [Prefer header](#sec_Preferencereturnrepresentationandret) with a value of [return=minimal](#sec_Preferencereturnrepresentationandret).{color}\n> \n\n{color:#333333}Change text in 11.4.3 to (new text in green){color}\n> Upon successful completion the service responds with either [200 OK](#sec_ResponseCode200OK) {color:#14892c}and a representation of the updated entity,{color} or [204 No Content](#sec_ResponseCode204NoContent).\n> \n\n\nImported from [ODATA-1294](https://issues.oasis-open.org/browse/ODATA-1294)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "CSDL 7.2.1 Nullable: improve wording",
    "body": "The current text in section 7.2.1 Nullable is\n> \n> 7.2.1 Nullable\n> A Boolean value specifying whether a value is required for the property.\n> \n\n\nThis is misleading and suggests that the property can be omitted. Actually it only means that the property can be null.\n\n### Proposal\n\nChange text to \n> \n> 7.2.1 Nullable\n> A Boolean value specifying whether the property can have the value `null`.\n> \n\n\nImported from [ODATA-1292](https://issues.oasis-open.org/browse/ODATA-1292)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ETags for Collections",
    "body": "With [ODATA-981](https://issues.oasis-open.org/browse/ODATA-981) we clarified that collections can also have ETags and clients must specify `if-match` when posting to the collection.\n\nWhat's missing is\n- an annotation in $metadata to tell clients up-front which collections, especially collection-valued navigation properties, use optimistic concurrency control\n- a way to transport ETags for collection-valued navigation properties in responses to the \"container\" entity\n\n\n### Proposal\n\nh1. JSON Format\n\nTransport the ETag for a collection-valued navigation property in its containing entity as control information on the navigation property:\n```java\n{\n  \"@context\": \"http://host/service/$metadata#Orders/$entity\",\n  \"@id\": \"Orders(1234)\",\n  \"@etag\": \"W/\\\"MjAxMy0wNS0yN1QxMTo1OFo=\\\"\",\n  \"ID\": 1234,\n  \"Items@etag\": \"W/\\\"MjAxOS0wMy0xMlQxMDoyMlo=\\\"\"\n}\n```\nNote: the collection ETag for a navigation property may or may not be identical to the ETag of the container entity, the example shows a different ETag for the Orders collection.\n\nServices MAY include these, just as they MAY include the entity @etag control information. Up to the server when to do it. based e.g. on computational complexity.\nh1. Annotate Navigation Properties\n\nExtend type `Capabilities.NavigationPropertyRestriction` with property `OptimisticConcurrencyControl` of type `Edm.Boolean`, default value `false`.\n\nNote: this differs from the existing term `Core.OptimisticConcurrency` which is a collection of property paths, using an empty collection for \"tagging\" without revealing which properties influence the calculated ETag.\nh1. Protocol\n\nAdd `POST` to the list of methods in sections 8.2.4 Header If-Match and 8.2.5 Header If-None-Match.\n\nMention collection ETags in section 11.4.1.1 Use of ETags for Avoiding Update Conflicts.\n\nImported from [ODATA-1291](https://issues.oasis-open.org/browse/ODATA-1291)",
    "labels": [
      "JSON Format",
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Can an etag value of \"*\" be used in If-Match to force update?",
    "body": "There was a question in [ODATA-1168](https://issues.oasis-open.org/browse/ODATA-1168) that got missed in its resolution, which was whether or not clients could specify If-Match:* could be used by the client to force an update.\n\nThis issue is to address that question.\n\n### Proposal\n\nClients can attempt to disable optimistic control on updating by specifying If-Match:*. Services MAY reject such requests.\n\nImported from [ODATA-1290](https://issues.oasis-open.org/browse/ODATA-1290)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities: use Edm.Boolean instead of Core.Tag as a type for properties",
    "body": "\n\n### Proposal\n\nSee summary: only use Core.Tag for tagging terms with default value \"true\":\n\nReplace existing use of Core.Tag in properties (i.e., in SelectSupportType) with Edm.Boolean.\n\n \n\nImported from [ODATA-1289](https://issues.oasis-open.org/browse/ODATA-1289)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Precisely specify the format of the Error Response",
    "body": "The current specification text does not explicitly specify that `message` and `target` are strings, and whether they can be `null`.\n\n### Proposal\n\n Updated proposal from 2019-3-7:\n - We need to specify the format-independent minimal content of an error response body in Protocol\n - code: non-empty string, not null\n -  code: not language-dependent\n -  message: language-dependent, non-empty, not null, human-readable\n -  target: string, can be null, can be omitted, can be empty\n - details: collection of structured instances with code, message, target, same rules as above\n - innererror: optional, structured instance, anything goes\n - Make comment about security concerns \"global\" to error response, not only specific to innererror\n\n \n\nChange paragraphs 3 to 5 in chapter 21 Error Response:\n> The value for the code name/value pair is a language-independent string. Its value is a service-defined error code. This code serves as a sub-status for the HTTP error code specified in the response.\n> \n> The value for the message name/value pair -MUST be-+is a string containing+ a human-readable, language-dependent representation of the error. The Content-Language header MUST contain the language code from *[[RFC5646]](#rfc5646)* corresponding to the language in which the value for message is written.\n> \n> The value for the target name/value pair is <ins>a string containing</ins> the target of the particular error (for example, the name of the property in error).\n>  <ins>Neither `code` nor `message` can have the value `null`.</ins> \n\n \n\n \n\n \n\nImported from [ODATA-1288](https://issues.oasis-open.org/browse/ODATA-1288)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Annotate a property as \"cannot be specified on insert, can be updated later\"",
    "body": "Business documents can contain fields that cannot be filled out when creating the document and can only be updated after successfully creating the business document.\n\nOne example is \"physical inventory\":\n- A physical inventory document is created as a plan for performing a physical inventory, listing the materials to be inventoried. \n- The stocks are counted for the materials to be inventoried.\n- The count results are entered in the physical inventory document. The document is now \"counted\".\n- If the count revealed differences between book and reality, the warehouse manager checks the reason for the difference and enters it in the document.\n- The difference can then be posted by the manager.\n\n\nTo accurately reflect this in the service metadata, the \"count\" and the “difference reason” properties need to be annotated as \"do not provide on insert, only provide on update\".\n\n### Proposal\n\nAdd a new property `NonInsertableProperties` to term `InsertRestrictions` that is a collection of property paths, similar to the existing `NonInsertableNavigationProperties`.\n\nNote: we do not need this yet for update as this is covered by term `Core.Immutable` on the property level.\n\nImported from [ODATA-1287](https://issues.oasis-open.org/browse/ODATA-1287)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "What is the meaning of year 0, and negative years",
    "body": "In dateValue and other places ABNF allows year zero (or negative).\n\nNow with OData V4 there is no specific reference to XML Schema Part 2 DataTypes (Second Edition) although OData 3 spec did have a reference to that document for dateTimeOffsetLiteral, so perhaps there is an unwritten understanding that OData lexical representations match those defined in XML Schema Part 2 Datatypes (Second Edition).\n\nIn any case, see [https://www.w3.org/TR/xmlschema-2/#year-zero]\n\nKey questions: (see the linked XML Schema section)\n\n(1) Is year 0 valid in OData Date/DateTimeXXX values (including Edm.String with Core.DateTime annotation in 4.01)? If so, what does it mean? (e.g. 1 BCE)\n\n(2) What is the interpretation of negative years in OData Date/DateTimeXXX values? Is year -1 equivalent to 1 BCE, or to 2 BCE?\n\n \n\n### Proposal\n\nYear 0 is equivalent to 1 BCE, and year -1 is equivalent to 2 BCE.\n\nSupport for negative years and years with more than four significant digits is not mandatory, e.g. SQL only supports years 0001 to 9999.\n\nImported from [ODATA-1286](https://issues.oasis-open.org/browse/ODATA-1286)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add ReadByKeyRestrictions similar to ReadRestrictions",
    "body": "With [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099) we added the term `ReadRestrictions` with a property `Readable`.\n\nFor entity sets we have two independent read operations that need to be distinguished:\n- Read list of entities\n- Read single entity by key\n\n### Proposal\n\nAdd property `ReadByKeyRestrictions` to `ReadRestrictionsType` with a complex type that has the same properties as `ReadRestrictionsType` except `ReadByKeyRestrictions`. If a property of `ReadByKeyRestrictions` is not specified, the corresponding property value of `ReadRestrictions` applies.\n\nAdd property `ReadRestrictions` of type `ReadRestrictionsType` to complex type `NavigationPropertyRestriction`.\n\nImported from [ODATA-1285](https://issues.oasis-open.org/browse/ODATA-1285)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow referencing properties of \"outer\" entity in expressions nested within $expand",
    "body": "Expressions in query options nested within $expand already can reference the instance identified by the resource path via the symbolic literal $it. \nWhat's missing is in case of multiple nesting levels of $expand to reference the \"next outer\" instance.\n\nArtificial example: expand all Bars that have the same Baz as the current instance of Foo\n```\nGET Foo?$expand=Bar($filter=Baz eq $it/Baz)\n```\n\nWhat if I want to do this one level down: expand all Bazes that have the same Qux as the current expanded Bar's Qux\n```\nGET Foo?$expand=Bar($expand=Baz($filter=Qux eq $outer/Qux))\n```\n\nNote: $up is basically the `..` operator in Unix file systems.\n\nLess artificial example: a service with temporal entity sets for Employee, WorkAssignment, and Department. I want to request employees and their work assignments over a period of time to see all changes in data, and want to expand the department with the snapshot state at the beginning of each work assignment because changes to the department are not of interest:\n\n```\nGET Employees?$from=2010-01-01&$to=2019-02-28&$expand=WorkAssignments($expand=Department($at=$outer/@Temporal.From))\n```\n\n\n### Proposal\n\nParameter aliases can be defined within $expand, and as they are evaluated upon assignment $this can be assigned to a \"parameter\" alias to solve the problem at hand:\n```java\nGET Foo?$expand=Bar(@b=$this;$expand=Baz($filter=Qux eq @b/Qux))\n```\n\nAdd an example in Protocol 11.2.6.1.3 Parameter Aliases\n\nChange \"literals\" to \"values\" in last paragraph of 11.2.6.1.3 \n \n\nImported from [ODATA-1284](https://issues.oasis-open.org/browse/ODATA-1284)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$search: ABNF comment is more restrictive than prose text",
    "body": "[ABNF line 347](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L347) states\n```java\n; The words AND, OR, and NOT are not a valid searchWord.\n```\nThis is more restrictive than the corresponding prose text (bold parts for later reference below):\n> The search expression can contain any number of terms, phrases, or group expressions, along with the case-sensitive keywords NOT, AND, and OR, evaluated in that order.\n> \n> Expressions *prefaced with NOT* evaluate to true if the expression is not matched, otherwise false.\n> \n> Two expressions not enclosed in quotes and separated by a space are equivalent to the same two expressions *separated by the AND* keyword. Such expressions evaluate to true if both of the expressions evaluate to true, otherwise false.\n> \n> Expressions *separated by an OR* evaluate to true if either of the expressions evaluate to true, otherwise false.\n> \n\n \nThe prose text would allow using the words AND and OR as the first search word in an expression because the operators *separate* search expressions, and NOT as the only search word because the operator *prefaces* an expression.\n \n\n### Proposal\n\nAdapt ABNF comment accordingly to allow\n  \n```java\n$search=AND\n$search=OR\n$search=OR ELSE\n$search=NOT```\nNote: it would be sufficient to allow AND, OR, and NOT as search words if they appear alone. Use case triggering this issue is type-ahead: a user slowly typing NOTE into a search field can trigger bad requests if the UI fires `$search=NO`, `$search=NOT`, `$search=NOTE` while the user is typing.\n\n \n\nImported from [ODATA-1283](https://issues.oasis-open.org/browse/ODATA-1283)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "How to set the mediaReadLink and mediaEditLink of a stream property",
    "body": "Stream properties allow the actual media to reside \"somewhere else\", redirecting clients to that location when directly addressing the stream property, and by including mediaReadLink and mediaEditLink in responses so clients can avoid the redirect from the canonical URL and directly access the media at its \"non-canonical\" location.\n\nHow can clients specify a \"non-canonical\" location when creating an entity with stream properties?\n\nHow can clients update the location of an existing stream property?\n\n### Proposal\n\nChange last paragraph of JSON Format section \"4.5.12 Control Information: media* (odata.media*)\" from\n> The `media*` control information is ignored in request payloads and not written in responses if metadata=none is requested.\n> \n\nto\n> The `media*` control information is not written in responses if metadata=none is requested.\n> \n> If a stream property is provided inline in a request, the `mediaContentType` control information may be specified.\n> \n> If a stream property is annotated with `Capabilities.MediaLocationUpdateSupported` and a value of `true`, clients MAY specify the `mediaEditLink` and/or `mediaReadLink` control information for that stream property in data modification requests to the structured type instance containing the stream property.\n> \n> In all other cases `media*` control information is ignored in request payloads.\n> \n\nAdd paragraph to Part 1: Protocol, section \"11.4.8.1 Update Stream Values\":\n> Services MAY support changing the association between a stream property and a media stream by specifying the edit URL or read URL of the stream property in data modification requests to the structured type instance containing the stream property. Services SHOULD advertise this by annotating the stream property with the term `Capabilities.MediaLocationUpdateSupported` defined in [OData-VocCap].\n> \n\n\nImported from [ODATA-1282](https://issues.oasis-open.org/browse/ODATA-1282)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify: interpretation of omitted optional function parameters",
    "body": "With https://issues.oasis-open.org/browse/[ODATA-1066](https://issues.oasis-open.org/browse/ODATA-1066) we added the possibility to mark parameters as optional.\n\nWe also added text to Part 1: Protocol describing how function overload resolution works in combination with optional parameters.\n\nTwo aspects of optional parameters just came up during implementation that I can’t find in the document or the issue:\n1. Are services free to interpret the absence of a parameter as best suits the purpose of the function?\n1. Can actions also have optional parameters?\n\n### Proposal\n\n# Omitting an optional function parameter means that the parameter has the default value specified in the annotation Core.OptionalParameter. \n1. If no explicit DefaultValue is specified, the service is free on how to interpret this. Call this out in term definition.\n1. Nullable non-binding action parameters can already be omitted from the request body, and omitting them means that they have the value null. \n1. Allow annotating action parameters with Core.OptionalParameter. This allows to omit them, whether they are nullable or not.\n1. Omitted action parameter with a DefaultValue means that default value\n1. Omitted action parameter without DefaultValue can be freely interpreted by the service\n\nA nullable non-binding action parameter is equivalent to being annotated with optionalParameter = true and a default value as null.\n\nImported from [ODATA-1281](https://issues.oasis-open.org/browse/ODATA-1281)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify insert entity defined only by key properties of related entities",
    "body": "Clarify how to specify key properties that are defined as properties of referenced entities.\n\n### Proposal\n\nThe key of an entity may include all key properties of a directly related entity if the relationship is single-valued and not nullable. In this case PropertyRefs for all key properties of the related entity have to be specified with an alias. Order need not be the same as in the referenced entity type. This makes the navigation property immutable.\n\nSpecify the related entity as an entity reference, i.e. in JSON Format as a JSON object just containing the `@odata.id`:\n```javascript\n{\n  \"RelatedThing\": {\n    \"@id\": \"Thing(10835)\"\n  },\n  \"NonKeyPropertyToInsert\": \"Inserted Value\",\n  ...\n}\n```\nAdd the corresponding CSDL snippet for clarity.\n\nImported from [ODATA-1280](https://issues.oasis-open.org/browse/ODATA-1280)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Data Aggregation: Clarify need for @odata.id in nested response structures",
    "body": "This issue is to clarify, if nested entities included in the response to an aggregation request need to be equipped with an @odata.id control information.\n\nConsider example 24 from the Data Aggregation specification:\n\n`GET ~/Sales?$apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum as Total))`\n\nresults in\n```java\n{\n  \"@odata.context\": \"$metadata#Sales(Customer(Country),Product(Name),Total)\",\n  \"value\": [\n    { \"@odata.id\": null,\n      \"Customer\": { \"Country\" : \"Netherlands\" },\n      \"Product\": { \"Name\": \"Paper\" },\n      \"Total\": 3 },\n   [...]\n \n```\nTop-level entities do have an @odata.id, but nested projections of related entities currently not. Is this according to rules defined in the format specs to be considered as a gap that needs to be discussed for the Data Aggregation spec?\n\nThe JSON specification describes in section 8.3 for expanded navigation properties that the content is to be rendered according to the entity representation. Two cases exist: 1) If the nested entity is a projection of a \"real\" entity, this could imply mentioning its @odata.id in the response. 2) If the nested entity is a result of an aggregation and therefore transient, section 4.5.8 of the JSON spec states: \"If the entity is transient (i.e. cannot be read or updated), the id annotation MUST appear and have the null value.\"\n\n### Proposal\n\nExamples in the document should comply with the rules stated in the JSON format specification. Since the current examples throughout the document that return transient aggregated entities based on 4.0, all examples having responses with nested projections of related entities should have included an \"@odata.id\":null annotation.\n\n \n\nProposal is to make a blanket statement for V4.01 that clients must be prepared to receive entities having neither @odata.id nor key fields and, in the absence of any additional information, must treat such entities as transient.\n\nWe will update the examples in the aggregation specification to be 4.01 and thus all @odata.id:null (as well as other 4.01 simplifications).\n\nMention in Aggregation that all examples are based on OData V4.01, and call out what would be different across examples for V4.0.\n\nImported from [ODATA-1279](https://issues.oasis-open.org/browse/ODATA-1279)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Deleted Entity: @odata.removed possible in addition to @removed?",
    "body": "Section 15.3 Deleted Entity talks about \"Annotation `removed`\":\n- Is this an annotation or control information?\n- Can it be alternatively be used as `\"@odata.removed\": \\{...`}?\n\nGeneral: clean up use of \"annotation\" and \"control information\".\n\n### Proposal\n\nIs control information and can be used with prefix odata.\n\nAdd subsection of 4.5 for it\n\nClean up use of \"annotation\" versus \"control information\" across the document\n\nImported from [ODATA-1278](https://issues.oasis-open.org/browse/ODATA-1278)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "null and empty paths in Annotation Path, Property Path, Navigation Property Path",
    "body": "The path syntax in annotations defines the empty path to mean \"the annotated model element\".\n\nThe sections on AnnotationPath, NavigationPropertyPath, and PropertyPath define a restriction on the last path element.\n\nThis can be mis-interpreted as \"such a path must not be empty, and must not be null\".\n\n### Proposal\n\nChange text for restriction in section 14.4.1.3 Annotation Path to\n\n> A non-null path MUST resolve to an annotation.\n\n\nChange text for restriction in section 14.4.1.5 Navigation Property Path to\n\n> A non-null path MUST resolve to a model element whose type is an abstract or concrete entity type, or a collection of abstract or concrete entity types, e.g. a navigation property.\n\n\nChange text for restriction in section 14.4.1.6 Property Path to\n\n> A non-null path MUST resolve to a model element whose type is an abstract or concrete primitive or complex type, or a collection of abstract or concrete primitive or complex types, e.g. a structural property.\n\n\nImported from [ODATA-1277](https://issues.oasis-open.org/browse/ODATA-1277)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly allow the minus sign / dash in a search term",
    "body": "The ABNF rule for [searchWord ](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L349) is overly restrictive.\n\nIt should also include the minus sign / dash \n\n### Proposal\n\nChange from\n> \n> `searchWord = 1*( ALPHA / DIGIT / COMMA / \".\" / pct-encoded )`\n> \n\nto\n> \n> `searchWord = 1*( ALPHA / DIGIT / COMMA / \".\" / \"-\" / pct-encoded )`\n\n\nImported from [ODATA-1276](https://issues.oasis-open.org/browse/ODATA-1276)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Describe structure of \"JSON properties\"",
    "body": "\"JSON properties\" are stream properties whose value is of media type `application/json` or one of its subtypes. They were introduced with [ODATA-1177](https://issues.oasis-open.org/browse/ODATA-1177).\n\nAs outlined in [OData Extension for JSON Data](https://www.oasis-open.org/committees/download.php/46559/OData%20Extension%20for%20JSON%20Data%20v1.0.doc) we need query capabilities on these properties.\n\nRequirements:\n1. Specify a JSON Schema that describes/restricts the JSON stream values (this issue)\n1. Address parts of the JSON stream values in common expressions, e.g. in `$filter`, `$compute`, `$orderby` ([ODATA-1336](https://issues.oasis-open.org/browse/ODATA-1336))\n\n \n\n### Proposal\n\nCreate a type definition `JSON.JSON` in the JSON vocabulary, similar to `Core.LocalDateTime`:\n- type `Edm.Stream`\n- annotated with `Core.AcceptableMediaTypes`, listing `application/json`\n\nCreate a new JSON vocabulary containing terms and functions specific to JSON stream properties.\n\nTerm `JSON.Schema` of type `JSON.JSON` containing a JSON Schema describing/restricting the values of a JSON stream property.\n\nThe annotation value is represented according to [ODATA-1323](https://issues.oasis-open.org/browse/ODATA-1323)\n - in XML metadata as a string\n - in JSON metadata as native JSON\nThe annotation needs to be annotated with `Core.MediaType` and a value of `application/json`.\n\n\nImported from [ODATA-1275](https://issues.oasis-open.org/browse/ODATA-1275)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that a server MUST respond with content-id annotations and MUST include nested entity IDs",
    "body": "Currently in section 11.4.2.2 in the part 1 protocol document it says that the server SHOULD annotate entities in the response with the same content-id used in the request.  This SHOULD needs to be a MUST if the server supports content-ids in deep insert/deep update requests.\n\n \n\nWe also need to clarify that the response must include the entity ID for all entities returned in the response for a create or update if conventional entity IDs are not used.\n\n### Proposal\n\nNew wording for 11.4.2.2: Clients MAY associate an id with individual nested entities in the request by using the Core.ContentID term defined in [OData-VocCore]. Services that respond with 201 Created SHOULD annotate the entities in the response using the same Core.ContentID value as specified in the request. Services SHOULD advertise support for deep inserts through the Capabilities.DeepInsertSupport term, defined in [OData-VocCap]; services that advertise support through Capabilities.DeepInsertSupport MUST return the Core.ContentID for the inserted or updated entities.\n \nClarify that the response must include the entity ID (or all key properties if conventional IDs are used) for all entities returned in the response for a create or update.\n\nImported from [ODATA-1274](https://issues.oasis-open.org/browse/ODATA-1274)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define mapping of permission scopes to resources",
    "body": "Our Authorizations vocabulary describes multiple different authentication flows and the scopes that can be requested for each flow.\n\nWhat is missing is a way of documenting which resources/properties are available given a particular scope.\n\nThis would allow documentation to be generated that tells the client/app which scopes they need to request in order to access certain resources.\n\nOData-884 and OData-1145 attempt to align with OpenAPI by describing operations supported, and necessary headers, parameters, and permissions required to invoke those operations.  However, we have moved away from OData-884, which uses a more operation-centric approach, to something that aligns with our capabilities.  In doing so, we need a way to specify what permissions are required to access a particular resource (or properties within a resource).\n\nImported from [ODATA-1273](https://issues.oasis-open.org/browse/ODATA-1273)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Highlight implications of derived complex types to their annotations",
    "body": "[Section 9.1](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#_Toc505863922) in the CSDL specification defines derived complex types. The rules how this impacts the annotations of these types are not so easy to grasp, because they are described in another [section 14.2](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#_Toc505863954).\n\n### Proposal\n\nAdd to section 9.1: The rules for annotations of derived complex types are described in section 14.2\n\nImported from [ODATA-1272](https://issues.oasis-open.org/browse/ODATA-1272)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define a validation term for terms applicable in a given context",
    "body": "Terms are sometimes intended to be used only in certain contexts. Consider, for example, terms Minimum and Maximum from the Validation vocabulary. As stated in [ODATA-856](https://issues.oasis-open.org/browse/ODATA-856), they can optionally be augmented with an annotation of the Exclusive term.\n\nThe Validation vocabulary documents this dependency in the description of term Exclusive. The descriptions of terms Minimum and Maximum, however, contain no related \"forward reference\" to Exclusive. Or to any other annotation, possibly from another vocabulary, that hypothetically could be applied in their context. This leads to the situation that the interface established by a term may or may not be fully described, and clients effectively do not know, which other terms may be applied in a context to add further aspects to the annotated target. In the given example, one has to read through the entire vocabulary to find out that Exclusive plays a role.\n\nWhile this can be mitigated by improving the documentation, the problem becomes more relevant, if annotations are not hand-crafted, but created by modeling tools. Such tools want to guide users and prevent misuse by reducing the overall set of annotations to those applicable in a given context. This requires a machine-readable format for expressing these dependencies. Such a formal description also reduces astonishment on client side, since it can prepare logic for all described combinations of term applications (as opposed to gradually learn the full complexity from different metadata documents)\n\nThe list of applicable terms is open, since there are terms that may be used in any context, e.g. Core.Example. This feature enhances the existing term syntax of AppliesTo=\"Annotation\" with optional information, which other annotations accept this term, described in the definitions of these other terms.\n\n### Proposal\n\nAdd new term ApplicableTerms to the Validation vocabulary that can be used to hint at a list of additional annotations applicable in the context of the target annotated with this ApplicableTerms:\n```xml\n  <Term Name=\"ApplicableTerms\" Type=\"Collection(Core.QualifiedTermName)\">\n    <Annotation Term=\"Core.Description\" String=\"Names of specific terms that are applicable and may be applied in the current context. This annotation does not restrict the use of other terms.\" />\n  </Term>\n```\n \n\n*Example 1: Express the applicability of term Exclusive in the context of terms Minimum and* *Maximum:*\n\nApplied:\n```xml\n<Annotations Target=\"SomeType/SomeSensorProperty\">\n    <Annotation Term=\"Validation.Maximum\" Decimal=\"1.34529\">\n      <Annotation Term=\"Validation.Exclusive\" />\n    </Annotation>\n  </Annotations>\n```\n Enhanced Terms: \n```xml\n  <Term Name=\"Minimum\" Type=\"Edm.Decimal\" Scale=\"variable\" AppliesTo=\"Property Parameter Term\">\n    <Annotation Term=\"Core.Description\" String=\"Minimum value that a property, parameter, or term can have.\" />\n    <Annotation Term=\"ApplicableTerms\">\n      <Collection>\n        <String>Validation.Exclusive</String>\n      </Collection>\n    </Annotation>\n  </Term>\n```\n \n```xml\n  <Term Name=\"Maximum\" Type=\"Edm.Decimal\" Scale=\"variable\" AppliesTo=\"Property Parameter Term\">\n    <Annotation Term=\"Core.Description\" String=\"Maximum value that a property, parameter, or term can have.\" />\n    <Annotation Term=\"ApplicableTerms\">\n      <Collection>\n        <String>Validation.Exclusive</String>\n      </Collection>\n    </Annotation>\n  </Term>\n```\n \n\n *Example 2: Individual term properties can be enhanced with further annotations*\n\nIndividual parts of a term such as a individual property or a complex type can be annotated to accept further annotations. Consider a term T with a structure having two properties, one of which may be further annotated with a certain aspect.\n```xml\n<Term Name=\"HasAspect\" Type=\"Core.Tag\" />\n  <Term Name=\"T\" Type=\"TType\" />\n  <ComplexType Name=\"TType\">\n    <Property Name=\"P1\" Type=\"Edm.String\" />\n    <Property Name=\"P2\" Type=\"Edm.String\">\n      <Annotation Term=\"ApplicableTerms\">\n        <Collection>\n          <String>HasAspect</String>\n        </Collection>\n      </Annotation>\n    </Property>\n  </ComplexType>\n```\n *Applied:*\n```xml\n  <Annotations Target=\"SomeType/SomeProperty\">\n    <Annotation Term=\"T\">\n      <Record>\n        <PropertyValue Property=\"P1\" String=\"...\" />\n        <PropertyValue Property=\"P2\" String=\"...\">\n          <Annotation Term=\"HasAspect\" />\n        </PropertyValue>\n      </Record>\n    </Annotation>\n  </Annotations>\n```\n \n\n*Open*: Which other term relations do exist and should be described?\n\nImported from [ODATA-1271](https://issues.oasis-open.org/browse/ODATA-1271)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.4.11: rephrase prose text for dynamic expression Null",
    "body": "Rephrase prose text to avoid the word \"untyped\" and thus confusion with the new type `Edm.Untyped`.\n\n### Proposal\n\nChange text from\n> The null expression returns an untyped null value. \n> \n\nto\n> The null expression indicates the absence of a value.\n> \n\n \n\nImported from [ODATA-1270](https://issues.oasis-open.org/browse/ODATA-1270)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add QueryRestrictions to the Capabilities Vocabulary",
    "body": "We have cases where we want to have an entity set which is only accessible by navigation from another entity but it is not a containment relationship.  We currently have InsertRestrictions and UpdateRestrictions in the capabilities vocabulary but no corresponding QueryRestrictions.  We should add QueryRestrictions to the capabilities vocabulary.\n\n### Proposal\n\nHere is an initial version which we can add too/adjust:\n\n<Term Name=\"QueryRestrictions\" Type=\"Capabilities.QueryRestrictionsType\" AppliesTo=\"EntitySet\">\n\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on queries\" />\n\n</Term>\n\n<ComplexType Name=\"QueryRestrictionsType\">\n\n    <Property Name=\"DirectlyAccessible\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"true\">\n\n        <Annotation Term=\"Core.Description\" String=\"Whether entities in this entity set can be accessed directly or must be accessed through a navigation property.\" />\n\n    </Property>\n\n</ComplexType>\n\nImported from [ODATA-1269](https://issues.oasis-open.org/browse/ODATA-1269)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify meaning of Nullable for collection-valued structural properties",
    "body": "Similar to parameters and return types (see [ODATA-1210](https://issues.oasis-open.org/browse/ODATA-1210)) clarify that Nullable \n\n### Proposal\n\n$Nullable\n\nThe value of $Nullable is one of the Boolean literals true or false. Absence of the member means false.\n\nFor single-valued properties the value true means that the property allows the null value.\n\nFor collection-valued properties the property value will always be a collection that MAY be empty. In this case $Nullable applies to items of the collection and specifies whether the collection MAY contain null values.\n\nImported from [ODATA-1268](https://issues.oasis-open.org/browse/ODATA-1268)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "URL Conventions example in 5.1.1.5.1 has \"bad\" whitespace",
    "body": "[http://host/service/Customers?$filter=concat(concat(City],', '), Country) eq 'Berlin, Germany'\n\nThe space before Country is not permitted by the ABNF construction rules.\n\n(Or else, my interpretation of \"BWS\" is wrong)\n\n### Proposal\n\n Use the same interpretation as RFC7230 for BWS and state this in ABNF Construction Rules:\n> The BWS rule is used where the grammar allows optional whitespace\n> only for historical reasons. A sender MUST NOT generate BWS in\n> messages. A recipient MUST parse for such bad whitespace and remove\n> it before interpreting the protocol element.\n> \n\nRepair examples in URL Conventions.\n\n \n\nImported from [ODATA-1267](https://issues.oasis-open.org/browse/ODATA-1267)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Geo literals with three dimensions",
    "body": "Geo literals in WKT (well-known text) representation as defined by the OpenGIS Simple Feature Access [http://www.opengeospatial.org/standards/sfa] require two dimensions (longitute, latitude) and allow two optional dimensions\n- Three-Dimension (x,y, z)\n- Two-Dimension Measured (x, y, m) with m being a linear referencing measure\n- Three-Dimension Measured (x, y, z, m)\n\n### Proposal\n\nGeoJSON only supports Three-Dimension with a third coordinate representing an altitude or elevation.\n\nGeoJSON notation in principle allows the two \"Measured\" variants, but RFC7946 strongly discourages its use.\n\nTo not be overly restrictive we should extend the ABNF for Geo types and also allow two optional coordinates:\n\n```\npositionLiteral = doubleValue SP doubleValue [ SP doubleValue ] [ SP doubleValue ] ; longitude, latitude, altitude/elevation (optional), linear referencing measure (optional)\n```\n\nImported from [ODATA-1266](https://issues.oasis-open.org/browse/ODATA-1266)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify property paths used in a lambda predicate expression",
    "body": "# In section 5.1.1.12, para #3, the next to last word must be “navigation path” instead of “resource path”\n1. It should be explicitly noted that the meaning of a property path that does not start with either $it or a lambda variable is undefined within a lambda predicate expression\n\n### Proposal\n\n1.\n\nRevised description for section 5.1.1.12 [Lambda Operators](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_LambdaOperators) (changes enclosed with *)\n\nOData defines two operators that evaluate a Boolean expression on a collection. Both must be prepended with a navigation path that identifies a collection.\n\n4.01 Services MUST support case-insensitive lambda operator names. Clients that want to work with 4.0 services MUST use lower case lambda operator names.\n\nThe argument of a lambda operator is a case-sensitive lambda variable name followed by a colon ( : ) and a Boolean expression that uses the lambda variable name to refer to properties of members of the collection identified by the *navigation path*.\n\nIf the name chosen for the lambda variable matches a property name of the current resource referenced by the resource path, the lambda variable takes precedence. Clients can prefix properties of the current resource referenced by the resource path with [$it](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_it).\n\n*Other path expressions in the Boolean expression neither prefixed with the lambda variable nor $it are evaluated in the scope of the collection instances at the origin of the navigation path prepended to the lambda operator.*\n\n2.\n\nTo illustrate evaluation of Boolean expressions not starting with a lambda variable or $it, add two examples to section 5.1.1.12.1 and 5.1.1.12.2:\n\nExample 92’: all employees having an order with a deviating shipping address\n\n`[http://host/service/Employees?$filter=Orders/any(o:o/ShipAddress](http://host/service/Employee?$filter=Orders/any(o:o/ShipAddress) ne Address)`\n\nThe `Address` path expression included in the predicate expression of the `any` lambda operator is evaluated in the scope of the Employee collection, because they are the origins of the `Orders` collection path prepended to the `any` operator.\n\n \n\nExample 93’:  all categories along with their products used in some order with a deviating unit price\n\n`[http://host/service/Categories?$expand=Products($filter=OrderItems/any(od:od/UnitPrice] ne UnitPrice)`\n\n`UnitPrice` is a path expression included in the predicate expression of the `any` lambda operator that gets evaluated in the scope of expanded product instances, because these are the origins of the `OrderItems` collection path prepended to the `any` operator.\n\nImported from [ODATA-1265](https://issues.oasis-open.org/browse/ODATA-1265)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "CRUDQ descriptions on entity sets",
    "body": "In public comment https://lists.oasis-open.org/archives/odata-comment/201510/msg00005.html the question was asked on how to provide descriptions specific to one of the standard operations on an entity set: \n- Create new\n- Query list\n- Read single\n- Update existing\n- Delete existing\n\nThis could be leveraged when generating OpenAPI descriptions for OData services, where each entity set results in up to two path items (for the list, for key access) with up to five operations.\n\n### Proposal\n\nAdd new properties to the `Capabilities` terms `InsertRestrictions`, `UpdateRestrictions`, `DeleteRestrictions`, `ReadRestrictions`, and `ReadByKeyRestrictions`:\n- `Description` of type string\n- `LongDescription` of type string\n\nNote: this automatically extends `NavigationPropertyRestriction` with descriptions for Insert, Update, and Delete.\n\n \n\nImported from [ODATA-1264](https://issues.oasis-open.org/browse/ODATA-1264)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Requirement for 204 (No Content) with 11.4.3 \"Update an Entity\" is not backwards compatible",
    "body": "We recently updated section 11.4.3 “Update an Entity” and added: On success the service MUST respond with 204 No Content, or with 200 OK if the request included a return Prefer header with a value of return=representation.\n\nUnfortunately that is not backwards-compatible with OData 4.0. Since the 4.0 spec says nothing at all about what the server will do when the client indicates no preference, a 4.0 server can be spec-compliant if it returns 200 with content (even without seeing a preference). The addition of that text will have the effect of retrospectively making some 4.0 services non-compliant. Also it sets a precedent that the server MUST respect preferences (at least return=representation for PATCH/PUT). Previously (AFAIK) servers could ignore preferences (although it could be argued that sections 11.4.2 and 11.4.7.1 already set such a precedent for POST responses).\n\nBetter would be if 4.01 required a 4.01 response to have status 200 (with content) for PATCH/PUT, unless the client specifies “Prefer: return=minimal” and the server chooses to respect the preference (and for 4.0 responses, no requirement one way or the other since that is the way the 4.0 spec has it). For consistency, sections sections 11.4.2 and 11.4.7.1 should be reworded so as not to force the respecting of preference return=minimal.\n\nThe requirement (by default) for content in a PATCH/PUT response is more important than it was for 4.0, since with “deep update” clients may need the ability to obtain keys. Not having any way for a client to be _sure_ of getting 200 (with content) in a PATCH/PUT response is problematic (it was not that bad with 2.0 - 4.0, since an extra query could always be sent to get the latest state, and there were no \"new keys\" available).\n\n\n### Proposal\n\nChange text for Update an Entity (and for Update a Primitive/Complex/Collection Property) to \n\n> Upon successful completion the service responds with either 200 OK or 204 No Content. The client may request that the response SHOULD include a body by specifying a prefer header with a value of return=representation.\n\n\nCorresponding text for Create an Entity is\n\n> Upon successful completion the service MUST respond with either 201 Created, or 204 No Content if the request included a Prefer header with a value of return=minimal.\n\n\nCorresponding text for Create a Media Entity is\n\n> Upon successful completion the service responds with either 201 Created, or 204 No Content if the request included a Prefer header with a value of return=minimal.\n\n\nImported from [ODATA-1263](https://issues.oasis-open.org/browse/ODATA-1263)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify read-write access via URLs differing from the canonical/read/edit URL",
    "body": "Section [11.2.2 Requesting Individual Entities](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingIndividualEntities) states:\n\n> \n> To retrieve an individual entity, the client makes a GET request to the read URL of an entity.\n> \n\n\nThis seems to suggest that read access is only possible via the readLink (and in subsequent paragraphs: the editLink or the canonical URL), and not for example via a navigation URL such as `Employees(123)/Manager`.\n\nSection 11.4.3 Update an Entity does not state at all which kinds of URLs can be used with PATCH or PUT.\n\nSection 11.4.4 Upsert an Entity allows any valid URL that identifies a single entity.\n\nSection 11.4.5 Delete an Entity only allows the edit URL.\n\nThis is inconsistent and confusing.\n\n### Proposal\n\n||Section||Current Text||New Text||\n|[11.2.2 Requesting Individual Entities](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingIndividualEntities) |To retrieve an individual entity, the client makes a GET request to the read URL of an entity.|To retrieve an individual entity, the client makes a GET request to {color:#14892c}a URL that identifies the entity, e.g. its{color} read URL.|\n|[11.4.3 Update an Entity](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_UpdateanEntity)| (no statement)|To update an individual entity, the client makes a PATCH or PUT request to a URL that identifies the entity. Services MAY restrict updates only to requests addressing the edit URL of the entity.|\n|[11.4.4 Upsert an Entity](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_UpsertanEntity)|An upsert occurs when the client sends an update request to a valid URL that identifies a single entity that does not exist.|An upsert occurs when the client sends an update request to a valid URL that identifies a single entity that does not {color:#14892c}yet{color} exist.|\n|[11.4.5 Delete an Entity](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_DeleteanEntity)|A successful DELETE request to an entity's edit URL deletes the entity.|To delete an individual entity, the client makes a DELETE request to a URL that identifies the entity. Services MAY restrict deletes only to requests addressing the edit URL of the entity.|\n\nImported from [ODATA-1260](https://issues.oasis-open.org/browse/ODATA-1260)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify @type (@odata.type) and metadata=full",
    "body": "Section [3.1.2 metadata=full (odata.metadata=full)](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_metadatafullodatametadatafull) states\n- [type](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_ControlInformationtypeodatatype): the type of the containing object or targeted property if the type of the object or targeted property cannot be heuristically determined\n\nIf \"heuristically determined\" for metadata=full means: only look at the data values, not at $metadata, the only objects whose type can be heuristically determined are GeoJSON values.\n\nAll structured type instances need $metadata knowledge.\n\n### Proposal\n\nReference \"heurstically determined\" in odata.type section:\n> type: the type of the containing object or targeted property if the type of the object or targeted property cannot be heuristically determined *from the data value, see section \"Control Information: type (odata.type)\"*.\n> \n\n(added text in bold).\n\nImported from [ODATA-1259](https://issues.oasis-open.org/browse/ODATA-1259)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should we allow arrays of primitive in term definitions?",
    "body": "When we introduced the Edm.Primitive type, we explicitly disallowed defining properties of type Collection(Edm.Primitive) because we had no way to annotate individual primitive values within a JSON array.\n\nWe did not define the same restriction for term definitions; as a result, it's possible to define a term as a Collection(Edm.Primitive).  This hasn't been a problem for terms applied in XML CSDL because the XML CSDL has a way to specify the type of a primitive value within a Collection. However, with [ODATA-1221](https://issues.oasis-open.org/browse/ODATA-1221) we now use the same primitive representation in JSON CSDL as in JSON data payloads, which means we no longer have a way to annotate individual primitive values within a collection in JSON CSDL.\n\nNote that we also have the issue with instance annotations -- we cannot apply a term in an instance annotation that is defined as a collection of Edm.Primitive without relying on hueristics for determining between string, bool, or double.\n\nIt seems that failing to restrict term definitions was an oversight, and our intention was likely to restrict any uses of collection(edm.primitive) in our data (and metadata) model.\n\n### Proposal\n\nClarify that Collection(Edm.Primitive) cannot be used in properties, term definitions, parameters, or type definitions.\n\nImported from [ODATA-1258](https://issues.oasis-open.org/browse/ODATA-1258)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Do URLs within a Batch Request need to be URL Encoded?",
    "body": "I couldn't find anywhere in the docs where we say definitively whether a URL within a JSON payload needs to be URL Encoded.\n\nSame question for multipart/mixed, although the answers could differ?\n\n### Proposal\n\nURLs must be fully percent encoded in the request, including in a multipart batch request\n\nURLs represented as string within a JSON payload, including JSON batch, must follow standard OData encoding rules, which do not require that{color:#000000} colons in the query string be percent encoded.{color}\n\nImported from [ODATA-1257](https://issues.oasis-open.org/browse/ODATA-1257)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Harmonize usage of custom aggregates with structured aggregatable properties",
    "body": "Section 3.1 introduces custom aggregates as one of several options for aggregate expressions. This, however, is currently limited to custom aggregates defined for the type of the input set, because no path prefix is allowed.\n\nOn the other hand, for structured properties that are aggregatable, [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206) requested to describe the possibility to reference aggregatable properties in related sets by mentioning the navigation paths as prefix.\n\n \n\n### Proposal\n\nProposal is to handle this symmetric for custom aggregates and allow path prefixes as described in [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206):\n\nAn aggregate expression may be:\n\n...\n- a custom aggregate \"that can be reached via a path consisting of a sequence of navigation properties, complex properties and complex collection properties\"\n\nImported from [ODATA-1256](https://issues.oasis-open.org/browse/ODATA-1256)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Correct usage of $count",
    "body": "Section 3.1 introduces $count as one of several options for aggregate expressions.\n\nExample 57 applies $count relative to a collection-valued navigation property, which is a different use case that is backed by the commonExpr ABNF rule to address the count of a collection (see URL spec, section 4.8). Since section 3.1 requires commonExpr to be augmented with an aggregation method, such a method must be added to the request in the example.\n\nThe current aggregation ABNF contains a rule for $count with a path prefix, which needs to be cleaned up accordingly.\n\n### Proposal\n\nUpdate request in example 57:\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count *with sum* as SalesCount))`\n\nRewrite section on aggregate, last item in list on \"virtual property $count\": replace it with \"$count, which is a shortcut for 1 with sum\"\n\nImported from [ODATA-1255](https://issues.oasis-open.org/browse/ODATA-1255)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Can the default set of properties change over time?",
    "body": "Absent a $select, services are allowed to return a service-specific default set of properties.\n\nCan that service-specific default set of properties change over time?\n\nAdding new properties should be allowed, but what about removing properties from the default list.  Unless we explicitly call out that services can remove properties from the default set, we could break apps that were expecting the same set of properties on each request.\n\nHowever, if an app is expecting certain properties then they should be using $select to ensure they get those properties.\n\n\n### Proposal\n\nAbsent $select, the service is allowed to change the default set of properties returned. This includes returning new properties by default and omitting properties previously returned by default.\n \nClients that rely on specific properties in the response MUST use $select, with the required properties or with \"*\", to ensure that properties are not omitted from the response.\n\nImported from [ODATA-1254](https://issues.oasis-open.org/browse/ODATA-1254)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Abstract type definition Core.Number as a super-type of all numeric types",
    "body": "CSDL has the abstract built-in type Edm.Primitive but no (less abstract) sub-type for numeric values.\n\n### Proposal\n\nAdd type definition `Core.Number` with underlying type `Edm.PrimitiveType` annotated with Validation.DerivedTypeConstraint listing all numeric types (depends on [ODATA-1252](https://issues.oasis-open.org/browse/ODATA-1252)), see [https://github.com/oasis-tcs/odata-vocabularies/pull/224.](https://github.com/oasis-tcs/odata-vocabularies/pull/224)\n\nAlternative: `Types.Number` in new vocabulary, see [https://github.com/oasis-tcs/odata-vocabularies/pull/225.](https://github.com/oasis-tcs/odata-vocabularies/pull/225)\n\nA new Types vocabulary could also solve\n- [ODATA-220](https://issues.oasis-open.org/browse/ODATA-220)\n- [ODATA-287](https://issues.oasis-open.org/browse/ODATA-287)\n\nAlternatively we could add these types to the Core vocabulary, similar to\n- [Core.LocalDateTime](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#LocalDateTime)\n\n \n\n[https://github.com/oasis-tcs/odata-vocabularies/pull/224]\n or [https://github.com/oasis-tcs/odata-vocabularies/pull/225]\n\nImported from [ODATA-1253](https://issues.oasis-open.org/browse/ODATA-1253)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "TypeDefinition should allow Edm.Primitive as underlying type",
    "body": "In [ODATA-1034](https://issues.oasis-open.org/browse/ODATA-1034) we added a DerivedTypeConstraint for the purpose of constraining a typedefinition that specified Edm.Primitive to be one of a subset of primitive types (i.e., a string or integer).\n\nWhile we originally defined this annotation term as being applied to a TypeDefinition, we missed the fact that TypeDefinition was originally defined with an UnderlyingType that precluded Edm.PrimitiveType.\n\nDefining a type definition with an underlying type of Edm.PrimitiveType requires that we also define semantics around what facets can be applied.  For example, can MaxLength, Precision, or Scale be applied, and what is the meaning of these facets for instances for which those facets don't apply.\n\nThe same semantics need to be defined for a property of type Edm.PrimitiveType.\n\n### Proposal\n\nAllow Edm.PrimitiveType as an underlying type for TypeDefinition for 4.01 and greater schemas only.\nType-specific facets applied to Edm.PrimitiveType (in property or type definition) should be ignored by the client.\n\nImported from [ODATA-1252](https://issues.oasis-open.org/browse/ODATA-1252)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should annotated null/default values be omitted/restored?",
    "body": "In [ODATA-818](https://issues.oasis-open.org/browse/ODATA-818) we added the ability to omit null or default values based on a preference request header. If this preference was specified in the preference-applied response header, the client could assume that any missing properties had the null/default value.\n\nWe had to call out certain cases in which nulls/defaults could not be omitted, such as delta and request payloads.\n\nWe did not specify, though, if a property has annotations, but default/null value, whether it could be omitted.  Indeed, in many cases the annotation may be describing *why* the property was value was omitted, and restoring it to a null/default may violate the intention of annotating the value as being missing.\n\n\n### Proposal\n\nProperties that are annotated must not be omitted due to omit-values if they would otherwise be written.\n\n\nImported from [ODATA-1251](https://issues.oasis-open.org/browse/ODATA-1251)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "GeoJSON, SRID, and LineString",
    "body": "Two issues with the JSON Format specification and GeoJSON:\n\n1) The JSON Format specification states\n> Geography and geometry values are represented as geometry types as defined in *[[RFC7946](https://tools.ietf.org/html/rfc7946)]*, with the following modifications:\n> - Keys SHOULD be ordered with type first, then coordinates, then any other keys\n> - The coordinates member of a LineString can have zero or more positions\n> - If the optional CRS object is present, it MUST be of type name, where the value of the name member of the contained properties object is an EPSG SRID legacy identifier.\n\n\nThe CRS object is not defined in RFC7946, it was defined in the now obsolete predecessor [GeoJSON-2008](http://geojson.org/geojson-spec.html), and RFC7946 has explicitly removed the concept of \"coordinate reference systems\" (CRS) and restricts GeoJSON to World Geodetic System 1984 (WGS 84), which (fortunately) is the default for the SRID facet in OData (EPSG 4326).\n \n2) RFC7946 and GeoJSON-2008 require a LineString to have at least two positions: why do we additionally allow zero or one position? And what does that mean?\n\n### Proposal\n\n1) Add GeoJSON-2008 as a non-normative reference and point to it (especially to [http://geojson.org/geojson-spec.html#named-crs]) in the bullet point mentioning the CRS object. Discourage use of CRS object as it is not part of the final GeoJSON specification.\n\n(Note: we already reference RFC 7946 as a _normative_ reference, which in turn references GeoJSON-2008, but without a hyperlink. So whole point of the non-normative reference is providing the link).\n\n2) Remove extension to zero/one position for LineString by removing the second bullet point in the current text (see Description).\n\nImported from [ODATA-1250](https://issues.oasis-open.org/browse/ODATA-1250)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "edm.xsd: ActionImport and IncludeInServiceDocument",
    "body": "The edm.xsd erroneously allows specifying the IncludeInServiceDocument attribute for the edm:ActionImport\n\n### Proposal\n\nedm.xsd: restrict IncludeInServiceDocument to edm:FunctionImport as defined in the prose specification\n\nImported from [ODATA-1249](https://issues.oasis-open.org/browse/ODATA-1249)",
    "labels": [
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "csdl.schema.json: add descriptions to all schema elements",
    "body": "\n\n### Proposal\n\nSee summary.\n\nThis only affects csdl.schema.json, not the specification document.\n\nImported from [ODATA-1248](https://issues.oasis-open.org/browse/ODATA-1248)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "DerivedTypeConstraint should apply to entityset, singleton, navigation properties, parameters, and action/function returns",
    "body": "[ODATA-1232](https://issues.oasis-open.org/browse/ODATA-1232) proposed supporting \"union types\" by restricting the set of types derived from a common type.  In processing [ODATA-1232](https://issues.oasis-open.org/browse/ODATA-1232), we discovered that we already had an annotation term, DerivedTypeConstraint, for restricting the set of derived types.\n\nThe DerivedTypeConstraint annotation term was originally added in [ODATA-1034](https://issues.oasis-open.org/browse/ODATA-1034) to restrict the set of primitive types supported for a property or type definition. While it makes sense to use the same term for other constraints on derived type, we neglected to add those other targeted elements to the AppliesTo list.\n\n### Proposal\n\n Add the following items to the \"AppliesTo\" attribute of the DerivedTypeConstraint annotation term:\n\nEntitySet, Singleton, NavigationProperty, Parameter, ReturnType\n\nImported from [ODATA-1247](https://issues.oasis-open.org/browse/ODATA-1247)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Extract expression syntax into own sub-section next to $filter",
    "body": "Currently the common expression syntax is defined in subsections to $filter.\n\nCommon expressions are also used by $compute and $orderby, so it would help extracting them into an own subsection next to the system query options.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1245](https://issues.oasis-open.org/browse/ODATA-1245)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add a function to determine aggregated values within common expressions",
    "body": "Currently, there is no possibility to combine values of a single entity with an aggregated value determined from the input set in a single calculation. Expressions passed to the compute transformation always operate on properties of the individual entities in the input set. This prevents use cases like calculating the ratio of an entity's property value to an aggregated value from the input set. Examples for ratio calculations can be found in [ODATA-947](https://issues.oasis-open.org/browse/ODATA-947)\n\n### Proposal\n\n1.\n\nAdd a new section before 3.16 Evaluating $apply to define a function aggregate that has a single parameter accepting an aggregate-function expression and returns the aggregated value of type Edm.PrimitiveType as the result from applying the aggregate expression on an input collection provided by the context.\n\nAn aggregate-function expression offers the same capabilities as an aggregate expression defined for the aggregate transformation except that it does not support aggregation on related entities, and it never includes an alias for introducing a dynamic property containing the aggregated value.\n\nThe function can be applied in any expression derived from the commonExpr rule (see **[OData-ABNF]). Within $apply, the function is applied as part of an argument expression to a transformation, and the input set of that transformation is the input collection for the function. Outside of $apply, the function may be applied in requests querying collections in an argument expression for a system query option and a lambda operator. Inside a system query option, the collection on which it operates is used as input collection for the function. This is also valid for nested query options used as arguments, like $filter in $expand. Inside a lambda predicate expression the input collection for the aggregate function depends on the path expression used in the aggregateFunctionExpr (see ABNF below): For a path expression starting with the lambda variable the input collection is given by the target of the navigation path prepended to the lambda operator; for a path expression starting with $it the collection addressed by the resource path is the input collection; for other path expressions the input collection is given by the collection of instances at the origin of the navigation path prepended to the lambda operator.\n\n \n\n2.\n In the Data Aggregation’s ABNF, define the rule for computeAggregateMethodCallExpr as\n{noformat}\naggregateMethodCallExpr = 'aggregate' OPEN BWS aggregateFunctionExpr BWS CLOSE \n\naggregateFunctionExpr   = '$count'\n                        / commonExpr aggregateWith [ aggregateFrom ]\n                        / / [ inscopeVariableExpr \"/\" ] pathPrefix primitiveProperty aggregateWith [ aggregateFrom ]\n                        / / [ inscopeVariableExpr \"/\" ] pathPrefix customAggregate [ aggregateFrom ]\n{noformat}\nAdd the aggregateMethodCallExpr rule to the set of rules recognized by methodCallExpr within a commonExpr:\n{noformat}\nmethodCallExpr =/ aggregateMethodCallExpr\n{noformat}\n\nImported from [ODATA-1244](https://issues.oasis-open.org/browse/ODATA-1244)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether $orderby and string comparison with ge, gt, le, lt is language-specific",
    "body": "Alphabetical order of modified letters (â, ö, ñ, ...) is language-specific, see e.g.  [https://en.wikipedia.org/wiki/Alphabetical_order#Language-specific_conventions]\n\nCurrently it is neither specified how this must be implemented, nor is it explicitly left to the specific service.\n\nAlso alphabetical order typically places the uppercase variant of a letter next to its lowercase variant, i.e. A, a, AA, Aa, aa, AAA, AAa, ...\n\n### Proposal\n\nServices SHOULD compare and sort language-dependent properties according to the content-language of the response.\n\nImported from [ODATA-1243](https://issues.oasis-open.org/browse/ODATA-1243)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that resolved relative URIs in batch responses cannot contain content-ID references",
    "body": "With [ODATA-1234](https://issues.oasis-open.org/browse/ODATA-1234) we allow services to return URLs relative to the request URL in headers.  We need to clarify that in a batch response, the service is responsible for producing URLs that don't contain content-id references.\n\n### Proposal\n\nClarify that if the service returns URLs relative to the request URL in a response the service is responsible for ensuring the resolved URLs do not contain a content-ID reference.\n\nImported from [ODATA-1242](https://issues.oasis-open.org/browse/ODATA-1242)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support common expressions as values in URL-JSON",
    "body": "The `in` operator allows comparing a property to a list of values, e.g.\n```java\n$filter=Name in ('Milk', 'Cheese')```\nFor multi-part keys it would be helpful to allow comparison of a tuple of properties to a list of value tuples:\n```java\n$filter=(Firstname,Lastname) in (('John', 'Doe'),('Jane','Smith'))```\n Note that this is natively supported by some databases:\n- [https://docs.oracle.com/cd/B19306_01/server.102/b14200/conditions013.htm]\n- [https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_in] \n\n### Proposal\n\nAllow using common expressions as \"values\" in URL-JSON. This will allow to construct an array from properties as the left operand of  the `in` operator:\n```java\n$filter=[FirstName,LastName] in ([\"John\",\"Doe\"],[\"Jane\",\"Smith\"])```\nNote: a list of arrays is already allowed as the right operand.\n\nImported from [ODATA-1241](https://issues.oasis-open.org/browse/ODATA-1241)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 2: wrong description of how to split URLs into syntax components",
    "body": "The text currently says\n- Split undecoded URL into components scheme, hier-part, query, and fragment at first \":\", then first \"?\", and then first \"#\"\n\nThe query part is optional, and the fragment may contain the question mark character, so the description is incorrect. \n\nDon't try to capture the RFC3986 ABNF into concise and correct text.\n\n### Proposal\n\n1) Put parsing rules in a 2.1 subsection, and OData ANBF in a 2.2 subsection.\n2) In Parsing rules, shorten text of first step to:\n- Split undecoded URL into components scheme, hier-part, query, and fragment \n\nImported from [ODATA-1240](https://issues.oasis-open.org/browse/ODATA-1240)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]