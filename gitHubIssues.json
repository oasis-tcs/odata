[
  {
    "title": "Specify how OData services can be protected against cross-site request forgery (CSRF or XSRF)",
    "body": "A good CSRF protection pattern is that the server issues a CSRF token that is communicated to the in a special header in responses to GET requests.\nThis CSRF token must be included in a special header in subsequent modifying requests.\n\nTo guarantee interoperability between different OData implementations the choreography, header names, and header formats must be standardized.\n\n### Proposal\n\nCreate a TC Note in order \"Securing Open Data\" to address security issues and add this to that note.\n\nThe client adds the header \n\n    X-CSRF-Token: Fetch\n\nto a GET request. The header value \"Fetch\" is case-insensitive. \n\nThe server adds the same header to the response. The header value is generated by the server. It is opaque, i.e. the client has to copy it verbatim without alteration. As a consequence it is case-sensitive.\n\nThe client adds this header with the copied, unaltered value to subsequent POST, PUT, PATCH, or DELETE requests.\n\nThe server accepts the modifying request if and only if the provided CSRF token is still valid. \n\nIf the token is invalid, the server responds with 403 Forbidden and includes the response header\n\n    X-CSRF-Token: Required\n\n\nIf a server requires a CSRF token for modifying requests, it MUST issue a CSRF token in responses to GET requests to the service document as this is the only well-known and small resource of a service. To guarantee freshness of the CSRF token the server MUST include cache control headers that advise intermediaries and clients to refresh their caches. The refresh period or point in time MUST be chosen to guarantee that the caches are refreshed before the CSRF token expires.\n\nThe service SHOULD issue a CSRF token in responses to GET requests to other resources whose cache residence period is sufficiently shorter than the CSRF token validity period.\n\nThe client MUST NOT assume to get a CSRF token in responses to GET requests to the metadata document, as this is typically not small and SHOULD be cached anyway, so there's no guarantee to get a fresh CSRF token.\n\nFor $Batch the X-CSRF-Token MUST be provided as a header. It's not allowed to specifiy any X-CSRF-Token in the \"inner\" requests.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49447/odata-meeting-40_on-20130606-minutes.html#odata-262\n\nImported from [ODATA-262](https://issues.oasis-open.org/browse/ODATA-262)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Explicitly disallow certain XML constructs (for CSDL, ATOM) to enhance OData security",
    "body": "Considering the XML security vulnerabilities detailed in:\n\n  http://stackoverflow.com/questions/1906927/xml-vulnerabilities\n\nit might be prudent to explicitly disallow certain XML constructs (DOCTYPE, ENTITY definitions and processing instructions) in ATOM, CSDL and any other XML documents used by OData.\n\nSpecifically, a server receiving an XML document from the client, and a client receiving a document from the server, would be \"permitted to ignore\" (or preferably, \"required to reject\"):\n\n(1)  XML DOCTYPE definitions\n(2)  XML ENTITY definitions\n(3)  XML processing instructions\n\n### Proposal\n\nServers should reject XML documents with  XML DOCTYPE definitions, XML ENTITY definitions, and XML processing instructions.\n\nClients may reject  XML documents with  XML DOCTYPE definitions, XML ENTITY definitions, and XML processing instructions.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50225/odata-meeting-48_on-20130808-minutes.html#odata-461\n\nImported from [ODATA-461](https://issues.oasis-open.org/browse/ODATA-461)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": []
  },
  {
    "title": "Clarify representation of floating-point numbers",
    "body": "We specify Edm.Double and Edm.Single to be IEEE754 binary floating-point numbers with 64 and 32 bits.\n\nUnfortunately the IEEE754 specifications are not freely available, and their publicly available excerpts in e.g. Wikipedia and XML Schema 1.1 Part 2 seem to diverge in the fine points of\n- normalized and denormalized values\n- smallest and largest positive and negative values\n\nAlso we don't give guidance like \"always produce normalized values, always accept all values and round appropriately\".\n\n### Proposal\n\nCreate a Committee Note  \"Implementing OData 4.0\" with hints/guidelines for implementers of OData. Using a non-normative committee note allows shorter response cycles than a normative specification document.\n\nImported from [ODATA-554](https://issues.oasis-open.org/browse/ODATA-554)",
    "labels": [
      "Implementing OData",
      "CN01"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Should we support dynamic functions/actions?",
    "body": "Currently we don't say whether or not we support dynamic actions/functions.\n\nCurrently, clients rely on metadata to describe parameters that can be passed to a function/action, so we would either have to augment the function/action element to describe parameters (and return type?) or restrict dynamic actions/functions to parameterless versions.\n\nImported from [ODATA-579](https://issues.oasis-open.org/browse/ODATA-579)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Investigate enhancements to interoperability and feature set of OData JSON through JSON-LD",
    "body": "Driven by current analysis of JSON-LD in the GeoJSON community, I kindly suggest we investigate how JSON-LD (A JSON-based Serialization for Linked Data) might be mixed into OData JSON to avoid interoperability problems when our annotation and referencing style meets the \"@\" key culture of JSON-LD.\n\nSpecification: URL=http://www.w3.org/TR/json-ld/ \nand Community URL=http://json-ld.org/\n\nWriting while thinking about it: Maybe a vocabulary might enable aliasing of the keys for JSON-LD overlapped concepts?\n\nCiting the content of JSON-LD 3.3 \"Syntax Tokens and Keywords\" to go \"in medias res\":\n\n\"\"\"\nJSON-LD specifies a number of syntax tokens and keywords that are a core part of the language:\n\n@context\n    Used to define the short-hand names that are used throughout a JSON-LD document. \n    These short-hand names are called terms and help developers to express specific identifiers in a compact manner. \n    The @context keyword is described in detail in section 5.1 The Context.\n\n@id\n    Used to uniquely identify things that are being described in the document with IRIs or blank node identifiers. \n    This keyword is described in section 5.3 Node Identifiers.\n\n@value\n    Used to specify the data that is associated with a particular property in the graph. \n    This keyword is described in section 6.9 String Internationalization and section 6.4 Typed Values.\n\n@language\n    Used to specify the language for a particular string value or the default language of a JSON-LD document. \n    This keyword is described in section 6.9 String Internationalization.\n\n@type\n    Used to set the data type of a node or typed value. This keyword is described in section 6.4 Typed Values.\n\n@container\n    Used to set the default container type for a term. This keyword is described in section 6.11 Sets and Lists.\n\n@list\n    Used to express an ordered set of data. This keyword is described in section 6.11 Sets and Lists.\n\n@set\n    Used to express an unordered set of data and to ensure that values are always represented as arrays. \n    This keyword is described in section 6.11 Sets and Lists.\n\n@reverse\n    Used to express reverse properties. This keyword is described in section 6.12 Reverse Properties.\n\n@index\n    Used to specify that a container is used to index information and that processing should continue deeper into a JSON data structure. \n    This keyword is described in section 6.16 Data Indexing.\n\n@base\n    Used to set the base IRI against which relative IRIs are resolved. This keyword is described in section 6.1 Base IRI.\n\n@vocab\n    Used to expand properties and values in @type with a common prefix IRI. This keyword is described in section 6.2 Default Vocabulary.\n\n@graph\n    Used to express a graph. This keyword is described in section 6.13 Named Graphs.\n\n:\n    The separator for JSON keys and values that use compact IRIs.\n\nAll keys, keywords, and values in JSON-LD are case-sensitive.\n\"\"\"\ncitation source at URL=http://www.w3.org/TR/json-ld/#syntax-tokens-and-keywords\n\nThe decorated IRI terms are described non-normatively e.g.. in section 6.1 for compact IRI:\n\n\"\"\"\nA compact IRI is a way of expressing an IRI using a prefix and suffix separated by a colon (:). The prefix is a term taken from the active context and is a short string identifying a particular IRI in a JSON-LD document. For example, the prefix foaf may be used as a short hand for the Friend-of-a-Friend vocabulary, which is identified using the IRI http://xmlns.com/foaf/0.1/. A developer may append any of the FOAF vocabulary terms to the end of the prefix to specify a short-hand version of the absolute IRI for the vocabulary term. For example, foaf:name would be expanded to the IRI http://xmlns.com/foaf/0.1/name.\n\"\"\"\n\nImported from [ODATA-601](https://issues.oasis-open.org/browse/ODATA-601)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Security:services should consider what media types they support",
    "body": "OData supports serving arbitrary media types stored in media entities streams, streamed properties, and binary properties that can be retrieved in their native format using $value.\n\nWhile this is certainly useful, for example in serving pictures directly from the ODataURL, there is a risk that this may be abused by attackers, for example by uploading ‘text/html’ content which contains a Cross-Site-Scripting payload. Once a user views this payload, it can then be used to make arbitrary OData calls and exfiltrate data, possibly crossing an intranet/internet boundary.\n\nIn general, anything that returns a content type of the client choice (as text/html, javascript, etc.) may cause typical web application attacks.\n\n\n### Proposal\n\nDescribe the potential for cross-site-scripting attacks when serving arbitrary media types and recommend that services carefully consider the media types they allow, for example by whitelisting expected media types (i.e., restrict to image/* if you are expecting an image). Note that services can report their set of supported types using the Core.AcceptableMediaTypes annotation.\n\nImported from [ODATA-626](https://issues.oasis-open.org/browse/ODATA-626)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": []
  },
  {
    "title": "Security: Returning 404 (Not Found) versus 401 (unauthorized) could leak information",
    "body": "If an unauthorized attacker can query a particular user and receive a 404 if the user does not exist, there is a potential for information leakage. \n\nIn general, security checks should always take place before any other processing, and 401 should be valid a valid response to any request.\n\n\n### Proposal\n\nClarify that the 401 unauthorized response is valid on any request, and that authorization should be checked before any further processing of any request, including 404 not found.\n\nImported from [ODATA-627](https://issues.oasis-open.org/browse/ODATA-627)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": []
  },
  {
    "title": "Security: Service implementors should consider timing-based information leakage attacks",
    "body": "If OData is used in a web application scenario, information about existence of OData endpoints may leak using time sidechannels. The attack scenario is as follows: an attacker forces a victim to load an OData resource in his browser (for example using an <img> or <iframe> tag) and times how long the loading takes. It is thus possible for the attack to observe whether an empty/401 response (small) or a 200 response with a certain payload size (“big”) was returned. Combined with the powerful OData syntax ($filter, contains() etc.), iterated requests may be used to leak information.\n\n\n### Proposal\n\nDescribe this possible vulnerability from \"automated requests\". This attack is mitigated by the attacker having to know (or guess) the presence, address, and schema of the internal service.\n\n\nImported from [ODATA-628](https://issues.oasis-open.org/browse/ODATA-628)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": []
  },
  {
    "title": "Security: Returning Core.Permission'None' could be information leakage",
    "body": "11.2.2 specifies that if properties are not available due to permissions, the Core.Permission’None’ is returned for that property. \n\nFor dynamic properties not advertised in metadata, there could be scenarios where even the fact that the property exists would be information leakage. For example, if the client specified the unadvertised property in $select and looked for a Core.Permission'None' annotation rather than a failed request.\n\n### Proposal\n\nDescribe the threat for the scenario where the existence of a particular dynamic property on an entity is privileged information and suggest the option of failing the request rather than returning the Core.Permission'None' for such properties. In general, services should not expose a different value for a property that doesn't exist and a property that exists but for which the authenticated user does not have permissions.\n\nImported from [ODATA-629](https://issues.oasis-open.org/browse/ODATA-629)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": []
  },
  {
    "title": "Parallel processing within batch requests",
    "body": "Describe that service implementations can process adjacent GET requests in parallel as long as the responses are represented in the order the requests appear in the batch request. Only change sets and stand-alone data modification requests have to wait for preceding request to finish.\n\nThis might require invisible contracts between the server-side service infrastructure and the actual data provider code as to whether the supposedly non-side-effecting GET requests really can be parallelized, but this is nothing that shows up in the protocol or $metadata.\n\nImported from [ODATA-714](https://issues.oasis-open.org/browse/ODATA-714)",
    "labels": [
      "Implementing OData",
      "CN01"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Lack of ordering constraints on delta responses may require clients to buffer (or persist) entire response to process it correctly",
    "body": "Firstly, a client may receive an \"added link\" before receiving one or both of the entities it refers to. In order to be able to maintain referential integrity (or surrogate foreign keys) the client might need to buffer (or persist) the \"added links\" until it has received the missing entities.\n\nSecondly, a client may receive a \"deleted entity\" before receiving a \"deleted link\" to remove the entity from a relationship. If the navigation property concerned was not marked in CSDL with <OnDelete Action=\"Cascade\" />, then the client may not be able to avoid buffering/persisting the \"deleted entity\" notification while awaiting possible later \"deleted link\" notifications.\n\n\n### Proposal\n\nAdd appropriate ordering constraints for delta responses to avoid situations where clients may need to buffer or persist changes in order to be able to correct process the delta response (including but not limited to the maintenance of referential integrity in the client's view of the data).\n\n\nImported from [ODATA-730](https://issues.oasis-open.org/browse/ODATA-730)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Consider use of OPTIONS for discovering formats, other capabilities and features",
    "body": "See ODATA-805 for an example of where this would be useful.\n\nAlso consider CORS, where browsers do a \"pre-flight check\" via OPTIONS, see ODATA-962\n\nSee https://tools.ietf.org/html/rfc7231#section-4.3.7\n\nImported from [ODATA-854](https://issues.oasis-open.org/browse/ODATA-854)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Support Arrays of Arrays",
    "body": "There are scenarios where it's convenient to represent something as an array of arrays. In JSON this would look as:\n\n[[\"foo1\",\"bar1\"],[\"foo2\",\"bar2\"]]\nor\n[[{\"foo\":\"foo1\"},{\"bar\":\"bar1\"}],[{\"foo\":\"foo2\"},{\"bar\":\"bar2\"}]]\n\nCurrently services must represent these as arrays of complex types that have array properties. In JSON, the result looks like:\n\n[{\"value\":[\"foo1\",\"bar1\"]},{\"value\":[\"foo2\",\"bar2\"]}]\nor\n[{\"value\":[{\"foo\":\"foo1\"},{\"bar\":\"bar1\"}]},{\"value\":[{\"foo\":\"foo2\"},{\"bar\":\"bar2\"}]}]\n\nIf we are trying to make JSON representation as close as possible to a custom representation we would need to support the former syntax (without the \"value\" objects).\n\nOne problem with arrays of arrays in JSON is that we don't have a way to annotate the (array) items within the array. For example, we couldn't add count, nextLink, etc. for the inner arrays..\n\n### Proposal\n\nProposal:\n1) Defer supporting collections of collections until we work through semantics.\n2) When we do support collections of collections ... of types, represent in CSDL as Type=\"Collection(Collection(...myType.Foo...))\"\n3) In JSON, always represent the inner collections as an object with a \"value\" property that is the array containing the collection members. In this way we have a consistent representation that supports annotating the inner members.\n4) arrays of arrays in JSON can still be represented as untyped or Collection(untyped).\n5) Take some time to think through other ramifications (i.e., how we reference nested collections within a request). For example:\n    a) How do we get counts on nested members?\n    b) How do we get just nested members with more than 10 values?\n    c) How do we apply a filter to nested members?\n    d) How do we select a subset of properties from nested members?\n    e) etc...\n\nPrevious Proposals:\n1) Don't add a formal notion of arrays of arrays to the data model (it breaks too many rules). Instead, use \"Edm.Untyped\" (see ODATA-881) or \"Collection(Edm.Untyped)\" (see ODATA-973) as a way to allow payloads that contain such structure.\n\n2) Support a new application/json type parameter \"odata.annotations\" that can have values \"external\" or \"structured\".  \"external\" is the current behavior, is the default, and is required for conformance. \"structured\" means that annotations on non-structured property values are represented by converting the property value to an object containing any annotations plus the property \"value\" containing the value for the property. If a JSON payload contains an array of non-structured values, and odata.annotations=structured is not specified, then those annotations are omitted. If the annotations are necessary for correctly interpreting the payload (for example, odata.nextLink), then the service returns an error. \n\n3) Similar to TypeDefinition for primitive types add a CollectionTypeDefinition element with an UnderlyingType attribute and a Nullable facet that allows defining a reusable collection type. The underlying type can be any type in scope, including another CollectionTypeDefinition, as long as that doesn't introduce a cycle. If the UnderlyingType is a primitive type, other type-specific facets can be specified.\n- JSON representation of a CollectionTypeDefinition instance is an array whose items are representations of instances of the UnderlyingType\n- Consider using the shorter name of CollectionType which was used with similar semantics and different syntax in OData V3, https://msdn.microsoft.com/en-us/library/ee781155.aspx\n- Consider using the TypeDefinition element for defining both faceted primitive types and collection types\n\n\nImported from [ODATA-879](https://issues.oasis-open.org/browse/ODATA-879)",
    "labels": [
      "CSDL XML",
      "JSON Format",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Specify the result type for each operation based on operator types",
    "body": "See ODATA-785 for a description of the issue --> Comments Section.\n\n### Proposal\n\nSpecify the result type for each operation based on operator types (refine and put in matrix) \na) int* add/mult/sub int* => int64 (may be +/-inf) \nb) Int* add/mult/sub decimal/single/double => promotion rules will promote, then type \nc) int* div int* => loperand (or larger) -> service can always promote to int64 \nd) Int* div decimal/single/double => roperand \ne) decimal/single/double div number => operation promotes smaller operand; result is that type \nf) number divideby number =>decimal \ng) Int* mod Int* the type of the loperand (or larger) \nh) Int* mod decimal/single/double => roperand (service can promote to decimal) \ni) Decimal/single/double mod number => loperand (service can promote to decimal) \nj) Single add/mult/sub single -> single \nk) Double add/mult/sub Double -> double (note, if either operand is single, gets promoted to double) \n\nl) Don't promote outside of type families \nm) Do not promote Single->Double \n\n\n\nImported from [ODATA-919](https://issues.oasis-open.org/browse/ODATA-919)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Support subsetting returned metadata",
    "body": "After being able to partition large services into smaller ones using cross-service navigation we might want to support requesting multiple of these small files in one request, similar to expanding an entity and including related entities.\n\n### Proposal\n\nAdd a new preference, metadata-scope, that can be specified on a metadata request. The value follows the syntax for the fragment portion of a context URL to describe the shape of results for which the client needs metadata.\n\nClients can then extract the fragment portion of the context url to use in the preference to requests only the metadata required to describe that particular response.  If the response spans multiple namespaces the service MAY include multiple schema elements in the response, one per namespace containing types used in the response.  Since this is a preference, services can also ignore and just return the metadata with references to related metadata.\n\nServices that support the metadata-scope preference SHOULD include a preference-applied header specifying the contextUrl fragment identifying the results described by the returned metadata.\n\nExample: to include the metadata required to describe customers and their orders, the client could specify:\n\nhttp://sampleservice.com/$metadata\nPrefer: metadata-scope=Customers(Orders)\n\nServices can return preference-applied to specify the extent of the metadata included. For any included namespaces, the service must return at least the requested data, but data in related namespaces can be referenced through Include.\n\nImported from [ODATA-923](https://issues.oasis-open.org/browse/ODATA-923)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "CORS Support",
    "body": "When a client application is written in any of java script technologies like AngularJS, JQuery they use XMLHttpRequest. If they are doing a cross domain call to a OData service, they will be subjected to CORS, especially when any authentication is defined on the OData service.\n\nA good write up CORS can be found here https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS\n\nShould OData as specification, recommend this to implemented on OData based services or leave it up to the service developer as implementation detail.\n\nImported from [ODATA-962](https://issues.oasis-open.org/browse/ODATA-962)",
    "labels": [
      "Implementing OData",
      "CN01"
    ],
    "assignees": [
      "zurmuehl"
    ]
  },
  {
    "title": "Make Data Great Again!",
    "body": "null\n\nImported from [ODATA-1000](https://issues.oasis-open.org/browse/ODATA-1000)",
    "labels": [],
    "assignees": []
  },
  {
    "title": "Security experts at RSA suggest adding guidance on the use of OAuth and openID",
    "body": "1.\tSince both OAuth and OpenID Connect (OIDC) define a broad framework, they offer a number of options in the based specification. Also there are new extensions and additions to these specs (especially for OAuth) that would add additional security or interoperability features. Therefore, when these standards are used in other specifications (such as in your case OData using OAuth), it is important to define a profile for the base spec (i.e. defining an Aoth Profile for OData) for two reasons:\na.\tTo define a concrete use of the base standard by eliminating the many options and clarifying the use model for the sake of interoperability\nb.\tTo adopt the unique combination of attributes, options, and extensions defined for the base standards that meet the needs of the consuming spec (i.e. OData)\n2.\tSome examples of what profile can tidy up regarding the base standard, OAuth in this case, are:\na.\tIs Dynamic client registration required?\nb.\tIs Discovery service required to be supported by Authorization Service?\nc.\tHandling of Token revocation\nd.\tIs the recent RFC for mitigating interception of Authz code required (PKCE [RFC 7636](https://datatracker.ietf.org/doc/rfc7636/))\ne.\tOAuth Token format (e.g. JSON format - [RFC 7519](https://datatracker.ietf.org/doc/rfc7519/))\nf.\tIs Introspection service required for resource server being able to query the Authorization server for metadata about the token ([RFC 7662](https://datatracker.ietf.org/doc/rfc7662/))\ng.\tConcrete or range-recommendation on token lifetimes\nh.\tIs it required for better security to mandate Proof of Possession (POP) ([RFC 7800](https://www.rfc-editor.org/rfc/pdfrfc/rfc7800.txt.pdf)) instead of the Bearer token?\n3.\tA similar (but simpler) profile can be defined for OData use of OIDC \n4.\tA good set of sample profiles you can examine for more clarification on above suggestions are the OAuth and OIDC profiles defined for use of OAuth in Healthcare ([HEART profiles](http://openid.net/wg/heart/)):\na.\t[HEART OAuth Profile](http://openid.bitbucket.org/HEART/openid-heart-oauth2.html#rfc.section.3.2.2))\nb.     [HEART OIDC Profile](http://openid.bitbucket.org/HEART/openid-heart-oidc.html))\n5.\tA good place for getting a broad view on all extensions and additions to OAuth core spec is the IETF DataTracker for OAuth that lists the approved RFCs as well as ongoing draft specifications:\na.\thttps://datatracker.ietf.org/wg/oauth/documents/\nHope this helps as opposed to just add confusion and complexity \n\nIn your particular case, depending on the use cases for OData, you may decide some of the above are unnecessary. But even then, if not a formal profile, perhaps a set of implementers guidelines should address the areas of the OAuth spec that are ambiguous or too broad.\n\n\n### Proposal\n\nAdd documentation that addresses the issue described.  Include a recommendation for a base profile.\n\nImported from [ODATA-1011](https://issues.oasis-open.org/browse/ODATA-1011)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": [
      "sthagen"
    ]
  },
  {
    "title": "Consider the \"fragility\" of server-driven paging",
    "body": "Server-driven paging can make client applications \"fragile\", as follows... \n\nSuppose that a server doesn't support server-driven paging (or supports it only for responses over a certain response size that the client has never queried for). \n\nNow suppose that a client has been developed without regard for server-driven paging. That client may be easily \"broken\" (fail to receive all applicable response data) if: \n\n (1) The server is upgraded to support server-driven paging, or \n (2) Response sizes go over a threshold due to growth in the volume of data at the server. \n\nNow things can get worse, since depending on interpretation of the spec, next-links can appear at any level within a result, e.g. \n\nhttp://docs.oasis-open.org/odata/odata-json-format/v4.0/errata03/os/odata-json-format-v4.0-errata03-os-complete.html#_Toc453766645 \n\nThis means that clients have to mix parsing with network-level access, i.e. a client that wants to be sure to receive all of the requested data must be prepared to walk over the initial response \"graph\" (e.g. JSON result) issuing additional network requests to follow all next-links which may appear in the graph. This is such an onerous requirement that it is unlikely that many clients will properly implement it. The result: a \"fragile\" client which may silently fail to retrieve all relevant expected response content. \n\nAnother case to consider is where a client uses a batch request to batch several queries (to avoid round-trips). This can be easily defeated by a server which may return next-links in each of the batched responses. The client may be unable to reduce round-trips as much as expected if many next-links are returned (or if the server uses a page size which is unreasonably small). \n\nThe above difficulties with next-links suggest a redesign of server-driven paging may be warranted.\n\n\n\n### Proposal\n\nAdd a warning to the spec to advise readers to be mindful that next-links can appear at any level in a server response, and that client applications will therefore need to be aware of this to ensure that data isn't unexpectedly missing when they process a response.\n\nImported from [ODATA-1052](https://issues.oasis-open.org/browse/ODATA-1052)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Improve specification and use of NavigationProperties, EntitySets, and Singletons",
    "body": "There is significant confusion over the role and semantics of Singletons and EntitySets.  For example, since Nullable is not an attribute, it is assumed that they must have a value, but implementors are also assuming that if a particular Singleton or EntitySet is not implemented, then a value need not be returned.\n\nObservations on Singletons and EntitySets from an OData metamodel point of view:\n1) A Singleton is a scalar Property with a Type that is an EntityType.\n2) An EntitySet is an array Property with a Type that is an EntityType.\n3) A NavigationProperty with ContainsTarget=\"True\" is a scalar or array Property with a Type that is an EntityType.\n4) A NavigationProperty with ContainsTarget=\"False\" is an association end with a Type that is an EntityType.\n\nThe overlap of 1, 2, and 3 is a source of great confusion.  Additionally the reasons for variations in semantics of these metatypes are not clear.  (i.e. missing Nullable attribute.)\n\n\n\n\n### Proposal\n\nThe following proposals are alternatives for simplifying the OData metamodel.\n\n\nProposal 1:\nAdd clarifying text to 4.01 along these lines:\n•\tA property must be owned by a StructuredType and must have a type\n•\tA scalar property is a property and may have at most one value that is an instance of its type\n•\tA collection property is a property that may have zero or more values that are instances of its type \n•\tA reference type value is a reference to an instance of the type\n•\tAn association end is a property that must be owned by a StructuredType and must have a reference type\n•\tEntityContainer is a special kind of StructuredType that must have exactly one instance in a model\n•\tEntitySet is a special kind of collection property that must be owned by an EntityContainer and must have type EntityType\n•\tSingleton is a special kind of scalar property that must be owned by an EntityContainer and must have type EntityType\n•\tA containment NavigationProperty (ContainsTarget=”True”) is a special kind of collection or scalar property that must be owned by an EntityType or ComplexType and must have type EntityType\n•\tA non-containment NavigationProperty (ContainsTarget=”True”) is a special kind of collection or scalar association end that must be owned by an EntityType or ComplexType and must have type EntityType\n\nAdvantages of proposal 1: \n* No changes required to implementations. \n\nProposal 2: \n1) Allow use of Singleton and EntitySet in the context of an EntityType or ComplexType declaration.\n2) Deprecate the ContainsTarget attribute.\n3) Add Nullable attribute to Singleton and EntitySet.\n\nThe advantages of Proposal 3:\n1) Eliminates implied Singleton and EntitySet.  These are now first class citizens in all cases.\n2) Simplifies specifications since containment NavigationProperty is eliminated.\n3) Clarifies whether or not a value may be omitted.\n\nProposal 4:\n1) Add EntityProperty, with same syntax and semantics as Property except that Type must be an EntityType.\n2) Allow use of EntityProperty in the context of EntityContainer, EntityType, or ComplexType.\n3) Deprecate the ContainsTarget attribute.\n4) Deprecate Singleton and EntitySet\n5) Modify syntax of NavigationProperty to only reference EntityProperties.\n\nThe advantages of Proposal 3:\n1) Eliminates Singleton and EntitySet.  These are now first class EntityProperty elements in all cases.\n2) Eliminates need for ContainsTarget attribute and therefore the concept of containment NavigationProperty.\n3) Rationalizes the syntax differences between Singleton, EntitySet, and NavigationProperty around Property.\n4) Simplifies semantics of NavigationProperty as an association.\n5) Clarifies whether or not a value may be omitted.\n\nProposal 4:\n1) Same as Proposal 3 except that instead of adding EntityProperty, instead extend Property to allow Type to be an EntityType.  In this case, the spec might refer to an entity property as a Property with Type that is an EntityType.\n2) Allow use of Property in the context of EntityContainer, EntityType, or ComplexType declarations.\n3) Deprecate the ContainsTarget attribute.\n4) Deprecate Singleton and EntitySet\n5) Modify syntax of NavigationProperty to only reference entity properties.\n\nThe advantages of Proposal 4:\n1) Everything in Proposal 3.\n2) Does not add a new metatype. \n\n\n\nImported from [ODATA-1059](https://issues.oasis-open.org/browse/ODATA-1059)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "GEricson"
    ],
    "repo": "odata-abnf"
  },
  {
    "title": "Improve specification of element response requirements",
    "body": "Element response requirements:  \nThere is ambiguity on the use and meaning of Nullable.  \n\nThe reason is a distinction between the semantics of Nullable and whether or not implementation is required.  \n\nAt least in one example, it is common practice to allow a Nullable=False property to be excluded from a response with the implied meaning of not implemented.  The implementation requirement is not a term defined by OData.\n\nProposal:\n1) Add the following Term to Core:\n\n<Term Name=\"ImplementationRequired\" Type=\"Core.Tag\" DefaultValue=\"false\">\n<Annotation Term=\"Core.Description\" String=\"If 'true', implementation of the qualified element is required. If the required element is Nullable and has no value, it may be omitted from a response.  Otherwise it must be present in a related response.\" If an element is not required, it may be omitted from a related response.  If an element is not required and is not Nullable and is not present in a response, it may be assumed to have not been implemented.  If the element is Nullable and not present in a response, it may either have no value or have not been implemented.\" />\n</Term>\n\nThe following summarizes the above:\na.\tNullable=True, Implementation=Optional => Omission implies no value or not implemented\nb.\tNullable=True, Implementation=Required => Omission implies no value\nc.\tNullable=False, Implementation=Optional => Omission implies not implemented, the value is unknown.\nd.\tNullable=False, Implementation=Required => Omission is not allowed, the property must indicate Null if no value.\n\n\n### Proposal\n\nProposal:\n1) Add the following Term to Core:\n\n<Term Name=\"ImplementationRequired\" Type=\"Core.Tag\" DefaultValue=\"false\">\n<Annotation Term=\"Core.Description\" String=\"If 'true', implementation of the qualified element is required. If the required element is Nullable and has no value, it may be omitted from a response.  Otherwise it must be present in a related response.\" If an element is not required, it may be omitted from a related response.  If an element is not required and is not Nullable and is not present in a response, it may be assumed to have not been implemented.  If the element is Nullable and not present in a response, it may either have no value or have not been implemented.\" />\n</Term>\n\nThe following summarizes the above:\na.\tNullable=True, Implementation=Optional => Omission implies no value or not implemented\nb.\tNullable=True, Implementation=Required => Omission implies no value\nc.\tNullable=False, Implementation=Optional => Omission implies not implemented, the value is unknown.\nd.\tNullable=False, Implementation=Required => Omission is not allowed, the property must indicate Null if no value.\n\nImported from [ODATA-1060](https://issues.oasis-open.org/browse/ODATA-1060)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "GEricson"
    ],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Formally define OData Metamodel ",
    "body": "Various aspects of OData seem unclear or redundant.  A formal UML model for the OData metamodel can be used to clarify and simplify OData.   \n\nThe existing metamodel defined by 'MetadataService.xml' contains much of what is needed, but has some issues, such as:\n- The MetadataContainer element refers to metadata elements, but should be referencing instances of metadata elements (i.e. schema).  \n- Various language elements are included, (eg. ne and eq)\n\nThe included proposal started from scratch out of a need to understand several concepts, including the semantics of Singletons and EntitySets.  It needs to be rationalized with the existing 'MetadataService.xml' .  It is preliminary and needs review and refinement.  It is expressed in CSDL XML.  (See https://www.oasis-open.org/apps/org/workgroup/odata/download.php/60420/OdataMetamodel.xml.)   UML diagrams are provided that illustrate this proposal.  (See: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/60421/OdataMetamodel.pdf)\n\nAn advantage of the UML model is that it expresses the Odata metamodel in precise terms.  Constraints and requirements on the various elements of the model are expressed normatively using the UML model together with UML Object Constraing Language (OCL) statements.  An added Term supports this.\n\nThe various schema definition languages CSDL XML, CSDL JSON, and others should conform to the OData metamodel.\n\n\nImported from [ODATA-1062](https://issues.oasis-open.org/browse/ODATA-1062)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Clarify text related to Canonical URL",
    "body": "Clause 3 and 4 \nMultiple thoughts:\nIn Clause 4\n* What are resource path conventions for entity container children?  Is that the Canonical URLs?  Please clarify.e comments.\n\nMore in proposal below.\n\n### Proposal\n\nClause 4\n* Clarify meaning of resource path conventions for entity container children.\n\nRecast clause 4 around 4 major sections\n1) Well-known URLs (clause 3, 4.1 and 4.2)\n- Service document\n-- Clarify that this URL is the URI of the service's EntityContainer\n-- Clarify that the services EntityContainer is the service document and is the service root.\n-- Pick a term: service document or service root: It is confusing to use both.\n- Metadata document\n-- possible to also make a metadata attribute of the service document\n-- clarify that $metadata addresses the metadata document that contains the declarations that define the service's entity model.\n-- clarify requirement to expose the metadata document.\n- Batch endpoint.\n-- possible to also make a metadata attribute of the service document\n-- clarify requirement to support a Batch service\n\n2) Canonical URLs  (clause 4.3)\nClarify that the requirements of this section are normative if Canonical URLs are supported.\nSection 4.3.1\n- 1st paragraph doesn't parse.  As stated elsewhere, all entities must be belong to a singleton or entity set.  So, not clear what the canonical path of a non-contained entity is.  I am guessing that the text is meant to specify  an implied entity set in the services entity container for all entities for which the entity set has not been explicitly declared.  But... this text needs to be clarified.\n-- All references to entity set need to also be to singletons.  Or maybe better.... define singletons as a special case of entity set where the max cardinality is 1.\n\nConsolidate references to keys to a single section defining keys both as URL segments or as parenthesized values.  Define the pitfalls of the segment formulation there.\n\n3) Composable URLs (clauses 4.4 - 4.10\nClause 4.4 should be rephrased. OData does not directly reference the references (associations in the UML sense) between entities.  Rather it references association ends (the Navigation Properties and depending on operation, there are side-affects on the association.  Two concepts:\n1)\tThe value of an association end (i.e. Navigation Property) is either a reference to or by-value copy of the related element.\n2)\tThe association itself is not a directly addressable model element in OData.  OData does not support UML Association Classes.   Navigation Properties are essentially association ends that are owned by the referencing type.  (In the UML sense.)  The opposite end is owned by the association in the case of no Partner specification.  Otherwise it is owned by the related type.  In either case, the UML association can be deleted.  In the second, the partner is also set to null.\n\n4) Operations on URLs (4.11 - 4.16)\n\n\nImported from [ODATA-1070](https://issues.oasis-open.org/browse/ODATA-1070)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Nullable Collection Navigation Property",
    "body": "There is the assertion:\n\"Nullable MUST NOT be specified for a collection-valued navigation property, a collection is allowed to have zero items.\"\n\nA property, regardless of multiplicity consumes a slot in an instance (entity representation).  The slot has a sequence of values, depending on cardinality.  If the slot has no values, then the property is said to be null.  If an entry in a list of values has no value, then that entry is null.  So, you can both have a collection property that is null or a collection property consisting of a list of null values.  After much discussion, the DMTF specified the following for the values of a collection property (i.e. upper bound on multiplicity > 1)\n- NULL: The collection has no specified value.\n- [] : The collection has no elements (I.e. size = 0\n- [ Null ] : The collection has one element specified as having no value\n- [ \"\" ] : The collection has one element specified as having the empty string\n- [ \"x\", Null, \"y\",...] : The collection has multiple elements, some may be specified as having no value.\n\nThe collection representing the list of values is not a separate modeled entity, rather it is a representation of the value list of the property itself.\n\n### Proposal\n\nExplain the possible variations as described above.  Then remove the prohibition against specifying NULL on a navigation property collection.  It should be treated like any other property.\n\n\nImported from [ODATA-1071](https://issues.oasis-open.org/browse/ODATA-1071)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "GEricson"
    ]
  },
  {
    "title": "Introduce instance annotation to specify which types an instance \"implements\"",
    "body": "With the new \"MayImplement\" annotation, and semantics around using a cast segment to cast to an type outside of the hierarchy we introduce a powerful new way of supporting \"dynamic interfaces\" which may be supported by some instances but not others.\n\nWhat we don't have is a way to specify, for a particular instance, which types (outside of the hierarchy) it supports.\n\n\nImported from [ODATA-1107](https://issues.oasis-open.org/browse/ODATA-1107)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Provide guidance for sql-injection type attacks",
    "body": "If the application has the expression:\n\n    Customers?$filter=id eq @id\n\nand the user supplies the value for @id as \"1&$expand=Orders\"\n\nThen they have expanded the data that the application was intending.\n\n\n### Proposal\n\nAdd a cautionary note that, when taking input from a user, an application must make sure it is the expected type; for example, make sure there are no unescaped '&'.\n\nImported from [ODATA-1110](https://issues.oasis-open.org/browse/ODATA-1110)",
    "labels": [
      "Securing OData",
      "CN01"
    ],
    "assignees": []
  },
  {
    "title": "Allow alternate / native search syntax",
    "body": "When doing text searches, many of the common algorithms we use have a number of different ways to define a match (Exact match, begins with, synonym, base word or inflection, etc). The $search query parameter defines a search syntax but its definition says it is up to the implementation as to what constitutes a match.  This is fine, but in the case where the search engine provides different matching types it would be nice if user had a way to specify how the type of match to be used in the search expression.\r\n\r\nThis was originally filed as ODATA-1100 as a request to modify the existing $search syntax to support specifying match type.  In discussing the proposal for ODATA-1100 with some users, it was suggested that we do not define our own syntax for specifying match type.  There are several common search engines that define a syntax that allows the type of match to be specified.  The most common of these is currently is Apache Lucene -\r\n https://lucene.apache.org/core/.  Instead of expanding the $search syntax, should we provide a way for the user to specify an alternate or native syntax so that they can utilize the underlying capabilities of the search engine?  If we do allow alternate syntax, there is likely a need for some metadata describing what if any alternate syntax a service understands.\n\n### Proposal\n\nMake $search a pass-through query option, impose no syntax, and impose no other restrictions than what is necessary to parse the URL.\r\n\r\nMake V4 $search syntax just an optional recommendation.\r\n\r\nAdd a Capabilities term of type URL that allows pointing to the search syntax supported by the service, which may be the V4 $search syntax. \n\nImported from [ODATA-1113](https://issues.oasis-open.org/browse/ODATA-1113)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Add details to HttpResponse",
    "body": "ODATA-884 introduced a way to describe the set of requests and associated valid responses that could be made against a resource.\n\nThe response includes an HTTP Status code, and the initial proposal included the ability to specify the set of conditions under which the status code may be returned, including a human-readable string and a machine-readable error/status code.\n\nThis detail error code and description would presumably be something that could be returned in the \"details\" section of an error response (i.e., \"code\" and \"message\" below):\n\n{\n  \"error\": {\n    \"code\": \"501\",\n    \"message\": \"Unsupported functionality\",\n    \"target\": \"query\",\n    \"details\": [\n      {\n       \"code\": \"301\",\n       \"target\": \"$search\"  \n       \"message\": \"$search query option not supported\",\n      }\n    ]\n    \"innererror\": {\n      \"trace\": [...],\n      \"context\": {...}\n    }\n  }\n}\n\nThis is similar to an effort going on in OpenAPI: https://github.com/OAI/OpenAPI-Specification/issues/1392 \nwhich references: https://datatracker.ietf.org/doc/rfc7807/?include_text=1 Problem Details for HTTP APIs.\n \n\n### Proposal\n\nAdd a {{Details}} property to the {{HttpResponse}} complex type defined in ODATA-884:\r\n\r\n{code:xml}\r\n<Property Name=\"Details\" Type=\"Collection(Core.HttpResponseCodeDetail)\">\r\n Annotation Term=\"Core.Description\" String=\"Descriptions of conditions resulting in the specified status code.\" />\r\n</Property>\r\n{code}\r\n\r\nThis points to a complex type representing a detailcode/description pair describing more details about the condition of the result code:\r\n\r\n{code:xml}\r\n<ComplexType Name=\"HttpResponseCodeDetail\">\r\n  <Property Name=\"SpecificErrorCode\" Type=\"Edm.String\">\r\n    <Annotation Term=\"Core.Description\" String=\"Language-independent, machine-readable specific error code\" />\r\n  </Property>\r\n  <Property Name=\"Description\" Type=\"Edm.String\">\r\n    <Annotation Term=\"Core.Description\" String=\"Human-readable description of the response situation\" />\r\n    <Annotation Term=\"Core.IsLanguageDependent\" />\r\n  </Property>\r\n</ComplexType>\r\n{code}\n\nImported from [ODATA-1140](https://issues.oasis-open.org/browse/ODATA-1140)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Equivalence of NavigationProperty and Singleton or EntitySet",
    "body": "A Service often needs to provide additional data, such as service name, organization, model version, ....  This can be defined in an entity type referenced by a Singleton in the service document, but there really is no need to define a separate type for this purpose or for the additional complexity.\r\n\r\nCurrently the Service document (EntityContainer) is restricted to two specially defined property meta types: Singleton and EntitySet.  Assuming null for Singleton is allowed, ODATA-1183, the functionality of these types is equivalent to functionality provided by containment Navigation Properties.  \n\n### Proposal\n\nThere are two aspects of the proposal.\r\n\r\n1) Allow Properties to be declared within an EntityContainer.\r\n\r\n2) Deprecate contained Navigation Properties (ContainsTarget = True) in favor of using EntitySet and Singleton declarations within EntityType and ComplexType declarations.\n\nImported from [ODATA-1184](https://issues.oasis-open.org/browse/ODATA-1184)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "Vocabularies Document references  OData Version 4.01. Part 3: Common Schema Definition Language (CSDL)",
    "body": "The OData Version 4.01 Part 1: Protocol document refers to the OData Vocabularies Version 4.0 document.  In turn the OData 4.0 Vocabularies document refers to  _OData Version 4.01. Part 3: Common Schema Definition Language (CSDL).  However there is no longer an OData Version 4.01 Part 3.  Part 3 has been replaced by the following two documents in the 4.01 spec._\r\n\r\n_OData Common Schema Definition Language (CSDL) JSON Representation Version 4.01_\r\n_OData Common Schema Definition Language (CSDL) XML Representation Version 4.01_\n\n### Proposal\n\nIn the Related Work section of the OData Vocabularies document remove the sub-bullet that references \r\n\r\n _OData Version 4.01. Part 3: Common Schema Definition Language (CSDL)_\r\n\r\nand replace with references to\r\n\r\n_OData Common Schema Definition Language (CSDL) JSON Representation Version 4.01_\r\n_OData Common Schema Definition Language (CSDL) XML Representation Version 4.01_\n\nImported from [ODATA-1204](https://issues.oasis-open.org/browse/ODATA-1204)",
    "labels": [
      "V4.01_CS02"
    ],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Annotate constructor/factory actions",
    "body": "In [11.5.4.1 Invoking an Action|http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_InvokinganAction] we define that\r\n{quote}Actions that create and return a single entity follow the rules for entity creation and return a Location header that contains the edit URL or read URL of the created entity.\r\n{quote}\r\nCurrently there's no way for clients and generic tools to recognize such \"constructor\" or \"factory\" actions. Annotating these actions would be helpful for e.g. OpenAPI generation from $metadata.\n\n### Proposal\n\nAdd tagging term Core.Constructor\r\n\r\n{code:xml}\r\n<Term Name=\"Constructor\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"true\" AppliesTo=\"Action\">\r\n  <Annotation Term=\"Core.Description\" String=\"The annotated action constructs new entities\" />\r\n</Term>\r\n{code}\n\nImported from [ODATA-1214](https://issues.oasis-open.org/browse/ODATA-1214)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Add (but don't support) ANSI/ISO isolation levels to registered Isolation header",
    "body": "As per ODATA-1223, the current proposed Isolation header only lists the single value supported by OData. \r\n\r\n \n\n### Proposal\n\nIn order to make the header general, add the remaining common isolation levels from ANSI/ISO to the IANA definition:\r\n\r\n   Snapshot\r\n\r\n   Serializable\r\n\r\n   RepeatableRead\r\n\r\n   ReadCommitted\r\n\r\n   ReadUncommitted\r\n\r\n \r\n\r\nIn OData, continue to support (and list) only Snapshot.\n\nImported from [ODATA-1233](https://issues.oasis-open.org/browse/ODATA-1233)",
    "labels": [
      "V4.01_CS02"
    ],
    "assignees": []
  },
  {
    "title": "ActionImport and FunctionImport on EntityType",
    "body": "We allow calling bound actions/functions with qualified name, or with unqualified (short) name if the namespace defining the function is marked as the default namespace. In the latter case we need precedence rules if action/function names collide with property names.\r\n\r\nThis can be avoided if an entity type can actively declare which actions/functions it allows by \"importing\" the (still global) action/function into the type, similar to what we currently do in the entity container. \r\n\r\nThis has several benefits:\r\n* explicitly declare support for bound actions/functions\r\n* provide clash-free short name for bound action/function\r\n* harmonize entity container and entity type \n\nImported from [ODATA-1235](https://issues.oasis-open.org/browse/ODATA-1235)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Define a mechanism to distinguish between inserted and updated entities in a Delta message",
    "body": "In a delta response, Added and Changed entities are represented as Entities in the delta response.  There is no way for the client to distinguish between an Inserted entity and a Changed entity.  If the client is using the delta response to keep data in a cache or data warehouse in sync, then the distinction between an Inserted and Updated entity doesn't really matter.  The client would do an upsert of the Inserted / Updated entity.  If the entity exists it gets updated and if it doesn't it gets inserted.\r\n\r\nHowever, in cases where the changes are being tracked for auditing or reporting purposes, it is useful to be able to distinguish between an inserted or updated entity.  There is a difference between inserted and updated entities in a delta response in that an inserted entity must include all selected properties where as an updated entity must only include all selected properties that changed.  The distinction is not reliable for detecting the difference though.  It is possible that all of the selected properties of an existing entity have change and it is also possible that a server would always return all selected properties of an updated entity.\r\n\r\nConsider adding an optional @inserted or @updated annotation or both to make the distinction between the Inserted and Updated entities,  This is similar to the @removed annotation that already exists.\r\n\r\nWhen a delta payload is provided to the service in the body of an update request, the @inserted or @updated annotations would typically would not be needed, but it should be fine to include them if for example the delta payload was originally received as a delta response.\r\n\r\n \r\n\r\n \n\n### Proposal\n\nDefine optional annotation {{@Core.PreviousState:\"Existed\"}} to allow making the distinction between added and changed entities.\r\n\r\nThis approach intentionally differs from the existing {{@removed}} control information, which is a required marker for deleted entities.\r\n\r\nThe presence or absence of the instance annotation does not alter the idempotent nature of a delta message, nor does it alter the UPSERT nature of an added/changed entity.\r\n\r\nThe recipient of a delta message may use the instance annotation for optimization, and still has to process any received added/changed entity as an UPSERT.\r\n\r\nAnnotation sketch: [https://github.com/oasis-tcs/odata-vocabularies/pull/201]\n\nImported from [ODATA-1239](https://issues.oasis-open.org/browse/ODATA-1239)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Allow BaseType of EntityType to be a ComplexType",
    "body": "Support common XML construction that defines a ComplexType, and then an Element (EntityType) based on that ComplexType.\n\n### Proposal\n\nIn CSDL 6.1\r\n\r\nchange:\r\n\r\nAn entity type can inherit from another entity type by specifying it as its base type.\r\nAn entity type inherits the key as well as structural and navigation properties of its base type.\r\n\r\nTo: \r\n\r\nAn entity type can inherit from another complex type or entity type by specifying it as its base type.\r\nIf the base type is a complex type, the derived entity type must define a key that consists of one or more references to structural properties..  If the base type is an entity type, the derived entity type inherits the key as well as structural and navigation properties of its base type.\r\n\r\n \n\nImported from [ODATA-1246](https://issues.oasis-open.org/browse/ODATA-1246)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Allow $pagesize system query option",
    "body": "Using an HTTP Prefer header for client's preferred odata.pagesize is problematic, particularly when the client-specified query URL uses $expand.\r\n\r\nWhile a server is free to ignore any client-specified pagesize, it is beneficial to be able to have the client indicate their preference for each \"node\" in a URL using that has one or more $expands, so that the server (if it is agreeable) may respect the client's intentions.\r\n\r\nSuggestion is to introduce $pagesize system query option (a positive integer). Where present in the outermost level of a query (not inside a $expand) it would take preference over odata.pagesize in HTTP Prefer header.\r\n\r\nNested $pagesize would apply to $expand, e.g.\r\n\r\n    Customer?$pagesize=100&$expand=Orders($pagesize=10)\r\n\r\nrequests up to 100 customers each with up to 10 orders.\r\n\r\nIf a returned customer has some orders with a next-link, then following that next-link is not required to use the same $pagesize of 10. It only applies to the originally-returned nested orders.\r\n\r\n \n\nImported from [ODATA-1261](https://issues.oasis-open.org/browse/ODATA-1261)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Explicitly state structural restrictions of type Edm.Untyped",
    "body": "The name Edm.Untyped is misleading as this type has an underlying implicit type system that is just more flexible than CSDL's current system of primitive, collection, and structured types.\r\n\r\nThis underlying type system is a little underspecified, e.g. there's a somewhat hidden restriction - only stated in the JSON Format specification - that object member names have to be OData SimpleIdentifiers and are not just strings as in JSON.\n\nImported from [ODATA-1262](https://issues.oasis-open.org/browse/ODATA-1262)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "JSON Format",
      "V4.02"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Clarify use of etags for optimistic concurrency versus conditional fetch",
    "body": "Currently, it's a bit confusing whether a client has to use an etag in a data modification if supplied, or only if supplied and the item is annotated with Optimistic Concurrency.\n\n### Proposal\n\nClarify that clients are only required to specify ETags on modification operations if the resource being updated is tagged with the OptimisticConcurrency annotation.\r\n{quote}Each entity has its own ETag value that MUST change when structural properties or links from that entity have changed. In addition, modifying, adding, or deleting a contained entity MAY change the ETag of the parent entity.\r\n\r\nCollections of entities (including collections of related entities) MAY have their own ETag value whose semantics is service-specific. It typically changes if entities are added to or removed from the collection, or if an entity in the collection is changed. The ETag of a collection of related entities reached via a navigation property MAY differ from the ETag of the entity containing the navigation property.\r\n\r\nA [Data Modification Request|#sec_DataModification] on an existing resource or an [Action Request|#sec_Actions] invoking an action bound to an existing resource MAY require optimistic concurrency control. Services SHOULD announce this via annotations with the terms [Core.OptimisticConcurrency|https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Core.V1.md#OptimisticConcurrency] in [*[OData-VocCore]*|#VocCore] and [Capabilities.NavigationRestrictions|https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Capabilities.V1.md#NavigationRestrictions] (nested property OptimisticConcurrencyControl) in [*[OData-VocCap]*|#VocCapabilities].\r\n\r\nIf optimistic concurrency control is required for a resource, the service MUST include an [ETag header|#sec_HeaderETag] in a response to a GET request to the resource, and MAY include the ETag in a format-specific manner in responses containing that resource.\r\n\r\nThe presence of an [ETag header|#sec_HeaderETag] in a response does not imply in itself that the resource requires optimistic concurrency control; the ETag may just be used for caching and/or conditional GET requests.\r\n\r\nIf an ETag value is specified in an [If-Match|#sec_HeaderIfMatch] or [If-None-Match|#sec_HeaderIfNoneMatch] header of a [Data Modification Request|#sec_DataModification] or [Action Request|#sec_Actions], the operation MUST only be invoked if the If-Match or If-None-Match condition is satisfied.\r\n\r\nIf the client does not specify an [If-Match|#sec_HeaderIfMatch] request header in a [Data Modification Request|#sec_DataModification] or [Action Request|#sec_Actions] on a resource that requires optimistic concurrency control, the service responds with a 428 Precondition Required and MUST ensure that no observable change occurs as a result of the request. Clients can attempt to disable optimistic concurrency control by specifying\r\n\r\nFor requests including an [OData-Version|#sec_HeaderODataVersion] header value of 4.01, any ETag values specified in the request body of an [update request|#sec_UpdateanEntity] MUST be * or match the current value for the record being updated.\r\n{quote}\n\nImported from [ODATA-1293](https://issues.oasis-open.org/browse/ODATA-1293)",
    "labels": [
      "V4.01_CS02"
    ],
    "assignees": []
  },
  {
    "title": "Ability to reference newly discovered OData services",
    "body": "An ecosystem that includes multiple OData services.\r\n\r\nExamples:\r\n * Internet of things, where things have embedded OData services and are plugged into a system, perhaps via wi-fi or blue-tooth.\r\n * An ecosystem containing vehicles that opportunistically create relationships with available edge servers as they become available.\r\n\r\nSchema currently requires a Reference.  But this schema is static and cannot accommodate the use case.\n\n### Proposal\n\nAllow Navigation Property, Singleton, and EntitySet types to either EntityContainer or EntityType.  The addition of EntityContainer as a possibility enables the use case.\n\nImported from [ODATA-1308](https://issues.oasis-open.org/browse/ODATA-1308)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "JSON Format",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "ContextUrl does not represent navigation properties for which the entity references ($ref) are included",
    "body": "Currently, following further clarification in ODATA-1238, we state that navigation properties with expanded references are not represented in the ContextUrl. This is somewhat surprising, especially when compared to i.e. selecting just a non key property in which case the representation could once again an entity with it's @odata.id plus that one property.\n\nImported from [ODATA-1317](https://issues.oasis-open.org/browse/ODATA-1317)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Fix issues with Capabilities vocabulary",
    "body": "There are a few typos in some of the things we added to the Capabilities vocabulary:\r\n1) In PermissionType, \"Scheme\" should be of type \"Edm.String\" (and perhaps renamed \"SchemeName\") rather than Auth.SecurityScheme. We don't expect to inline the definition of the security scheme (including supported scopes, etc.)\r\n2) OperationRestrictions should be a single Capability.OperationRestriction, not Collection(Capability.OperationRestriction).\r\n3) For consistency, OperationRestriction should really be named OperationRestrictionType\r\n4) We don't have a way to apply restrictions to an ActionImport.  We can target a FunctionImport with ReadRestrictions (although it would be a bit strange to have a FunctionImport with Readable=false), and Actions and Functions with OperationRestrictions, but we don't have a way to define permissions, headers, etc. associated with an ActionImport.  Everything in OperationRestrictions applies to imports *except* FilterSegmentSupported.\n\n### Proposal\n\n0) Define a new \"SchemeName\" TypeDefinition in the Auth vocabulary and use within Auth vocabulary whenever referencing a scheme.\r\n1) In PermissionType, rename \"Scheme\" to \"Authorization\" and change type to be \"Auth.SchemeName\".\r\n2) Change the type of OperationRestrictions to be Capability.OperationRestriction, not Collection(Capability.OperationRestriction).\r\n3) Rename OperationRestriction to OperationRestrictionType\r\n4) Remove \"FunctionImport\" from ReadRestrictions \n\nImported from [ODATA-1318](https://issues.oasis-open.org/browse/ODATA-1318)",
    "labels": [
      "V4.01_CS02"
    ],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Add Terms, Abbreviated Terms, and Symbols sections to specifications",
    "body": "Terms are currently defined inline to text.  This makes definition harder to find, (at least on printed copies).\n\n### Proposal\n\nAdd terms, abbreviated terms, and symbols clauses as recommended by ISO/IEC\r\nDirectives, Part 2 Principles and rules for the structure and drafting of ISO and IEC documents, [https://www.iso.org/sites/directives/current/part2/index.xhtml]\r\n\r\nNote: the new OASIS specification template has sections\r\n- 1.2.1 Definitions of Terms\r\n- 1.2.2 Acronyms and Abbreviations\r\n\r\nWe are already using them in [Data Aggregation|https://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/csd04/odata-data-aggregation-ext-v4.0-csd04.html#DefinitionsofTerms]\n\nImported from [ODATA-1333](https://issues.oasis-open.org/browse/ODATA-1333)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Querying \"JSON properties\"",
    "body": "\"JSON properties\" are stream properties whose value is of media type {{application/json}} or one of its subtypes. They were introduced with ODATA-1177.\r\n\r\nAs outlined in [OData Extension for JSON Data|https://www.oasis-open.org/committees/download.php/46559/OData%20Extension%20for%20JSON%20Data%20v1.0.doc] we need query capabilities on these properties.\r\n\r\nRequirements:\r\n # Specify a JSON Schema that describes/restricts the JSON stream values (ODATA-1275)\r\n # Address parts of the JSON stream values in common expressions, e.g. in {{$filter}}, {{$compute}}, {{$orderby}} (this issue)\r\n\r\nThe second requirement can be solved via functions on JSON stream properties, e.g.\r\n * extract/compute an OData value (primitive, complex, collection) from a JSON stream\r\n * special case: extract/compute a JSON stream from a JSON stream\r\n * special case: extract/compute a Boolean value from a JSON stream\r\n\r\nThese functions can be inspired by (or be direct wrappers for) the SQL/JSON functions\r\n * JSON_QUERY, see [IBM Db2|https://www.ibm.com/docs/en/db2/11.5?topic=functions-json-query], [Microsoft SQL Server|https://docs.microsoft.com/en-us/sql/t-sql/functions/json-query-transact-sql?view=sql-server-2017], [Google BigQuery Standard SQL|https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions], or [SAP HANA|https://help.sap.com/viewer/4fe29514fd584807ac9f2a04f6754767/2.0.03/en-US/3126ea33d50d42d19517a08fe22ec5a1.html]\r\n * JSON_VALUE, see [IBM Db2|https://www.ibm.com/docs/en/db2/11.5?topic=functions-json-value], [Microsoft SQL Server|https://docs.microsoft.com/en-us/sql/t-sql/functions/json-value-transact-sql?view=sql-server-2017], [Google BigQuery Standard SQL|https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions], or [SAP HANA|https://help.sap.com/viewer/4fe29514fd584807ac9f2a04f6754767/2.0.02/en-US/9355cb9e45a149c1a6ddb2bd2392d864.html]\r\n\r\nPostgreSQL has its own set of [JSON Functions and Operators|https://www.postgresql.org/docs/9.4/functions-json.html].\n\n### Proposal\n\nDefine functions {{JSON.query}} and {{JSON.value}} specific to JSON stream properties in the new JSON vocabulary.\r\n\r\n \n\nImported from [ODATA-1336](https://issues.oasis-open.org/browse/ODATA-1336)",
    "labels": [
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ],
    "repo": "odata-vocabularies"
  },
  {
    "title": "PATCH: new preference return=delta to get back a delta response",
    "body": "Update requests can have side-effects, e.g. changing the street of an address could as a side-effect also change the zip code even if it is not present in the PATCH request body.\r\n\r\nWe need a way to communicate to the client what actually has changed.\n\n### Proposal\n\nAdd preference {{return=delta}} for PATCH requests. The server then may respond with a delta payload containing the changes to the server state identified by the ETag in the PATCH request.\r\n\r\nIt is a preference, so servers can ignore it.\r\n\r\nThe maximum shape of the delta can be specified via $select and $expand.\r\n\r\nAdd boolean property {{DeltaResponseSupported}} to type {{Capabilities.UpdateRestrictionsType}} to advertise support for this feature.\n\nImported from [ODATA-1340](https://issues.oasis-open.org/browse/ODATA-1340)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "OData V2 required continue-on-error style batch responses, V4 makes it optional for servers (due to use of Prefer)",
    "body": "OData V2 spec for batch responses (Example 2) shows a response with multiple errors. OData V2 didn't have a continue-on-error preference to obtain this, it was just assumed that a batch could have multiple requests that were able to fail and the client would find out about all the failures.\r\n\r\nFor V4 we have Prefer (odata.continue-on-error) but it is opt-in, and optional for the server to support.\r\n\r\nV2 clients had certainty that a server supporting batches would be able to return a single response with all parts (whether or not an error had occurred).\r\n\r\nV4 clients no longer have that certainty, which from a performance perspective (in the presence of errors) is unsatisfactory. If a client sends a lot of GET requests that might return 404, they might only get one 404 response (batch response is truncated at the first error). Then they needs to resubmit the tail end of the batch. Time complexity is proportional to E*N*L, where E is the number of errors in the batch and N is the size of the batch request payload and L is the per-request latency.\r\n\r\nWe have clearly lost an important performance characteristic (clients having certainty about the cost of a batch of requests some of which can fail).\r\n\r\nHow can we get it back?\r\n\r\nPerhaps we can make continue-on-error mandatory for servers to support if they support batches at all.\r\n\n\n### Proposal\n\nAdd a mechanism for clients to insist on the server continuing on errors with multipart batches (for parity with JSON batches)\n\nImported from [ODATA-1350](https://issues.oasis-open.org/browse/ODATA-1350)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Add support for SoundsLike expressions",
    "body": "Introduction\r\nThis is a proposal to introduce phonetic comparison functionality to Open Data Protocol. The foundation of this feature relies on the service implementing a phonetic algorithm for indexing strings by sound, such as SOUNDEX which indexes strings according to English pronunciation.\r\n\r\nThe goal is for homophones to be encoded to the same representation so they can be matched despite minor differences in spelling them, then expose that through RESTful API OData calls.\r\n\r\nThis proposal will navigate through the details of the feature and its potential implementation in OData.\r\n\r\nSOUNDEX Algorithm\r\nThe SOUNDEX converts an alphanumeric string to a four-character code that is based on how the string sounds when spoken. The first character of the code is the first character of character expression, converted to upper case. The second through fourth characters of the code are numbers that represent the letters in the expression. The letters A, E, I, O, U, H, W, and Y are ignored unless they are the first letter of the string. Zeroes are added at the end if necessary, to produce a four-character code.\r\n\r\nFor example, the name Michelle and Michael both return SOUNDEX value of M240, while David for instance will return a SOUNDEX value of D130 which makes Michael a more of a nearly sounding match to Michelle than David.\r\n\r\nRules\r\nSOUNDEX follows the NARA coding rules which are as follows:\r\n1.\tCoding consists of a letter followed by three numerals.  Examples: L123, C472, S160.\r\n2.\tThe first letter of a surname is not coded, it is retained as the initial letter.\r\n3.\tA, E, I, O, U, Y, W, and H are not coded.\r\n4.\tDouble letters are coded as one letter (as in Lloyd).\r\n5.\tPrefixes to surnames like \"van\", \"Von\", \"Di\", \"de\", \"le\", \"D\", \"dela\" or \"du\" are sometimes disregarded in coding.\r\n6.\tCode the following letters to three digits, using 0 at the end if needed.\r\n\r\nSOUNDEX system is based on a coding guide as represented in the following table:\r\nNumber\tRepresents the Letters\r\n1\tB, F, P, V\r\n2\tC, G, J, K, Q, S, X, Z\r\n3\tD, T\r\n4\tL\r\n5\tM, N\r\n6\tR\r\nNot Coded\tA, E, I, O, U, Y, W, H\r\n\n\n### Proposal\n\nAdd a new query function, soundslike, to the list of available OData string functions that can be used in $filter:\r\n           GET http://host/service/Customers?$filter=soundslike(Name, ‘Michael’)\r\n\r\nThe result is a list of all names that sounds like the passed in search keyword.\r\n\r\nServices can indicate support by returning \"soundslike\" in the list of strings returned in the Core.FilterFunctions annotation term.\r\n\r\nThe comparison algorithm is implementation-dependent, and may be chosen based on the language of the operator(s).  The preferred algorithm for English is SOUNDEX.\n\nImported from [ODATA-1354](https://issues.oasis-open.org/browse/ODATA-1354)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Detach textual descriptions from operation restriction terms in Capability vocabulary",
    "body": "The terms for describing restrictions on the CRUD capabilities of service operations contain properties for textual descriptions side by side with other properties expressing restrictions with semantic values. A service consumer cannot identify the description properties.\r\n\n\n### Proposal\n\nUpdate the term definitions to clearly separate the textual descriptions from the semantic restrictions:\r\n # Allow application of the terms Core.Description and Core.LongDescription to the types:\r\n -- InsertRestrictionsType\r\n -- UpdateRestrictionsType\r\n -- DeleteRestrictionsType\r\n -- ReadRestrictionsBase, used by ReadByKeyRestrictionsType and ReadRestrictionsType\r\nDocument this via Validation.ApplicableTerms\r\n\r\n # Deprecate usage of properties \"Description\" and \"LongDescription\" in these types. Document this via Core.Revisions of Kind=Deprecated\n\nImported from [ODATA-1358](https://issues.oasis-open.org/browse/ODATA-1358)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Define ExpandOptions for nav property in $select",
    "body": "The defined semantics for a navigation property in $select is to include the navigation link in the response body. However, that navigation link may be opaque, making it difficult for a generic hypermedia-driven client to append options such as nested selects/expands.  There should be a way to specify that the response should include a navigation link that selects a subset of rows, and properties, in a certain order, with certain nested properties expanded, etc.  In short, everything that you could specify if you $expanded the navigation property inline.\n\n### Proposal\n\nSupport the full set of $expand options on navigation properties within $select. For example:\r\n\r\nGET customers?$select=firstName, orders($select=orderId, amount)\r\n\r\n{ \"firstName\": \"Victor\", {color:#de350b}{color:#00875a}\"orders@odata.navigationLink\": \"customers('victorb')/orders?$select=orderId, amount\"{color}{color} }\r\n\r\nNote that this does not affect the contextUrl.\n\nImported from [ODATA-1364](https://issues.oasis-open.org/browse/ODATA-1364)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "CSDL Section 12.9 \"Parameter\" mixing with \"overload\" causes ambiguity, particularly with regard to parameter ordering",
    "body": "CSDL XML Section 12.9 Paramerter\r\n\r\nFirst paragraph:\r\n\r\n```\r\nAn action or function overload MAY specify parameters.\r\n```\r\n\r\nProblem: Even an action or function that isn't an overload may specify parameters.\r\n\r\nSecond paragraph:\r\n\r\n```\r\nA bound action or function overload MUST specify at least one parameter; the first parameter is the binding parameter. The order of parameters MUST NOT change unless the schema version changes.\r\n```\r\n\r\nProblem: Ambiguous as to whether parameter ordering may (or may not) change seems linked to whether we are referring to an overloaded, or non-overloaded, action or function.\r\n\r\nSince I originally identified the issue about parameter ordering, I can assert that I wasn't concerned about ordering only for overloaded actions/functions. It is important for parameter ordering to remain stable for non-overloaded actions/functions. (Otherwise client applications using code generated from model elements will experience backwards-incompatible changes in method/function signatures).\r\n\r\nFurthermore, the \"Element edm:Action\" and \"Attribute Name\" parts belong in section 12.1 \"Action\", not in 12.2 \"Action Overloads\".\r\n\r\nSimilarly, the \"Element edm:Function\" and \"Attribute Name\" parts belong in section 12.3 \"Function\", not in 12.4 \"Function Overloads\".\r\n\n\n### Proposal\n\nDistinguish between\r\n * an action/function as the named set of all its signature definitions aka overloads\r\n * a single signature definition aka overload\r\n\r\n \n\nImported from [ODATA-1370](https://issues.oasis-open.org/browse/ODATA-1370)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Consider adding railroad diagrams for the URL syntax",
    "body": "It may be helpful to have diagrams for the URL conventions, similar to [https://www.odata.org/documentation/odata-version-2-0/uri-conventions/]\r\n\r\nHere's a nice diagram generator for EBNF: [https://www.bottlecaps.de/rr/ui]\r\n\r\nExplore whether/how this can be used to visualize parts of our URL ABNF.\r\n\r\nThis looks quite nice (after a little cleanup) for the reduced [OData URL syntax supported by SAP Graph|https://help.sap.com/docs/graph/graph/graph-syntax-diagrams]\r\n\r\n \n\nImported from [ODATA-1379](https://issues.oasis-open.org/browse/ODATA-1379)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Introduce primitive types for color values",
    "body": "Consider adding a new primitive type for color to the list of standard primitive types at\r\n\r\n[http://docs.oasis-open.org/odata/odata/v4.01/csprd01/part3-csdl/odata-v4.01-csprd01-part3-csdl.html#_Toc469935966]\r\n\r\n \r\n\r\nWith a JSON serialization format similar to (or a subset of ) [https://www.w3.org/TR/css-color-3/#numerical]\r\n\r\n[CSS, 6.3 Color units|https://www.w3.org/TR/REC-CSS1-961217#color-units]\n\nImported from [ODATA-1386](https://issues.oasis-open.org/browse/ODATA-1386)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "JSON Format",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Make key aliases optional, clarify multiple to-one navigation hops",
    "body": "When using an \"association to one\" as a key component, it is currently required to provide an alias for use in parentheses-style key syntax.\r\n\r\nThis can lead to \"funny\" aliases when the OData model is automatically derived from a conceptual model that does not know about OData key syntax.\r\n\n\n### Proposal\n\nCSDL:\r\n* Make key aliases optional for keys with a path.\r\n* Clarify that multiple non-nullable to-one navigation hops can occur if the referenced key property of the directly related entity type itself is referenced from a directly related entity type etc.\r\n\r\nURL Conventions:\r\n* If no key alias is provided for a related/nested primitive property, use the dash-separated path in parentheses-style keys, e.g. {{/something(foo-bar-id='abc')}}\n\nImported from [ODATA-1388](https://issues.oasis-open.org/browse/ODATA-1388)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "URL Conventions",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "New control information @fileName / @odata.fileName",
    "body": "Similar to @mediaType we could add an @fileName control information to fill the empty quadrant:\r\n\r\n||Core Vocabulary||JSON Control Information||\r\n|Mediatype|@mediaType|\r\n|ContentDisposition/FileName|@fileName|\r\n\r\nThis would allow transporting the (proposed) filename for a stream or binary value between client and server (both directions).\r\n\r\nAlternative would be to use an instance annotation with the Core term, but that's somewhat asymmetric.\n\nImported from [ODATA-1389](https://issues.oasis-open.org/browse/ODATA-1389)",
    "labels": [
      "JSON Format",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "Add full-fledged support  for ISO 8601-1 duration ",
    "body": "Next version of OData [protocol |[https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html]] should support full-fledged duration for Edm.Duration .\r\n\r\nThe [ABNF|[https://docs.oasis-open.org/odata/odata/v4.01/os/abnf/odata-abnf-construction-rules.txt]] today states duration value is\r\n\r\n   [ SIGN ] \"P\" [ 1*DIGIT \"D\" ] [ \"T\" [ 1*DIGIT \"H\" ] [ 1*DIGIT \"M\" ] [ 1*DIGIT [ \".\" 1*DIGIT ] \"S\" ] ]\r\ni.e. no years or month as defined by W3C's XML dayTimeDuration.\r\n\r\nIn contrast, ISO 8601-1 2019  5.5.2.2 allows to specify Years and Months.\r\n\r\nThere are well understood libraries that do support the notion of ISO 8601-1, for example Joda's Period class [https://www.joda.org/joda-time/key_period.html]\r\n\r\n\r\nTo notion of weeks or month as a duration makes it possible to model calendar recurrence patterns in a less custom way.\n\n### Proposal\n\nSimilar to [{{Core.LocalDateTime}}|https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Core.V1.md#localdatetime] add a new type definition based on {{Edm.String}}.\r\n\r\n{{Core.YearMonthDayDuration}} is a duration in years, months, and days that can be used to describe regularly recurring calendar events. Services MAY support arithmetic operations on {{Core.YearMonthDayDuration}} values and with {{Edm.Date}} values and MAY describe this via the term {{Capabilities.YearMonthDayDurationSupport}}.\n\nImported from [ODATA-1394](https://issues.oasis-open.org/browse/ODATA-1394)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "/$query shall allow Content-Type: application/x-www-form-urlencoded",
    "body": "An HTML form can be used to have a browser _navigate_ to the response of an OData request, especially if the response is a stream. If that OData request makes use of the [{{/$query}}|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_PassingQueryOptionsintheRequestBody] segment, it must have {{Content-Type: text/plain}}, which forces an HTML form like\r\n{code:xml}\r\n<form method=\"post\" action=\"~/$query\" enctype=\"text/plain\">\r\n <input name=\"$filter\" value=\"a%20eq%201&$select=b\"/>\r\n</form>\r\n{code}\r\nMuch more natural would be if {{Content-Type: application/x-www-form-urlencoded}} were also allowed:\r\n{code:xml}\r\n<form method=\"post\" action=\"~/$query\"\r\n  enctype=\"application/x-www-form-urlencoded\">\r\n <input name=\"$filter\" value=\"a eq 1\"/>\r\n <input name=\"$select\" value=\"b\"/>\r\n</form>\r\n{code}\r\nThis leads to the same request body as above:\r\n{code}\r\n$filter=a%20eq%201&$select=b\r\n{code}\r\nbut without forcing the client to percent-encode spaces and insert the ampersand.\n\n### Proposal\n\nThe request body MUST use the content-type {{text/plain}} _or {{application/x-www-form-urlencoded}}_.\r\n\r\nhttps://github.com/oasis-tcs/odata-specs/pull/170\n\nImported from [ODATA-1405](https://issues.oasis-open.org/browse/ODATA-1405)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "HeikoTheissen"
    ]
  },
  {
    "title": "No way to $select instance annotations on primitive types",
    "body": "We added the ability to explicitly $select/$expand an instance annotation by including the annotation in the $select list.  However, according to the ABNF, this annotation is of the form @ns.termName[#qualifier] which makes it impossible to $select an annotation applied to a primitive, enum, or collection-valued property (which would be of the form propertyName@ns.termName):\r\n\r\nprimitiveAnnotationInQuery = annotationInQuery\r\nannotationInQuery    = AT [ namespace \".\" ] termName [ HASH annotationQualifier ]\n\n### Proposal\n\nIn order to support explicitly selecting instance annotations on primitive, enum, and collection-valued properties, we would need to ehance the ABNF to support property annotations as in:\r\n\r\n{code:java}\r\nselectProperty = primitiveProperty \r\n               / primitiveAnnotationInQuery\r\n               / primitiveProperty primitiveAnnotationInQuery\r\n{code}\r\n \n\nImported from [ODATA-1407](https://issues.oasis-open.org/browse/ODATA-1407)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ],
    "repo": "odata-abnf"
  },
  {
    "title": "Capabilities vocabulary: Add EntityContainer as annotation target",
    "body": "If a service that exposes multiple entity sets as endpoints implements only the minimal conformance level and wants to inform clients about its (in)capabilities, it is required to annotate each entity set individually with the restriction terms (top&skip&compute supported, filter & sort restrictions, change tracking etc. These are many repetitions just to express restrictions at service level. \n\n### Proposal\n\n* Create new term at container level with all settings from existing terms that are not yet applicable to containers and do not reference individual properties:\r\n * Refactor the existing complex types used by the existing terms to be derived from base types used for the properties of the new container-level term.\r\n * State for each capability that it is combined with the container-level defaults using PATCH semantics, i.e. all container-level default values that are not explicitly changed in a set-level annotation still apply.\n\nImported from [ODATA-1412](https://issues.oasis-open.org/browse/ODATA-1412)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Allow Type of Singleton to be a Primitive, EnumType, or ComplexType",
    "body": "In the context of an EntityContainer, it is more difficult than necessary to include a service level property or set of properties.  \r\n\r\nFor example, if we want to expose the service name as a simple string property in the entity container (i.e. as a Singleton).\r\n\r\nWe could add this to a *Details* entity type without a key, and then reference this via a Singleton.  Then _GET_ _get <service>/details/name._ It would be more natural to simply _GET <service>/name._   In another example, suppose we want to reuse this structure within other entity types.  If *Details* is specified as a _complex type_, then the natural thing is to define a scalar _property_ *detail* with type *Details*.  However, if *Details* is an entity type, we instead use a scalar _navigation property with attribute_ _ContainsTarget=true_ _and annotate_ with Core._AutoExpand_ to get the same behavior.\r\n\r\n \r\n\r\n \r\n\r\n \n\n### Proposal\n\nProposed change to 13.3 Singleton of CSDL specs\r\nFrom:\r\n{{A singleton MUST specify a type that MUST be an entity type in scope.}}\r\nTo:\r\n{{A singleton MUST specify a type that MUST be an entity type}} *, primitive type, complex type, or enumeration type* {{in scope.}}\n\nImported from [ODATA-1415](https://issues.oasis-open.org/browse/ODATA-1415)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "OData 4.01 JSON \"Delta Responses\" doesn't describe use of \"@id\" (or \"@odata.id\") for Added/Changed Entity",
    "body": "https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_AddedChangedEntity\r\n\r\nText states:\r\n\r\n* Added entities MUST include all available selected properties and MAY include additional, unselected properties. Collection-valued properties are treated as atomic values; any collection-valued properties returned from a delta request MUST contain all current values for that collection.\r\n\r\n* Changed entities MUST include all available selected properties that have changed, and MAY include additional properties.\r\n\r\nNowhere in the prose does it state that \"id\" control information *must* be included for added/changed entities (as compared with, in particular, providing the key properties). The non-normative example 32 shows the use of \"@id\" (V4.01) for a changed entity. There aren't any examples for added entities.\r\n\r\nContrast this with section 15.3 Deleted Entity:\r\n\r\n\"In OData 4.01 payloads the deleted-entity object MUST include the following properties, regardless of the specified metadata value: ... Control information id or all of the entity’s key fields.\"\r\n\r\nFor consistency between added/changed entities and deleted entities, perhaps added/changed entities could similarly require: \"Control information id or all of the entity’s key fields\".\r\n\n\n### Proposal\n\n\"@id\" (or \"@odata.id\") is optional, for consistency (in 4.01 at least) with deleted entities, and to reduce payload bloat (in the case of added entities, where the key properties must already be present if they were selected).\r\n\r\nWe need to clarify the 4.0 rules here as well, since the 4.01 spec covers both versions.\r\n\r\nNeed to review both the 4.0 and 4.01 text for compatibility\r\n\n\nImported from [ODATA-1424](https://issues.oasis-open.org/browse/ODATA-1424)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify use of byte-order mark (BOM) in text/plain responses",
    "body": "The specification is currently unclear on the use of byte-order marks in \"plain text\" responses to e.g. {{/$count}} segments or {{/$value}} requests to numeric properties.\n\n### Proposal\n\nOData services [REALLY SHOULD NOT|https://tools.ietf.org/html/rfc6919#section-3] send a byte-order mark in responses with {{Content-Type: text/plain}}.\r\n\r\nClients SHOULD be aware that it is returned by some services.\n\nImported from [ODATA-1426](https://issues.oasis-open.org/browse/ODATA-1426)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "Hubert-Heijkers"
    ]
  },
  {
    "title": "Conditionally add an element to a collection",
    "body": "[OData-CSDL, section 14.4.7|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_IfThenElse] allows {{If}} without third (\"else\") child only as a direct descendant of a {{Collection}}. But the following would also make sense:\r\n{code:xml}\r\n<Collection>\r\n <If>\r\n  <Path>IsLTR</Path>\r\n  <String>margin-left</String>\r\n  <If>\r\n   <Path>IsRTL</Path>\r\n   <String>margin-right</String>\r\n  </If>\r\n </If>\r\n</Collection>\r\n{code}\r\nThis would add \"margin-left\" or \"margin-right\" to the collection for left-to-right and right-to-left scripts, respectively, but add nothing, e.g., for top-to-bottom scripts. The {{If}} without \"else\" is embedded in another {{If}}.\n\n### Proposal\n\nThe if-then-else expression enables a value to be obtained by evaluating a condition expression. _The if-then-else expression is called a collection-if-then-else expression if_\r\n * _it is a direct child of a collection expression or_\r\n * _it is the second or third child of a collection-if-then-else expression._\r\n\r\n_An if-then-else expression_ MUST contain exactly three child expressions. There is one exception to this rule: if and only if the if-then-else expression is a -direct child of a collection expression- _collection-if-then-else expression_, the third child expression MAY be omitted, reducing it to an if-then expression. This can be used to conditionally add an element to a collection.\n\nImported from [ODATA-1435](https://issues.oasis-open.org/browse/ODATA-1435)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "HeikoTheissen"
    ]
  },
  {
    "title": "Relax constraint that DELETE Cannot return data",
    "body": "The current wording in [11.4.5 Delete an Entity](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_DeleteanEntity) in [Protocol] states:\r\n\r\nOn successful completion of the delete, the response MUST be 204 No Content and contain an empty body.\r\n\r\nThis is overly restrictive.  HTTP allows Delete to return a response, and since we added a preference header for clients to request a response from requests that typically may not return responses, we should allow clients to request, and services to return, responses from DELETE (i.e., if return=representation preference is specified).\r\n\r\nThe response should be a representation of the deleted entity.\n\n### Proposal\n\nAllow clients to request, and services to return, responses from DELETE (i.e., if return=representation preference is specified).\r\n\r\nThe response should be a representation of the deleted entity (i.e., a tombstone) \r\n\r\nIf the service supports $select/$expand on the DELETE, standard semantics apply (the same as would be specified in a delta response or delta update payload.)\r\n\r\nAlso clarify, in the collection case, the response minimally includes the items requested to be deleted that were NOT deleted, and MAY also include tombstones for the ones that were successfully deleted.\n\nImported from [ODATA-1436](https://issues.oasis-open.org/browse/ODATA-1436)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "New preference return=keys",
    "body": "Add new preference {{return=keys}} which returns only the keys. This is a convenience allowing clients not to inspect $metadata first and construct corresponding $select statements.\n\n### Proposal\n\nSee description\n\nImported from [ODATA-1438](https://issues.oasis-open.org/browse/ODATA-1438)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "New query option $expect combining $expand and $select",
    "body": "Both $expand and $select shape the response, but preserve in query syntax the differentiation between \"structural\" and \"navigation\" properties.\r\n\r\nFrom a pure response shape perspective this differentiation has become less relevant over the last OData increments, supporting paging for all collections, indexing for all ordered collections, and field selection on all structured response parts.\n\n### Proposal\n\nIntroduce a new query option $expect that combines the functionality of $expand and $select in a simplified syntax, inspired by the field list structure used in the context URL. In the simplest form it is just a nested list of fields, with primitive properties as \"leafs\" and  (single- or collection-valued) complex/navigation properties suffixed with parentheses including the field list for their properties, recursively:\r\n\r\n{code}\r\n$expect=a,b(c,d,e(f,g),h),i\r\n{code}\r\n\r\nQuery options other than $expect, $expand and $select can be mixed in with the field lists:\r\n\r\n{code}\r\n$expect=a,b(c,d,e(f,g,filter=f eq 3),h,top=5,skip=100),i\r\n{code}\r\n\n\nImported from [ODATA-1441](https://issues.oasis-open.org/browse/ODATA-1441)",
    "labels": [
      "URL Conventions",
      "V4.02",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "Capabilities.SearchRestrictions/UnsupportedExpressions: description of default value \"none\" is misleading",
    "body": "The enum type {{SearchExpressions}} has no description, suggesting it simply is a set of flags allowing to turn _on_ an arbitrary combination of search features. This suggests that the value {{none}} with a numeric value of {{0}} means \"no features are on\".\r\n\r\nThe description of {{none}} however is \"Single search term\", suggesting that this is the _minimum_ feature set, and other features can be added on top.\r\n\r\nThe single use of type {{SearchExpressions}} is in the negatively named property {{UnsupportedExpressions}}, with a default value of {{none}}. Does this mean that:\r\n # \"Single search term\" is _not_ supported, i.e. even the most basic search will _not_ work?\r\n # \"None of the features are not supported\", i.e. everything _is_ supported?\n\n### Proposal\n\nOptions:\r\n # Change description of {{none}} to \"no restrictions, all search terms are supported\" - somewhat counter-intuitive in the context of the enum type, but understandable in its single use\r\n # Make {{UnsupportedExpressions}} nullable and its default value {{null}} - what would the value {{none}} then mean? No simple search, but more complicated expressions are allowed?\n\nImported from [ODATA-1453](https://issues.oasis-open.org/browse/ODATA-1453)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Potential confusion wrt Content-Type header for media entities",
    "body": "In section 8.1.1 wrt Content-Type header, which MUST be specified on requests and responses with a non-empty request or response body, an exception is specified for bodies representing the media stream of a media entity of stream property, in which case that Content-Type header is optional and SHOULD be present.\r\nHowever section 11.4.7, dealing with the creation and updating of these media entities and their associated streams, as well as section 11.4.8 pertaining to the update of stream values, both specify that the Content-Type header MUST be specified.\r\nAre we implicitly saying that the Content-Type is potentially optional while retrieving the media stream of a media entity or a stream property?\n\n### Proposal\n\nRelax our requirement, and as such be consistent, about the requirement of having to provide a Content-Type header in requests creating and updating media entities, and as such be no stricter then the HTTP specification itself either.\n\nImported from [ODATA-1457](https://issues.oasis-open.org/browse/ODATA-1457)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "Hubert-Heijkers"
    ]
  },
  {
    "title": "Align wording on \"safe\" and \"idempotent\" with RFC 7231",
    "body": "Align text with [RFC 7231, Section 4.2|https://datatracker.ietf.org/doc/html/rfc7231#section-4.2].\n\n### Proposal\n\nIn [2 Repeatable Requests|https://docs.oasis-open.org/odata/repeatable-requests/v1.0/cs01/repeatable-requests-v1.0-cs01.html#sec_RepeatableRequest] change\r\n{quote}An _unsafe request_ is a -non-idempotent request; that is, a- request which has the potential to change the service each time it is executed.\r\n{quote}\r\nIn [10.2 Client Conformance|https://docs.oasis-open.org/odata/repeatable-requests/v1.0/cs01/repeatable-requests-v1.0-cs01.html#sec_ClientConformance] change\r\n\r\n{quote}\r\nIf a client wants to -safely- repeat a request, a client:\r\n# MUST specify the [Repeatability-Request-ID|https://docs.oasis-open.org/odata/repeatable-requests/v1.0/cs01/repeatable-requests-v1.0-cs01.html#_Repeatability-Request-ID] header in an unsafe request (section [3.1.1|https://docs.oasis-open.org/odata/repeatable-requests/v1.0/cs01/repeatable-requests-v1.0-cs01.html#_Repeatability-Request-ID])\r\n # MUST specify the [Repeatability-First-Sent|https://docs.oasis-open.org/odata/repeatable-requests/v1.0/cs01/repeatable-requests-v1.0-cs01.html#_Repeatability-First-Sent] header in -a- +an+ unsafe request (section [3.1.2|https://docs.oasis-open.org/odata/repeatable-requests/v1.0/cs01/repeatable-requests-v1.0-cs01.html#_Repeatability-First-Sent])\r\n{quote}\n\nImported from [ODATA-1463](https://issues.oasis-open.org/browse/ODATA-1463)",
    "labels": [
      "Repeatable Requests",
      "V4.0_CSD02"
    ],
    "assignees": []
  },
  {
    "title": "Keep a CHANGELOG.md, use Semantic Versioning for each vocabulary",
    "body": "We recently published a \"breaking\" change with [https://github.com/oasis-tcs/odata-vocabularies/pull/127] - removing {{EntityContainer}} from the {{AppliesTo}} list of a term.\r\n\r\nWe claim that {{AppliesTo}} is only a recommendation, but some tools actually take this literally and do not apply terms to model elements not listed.\r\n\r\nIndependent of whether this was really a breaking change we should:\r\n * Use  [Semantic Versioning|https://semver.org/spec/v2.0.0.html] for each of our vocabulary files and add a version number using annotation {{Core.SchemaVersion}} to the schema of each vocabulary\r\n ** We may want to adapt the description of {{Core.SchemaVersion}} and also mention vocabularies in addition to services, or \"abstract\" to talk about schemas\r\n * Keep a [Changelog|https://keepachangelog.com/en/1.0.0/] in the repository root as a file {{CHANGELOG.md}} and mention all (interesting) changes there.\r\n ** \"Interesting\" are all major changes (rename/remove stuff), and most of the minor changes (add new stuff), but probably not patches.\r\n\r\n \n\n### Proposal\n\n* Use  [Semantic Versioning|https://semver.org/spec/v2.0.0.html] for each of our vocabulary files and add a version number using annotation {{Core.SchemaVersion}} to the schema of each vocabulary\r\n ** We may want to adapt the description of {{Core.SchemaVersion}} and also mention vocabularies in addition to services, or \"abstract\" to talk about schemas\r\n * Keep a [Changelog|https://keepachangelog.com/en/1.0.0/] in the repository root as a file {{CHANGELOG.md}} and mention all (interesting) changes there.\r\n ** \"Interesting\" are all major changes (rename/remove stuff), and most of the minor changes (add new stuff), but probably not patches.\n\nImported from [ODATA-1467](https://issues.oasis-open.org/browse/ODATA-1467)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Current instance/collection is only defined adhoc",
    "body": "[OData-CSDL, section \"Path evaluation\"|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_PathEvaluation] says that certain paths \"resolve to a type\" and leaves unclear what this means for instance paths, especially since the annotation target may be\r\n * a single instance (like for `Measures.ISOCurrency`)\r\n * or a collection (like for `Capabilities.UpdateRestrictions` where the path is evaluated for each instance in turn).\r\n\r\nThe current wording hides the fact that the specification does not have an overarching notion of \"current instance\" or \"current collection\". These have rather been introduced in an adhoc manner and were therefore not available in the section on path evaluation or in the definition of the aggregate function (see ODATA-1451). Compare this to the [XPath specification|https://www.w3.org/TR/xpath-10/] which begins by saying\r\n{quote}Expression evaluation occurs with respect to a context. ... The context consists of:\r\n * a node (the context node)\r\n * a pair of non-zero positive integers (the context position and the context size)\r\n * a set of variable bindings\r\n * a function library\r\n * the set of namespace declarations in scope for the expression{quote}\r\nand then makes use of these terms throughout the text.\r\n\r\nSuggestion to try something similar in the OData spec.\n\nImported from [ODATA-1479](https://issues.oasis-open.org/browse/ODATA-1479)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Missing term property Capabilities.NavigationRestrictions/.../ComputeSupported",
    "body": "The term [{{Capabilities.ComputeSupported}}|https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Capabilities.V1.md#ComputeSupported] applies only to entity sets, and there is no analogous term property {{Capabilities/NavigationRestrictions/RestrictedProperties/ComputeSupported}}.\r\n\r\nAs a consequence, support for {{$compute}} cannot be advertised for entity sets addressed by a navigation path.\n\nImported from [ODATA-1480](https://issues.oasis-open.org/browse/ODATA-1480)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Expand all containment navigation properties recursively",
    "body": "Containment navigation properties are often used to model \"structured documents\" where each of the \"parts\" is identifiable within its \"container\".\r\n\r\nThe proposed new expand syntax allows convenient retrieval of complete documents without having to inspect {{$metadata}}, and only retrieve the \"composition\" parts modeled via containment navigation, not the merely \"associated\" entities that are not contained in the requested entity.\n\n### Proposal\n\nAdd a new wildcard that recursively expands all containment navigation properties, for example\r\n * {{$expand=+}}\r\n\r\nOr add a \"modifier\" to the existing {{*}} operator, for example\r\n * {{$expand=*contained($levels=max)}}\r\n\r\nThis would allow adding other modifiers in the future.\n\nImported from [ODATA-1483](https://issues.oasis-open.org/browse/ODATA-1483)",
    "labels": [
      "URL Conventions",
      "V5.0"
    ],
    "assignees": []
  },
  {
    "title": "Allow a client to query the status of an asynchronous request without returning the result if the request completed.",
    "body": "In some cases, the waiting for an asynchronous request to finish and actual processing of the result are separated even up to a point where the processing might [need to] be done in a different thread, process or even different [micro-]service. As it stands, querying the status monitor gives you the state of that process but if that state has been completed it also immediately includes the response of the completed asynchronous request.\r\nI was wondering if it would it be possible to extend the existing protocol for asynchronous request handling in a way that this extra step could be injected.\r\n\n\n### Proposal\n\nAdd to [11.6 Asynchronous Requests|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_AsynchronousRequests]:\r\n\r\n{quote}\r\nOnce the asynchronous processing has completed, a GET request to the status monitor resource returns a 200 OK, *or 204 No Content if the request included a Prefer header with a value of return=minimal*. For OData 4.01 and greater responses, or OData 4.0 requests that include an Accept header that does not specify application/http, the response MUST include the AsyncResult response header. *A response with 204 No Content MUST include a Location header that can be used to request the result of the completed asynchronous operation. The Location header may or may not contain the same values as returned by the previous request.* In a response *with 200 OK* any other headers, along with the response body, represent the result of the completed asynchronous operation. If the GET request to the status monitor includes an OData-MaxVersion header with a value of 4.0 and no Accept header, or an Accept header that includes application/http, then the body of the final 200 OK response MUST be represented as an HTTP message, as described in [RFC7230], which is the full HTTP response to the completed asynchronous operation.\r\n{quote}\r\n\n\nImported from [ODATA-1484](https://issues.oasis-open.org/browse/ODATA-1484)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "Hubert-Heijkers"
    ]
  },
  {
    "title": "Temporal transformation at(<date or timestamp>) for snapshot entity sets",
    "body": "Add a transformation {{at(...)}} that sets the point in time for all snapshot entity sets for subsequent transformations.\r\n\r\nThis can be for example combined with {{concat()}} to use different points in time for different branches of the transformation pipeline.\n\nImported from [ODATA-1492](https://issues.oasis-open.org/browse/ODATA-1492)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS03"
    ],
    "assignees": []
  },
  {
    "title": "Clarify how to allow/disallow an unbound function in $filter/$orderby",
    "body": "[11.5.4.1 Invoking a Function|https://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_InvokingaFunction]\r\n states (emphasize mine)\r\n{quote}Functions can be used within $filter or $orderby system query options. Such functions can be bound to a resource, as described above, *or called directly* by specifying the namespace- (or alias-) qualified function name.\r\n{quote}\r\nIt states how bound functions can be used. \r\n The standard also explains how function imports can be used but there seems to be now explanation if and how they are connected for the \"called directly\" case.\r\n\r\nWhat is necessary to use a function in $filter an $apply? (e.g. is a function import necessary?)\r\n And depending on the answer, how can it's usage in these cases be restricted/disabled ?\n\nImported from [ODATA-1499](https://issues.oasis-open.org/browse/ODATA-1499)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Allow to specify expand query options beyond just nested expands (filter, select, ...)",
    "body": "In the current state, [ExpandRestrictions|https://github.com/oasis-tcs/odata-vocabularies/blob/ee275ab8006b9f6a93e8e817656838dcd623da0d/vocabularies/Org.OData.Capabilities.V1.xml#L524] can specify the forbidden *nested* expansions via the NonExpandableProperties but can't specify the other nested query options.\r\n\r\nFor example the request {{GET /orders/?$expand=items($expand=sku)}} is allowed with Capabilities annotation that allows expansion for the paths {{[\"items\", \"items/sku\"]}}. But the capabilities a) needs to list the NonExpandableProperties b) has no way to specify if there is a filter restriction allowed inside of the expanded {{items}} ( {{GET /orders/?$expand=items($expand=sku; $filter=count gt 10)}} )\r\n\r\nThis is different for other restrictions that typically are used as part of a NavigationPropertyRestriction that lists the NavigationProperty Path together with all kinds of restrictions.\r\n\r\nHypothetical\r\n\r\n{code:xml}\r\n<Annotations Target=\"example.com.Service/orders\">\r\n  <Annotation Term=\"Org.OData.Capabilities.V1.NavigationRestrictions\">\r\n    <Record Type=\"Org.OData.Capabilities.V1.NavigationRestrictionsType\">\r\n      <PropertyValue Property=\"RestrictedProperties\">\r\n        <Collection>\r\n          <Record Type=\"Org.OData.Capabilities.V1.NavigationPropertyRestriction\">\r\n            <PropertyValue Property=\"NavigationProperty\" NavigationPropertyPath=\"items\" />\r\n            <PropertyValue Property=\"ExpandRestrictions\">\r\n              <Record Type=\"Org.OData.Capabilities.V1.ExpandRestrictionsType\">\r\n              </Record>\r\n            </PropertyValue>\r\n          </Record>\r\n          <Record Type=\"Org.OData.Capabilities.V1.NavigationPropertyRestriction\">\r\n             <PropertyValue Property=\"NavigationProperty\" NavigationPropertyPath=\"items/sku\" />\r\n             <PropertyValue Property=\"ExpandRestrictions\">\r\n               <Record Type=\"Org.OData.Capabilities.V1.ExpandRestrictionsType\">\r\n               </Record>\r\n             </PropertyValue>\r\n          </Record>\r\n        </Collection>\r\n      </PropertyValue>\r\n    </Record>\r\n  </Annotation>\r\n</Annotations>\r\n{code}\r\n\r\nBut that doesn't quite capture the situation since the ExpandRestriction is not restricting the navigation property it is \"applied to\" (items and items/sku) in the above but rather is restricting the navigation properties of the structured type of structured type it is applied to (hence the NonExpandableProperties)\n\nImported from [ODATA-1502](https://issues.oasis-open.org/browse/ODATA-1502)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Dry-run of data modification requests",
    "body": "Add a feature to allow submitting a data modification request in \"simulation\" or \"dry-run\" mode without actually modifying data:\r\n * Client sends request in the usual form, only difference is an additional \"dry-run\" header or query option\r\n * Service processes the request\r\n ## Syntax check\r\n ## Semantic check (business rules are satisfied)\r\n ## Simulated request outcome (for 201 or 200 responses)\r\n * Service does not perform the data modification\r\n * Service responds in the usual form (response code, headers and body), only difference is an additional \"was a dry-run\" marker\r\n\r\nService announces dry-run capability via annotation on entity container or top-level resource.\r\n\r\nService may announce check level (1. is minimum, 2. and 3. are optional) in the annotation.\r\n\r\nIf response is an entity or collection of entities, mark them as transient.\r\n\r\nQuery option may be safer than a header because servers are strongly encouraged not to silently ignore unknown {{$xxx}} query options.\n\nImported from [ODATA-1504](https://issues.oasis-open.org/browse/ODATA-1504)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Expressions in action payloads",
    "body": "h2. Use case\r\n\r\nThe history of department D15 (example data from [OData-Temporal]) shall be merged into D08. Assume we already have a function {{toTimeslices}} that converts {{Departments('D15')/history}} into the {{TimesliceWithPeriod}} format so that\r\n{code:java}\r\nGET ~/Departments('D15')/history/Temporal.toTimeslices()\r\n{code}\r\nreturns\r\n{code:json}\r\n[{\"Timeslice\": {\r\n   \"From\": \"2010-01-01\",\r\n   \"To\": \"2011-01-01\",\r\n   \"Name\": \"Services\",\r\n   \"Budget\": 1100\r\n}},\r\n {\"Timeslice\": {\r\n   \"From\": \"2011-01-01\",\r\n   \"To\": \"9999-12-31\",\r\n   \"Name\": \"Services\",\r\n   \"Budget\": 1700\r\n}}]\r\n{code}\r\nIf action parameters were specified in the URL, one could write:\r\n{code:java}\r\nPOST ~/Departments('D08')/history/Temporal.Update(deltaTimeslices=@delta)\r\n&@delta=$root/Departments('D15')/history/Temporal.toTimeslices()\r\n{code}\r\nBut action parameters must be passed in the payload, and this does not allow aliases and expressions.\r\nh2. Suggestion\r\n{code:java}\r\nPOST ~/Departments('D08')/history/Temporal.Update\r\n\r\n{\r\n \"deltaTimeslices@expressionUrl\":\r\n  \"$root/Departments('D15')/history/Temporal.toTimeslices()\"\r\n}\r\n{code}\r\nOr, because in a structured payload, a structured expression fits better than an expression string that must be parsed, we borrow notation from [CSDL|https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html#sec_ApplyClientSideFunctions]:\r\n{code:java}\r\nPOST ~/Departments('D08')/history/Temporal.Update\r\n\r\n{\r\n \"deltaTimeslices@expressionCsdl\": {\r\n  \"$Function\": \"Temporal.toTimeslices\",\r\n  \"$Apply\": [\r\n   {\"$Path\": \"$root/Departments('D15')/history\"}\r\n  ]\r\n }\r\n}\r\n{code}\n\nImported from [ODATA-1505](https://issues.oasis-open.org/browse/ODATA-1505)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Allow index segments in path expressions",
    "body": "OData already allows numeric index segments for ordered collections in the path part of the URL, see ODATA-820.\r\n\r\nAllow this also in [Path Expressions|https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_PathExpressions]:\r\n{code:java}\r\nGET Entries?$expand=components($orderby=name))&$orderby=components/0/name\r\n{code}\r\nNote: the index in {{$orderby}} is evaluated on the implicit server-defined order of the {{components}} as {{$orderby}} has to be evaluated _before_ {{$expand}}. This is somewhat counter-intuitive and could be remedied by further extending the path syntax to e.g.\r\n{code}\r\n$orderby=components($orderby=name)/0/name\r\n{code}\r\n\r\nWith that however it would be more \"natural\" to use a nested {{$index}} option instead of an index segment:\r\n{code}\r\n$orderby=components($orderby=name;$index=0)/name\r\n{code}\r\n\n\n### Proposal\n\nTwo alternatives:\r\n- [https://github.com/oasis-tcs/odata-abnf/pull/59]\r\n- [https://github.com/oasis-tcs/odata-abnf/pull/61]\n\nImported from [ODATA-1506](https://issues.oasis-open.org/browse/ODATA-1506)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ],
    "repo": "odata-abnf"
  },
  {
    "title": "Delta: distinguish \"soft-deleted\" and \"hard-deleted\" entities",
    "body": "One of our business object framework would like to only include \"soft-deleted\" entities ({{@removed:\\{reason:\"changed\"}}}) in standard delta responses, and provide \"hard-deleted\" entities ({{@removed:\\{reason:\"deleted\"}}}) via a separate call to a bound function.\r\n\r\nIs that something the TC wants to allow expressing in the standard Capabilities vocabulary, or is it rather something for an SAP-specific vocabulary?\n\nImported from [ODATA-1512](https://issues.oasis-open.org/browse/ODATA-1512)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Clarify use of read/update restrictions for complex types",
    "body": "Currently, ReadRestrictions and UpdateRestrictions target entities/collections of entities.\r\n\r\nMany of these properties apply equally to complex types.\r\n\r\n \r\n\r\nOne option is adding complex types to the AppliesTo for these and perhaps calling out which are/are not valid for complex types.\n\nImported from [ODATA-1513](https://issues.oasis-open.org/browse/ODATA-1513)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Generalize the use of $each",
    "body": "Allow the use of {{$each}} between a collection-valued path and any {{singleNavigationExpr}}. For example,\r\n{code:java}\r\n$root/SalesOrganizations/$each/ID\r\n{code}\r\nshall evaluate to a collection of primitive ID values.\r\n\r\n(This was proposed in the TC meeting on 2022-02-10.)\n\nImported from [ODATA-1514](https://issues.oasis-open.org/browse/ODATA-1514)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Support returning inline count accuracy",
    "body": "We say that the @odata.count value may be an approximation, but we don't provide a way for a client to know if it is accurate.\r\n\r\nAdditional control information to return an accuracy would enable clients to understand how reliable the count value.\r\n\r\nOne option would be to add @odata.countAccuracy (or @odata.count.accuracy) to the JSON control information, with values such as: exact, atLeast, estimated.\n\n### Proposal\n\nSpecify in [Protocol] that services may return the accuracy of the count in a format-specific manner.\r\n\r\n \r\n\r\nSpecify in [OData-Json] that @odata.countAccuracy with values \"counted\", \"partial\", or \"estimated\" *may* be returned to specify the accuracy of the count.\n\nImported from [ODATA-1516](https://issues.oasis-open.org/browse/ODATA-1516)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Support collapsing individual sections (chapters) in the HTML versions of the specification",
    "body": "null\n\n### Proposal\n\nFor better usability of the standard's documents it would be beneficial to be able to collapse complete sections (chapters, sub-chapters .\r\n\r\nsee [How To Create a Collapsible (w3schools.com)|https://www.w3schools.com/howto/howto_js_collapsible.asp] for \"collapsible\"\n\nImported from [ODATA-1526](https://issues.oasis-open.org/browse/ODATA-1526)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Allow functions/actions to return (and take) a delta payload",
    "body": "We define a delta payload that can be returned from a(n opaque) delta link, as well as other service-defined mechanisms.\r\n\r\nHowever, we don't have a way to define a custom function (or action) that can return a delta payload, and there are many places where a service may want to describe the results of a custom function (or action) using a delta payload.\r\n\r\nSimilarly, one can imagine using the delta payload as a payload to a custom action.\r\n\r\nHow can users define functions/actions that can return (or take) delta payloads.\n\nImported from [ODATA-1527](https://issues.oasis-open.org/browse/ODATA-1527)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Update JSON Delta Response payload examples",
    "body": "The first example (example 31) shows an outdated/less common flattened delta payload. The next example (example 32) shows the more common nested representation.\r\n\r\nWe should start with the more common representation.\r\n\r\nAlso, the context is not needed for the deleted entity since the @id is provided.\n\n### Proposal\n\nSee description\n\nImported from [ODATA-1528](https://issues.oasis-open.org/browse/ODATA-1528)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Provide support for selecting the id of an entity",
    "body": "With full metadata in the JSON format, all control information (ids, read/edit links, navigation links, media links, etc.) are returned in the payload.\r\n\r\nIn the JSON minimal metadata format, only that control information that cannot be derived from the context (i.e., contextUrl and associated metadata) is returned.\r\n\r\nIn the JSON no metadata format, no control information (other than nextLink and explicitly requested deltalink) is returned.\r\n\r\nThere may be scenarios where the client explicitly wants ids, but does not want additional control information. There is no way to request such a response in JSON today.\r\n\r\nA JSON-specific solution would perhaps be to define a new metadata-level, such as application/json;odata.metadata=id. \r\n\r\nIf we believe that other formats may have similar payload optimizations, we could define a special value used in $select (such as @id) to explicitly request (in any format) that the id be present, similar to how we use $select to include navigation links.  Note that services *can* always include the id, and in some formats may always have an id, but the syntax would enable a common way to request id across formats.\r\n\r\n\n\nImported from [ODATA-1529](https://issues.oasis-open.org/browse/ODATA-1529)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "OData 4.01 JSON batch format doesn't support streaming use cases well",
    "body": "JSON Format 19.5 Batch Response states:\r\n\r\n\"In a response to a batch request using the JSON batch request format specified in the preceding section the response objects MAY appear in any order, and each response object MUST contain the id name/value pair with the same value as in the corresponding request object.\"\r\n\r\nThis presents difficulties for clients that may wish to stream the processing of responses.\r\n\r\nFor example, a client sends a batch of GET requests, each of which is expected to return a large volume of data without having all of it in memory at once.\r\n\r\nIt is reasonable to expect that in order to correctly process a response object, the client needs to at least get the \"id\" from the response object and then it will be able to determine which of its requests the response object is associated with. However since payload ordering constraints in section 4.4 don't require the \"body\" of a batch response object to appear after the \"id\" of the batch response object, the client may need to buffer the entire response object in memory before being able to process it, which entirely defeats the client's intention of streamed batch response processing.\r\n\r\nNote: section 4.4 does mention \"id\" control information in relation to payload ordering, but the \"id\" in a batch response object is not \"id\" control information, it is rather the equivalent of a Content-ID.\r\n\r\nFor multipart/mixed batch responses, effective response streaming can already be achieved.\r\n\n\n### Proposal\n\nDefine a mechanism by which the client can expect \"id\" to appear before \"body\" in batch response objects.\n\nImported from [ODATA-1534](https://issues.oasis-open.org/browse/ODATA-1534)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": [
      "Hubert-Heijkers"
    ]
  },
  {
    "title": "Should updates of related resources be supported in Create?",
    "body": "As described in ODATA-1450, when we create a resource we can link it to other, existing resources using @odata.id. We can also create new related resources.\r\n\r\nThis is similar to what we do with a delta patch operation and, indeed, within a delta patch operation we can create a new entity and create/update/remove related nested entities.\r\n\r\nShould we support the same functionality when creating a single resource (i.e., using POST) that we do in a delta update?\r\n\r\nSpecifically, when we create an item using POST, should we\r\n 1) Support referencing existing items by key properties as an alternative to @odata.id? Note that, for non-contained nested resources with no navigation property binding you would have to either include the @odata.context in addition to key values or include the @odata.id.\r\n 2) Support modifying properties of related existing items?\r\n\r\nSame question for using PUT/PATCH as an upsert – seems like at least PATCH, which already supports keyvalues and nested deltas for update, should also support the same changes as part of a create.\n\nImported from [ODATA-1535](https://issues.oasis-open.org/browse/ODATA-1535)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Need to constrain functions/actions to particular paths",
    "body": "Today, actions and functions are bound to a type. This implies that, anywhere that type is present, the action or function can be invoked.\r\n\r\nThere are many scenarios in which whether an action or function could be invoked is dependent upon where the instance of the type lives.\r\n\r\nFor such scenarios, it would be nice to be able to specify exactly what usages of a type supported a particular operation.\r\n\r\nOne option would be to introduce a BindingConstraint annotation; something like:\r\n\r\n{code:xml}\r\n<Action Name=\"forward\" IsBound=\"true\" >\r\n  <AnnotationTerm=\"Org.OData.Core.V1.Capabilities.BindingConstraint\">\r\n     <Collection>\r\n        <Record>\r\n           <PropertyValue Property=\"Target\" ModelElementPath=\"/me/email\"/>\r\n        </Record>\r\n     </Collection>\r\n  </Annotation>\r\n  <ParameterName=\"bindingParameter\" Type=\"self.email\"/>\r\n  <ParameterName=\"recipient\" Type=\"Collection(self.recipent)\"/>\r\n  <ReturnTypeType=\"self.email\" />\r\n</Action>\r\n{code}\r\n\r\nIf we don't think we need to add additional properties/annotations to the path, it would be simpler to make a collection of model element paths:\r\n\r\n{code:xml}\r\n<Action Name=\"forward\" IsBound=\"true\" >\r\n  <AnnotationTerm=\"Org.OData.Core.V1.Capabilities.BindingConstraint\">\r\n      <Collection>\r\n         <ModelElementPath>/me/email<ModelElementPath/>\r\n      </Collection>\r\n  </Annotation>\r\n  <ParameterName=\"bindingParameter\" Type=\"self.email\"/>\r\n  <ParameterName=\"recipient\" Type=\"Collection(self.recipent)\"/>\r\n  <ReturnTypeType=\"self.email\" />\r\n</Action>\r\n{code}\r\n\n\n### Proposal\n\nIntroduce two new terms:\r\n\r\n*RequiresExplicitBinding* targets a bound action or function and specifies that the operation must be specified through an ExplicitOperationBinding to be available on a model element.\r\n\r\n*ExplicitOperationBindings* targets a model element and specifies the qualified name of explicitly bound operations that are supported through that path. These bindings are in addition to any bindings to the target type not annotated with RequiresExplicitBinding.\r\n{code:xml}\r\n<Term Name=\"RequiresExplicitBinding\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"Action, Function\">\r\n  <Annotation Name=\"Description\" Edm.String=\"This bound action or function is only available on model elements annotated with the ExplicitOperationBinding term.\"/>\r\n</Term>\r\n\r\n<Term Name=\"ExplicitOperationBindings\" Type=\"Collection(Edm.String)\"> \r\n   <Annotation Name=\"Description\" Edm.String=\"The qualified names of explicitly bound operations that are supported on the target model element. These bindings are in addition to any bindings to the type of the target model element not annotated with RequiresExplicitBinding\"/> \r\n</Term>\r\n{code}\r\n \r\n\r\nExample usage:\r\n{code:xml}\r\n<Action Name=\"forward\" IsBound=\"true\" >\r\n  <AnnotationTerm=\"Org.OData.Capabilities.V1.RequiresExplicitBinding\"/>\r\n  <ParameterName=\"bindingParameter\" Type=\"self.email\"/>\r\n  <ParameterName=\"recipient\" Type=\"Collection(self.recipent)\"/>\r\n  <ReturnTypeType=\"self.email\" />\r\n</Action>\r\n\r\n<Annotations Target=\"self.Container/me/email\">\r\n  <Annotation Term=\"Org.OData.Capabilities.V1.ExplicitOperationBindings\">\r\n    <Collection>\r\n      <String>self.forward</String>\r\n    </Collection>\r\n  </Annotation>\r\n</Annotations>\r\n{code}\n\nImported from [ODATA-1538](https://issues.oasis-open.org/browse/ODATA-1538)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Chapter 3, example 7 still uses TimeSliceStart and TimeSliceEnd",
    "body": "Example 7 does not reflect the current state of the Temporal vocabulary, it should use\r\n * {{PeriodStart}} instead of {{TimeSliceStart}}\r\n * {{PeriodEnd}} instead of {{TimeSliceEnd}}\n\nImported from [ODATA-1542](https://issues.oasis-open.org/browse/ODATA-1542)",
    "labels": [
      "Temporal",
      "V4.0_CS02"
    ],
    "assignees": []
  },
  {
    "title": "Section 4.17: support new HTTP QUERY method, deprecate /$query path suffix",
    "body": "The IETF Draft [The HTTP QUERY Method|https://httpwg.org/http-extensions/draft-ietf-httpbis-safe-method-w-body.html] defines a new HTTP method {{QUERY}} that basically is a \"GET with request body\", being \r\n* safe\r\n* idempotent\r\n* cacheable, with the request body incorporated in the cache key\r\n\r\nThis could replace the OData-specific solution {{POST .../$query}} defined in section [4.17 Passing Query Options in the Request Body|https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_PassingQueryOptionsintheRequestBody].\n\n### Proposal\n\nRephrase section 4.17 to use the new {{QUERY}} method with a request body of {{Content-Type: application/x-www-form-urlencoded}} or {{application/json}} as defined by ODATA-1405.\r\n\r\nRequire all query options to be passed in the request body (rationale: mixed locations for query options are an unnecessary complication). \r\n\r\nDeprecate the current approach using {{POST}} and path suffix {{/$query}}.\n\nImported from [ODATA-1544](https://issues.oasis-open.org/browse/ODATA-1544)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Allow services to validate read-only properties in update payloads",
    "body": "Section [11.4.3, Updating an Entity|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity] states: \r\n{code:java}\r\nKey and other properties marked as read-only in metadata (including computed properties), as well as dependent properties that are not tied to key properties of the principal entity, can be omitted from the request. If the request contains a value for one of these properties, the service MUST ignore that value when applying the update. Services MUST return an error if an insert or update contains a new value for a property marked as updatable that cannot currently be changed by the user (i.e., given the state of the object or permissions of the user). The service MAY return success in this case if the specified value matches the value of the property. Clients SHOULD use PATCH and specify only those properties intended to be changed.\r\n{code}\r\nWe defined the semantics this way because we wanted the ability to take a response payload, make some changes, and PUT it back without having to remove properties that were not updatable by the client.\r\n\r\nWe chose \"ignore\" because:\r\n1) We wanted to ignore key properties because we wanted the ability to take a response payload from one service and use it to insert into another service.\r\n2) We wanted to ignore computed properties because the computed value could change based on other properties in the payload or on external information.\r\n\r\nHowever, \"read-only\" is not a strictly defined term – it refers generically to properties that can't be changed by the user and includes not only key and computed properties, but other read-only properties.\r\n\r\nFor other such read-only properties, it may be useful, and should be valid, for services to validate that the value of the read-only property matches the stored value and, if not, return an error.\n\n### Proposal\n\nIn 4.02, allow services to validate for non-key, non-computed read-only values and return an error if they don't match persisted values. \n\nImported from [ODATA-1545](https://issues.oasis-open.org/browse/ODATA-1545)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Encourage clients to specify the correct value for non-key, non-computed read-only values (or omit)",
    "body": "Section [11.4.3, Updating an Entity|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity] states: \r\n{code:java}\r\nKey and other properties marked as read-only in metadata (including computed properties), as well as dependent properties that are not tied to key properties of the principal entity, can be omitted from the request. If the request contains a value for one of these properties, the service MUST ignore that value when applying the update. Services MUST return an error if an insert or update contains a new value for a property marked as updatable that cannot currently be changed by the user (i.e., given the state of the object or permissions of the user). The service MAY return success in this case if the specified value matches the value of the property. Clients SHOULD use PATCH and specify only those properties intended to be changed.\r\n{code}\r\nWe defined the semantics this way because we wanted the ability to take a response payload, make some changes, and PUT it back without having to remove properties that were not updatable by the client.\r\n\r\nWe chose \"ignore\" because:\r\n1) We wanted to ignore key properties because we wanted the ability to take a response payload from one service and use it to insert into another service.\r\n2) We wanted to ignore computed properties because the computed value could change based on other properties in the payload or on external information.\r\n\r\nHowever, \"read-only\" is not a strictly defined term – it refers generically to properties that can't be changed by the user and includes not only key and computed properties, but other read-only properties.\r\n\r\nFor other such read-only properties, it may be useful, and should be valid, for services to validate that the value of the read-only property matches the stored value and, if not, return an error.\n\n### Proposal\n\nEncourage clients to specify the correct value for non-key, non-computed read-only values (or omit).\r\n\r\n\n\nImported from [ODATA-1548](https://issues.oasis-open.org/browse/ODATA-1548)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify semantics of etag in delta requests/responses",
    "body": "We define that etags may be returned in a response for a single entity or as control information for each entity in a response containing a collection of entities.\r\n\r\nThese etags can be used in an if-match header in order to enforce optimistic concurrency when updating an instance of one of these entities.\r\n\r\nWe don't, however, describe how this applies to delta response or update payloads.\n\n### Proposal\n\nServices that support optimistic concurrency (i.e., that would return etag control information in a GET to a collection of entities) should include the current etag value in a delta response for added/updated entities (they could include for deleted entities as well, which would tell the receiver the last version of the entity when it was deleted, but it's of dubious value).\r\n\r\nClients can specify an etag value in a delta update, in which case the update should only apply if the etag matches the current etag value in the server. If it does not match, then the service should either fail the entire operation, or not apply the change and mark it as a datamodificationerror in the response, depending on the continueonerror behavior.\r\n\r\nThe special value {{\"@odata.etag\":\"\\*\"}} can be used to request overriding optimistic concurrency control, identical to an {{If-Match:*}} header in a PATCH request to a single entity.\r\n\r\nIf an etag value is present, this is interpreted as an update of an existing entity, and fails if the entity doesn't exist yet.\r\n\r\nWithout an etag value it can be interpreted as an upsert if the service doesn't require optimistic concurrency for that entity set.\r\n\r\nRequest body example:\r\n{code:json}\r\n{\r\n  \"@context\" : \"#$delta\",\r\n  \"value\" : [\r\n    {\r\n      \"Id\" : \"New Entity\",\r\n      \"Name\" : \"Foo\",\r\n      \"BudgetCurrency\" : \"USD\",\r\n      \"Budget\" : 555.55\r\n    },\r\n    {\r\n      \"@odata.etag\" : \"W/\\\"197707241234132000000.0000000 \\\"\",\r\n      \"Id\" : \"Existing Entity 1\",\r\n      \"Name\" : \"Bar\"\r\n    },\r\n    {\r\n      \"@odata.etag\" : \"W/\\\"197707240839125000000.0000000 \\\"\",\r\n      \"@odata.removed\" : {},\r\n      \"Id\" : \"Existing Entity 2\",\r\n    }\r\n  ]\r\n}\r\n\r\n{code}\n\nImported from [ODATA-1549](https://issues.oasis-open.org/browse/ODATA-1549)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify whether Validation.AllowedValues can be applied to collection-valued properties",
    "body": "Validation.AllowedValues takes an array of primitive values, so it is obvious how it constrains the value range of a single-valued primitive-typed model element.\r\n\r\nCan this annotation also be applied to model elements whose type is a collection of primitive values, and the value constraint applies to each item in the collection?\n\n### Proposal\n\nTwo alternatives:\r\n# Only allow application to single-valued primitive-typed model elements and to type definitions. Restricting values of a collection-valued property can be achieved by introducing a type definition that is annotated with {{Validation.AllowedValues}}.\r\n# Allow annotating single- and collection-valued primitive-typed model elements, and call out that the annotation applies to items of a collection-valued model element, similar to the type facets {{MaxLength}} etc.\n\nImported from [ODATA-1550](https://issues.oasis-open.org/browse/ODATA-1550)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "4.3.2.3 Delete during a Period, step 3: align with corresponding step of 4.3.2.1, step 3",
    "body": "Time slices that are not fully included may need to be split into two _or three_ adjacent time slices\n\n### Proposal\n\nTake and adapt text from [4.3.2.1 Update during a Period|https://docs.oasis-open.org/odata/odata-temporal-ext/v4.0/cs01/odata-temporal-ext-v4.0-cs01.html#sec_UpdateduringaPeriod], step 3\n\nImported from [ODATA-1551](https://issues.oasis-open.org/browse/ODATA-1551)",
    "labels": [
      "Temporal",
      "V4.0_CS02"
    ],
    "assignees": []
  },
  {
    "title": "Define semantics for navigation properties of type Edm.EntityType",
    "body": "[OData Common Schema Definition Language (CSDL) XML Representation Version 4.01 (oasis-open.org)|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_BuiltInAbstractTypes] defines the behavior for Edm.EntityType. It specifically disallows use of Edm.EntityType as the type of an EntitySet, because all instances within an entity set must have the same key.  However, it leaves open the ability to use Edm.EntityType as the entity type of a navigation property. And, indeed, ODATA-1552 updates the xsd to allow navigation properties of type Edm.EntityType.\r\n\r\nWhat is missing is a description of the semantics of a navigation property whose type is Edm.EntityType. Specifically, since Edm.EntityType doesn't define a key, it's not possible to index into a navigation property of type Edm.EntityType by key *unless you insert a cast segment*.\r\n\r\nThis is ramification is implied by other rules (so calling it out is not a breaking change) but it should be explicitly called out so that the user doesn't have to derive the semantics from the existing rules.\r\n\r\nWe do separately have a rule that requires a collection-valued containment navigation property define a key (and thus, Edm.EntityType cannot be used as the type of a collection-valued containment navigation property):\r\n\r\n\"For a collection-valued containment navigation property the specified entity type MUST have a [key|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Key] defined.\"\r\n\r\nThis is consistent with entitysets, which disallow the use of Edm.EntityType \"because all entities in an entity set must have the same key fields to uniquely identify them within the set\".\r\n\r\nAre there any other semantics of a (collection-valued) navigation property of Edm.EntityType that need to be spelled out?\r\n\r\nAlso note that, in general, if there is no navigation property binding for a non-containment collection-valued navigation property, the key may not uniquely identify the instance. This has nothing to do with Edm.EntityType, and we may want to decide to open a separate issue to track, it just came up in scope of the discussion. \n\n### Proposal\n\nClarify that, if the entity type defined for a collection-valued navigation property does not define a key (including Edm.EntityType), indexing the collection by key requires a cast segment to an entity type with a key defined, and will return the entity of that type (or subtype) with the specified key, if such an instance exists.\n\nImported from [ODATA-1558](https://issues.oasis-open.org/browse/ODATA-1558)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify usage of URL templates with callback preference",
    "body": "Section 8.2.8.2 introduces and describes the use of the 'callback' preference which must include a 'url' parameter. It also describes that the service can advertise it's support for the callback preference by means of the [CallbackSupported annotation|https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Capabilities.V1.md#CallbackSupported] from our Capabilities vocabulary.\r\n\r\nThe CallbackSupported annotation, of [CallbackType|https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Capabilities.V1.md#CallbackType], represents the collection of protocols supported but also a UrlTemplate, a template which can include parameters, parameters for which the meaning can be documented in a document referenced by a DocumentationUrl.\r\n\r\nThe clarification I'm seeking is twofold:\r\n # What is the relationship between this UrlTemplate property in the CallbackSupported annotation and the url parameter specified as part of the Callback preference?\r\n # Can the requester specify a url template as part of that url parameter referencing variables that are available/advocated by the service using this template?\r\n\r\nFYI: what I'm trying to do is to allow the requester to specify if, and if so how, it wants the job/request ID (an ID we assign to our asynchronous requests) passed to the service being notified of completion of such job.\n\nImported from [ODATA-1560](https://issues.oasis-open.org/browse/ODATA-1560)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "Hubert-Heijkers"
    ],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Clarify \"Expand to the level present in the deep insert request\"",
    "body": "In 11.4.2.2 [Create Related Entities When Creating an Entity,|http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CreateRelatedEntitiesWhenCreatinganE] we state that:\r\n\r\n\"If the service responds with 201 Created, the response MUST be expanded to at least the level that was present in the deep-insert request.\"\r\n\r\nHowever, we don't specify what information must be included in that nested response (i.e., do unaffected properties need to be retrieved?) nor whether the entire response must be expanded to the maximum level, or if different elements may be expanded to different levels, based on their depth within the request.\"\r\n\r\nWe are finding scenarios where it is hard/expensive to return more data that specified in the request. Since we have since added the ability to specify select/expand on the results of the request, we are fine paying the extra cost to re-query whatever data is required, but doing this by default in order to return a 201 Created seems onerous.\r\n\r\nNote that, in 11.4.3 [Update an Entity|http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity], we specify:\r\n\"Upon successful completion the service responds with either [200 OK|http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ResponseCode200OK] and a representation of the updated entity, or [204 No Content|http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ResponseCode204NoContent]\"\r\n\r\nWe do not here specify which properties of the representation must be returned (i.e., only the updated properties or all of the properties or some default set of properties or???)\n\n### Proposal\n\nClarify that, for create or update, the returned response need not do further expansion of the properties or depth.  i.e., the response is not required to include properties not specified in the request and, if only ids of related entities are in the request, only ids are required in the response.\n\nImported from [ODATA-1567](https://issues.oasis-open.org/browse/ODATA-1567)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "clarify behavior for omitted values in PATCH and PUT",
    "body": "null\n\nImported from [ODATA-1573](https://issues.oasis-open.org/browse/ODATA-1573)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Expand function results ",
    "body": "Allow function results to be included in the response by including the function, optionally with parameters, in the $expand list.\n\nImported from [ODATA-1574](https://issues.oasis-open.org/browse/ODATA-1574)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [],
    "repo": "odata-abnf"
  },
  {
    "title": "Remove restriction on Partner navigation",
    "body": "Consider the following scenario:\r\n * Foo\r\n ** allBar Type=Collection(Bar) Partner=foo\r\n ** redBar Type=Collection(Bar) Partner=foo\r\n ** greenBar Type=Collection(Bar) Partner=foo\r\n * Bar\r\n ** foo Type=Foo Partner=allBar\r\n\r\nThese partner navigation properties satisfy the basic rules\r\n{quote}If the partner navigation property is single-valued, it MUST lead back to the source entity from all related entities. If the partner navigation property is collection-valued, the source entity MUST be part of that collection.\r\n{quote}\r\nIn addition this model clearly expresses that the pair (Foo/allBar, Bar/foo) forms a bi-directional relationship, and the other two navigation properties on Foo are uni-directional with a back-link.\r\n\r\nUnfortunately this model violates the last paragraph in CSDL section [8.3 Partner Navigation Property|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_PartnerNavigationProperty]\r\n{quote}If a partner navigation property is specified, this partner navigation property MUST either specify the current navigation property as its partner to define a bi-directional relationship or it MUST NOT specify a partner navigation property. The latter can occur if the partner navigation property is defined on a complex type, or if the current navigation property is defined on a type derived from the type of the partner navigation property.\r\n{quote}\r\nA spec-compliant model would have to hide useful information, either\r\n * remove Partner=allBar from Bar/foo, or\r\n * remove Partner=foo from Foo/redBar and Foo/greenBar\r\n  \n\n### Proposal\n\nReplace the requirement with an explanation\r\n\r\n{quote}\r\nIf a partner navigation property is specified, and this partner navigation property specifies the current navigation property as its partner, the two navigation properties define a bi-directional relationship. A partner navigation property may specify a navigation property different from the current navigation property. \r\n{quote}\r\n\r\n \n\nImported from [ODATA-1575](https://issues.oasis-open.org/browse/ODATA-1575)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Allow references to Core.ContentIDs in batch request URLs",
    "body": "Allow URLs in batch requests that reference an entity that was returned by a previous request by its {{Core.ContentID}}, like in\r\n{code}\r\nPOST SalesOrganizations\r\n\r\n{\"ID\": \"EMEA\", \"Children\": [\r\n {\"@Core.ContentID\": \"child1\", \"ID\": \"Germany\"}\r\n]}\r\n{code}\r\nfollowed by\r\n{code}\r\nPOST $child1/ns.ChangeNextSiblingAction\r\n\r\n{\"ID\": \"Switzerland\"}\r\n{code}\n\nImported from [ODATA-1579](https://issues.oasis-open.org/browse/ODATA-1579)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Further clarify restrictions around open types",
    "body": "ODATA-1498 clarifies that \"A collection of primitive values that occurs in a property of type Edm.Untyped is interpreted as a collection of Edm.Boolean, Edm.String, and Edm.Decimal, depending on the JavaScript type.\"\r\n\r\nThis rule is true because we can't specify the type of a primitive value within a collection. However, the wording is misleading, because:\r\n1) It's a bit ambiguous what \"occurs in a property of type Edm.Untyped\" references – is that to say, that the property *is* an untyped collection of primitives, or is an untyped collection that contains a collection of untyped primitives, or...? \r\n\r\n2) It doesn't mention Collection(Edm.Untyped)\r\n\r\n3) It implies that the *collection* is a collection of one of the javascript types, as opposed to an individual value within any untyped collection being interpreted as one of these types.  i.e., the collection itself is untyped, and can contain primitives of any of these three types.\r\n\r\nBetter wording would be something like \"A primitive value within an untyped collection is interpreted as a Edm.Boolean, Edm.String, or Edm.Decimal.\"\r\n\r\nIn addition, we should note that a collection nested within a collection will always be an untyped collection; this is because there is no place to put a type annotation for the collection, and we say that, once you enter the untyped world, you remain untyped unless type information is explicitly supplied.\r\n\r\n \n\n### Proposal\n\n1) Close ODATA-1498 with no further action. It clarifies what was originally intended, and that clarification has been applied. Use this issue to track restrictions around how primitives are interpreted within an untyped collection.\r\n\r\n2) Add a note to [OData-JSON] that \"A primitive value within an untyped collection is interpreted as a Edm.Boolean, Edm.String, or Edm.Double.\"\r\n\r\n3) Clarify that an enum value within an untyped collection should be represented as a string, using the member name.\r\n\r\n4) Clarify that any collection within an untyped collection is itself untyped.\n\nImported from [ODATA-1580](https://issues.oasis-open.org/browse/ODATA-1580)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify representation of context URLs in JSON payloads",
    "body": "Context URLs may include characters outside of the unreserved set, e.g. a '(', ')', '/' like for a collection of entities reached via a path to a containment navigation property: \"$metadata#set('<key_value>')/cont_nav_prop\"\r\n\r\nSome implementations return such a context URL in a JSON payload with percent-encoded '(', ')', '/', e.g. \"$metadata#set%28'<key_value>'%29%2Fcont_nav_prop\", others return it with plain characters.\r\n\r\nQuestion is if servers are free to choose the representation of context URLs and service consumers must be prepared to do a percent-decoding before interpreting the context URL\r\n\r\nReferences:\r\n - The JSON Format specification in section [4.3 Relative URLs |http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_RelativeURLs] mention _colons_ inside the path part that must be percent-encoded\r\n - The ABNF includes a statement for the grammar on the necessity of a percent-decoding a URL before parsing it. Shall this rule also be applied for URLs in JSON payloads?\n\n### Proposal\n\nContext URLs for contained entities MUST use parenthesis-style keys.\r\n\r\nContext URL fragments MUST NOT be percent-encoded, not even key values for contained entities.\n\nImported from [ODATA-1583](https://issues.oasis-open.org/browse/ODATA-1583)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Should be able to change type when PATCHing an entity",
    "body": "In [Protocol](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateanEntity) we say that Entity id and entity type cannot be changed when updating an entity.\r\n\r\nODATA-1472 introduces the notion of changing the type of a nested complex type, but stopped short of changing the type of an entity due to concerns that an entities type was part of its identity. \r\n\r\nHowever, updating an entity type doesn't necessarily change the identity of the entity; for example, an employee can become a manager and back.\r\n\r\nAn entities id is made up of its container plus its key properties. The allowable types that you could change an entity to is already restricted to the hierarchy of the entityset or navigation property in which the entity instance is contained, and the type of that container defines the key property, so there is no concern that changing the type of an entity will change its container nor its key property.  Therefore, an entity's identity doesn't change when you change its type.\r\n\r\nThus, we should allow the semantics defined in ODATA-1472 to extend to updating the type of an entity (within the hierarchy of the collection in which it is contained).\n\n### Proposal\n\nAllow the semantics defined in ODATA-1472 to extend to updating the type of an entity (within the hierarchy of the collection in which it is contained).\n\nImported from [ODATA-1585](https://issues.oasis-open.org/browse/ODATA-1585)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify create/replace for server-defined dynamic properties",
    "body": "I wrote:\r\n\r\nI think we need to understand why this text:\r\n \r\n\tA missing dynamic property is defined to be the same as a dynamic property with value null. \r\n \r\nis only present in the section “Set a Value to null”.\r\n \r\nIs it also intended that that same text would apply to the request payload of entity-level (not property-level) POST and PUT requests?\r\n \r\nWould a server be considered spec-compliant if it responds to a missing value by generating a non-null default, and responds to a null value by having no value at all?\r\n\r\n---\r\n\r\nthen Ralf wrote:\r\n\r\nI think there’s no corresponding text in the sections for Create (POST) and Replace (PUT) because the text would have to differentiate between client-defined (“open”) dynamic properties and server-defined (“hidden”) dynamic properties.\r\n \r\nFor client-defined dynamic properties the same statement is obviously valid for Create: the server does not know that property, the client does not state its value, so it is completely unknown to the server.\r\n \r\nFor client-defined dynamic properties and Replace there’s the edge case that the property had been sent in a previous request and has a known value for the server. Here the server can decide to\r\n1.\tCompletely forget that this dynamic property ever existed\r\n2.\tKeep a trace that this property once existed and now doesn’t have a value\r\n3.\tSomething else I wouldn’t think of\r\n \r\nFor server-defined dynamic properties the behavior can be server-specific and even vary between different “hidden” properties: no value, implicit default value, explicitly stored default value – that’s completely up to the server.\r\n\n\n### Proposal\n\nDocument that when a dynamic property is missing in entity-level POST/PUT, the server is free to generate a non-null default.\n\nImported from [ODATA-1586](https://issues.oasis-open.org/browse/ODATA-1586)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "/$query shall allow Content-Type: application/json",
    "body": "JSON as content type should also be supported by {{/$query}}:\r\n{code:java}\r\nPOST ~/$query\r\nContent-Type: application/json\r\n\r\n{\"$filter\": \"a eq 1\",\r\n \"$select\": \"b\"}\r\n{code}\r\nThis is especially useful for complex function parameters, that would then be represented as if they were action parameters:\r\n{code:java}\r\nPOST ~/Countries('DE')/GetPostcodes\r\nContent-Type: application/json\r\n\r\n{\"$filter\": \"ValidityStart gt 2020-01-01\",\r\n \"City\": \"Heidelberg\",\r\n \"Address\": {\"Street\": \"Hauptstraße\", \"Number\": \"1\"}}\r\n{code}\r\nNote that\r\n * the name of the bound function in the URL is without parentheses (because the parameters are in the body)\r\n * all parameter values in the JSON payload must be literals (whereas in the URL they could be aliases that evaluate to arbitrary expressions)\r\n * the {{/$query}} segment in the URL is optional and has been omitted here. (There is no risk of misinterpreting a function invocation URL.)\n\n### Proposal\n\nSee description\r\n\r\nNote: this would allow providing \"literal\" values to non-binding function parameters of type {{Edm.Stream}} introduced by ODATA-1481 because there's now a natural way to provide the content-type in addition to the stream data:\r\n\r\n{code:json}\r\n{\r\n  \"Thumbnail@mediaContentType\": \"image/jpeg\",\r\n  \"Thumbnail\": \"...base64url encoded value...\",\r\n}\r\n{code}\n\nImported from [ODATA-1589](https://issues.oasis-open.org/browse/ODATA-1589)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "HeikoTheissen"
    ]
  },
  {
    "title": "Clarify where alternate keys can be used",
    "body": "[OData Version 4.01. Part 2: URL Conventions (oasis-open.org)|http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_AlternateKeys] describes the use of alternate keys as a substitute for primary keys, but doesn't say where they can be used (i.e., just as part of the canonical url or in any collection).\n\n### Proposal\n\nClarify that alternate keys can be used in any collection of the target entity type.\n\nImported from [ODATA-1590](https://issues.oasis-open.org/browse/ODATA-1590)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Add support for fuzzy search function within $filter, etc.",
    "body": "The $search functionality allows fuzzy searching across all properties, and is useful for finding entities that have something to do with a particular search term.\r\n\r\nHowever, some engines may support content search on a particular field, and customers may want to combine such content searches with other predicates, for example:\r\n\r\n/users?$filter=address/state eq 'WA' or search(jobTitle,'smith')\r\n\r\nNote:\r\n\r\n1) They specifically want job titles related to a \"smith\" (woodsmith, ironsmith, etc.), not last names related to \"smith\"\r\n 2) They want to logically \"OR\" this condition with other conditions within the $filter clause.\r\n\r\nThey can't do either #1 or #2 with $search today.\n\n### Proposal\n\nIntroduce a new string function, \"search\", which does a content search on the first parameter for the search text provided by the second parameter.  The second parameter can support the same syntax as the $search query option.\r\n\r\n \r\n\r\nAlternative names: \"fuzzyMatch\", \"fuzzySearch\", \"contentMatch\", \"contentSearch\"\r\n\r\n \n\nImported from [ODATA-1594](https://issues.oasis-open.org/browse/ODATA-1594)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Allow to create annotations in CSDL with a less verbose format to increase adoption",
    "body": "CSDL XML annotations can be quite verbose. E.g. \r\n{code:xml}\r\n<Annotation Term=\"Org.OData.Core.V1.Revisions\">\r\n  <Collection>\r\n    <Record>\r\n      <PropertyValue Property=\"Version\" String=\"2023-03/PrivatePreview:analytics\" />\r\n      <PropertyValue Property=\"Kind\" EnumMember=\"Org.OData.Core.V1.RevisionKind/Deprecated\" />\r\n      <PropertyValue Property=\"Description\" String=\"Private preview for Analytics APIs\" />\r\n    </Record>\r\n  </Collection>\r\n</Annotation>\r\n{code}\r\nBut Annotation can also be expressed in a much cleaner, more readable and less verbose form in CSDL JSON.\n\n### Proposal\n\nAllow embedding CSDL JSON annotation values according to [14 Vocabulary and Annotation|https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html#sec_VocabularyandAnnotation] as CData in CSDL XML\r\n{code:xml}\r\n<Annotation Term=\"Org.OData.Core.V1.Revisions\">\r\n  <![CDATA[\r\n    [\r\n      {\r\n        \"Version\": \"2023-03/PrivatePreview:analytics\",\r\n        \"Kind\": \"Deprecated\",\r\n        \"Description\": \"Private preview for Analytics APIs\"\r\n      }\r\n    ]\r\n  ]]>\r\n</Annotation>\r\n{code}\r\n \n\nImported from [ODATA-1597](https://issues.oasis-open.org/browse/ODATA-1597)",
    "labels": [
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "chrisspre"
    ]
  },
  {
    "title": "Clarify support for supplementary plane characters in OData Identifiers",
    "body": "in [OData Common Schema Definition Language (CSDL) XML Representation Version 4.01 (oasis-open.org)|http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_SimpleIdentifier] we define the rules for a legal identifier (for instance, a property name) in OData as follows:\r\n{quote}A simple identifier is a Unicode character sequence with the following restrictions:\r\n * It consists of at least one and at most 128 Unicode characters (code points).\r\n * The first character MUST be the underscore character (U+005F) or any character in the Unicode category “Letter (L)” or “Letter number (Nl)”.\r\n * The remaining characters MUST be the underscore character (U+005F) or any character in the Unicode category “Letter (L)”, “Letter number (Nl)”, “Decimal number (Nd)”, “Non-spacing mark (Mn)”, “Combining spacing mark (Mc)”, “Connector punctuation (Pc)”, and “Other, format (Cf)”.\r\n\r\nNon-normatively speaking it starts with a letter or underscore, followed by at most 127 letters, underscores or digits.\r\n{quote}\r\nThe Unicode Category L is defined as Lu | Ll | Lt | Lm | Lo.\r\n\r\nWhere Lo is \"Other Letter\".\r\n\r\nQuestion: did we intent to include Surrogates (see [The Unicode Standard, Version 15.0)|https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf#G2630] (or, more properly, [supplementary plane characters|https://en.wikipedia.org/wiki/Plane_(Unicode)]) as valid characters in an OData identifier?\r\n\r\nThe rules for valid property names were largely taken from programming languages in order to facilitate mapping between OData types and language objects. C#, for example, does not allow surrogates in property names.\r\n\r\nNote that ODATA-1348 tries to distinguish between characters and code points with regard to things like max string length, but this doesn't address character validity within an identifier.\n\n### Proposal\n\nWe believe, according to the current rules, that characters from the supplementary plane would be included in Lo, so are valid in identifiers.\r\n\r\nHowever, rather than call out characters that we don't recommend, we will leave that as an exercise to the reader and instead add a comment that, in order to support maximum interoperability, services SHOULD only use A-Z, a-z, 0-9, and underscore in identifiers.\n\nImported from [ODATA-1599](https://issues.oasis-open.org/browse/ODATA-1599)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "It is not clear if the entities in a collection returned by a function always have an entity-id",
    "body": "A function can return a collection of an entity where that entity does not have a key defined. Keys are only required for [entity sets and multivalued navigation properties](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#_Toc38530354):\r\n\r\n > In order to be specified as the type of an entity set or a collection-valued containment navigation property, the entity type MUST either specify a key or inherit its key from its base type.\r\n[The standard](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_EntityIdsandEntityReferences) also says:\r\n\r\n> entities are also uniquely identified by a durable, opaque, globally unique entity-id\r\n> ...\r\n> Services are strongly encouraged to use the canonical URL for an entity\r\n\r\nSo, my conclusion is that an entities returned in a collection by a function should have entity-ids. However, looking at how to create the canonical URL for an entity, the [standard says this](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_CanonicalURL):\r\n\r\n> the canonical form of an absolute URL identifying a non-contained entity is formed by adding a single path segment to the service root URL. The path segment is made up of the name of the entity set associated with the entity followed by the key predicate identifying the entity within the collection.\r\n\r\nIt appears that an assumption is made that non-contained entities must exist within an entity set. However, entities that only exist as the result of a function may not have any entity set defined. So, it appears that there is no entity-id for the entities returned from a function, despite the standard declaring that entities have a durable, opaque, globally unique entity-id which can be exposed by following the canonical URL conventions.\n\n### Proposal\n\n<See discussion below.>\r\n\r\nI believe that the standard should be updated to include two situations:\r\n # A function returns a collection of entities that have keys and have no other container - In this case, it is not clear to me how the canonical URL should be generated for the entities in the returned collection. The standard may call this out somewhere, but I am not able to find it.\r\n ## Extend section [https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_OperationResult] to include function results - could be similar to containment case, including the parameter values in the canonical URL\r\n\r\n # A function returns a collection of entities that do not have keys - In this case, I believe that these entities should be considered [transient entities]([http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_TransientEntities]) and that the portion of the standard that talks about entity-ids should call out that transient entities do not have an entity-id.\n\nImported from [ODATA-1603](https://issues.oasis-open.org/browse/ODATA-1603)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Separation of concerns: ABNF for URL components instead of whole URLs",
    "body": "We have published ABNF rules for OData request URLs\r\n- odataUri\r\n- odataRelativeUri\r\n- resourcePath\r\n- queryOptions\r\n\r\nwhich are much complicated by the fact that they produce percent-encoded URLs. Because of ODATA-1583, much of these rules must be duplicated for the context rule, which (being a URL fragment) does not use percent-encoding.\r\n\r\nIt would be much easier if we only had ABNF rules for the _components_ of a URL:\r\n- path segment\r\n- search parameter name\r\n- search parameter value\r\n- fragment\r\n\r\nand then assemble a URL from these components, with the necessary percent-encoding.\r\n\r\nConsider writing an alternative set of ABNF rules with this approach.\n\nImported from [ODATA-1606](https://issues.oasis-open.org/browse/ODATA-1606)",
    "labels": [
      "V4.02"
    ],
    "assignees": [],
    "repo": "odata-abnf"
  },
  {
    "title": "Safety, Security and Privacy Considerations: fill out or remove appendix",
    "body": "Do we have considerations specific to URLs, for example length, encoding, privacy (use {{$batch}} if in doubt), ...?\n\nImported from [ODATA-1608](https://issues.oasis-open.org/browse/ODATA-1608)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Clarify use of 'wait' preference without 'respond-async' preference",
    "body": "The specification as is is a bit unclear around the behavior/expectation that a client might have from a server when a client is specifying a {{wait}} preference in case there is not also a {{respond-async}} preference.\r\n\r\n8.2.8.10 describing this behavior in our specification, whilst referencing [RFC7240|https://datatracker.ietf.org/doc/html/rfc7240], states that if the respond-async preference has not been specified, the service MAY interpret the wait as a request to timeout after the specified period of time.\r\n\r\nThe referenced [Prefer Header for HTTP specification in section 4.3|https://datatracker.ietf.org/doc/html/rfc7240#section-4.3] pertaining to the \"wait\" preference states however that a service can choose to utilize an asynchronous processing model in that case and return a 202 Accepted.\r\n\r\nLooking at 9.1.3 in the OData protocol specification pertaining to the 202 Accepted Response Code, whilst stating that is returned when an asynchronous request hasn't been completed yet, refers to the sections on asynchronous requests.\r\n\r\nWhilst one doesn't preclude the other it has caused confusion in our interpretation/implementations so I thought some clarification might be in order.\n\n### Proposal\n\nBe specific about the behavior of the status monitor resource regarding {{wait}}:\r\n{quote}If a client queries the status monitor resource with a {{wait}} preference, the preference applies to the status query and not to the original request that is/was processed asynchronously. A server may\r\n * ignore this preference on a status query, or\r\n * send {{202 Accepted}} if it cannot figure out within the given length of time whether the original async request is still being processed (i.e. assume it is still running){quote}\n\nImported from [ODATA-1610](https://issues.oasis-open.org/browse/ODATA-1610)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "Hubert-Heijkers"
    ]
  },
  {
    "title": "Clarify where RequiredProperties have to appear",
    "body": "{{Capabilities.FilterRestrictionsType/RequiredProperties}} are defined as\r\n{quote}\r\nThese properties must be specified in the $filter clause\r\n{quote}\r\nBe more explicit where/how these must be specified.\r\n\r\nFor example if {{Foo}} is required, is this filter expression sufficient?\r\n{code}\r\n$filter=Foo eq 'bar' or Baz eq 'qux'\r\n{code}\r\nOr do required properties have to appear in every expression of a top-level disjunction?\n\nImported from [ODATA-1611](https://issues.oasis-open.org/browse/ODATA-1611)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Capabilities for creating a relation to an existing entity during insert",
    "body": "The following request creates an Employee entity and associates it to an existing Employee entity via the {{Manager}} navigation property.\r\n{code}\r\nPOST Employees\r\n\r\n{\r\n  \"Manager@odata.bind\": \"Employees(0)\",\r\n  \"Name\": \"Peter\"\r\n}\r\n{code}\r\n\r\nIs there a Capabilities annotation on the navigation property that would forbid this operation?\r\n\r\n* {{UpdateRestrictions/NonUpdatableNavigationProperties}} controls changing a relation during update.\r\n* {{InsertRestrictions/NonUpdatableNavigationProperties}} controls creating a relation together with the related entity during insert.\r\n* What controls creating a relation to an existing entity during insert?\n\nImported from [ODATA-1612](https://issues.oasis-open.org/browse/ODATA-1612)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Validation.Minimum, Validation.Maximum: clarify possible data types",
    "body": "The term description does not state how closely the data types of the boundaries have to match the data type of the model element they are applied to, especially if the boundaries are provided via a [value path|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ValuePath].\r\n\r\nIt should be sufficient if the two types can be [cast|https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_cast] to each other,\n\nImported from [ODATA-1613](https://issues.oasis-open.org/browse/ODATA-1613)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Add NonSelectableProperties to SelectSupportType",
    "body": "There are times when properties can only be set when creating an entity or updating an entity, but cannot be retrieved.  An example of this would be a password, which can be set through the API but not read.\r\n\r\nWe have capabilities for saying that a property can *not* be specified on creation (InsertRestrictions.NonInsertableProperties) or can not be specified on update (UpdateRestrictions.NonUpdatableProperties), and we have SelectSupportType for describing select capabilities, but we don't have any way to say a particular property cannot be read (there is no NonSelectableProperties).\n\n### Proposal\n\n1a. Add NonSelectableProperties to SelectSupportType in the capabilities spec:\r\n{code:xml}\r\n<Property Name=\"NonSelectableProperties\" Type=\"Collection(Edm.PropertyPath)\" Nullable=\"false\">\r\n     <Annotation Term=\"Core.Description\" String=\"These structural properties cannot be specified in a select statement.\" />\r\n </Property>\r\n{code}\r\n \r\n\r\n1b. Alternatively, if we believe that read/write is a fundamental characteristic of the property, rather than a capability of the service, we could add a model annotation to the core vocabulary for specifying the readability/writeability of a property:\r\n\r\n{code:xml}\r\n<Term Name=\"PropertyUsage\" Type=\"Core.PropertyUsageType\" DefaultValue=\"Create Read Update\" Targets=\"property\">\r\n    <Annotation Term=\"Core.Description\" String=\"Specifies whether the target property is intended for use in a create, read, or update operation.\" />\r\n</Term>\r\n<EnumType Name=\"PropertyUsageType\" IsFlags=\"true\">\r\n   <Member Name=\"Create\" Value=1>\r\n      <Annotation Term=\"Core.Description\" String=\"The annotated property can be used in a Create operation.\" />\r\n   </Member>\r\n   <Member Name=\"Read\" Value=2>\r\n      <Annotation Term=\"Core.Description\" String=\"The annotated property can be read.\" />\r\n   </Member>\r\n   <Member Name=\"Update\" Value=4>\r\n      <Annotation Term=\"Core.Description\" String=\"The annotated value can be updated.\" />\r\n   </Member>\r\n</EnumType>\r\n{code}\r\n\r\n\r\n2. Add \"Omitted\" term to OData Core vocabulary used as an instance annotation to describe properties omitted from the payload:\r\n{code:xml}\r\n<Term Name=\"Omitted\" Type=\"Edm.String\">\r\n    <Annotation Term=\"Core.Description\" String=\"The annotated property in a request or response payload was omitted for the specified reason.\" />\r\n</Term>\r\n{code}\n\nImported from [ODATA-1614](https://issues.oasis-open.org/browse/ODATA-1614)",
    "labels": [
      "V4.02"
    ],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "4.3.2.3 Delete during a Period: add example",
    "body": "null\n\n### Proposal\n\nAdd example with timeslices before and after, similar to the examples for Update during a period.\r\n\r\nDeletion produces a gap in the time series.\n\nImported from [ODATA-1615](https://issues.oasis-open.org/browse/ODATA-1615)",
    "labels": [
      "Temporal",
      "V4.0_CS02"
    ],
    "assignees": []
  },
  {
    "title": "Clarify rules around results returned from Create/Update",
    "body": "In ODATA-1609 we defined that a create or update request with query parameters would return success if the resource was created or updated, even if a response could not be generated.\r\n\r\nClients can specify that they desire a response through a Prefer header (return=representation).\r\n\r\nIn 4.01 we added the ability for the client to specify select and expand query options for a create/update request, and suggested that presence of the select or expand would imply the user's intent to return results.  However, with OData-1609 we are left with a situation in which the select and expand is ignored and yet we return a success code, meaning that adding select and expand indicates, at most, a preference, rather than a requirement to return results.\r\n\r\nIn 4.02 we should clarify that clients should couple the addition of a $select/$expand to a create/update statement with a return=representation preference if they want a result returned. Services then return a preference-applied header specifying return=representation if a response can be returned, or return=minimal if no response is returned. Note that it is always valid for the service to return a result even if the create/update is not specified, so any services that return results without the presence of a return=representation are not out of compliance, but clients should specify the preference as well as any select or expand in order to get results.\r\n\r\nAlternatively, we could say that the presence of a $select/$expand implicitly sets the preference for return=representation, and the service should behave as if a return=representation preference had been explicitly specified, including returning a preference-applied (unless a return preference had been explicitly specified, in which case it should take precedence – i.e., if the client specifies $select/$expand and return=minimal, then service should omit a response body).\n\n### Proposal\n\nClarify that clients wanting a result returned from a create or update SHOULD specify a {{return=representation}} preference and MAY *additionally* specify {{$select}} and/or {{$expand}} to specify how results are returned. Services SHOULD return a {{preference-applied}} header specifying {{return=representation}} if a response is returned, or {{return=minimal}} if the create/update succeeds and no response is returned, for example, because the service doesn't support returning results from create/update, the requested query options could not be honored, or due to a service issue between create/update and selecting the results.\n\nImported from [ODATA-1616](https://issues.oasis-open.org/browse/ODATA-1616)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Clarify annotations on unavailable properties",
    "body": "[OData-Protocol, section 11.2.2|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestingIndividualEntities] states\r\nbq. Properties that are not available, for example due to permissions, are not returned. _In this case_, the Core.Permissions annotation, defined in OData-VocCore MUST be returned for the property with a value of None.\r\n\r\n_In this case_ refers to the case of missing permissions. Properties that are unavailable for some _other_ reason must also have their omission explained by an annotation, lest the client wrongly assumes null or default values for them.\n\n### Proposal\n\nMandate instance annotations for unavailable properties in all cases where the {{omit-values}} preference is applied.\n\nImported from [ODATA-1621](https://issues.oasis-open.org/browse/ODATA-1621)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "HeikoTheissen"
    ]
  },
  {
    "title": "Support alternate keys in delta patch",
    "body": "In 4.01 we introduced a delta patch mechanism that uses the delta payload to update a collection of entities.\r\n\r\nWithin the 4.01 delta payload, we support identifying an existing resource (for update or delete) by *either* the id, or the key properties.\r\n\r\nSince alternate key properties can also be used to identify a resource, in 4.02 we should allow the use of alternate keys to identify an existing resource in a delta update payload for update or delete.\n\n### Proposal\n\nAllow use of alternate keys to identify an existing resource in a delta update payload for update or delete.\n\nImported from [ODATA-1623](https://issues.oasis-open.org/browse/ODATA-1623)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Make conformance clauses more future-proof",
    "body": "The current [Conformance clauses|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_Conformance] require services to fail with {{501 Not Implemented}} for unsupported functionality.\r\n\r\nThis is problematic when adding new functionality in later specification versions that is unknown to services conforming with earlier specification versions: do they become non-conforming by responding with {{400 Bad Request}} to the new functionality?\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-specs/pull/225\n\nImported from [ODATA-1624](https://issues.oasis-open.org/browse/ODATA-1624)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "Cannot specify null as DefaultValue in CSDL XML",
    "body": "To be able to omit a nullable property, it must be given a DefaultValue of null, because the client SHOULD NOT assume a DefaultValue otherwise ([https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_DefaultValue]).\r\n\r\nIn CSDL JSON, this can be expressed as\r\n{code:json}\r\n{\"PropertyName\": {\"$Nullable\": true, \"$DefaultValue\": null}}\r\n{code}\r\nBut in CSDL XML, it cannot be expressed:\r\n{code:xml}\r\n<Property Name=\"PropertyName\" Type=\"Edm.String\" Nullable=\"true\"\r\n  DefaultValue=\"null\" />\r\n{code}\r\nwould mean the string \"null\" as DefaultValue.\r\n\r\n*Questions:*\r\n * Can the _server_ assume a DefaultValue if none is specified?\r\n * [OData-Protocol, section 8.2.8.6|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_Preferenceomitvalues] instructs the client to interpret a missing property without DefaultValue as having null value. Does the \"SHOULD NOT\" rule above apply only to the case without {{omit-values}} preference?\n\nImported from [ODATA-1625](https://issues.oasis-open.org/browse/ODATA-1625)",
    "labels": [
      "CSDL XML",
      "V4.02"
    ],
    "assignees": []
  },
  {
    "title": "Should support annotations to bound actions/functions via path",
    "body": "For capability annotations in particular, we have moved towards path-based external targeting in order to differentiate capabilities based on how the element is accessed.\r\n\r\nThese type of path-based annotation targets start with the entity container, started by an entity set, singleton, action import or function import, and then on from there, using the following rule:\r\n\r\n·         [qualified name|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_QualifiedName] of an entity container followed by a segment containing a singleton or entity set name and zero or more property, navigation property, or type-cast segments\r\n\r\nHowever, this rule doesn't include target paths that contain bound actions/functions.\n\n### Proposal\n\nAdd bound actions and bound functions to the list of things allowed within a target path for annotations.\r\n\r\nParameters can be used to differentiate overloads, including differentiating targets that identify operations bound to a collection versus members of a collection of a particular type.\r\n\r\nhttps://github.com/oasis-tcs/odata-specs/pull/233\n\nImported from [ODATA-1626](https://issues.oasis-open.org/browse/ODATA-1626)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "HeikoTheissen"
    ]
  },
  {
    "title": "clarify usage of Capabilities.IndexableByKey  Vs  Capabilities.ReadRestrictions.ReadByKeyRestriction.Readable",
    "body": "null\n\nImported from [ODATA-1627](https://issues.oasis-open.org/browse/ODATA-1627)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Resharpen definitions of PropertyPath and NavigationPropertyPath",
    "body": "V4.01 rephrased the definitions of {{PropertyPath}} and {{NavigationPropertyPath}} _and_ added absolute paths, which in combination leads to the strange effect that these two kinds of path expressions can now reference term definitions.\r\n\r\nThis is certainly surprising and afaik unintended.\n\n### Proposal\n\nRevert back to the sharper definition from V4.0 Errata 03.\n\nImported from [ODATA-1630](https://issues.oasis-open.org/browse/ODATA-1630)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [
      "ralfhandl"
    ]
  },
  {
    "title": "In should support empty literal arrays",
    "body": "[ABNF] defines the inexpr as:\r\n\r\ninExpr = RWS \"in\" RWS ( listExpr / commonExpr )\r\n\r\nwhere listExpr is defined as:\r\n\r\nlistExpr  = OPEN BWS primitiveLiteral BWS *( COMMA BWS primitiveLiteral BWS ) CLOSE\r\n\r\nmeaning, the list must have at least one primitive literal.\r\n\r\nClient code generating the expression may well write the open paren, loop through the elements of the array writing each into the expression, then write a close paren.  If the array is empty, this will result in an empty listExpr.\r\n\r\nAny reason not to allow an empty listExpr and force the client code above to handle this as a special case?\n\n### Proposal\n\nUpdate listExpr in ABNF:\r\n\r\nlistExpr  = OPEN BWS [primitiveLiteral BWS *( COMMA BWS primitiveLiteral BWS )] CLOSE\r\n\r\nCall out that this evaluates to false.\r\nBe clear that this was added in 4.02.\n\nImported from [ODATA-1633](https://issues.oasis-open.org/browse/ODATA-1633)",
    "labels": [
      "V4.02"
    ],
    "assignees": [
      "mikepizzo"
    ],
    "repo": "odata-abnf"
  },
  {
    "title": "Case-insensitive contains, startswith and endswith",
    "body": "Analogous to ODATA-1618, functions {{contains}}, {{startswith}} and {{endswith}} shall support an additional parameter for case-insensitive comparisons (like the \"i\" flag for {{matchespattern}}).\n\nImported from [ODATA-1635](https://issues.oasis-open.org/browse/ODATA-1635)",
    "labels": [
      "URL Conventions"
    ],
    "assignees": []
  },
  {
    "title": "Clarify creation of a singleton media entity",
    "body": "11.4.7.1 Create a Media Entity in [Protocol] describes how to create a media entity within a collection. It doesn't mention how to create a singleton contained media entity.\r\n\r\n11.4.7.2 Update a Media Entity Stream says that, to update, you would submit a request to the media edit link (the editlink of the entity suffixed with /$value).\r\n\r\nPresumably, creation of a singleton contained media entity would be done by calling PUT to the media entity link, which should return 201 created and a location header, and may set other properties of the entity, but this is not called out.\r\n\r\n11.4.4 Upsert an Entity calls out that it's not possible to upsert a media entity, which is correct but misleading.  PUT to the media edit link replaces the media. As above, if the entity doesn't already exist it will be created with the new stream value. In either case, additional properties of the entity may be set.\n\n### Proposal\n\nClarify, in section 11.4.7.1, that a singleton contained media entity is created by calling PUT to the media entity link. If the singleton was null, this should return 201 created and a location header, and may set other properties of the entity.\r\n\r\nIn 11.4.4 Upsert an Entity, clarify that, while it's not possible to upsert a media entity through a PATCH to the entity url, a PUT to the media edit link replaces the media and, if the entity doesn't already exist, results in the creation of the entity with the new stream value. In either case, additional properties of the media entity may be set when setting the stream value.\n\nImported from [ODATA-1638](https://issues.oasis-open.org/browse/ODATA-1638)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [
      "mikepizzo"
    ]
  },
  {
    "title": "Distinguish expandability for a collection vs expandability for an item within a collection",
    "body": "Gareth Jones opened [https://github.com/oasis-tcs/odata/issues/12:]\r\n\r\nIt's very useful to be able to distinguish capabilities of a single entity in a collection vs the capabilities of a collection.\r\n\r\nThis is embodied in ReadRestrictions vs ReadByKeyRestrictions for support for GET foos vs GET foos/\\{fooId}\r\n\r\nIn practice we've found that implementing $expand on a single entity is frequently cost-effective, whereas implementing it across a whole collection is not. Consequently we'd like to be able to qualify ExpandRestrictions with something akin to an ExpandByKeyRestrictions.\r\n\r\nA cheap and cheerful variant of this would be a boolean control flag in ExpandRestrictions, but it misses the possibility that the expandable set of nav properties varies between single/collection.\r\n\r\nFor clarity, we need a vocabulary annotation that allows us to express\r\n # NOT Supported: {{GET /foos?$expand=bars}}\r\n # Supported: {{GET /foos/\\{fooId}?$expand=bars}}\r\n\r\nAnother issue of ExpandRestrictions is ODATA-1502.\n\nImported from [ODATA-1639](https://issues.oasis-open.org/browse/ODATA-1639)",
    "labels": [],
    "assignees": [],
    "repo": "odata-vocabularies"
  },
  {
    "title": "Access a property of the result of a non-composable function",
    "body": "Must a function be composable to allow access to individual properties of its returned value?\r\n{code:java}\r\nGET BillingDocument('90000090')/self.GetPDF()/BillingDocOutputDataBinary\r\n{code}\r\nThe [CSDL specification|https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html#sec_ComposableFunction] says\r\n{quote}A composable function can be invoked with additional path segments or key predicates appended to the resource path that identifies the composable function, and with system query options as appropriate for the type returned by the composable function.\r\n{quote}\r\nand {{BillingDocOutputDataBinary}} is an \"additional path segment\".\r\n\r\nThe [Protocol specification|https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_InvokingaFunction] seems to allow system query options without composability\r\n{quote}\r\nIf the function is composable, additional path segments may be appended to the URL that identifies the composable function (or function import) as appropriate for the type returned by the function (or function import). The last path segment determines the system query options and HTTP verbs that can be used with this this URL\r\n{quote}\r\n\r\nAssuming that {{BillingDocOutputDataBinary}} is a stream property,\r\n{code:java}\r\nGET BillingDocument('90000090')/self.GetPDF()?$expand=BillingDocOutputDataBinary\r\n{code}\r\nis allowed without composability, and it requires the server to retrieve the same data (just serialize it differently).\r\n\r\n Related to ODATA-1644\n\nImported from [ODATA-1640](https://issues.oasis-open.org/browse/ODATA-1640)",
    "labels": [
      "CSDL JSON ",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": []
  },
  {
    "title": "More rigorous definition of $<request identifier> references",
    "body": "Sections [11.7.4|https://oasis-tcs.github.io/odata-specs/odata-protocol/odata-protocol.html#ReferencingReturnedEntities] and [11.7.6|https://oasis-tcs.github.io/odata-specs/odata-protocol/odata-protocol.html#ReferencingValuesfromResponseBodies] of OData-Protocol introduce \"references\" of the form {{$<request identifier>}} but do not rigorously explain how these are to be evaluated.\r\n\r\nThese references should be defined in analogy with the {{$root}} URL segment (in section 11.7.4) or {{$this}} references (in section 11.7.6). They should also appear in the ABNF.\n\nImported from [ODATA-1641](https://issues.oasis-open.org/browse/ODATA-1641)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [],
    "repo": "odata-abnf"
  },
  {
    "title": "Clarify key values in upsert along navigation properties",
    "body": "Current text in [https://oasis-tcs.github.io/odata-specs/odata-protocol/odata-protocol.html#UpsertanEntity] says\r\n{quote}Key and other non-updatable properties, as well as dependent properties that are not tied to key properties of the principal entity, MUST be ignored by the service in processing the Upsert request.\r\n{quote}\r\nIn the allowed case of single-valued non-containment navigation with navigation property binding the key property values cannot be ignored as they cannot always be derived from key values provided in the URL.\r\n\r\n \n\n### Proposal\n\nFor key properties whose value is provided in the request URL any values provided in the request body must be ignored.\n\nImported from [ODATA-1642](https://issues.oasis-open.org/browse/ODATA-1642)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": []
  },
  {
    "title": "Clarify whether query options can be applied to the result of an action invocation.",
    "body": "Originally, actions were intended to map to sql stored procedures and functions to user defined functions.  Sql stored procedures are (possibly) side-effecting and not guaranteed to be idempotent, so are not safe for a query processor to compose with other query operators. As such, stored procedures don't support composition, filtering, ordering, etc., where user defined functions do.\r\n\r\nSo, functions have an `IsComposable` attribute to specify whether they can be followed in a resource path with additional segments *and query options*, where actions do not have such an attribute and are defined not to be composable (though we never actually define composable, and whether it only applies to composition in the resource path or whether it precludes things like $orderby/$filter).\r\n\r\nOData quickly grew beyond the databases, and we relaxed many of the implication constraints imposed by underlying storage systems such as sql. \r\n\r\nThere is nothing in the text or ABNF to explicitly preclude the use of query options, including $filter and $orderby, from being applied to the results of an action. I think that was intentional, but I don't see it explicitly called out anywhere.\r\n\r\nThe ABNF *does* preclude appending any segment to a bound action invocation, including the use of /$query for action invocations, but doesn't seem to preclude query options such as ?$filter.\r\n\r\nIn ODATA-569, we decided to explicitly allow appending a cast segment to the result of an action, which is performing a special type of filtering operation, further suggesting that such post processing should be supported for actions. However, that doesn't seem to be reflected in the ABNF.\r\n\r\nFurther, we do not preclude nextLinks from the results of actions, nor warn that following a nextlink should not cause a side-affecting action to be re-invoked, especially if it is not idempotent (though that could be implied by the use of GET).\r\n\r\nSo, while it's clear that actions don't support appending certain segments (i.e., you can't navigate to related entities) it is suggested that some segments (like cast segments) were intended to be supported, and very murky what query options should be supported.\n\n### Proposal\n\nClarify that query options, such as filter, orderby, *may* be supported.\r\n\r\nBe clear that following nextLinks should *NOT* cause side-affects.\r\n\r\nWarn that $top/$skip, if supported, should not be used to invoke client paging through the results of an action that may be side-affecting.\n\nImported from [ODATA-1644](https://issues.oasis-open.org/browse/ODATA-1644)",
    "labels": [
      "Protocol",
      "URL Conventions"
    ],
    "assignees": [],
    "repo": "odata-abnf"
  },
  {
    "title": "Find reliable references for Geo WKT and SRID",
    "body": "http://www.epsg.org/ apparently no longer exists, we need better references for SRID and Wel-Known Text (WKT).\r\n\r\nCandidates:\r\n* https://epsg.io/\r\n* ISO 19111 from 2019\n\nImported from [ODATA-1645](https://issues.oasis-open.org/browse/ODATA-1645)",
    "labels": [
      "CSDL XML",
      "URL Conventions",
      "V4.02"
    ],
    "assignees": []
  }
]