[
  {
    "title": "Part1, examples 36-40: replace \"associated\" with \"related\"",
    "body": "We intentionally removed the Association and AssociationSet elements but use the word \"associated\" in the non-normative descriptions of examples 36-40. This already led to confusion for readers familiar with OData v2/v3.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-591](https://issues.oasis-open.org/browse/ODATA-591)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Leading zeroes in values for $level",
    "body": "$levels takes a positive integer or the literal max as its value. \n\nThe current ABNF allows leading zeroes for the numeric values of $levels, e.g. $levels=000004\n\nlevels = '$levels' EQ ( 1*DIGIT / 'max' )\n\n### Proposal\n\nRestrict the ABNF to discourage leading zeroes:\n\nlevels = '$levels' EQ ( oneToNine *DIGIT / 'max' )\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-590\n\nImported from [ODATA-590](https://issues.oasis-open.org/browse/ODATA-590)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add a JSON version of the Metadata document",
    "body": "Add a JSON version of the CSDL and metadata document.  This seems like a natural feature to support since all other responses (including the metadata service responses) can be formatted using JSON.\n\n### Proposal\n\nStart a standards track document \"OData JSON Format for Common Schema Definition Language (CSDL) Version 4.0\"\n\nImported from [ODATA-589](https://issues.oasis-open.org/browse/ODATA-589)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Typo in example 10: query uses MaxAmount, response uses MinAmount",
    "body": "\n\n### Proposal\n\nUse MaxAmount also in response\n\nImported from [ODATA-588](https://issues.oasis-open.org/browse/ODATA-588)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for complex value that is an empty object",
    "body": "In some cases a complex value can be an empty object, e.g. if a complex type only contains navigation properties, or only its navigation properties are specified in $select, and the response format is minimal JSON:\n\n- 7.2: A complex value is represented as a single JSON object containing one name/value pair for each property that makes up the complex type. \n- 8.1: The navigation link for a navigation property is only represented if the client requests odata.metadata=full or the navigation link cannot be computed[...]\n\nSo it clearly is a JSON object with zero name-value pairs (one for each property = zero, one for each non-computable navigation = zero), but it is somewhat hard to deduce this from the specification text. An explicit statement and/or example would help.\n\nAnother example is an open complex type that for this instance doesn't have any properties.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-587\n\nImported from [ODATA-587](https://issues.oasis-open.org/browse/ODATA-587)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow 405 Method Not Allowed when attempting to delete a non-nullable value",
    "body": "According to 11.4.9.2 in [Core], A DELETE request to a non-nullable value MUST fail and the service respond with 400 Bad Request.\n\nAn equally good response code would be 405 Method Not Allowed.\n\n### Proposal\n\nDefine 405 Method Not Allowed as an alternative to 400 Bad Request for attempting to delete a non-nullable resource.\n\nImported from [ODATA-586](https://issues.oasis-open.org/browse/ODATA-586)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Status response message as carrier for annotations as alternative to 204 No Content",
    "body": "There are some situations where OData 4.0 requires a response with 204 No Content:\n  1. GET a raw primitive value using the /$value path suffix and the value is null\n  2. GET a nullable property or navigation property and the value is null\n  3. DELETE a nullable property or relationship to set it to null\n  4. GET a function result that is primitive or structured and is null \n  5. POST an action call and the primitive or structured result is null, or the action has no result\n\nThis does not allow to add explanatory annotations to the logically empty result.\n\n\n\n### Proposal\n\nDefine a \"status\" response as a carrier for explanations that can be used with status 200 OK in all situtations that currently require 204 No Content.\n\nOptions:\n  1. Define a minimal structure similar to the error response to contain a machine-readable code and a human-readable message\n  2. Define just a new context URL (e.g. #odata.status or #Edm.Status) without required structure\n\nImported from [ODATA-585](https://issues.oasis-open.org/browse/ODATA-585)",
    "labels": [
      "Protocol",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Change the name of the \"AllPropertiesSupported\" property of the \"ApplySupported\" term to something more meaningful",
    "body": "We had long debates on how to handle the case where a service supported grouping and aggregation on all properties versus having to annotate each property as groupable and/or annotatable.\n\nWe initially said that the service would annotate each property as being groupable and/or aggregatable, and the absence of any such annotation, in the presence of an ApplySupported, meant that there were no restrictions on which property could be used in groupby or and aggregate clause. The problem with this was it required looking at all properties to see if any were annotated in order to determine if absence of an annotation on a single property implied it was not groupable/aggregatable, or that there were no such restrictions.\n\nSo we added a single property to the ApplySupported aggregation term that a client could check to see if there were any such restrictions. We called this property \"AllPropertiesSupported\", which is really not very intuitive or meaningful.\n\nThere are a couple of options for improving this:\n\n1) We could have two properties, \"AllPropertiesGroupable\" and \"AllPropertiesAggregatable\", which would allow us to separately specify whether there are restrictions on grouping versus aggregation.\n2) If we don't think there is an interesting scenario for a service having different rules for all properties being groupable versus all properties being aggregatable, we could name the property something like \"PropertyRestrictions\" which would be true if you can't group/aggregate individual properties, and defaults to false meaning there are no restrictions around properties. This is also kinda nice in that it can have a default value of true, so you can use it as a tag for the case where restrictions exist, or just omit it if restrictions don't exist).\n\n### Proposal\n\nRename \"AllPropertiesSupported\" to \"PropertyRestrictions\" with a default value of false.\n\nImported from [ODATA-584](https://issues.oasis-open.org/browse/ODATA-584)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify intentions around implied ordering of input set to aggregation transformations",
    "body": "The current specification, in several places, refers to the ordering of the input set, and defines rules around preservation of that ordering.\n\nIn most cases the input set is not ordered, and preserving the arbitrary order is meaningless and potentially onerous as it may require extra ordering of intermediate results.\n\nThis wording is used in operations like topcount which returns the top n values after applying an aggregate (i.e., count) to a field. This preservation of ordering was taken from $top and $skip in [Core], which requires a stable ordering of the results so that, if I do $top=10&$skip=0, followed by $top=10&$skip=10, and both the 10th and 11th orders have the same values for the properties specified in the orderby, I am guaranteed that I consistently get the same values for the 10th versus 11th record.\n\nThis same scenario isn't required for methods like topcount, however it may still be desireable to get consistent results when applying methods like topcount to entities that have the same aggregate value. However, rather than imposing a preservation of the order, we can follow the model of $top and $skip by simply saying that the service must guarantee a stable ordering across requests (for example, by adding the key fields to the ordering before applying the top) and not tie the ordering to the order of the input set.\n\n### Proposal\n\nChange the requirement for the top* and bottom* transformation from preserving ordering of an input set to ensuring a stable ordering of the result.\n\nImported from [ODATA-583](https://issues.oasis-open.org/browse/ODATA-583)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify custom aggregate term",
    "body": "In the current draft we have introduced an annotation term for defining a custom aggregate that can be applied to either an entity type or an entity container.  The term's type is a complex type with a single property named \"Type\" which is the type returned by the custom aggregate.\n\nBecause the type of the term is a complex type, rather than a simple type, application of the term requires a record constructor as in:\n\n<Annotation Term=\"Aggregation.CustomAggregate\" Qualifier=\"Forecast\">\n  <Record>\n    <PropertyValue Property=\"Type\" String=\"Edm.Decimal\"/>\n  </Record>\n</Annotation>\n\nHowever, since we have only one property defined for the term we can make the term be of that type (string), rather than a complex type having a single property of that type. This would allow a much more concise application as:\n\n<Annotation Term=\"Aggregation.CustomAggregate\" Qualifier=\"Forecast\" String=\"Edm.Decimal\"/>\n\nThe drawbacks to this approach are:\n1) It would be harder to add additional properties to a custom aggregate in the future. However, the most common properties to want to add would be facets, and we could use a TypeDefinition for that. For other extensions, we could use the common metadata extension mechanism of annotating the annotation.\n2) It is slightly less intuitive what the single property represents. In the old format, you had the name of the property (\"Type\") to give you a hint what the string represented. In the new syntax you have to know that the string property that is the value of the custom aggregate is the type. We could rename the term something that would indicate that the string property represented the type of the custom aggregate (i.e., \"CustomAggregateType\"), but that would probably be even more confusing as the term really does define the aggregate (whose name is specified through the qualifier attribute) and not just the type of something being annotated.\n\nStill, the simplicity of expression seems to outweigh either of these drawbacks.\n\n\n\n### Proposal\n\nChange the type of the CustomAggregate term to be an Edm.String which is the name of the type of the custom aggregate.\n\nImported from [ODATA-582](https://issues.oasis-open.org/browse/ODATA-582)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove parameterless aggregate() transformation",
    "body": "the groupiby transformation splits the input set into subsets based on the specified grouping properties, applies the specified transformation to each set, and then combines them into a single result.\n\nIn some cases it is useful to do grouping without any transformation of the intermediate subsets in order to get the unique combination of values across the grouping properties. In CSD01 we allowed specification of the aggregate transformation with no parameters as a way to say \"apply grouping without any aggregate\".  so Customers?$apply=groupby((Name),aggregate()) would return the distinct customer names without applying an aggregate.\n\nLater, we added an overload of the groupby method that took only the grouping properties, not the parameterless aggregate method, and said that the two were equivalent.  So the same request could be (more simply and intuitively) Customers?$apply=groupby((Name)).\n\nHowever, we didn't get rid of the old syntax, we just defined the new syntax as a shortcut for passing the paramterless aggregate as a second argument. Which means we have two ways of doing the same thing, one short and intuitive, and one through what looks like a bit of a hack.\n\nWe have no other reason to keep the parameterless aggregate, so we should go back to requiring that aggregate have one or more parameters.\n\n### Proposal\n\nremove the parameterless overload for the aggregate transformation.\n\nImported from [ODATA-581](https://issues.oasis-open.org/browse/ODATA-581)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "8.2.4 If-Match should refer to term Core.OptimisticConcurrency",
    "body": "When shortening the name of the Core term OptimisticConcurrencyControl to OptimisticConcurrency we forgot to update section 8.2.4.\n\n### Proposal\n\nRefer to the new shorter term name Core.OptimisticConcurrency\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-580](https://issues.oasis-open.org/browse/ODATA-580)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Contains example has order of arguments backwards",
    "body": "I can't believe we got this wrong again...\n\nThe example for \"contains\" in [Core] section 11.2.5.1.2, Built-In Query Functions has the order of arguments incorrect.\n\nIt *SHOULD* read:\n\ncontains(CompanyName,'Alfreds')\n\nThis is correct in URL Conventions.\n\n### Proposal\n\nChange the example for \"contains\" in section 11.2.5.1.2 to:\ncontains(CompanyName,'Alfreds')\n\nSince this is a change to an example it is a non-normative change.\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-578](https://issues.oasis-open.org/browse/ODATA-578)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Do we need a way to distinguish between properties that are omitted due to being aggregated away versus those that don't apply (i.e., in a concatenated result)?",
    "body": "There appear to be (at least) two ways a property may be omitted from an aggregated result:\n1) The property may be omitted because it has been aggregated away (i.e., in a rollup)\n2) The property may be omitted because an operator has been applied (i.e., concat) that leaves certain properties undefined for certain rows\n\nDo we need a property annotation for either (or both) so that clients can distinguish between properties being omitted because they were aggregated away versus because they didn't apply?\n\n### Proposal\n\n@odata.context allows to identify and distinguish all cases: aggregation result, rollup entities, concat result.\n\n- The @odata.context describes the properties from the input set that remain in the result after aggregation. Any property of the input/expanded sets not listed here has been aggregated away.\n\n- In rollup entities, one or more of those properties are omitted. Comparing an instance with the surrounding @odata.context, the absence of a property in an instance classifies this entity as rollup entities, because there is no other way how a property could get lost.\n\n- Concat combines two aggregated results with potentially different structures as a single result collection. This inhomogeneous structure cannot be described with a single context URL at the level of the collection. If the two partial results deviate structurally, the current JSON spec requires a provider to apply @odata.context at entity instance level for every entity. This is not efficient if done for a large set of such instances, but we do not see any other option with the current capabilities of @odata.context. On the other hand, every part of the result structure is clearly defined, so there's need to further distinguish the cases mentioned in the issue.\n\nClose without action\n\nAccepted: https://www.oasis-open.org/committees/download.php/51905/odata-meeting-64_on-20140109-minutes.html#odata-577\n\nImported from [ODATA-577](https://issues.oasis-open.org/browse/ODATA-577)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Aggregation: Can we find a better way to represent nested expands?",
    "body": "The current aggregation specification use the old path syntax for nested expands. This is inconsistent with the new way to represent expands in core. Can we figure out a syntax for nested expands in aggregation that is consistent with core?\n\n### Proposal\n\nThe mandatory first parameter for the expand path can be followed by either a filter() or an expand() transformation, after wich an arbitrary number of expand() expressions can optionally be passed:\n\n    GET ~/Categories?$apply=expand(Products,filter(startswith(Name,'Ski'),expand(Sales,filter(Amount gt 1000)))\n\n    GET ~/Categories?$apply=expand(Products,expand(Sales))\n\nThis is very close to the new V4 $expand syntax: \n\n    GET ~/Categories?$expand=Products($filter=startswith(Name,'Ski'),$expand=Sales($filter=Amount gt 1000))\n\nand \n\n    GET ~/Categories?$expand=Products($expand=Sales)\n\nAccepted: https://www.oasis-open.org/committees/download.php/51906/odata-meeting-64_on-20140109-minutes.html#odata-576\n\nImported from [ODATA-576](https://issues.oasis-open.org/browse/ODATA-576)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rationalize vocabulary and other editorial changes",
    "body": "Refactor vocabulary and apply other editorial corrections.\n\n### Proposal\n\n1. Remove the rollup instance annotation\n2. Reconsider allowing multiple multi-valued path segments in expand transformation\n3. Add property to ApplySupported to make explicit that not all properties are groupable and aggregatable.\n\nBased on https://www.oasis-open.org/committees/download.php/51818/odata-data-aggregation-ext-v4.0-wd02-2013-12-19.2.docx\n\nAccepted: https://www.oasis-open.org/committees/download.php/51823/odata-meeting-63_on-20131219-minutes.html#odata-575\n\nImported from [ODATA-575](https://issues.oasis-open.org/browse/ODATA-575)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rationalize Aggregatable Properties, Dynamic Aggregates, and floating aggregates",
    "body": "In the CSD01 specification we sometimes treat properties as aggregates by applying a \"default aggregation method\". This was confusing to folks who didn't expect this special aggregation behavior to automatically apply to properties. other times the user can apply an aggregation method to a property or expression. In some cases an alias was required, in others it was not, and the type could be dependent on whether or not an alias was used. \n\nThe addition of floating aggregates added yet a new way to apply define aggregates, leaving services multiple ways to do the same thing and clients either having to support all different combinations or pick a subset of combinations and not be interoperable. \n\nAlso, we could use this opportunity to refactor the annotations so they are not nested under one huge annotation but are more naturally specified in the context which they apply.\n\n### Proposal\n\nDefine two types of aggregates; \n-aggregation methods (standard and custom), which may be applied to aggregatable properties or expressions\n-custom aggregates which may be associated with an entity type or entity container. \n\nThe use of aggregate methods always requires an alias.\nWe achieve the previous simplification of \"default aggregation\" for a property by allowing a custom aggregate to be defined with the same name as a property with the same type. \n\n\n\nImported from [ODATA-574](https://issues.oasis-open.org/browse/ODATA-574)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that eq, ne can be used with complex type",
    "body": "In [ODATA-400](https://issues.oasis-open.org/browse/ODATA-400) we decided to allow JSON arrays and objects as common expressions, and the example uses the eq operators to compare an entity with a JSON-represented entity reference. The ABNF supports this, and it would be useful to use objects and arrays for eq, ne comparisons, but [URL Conventions] appears to have leftover wording that prohibits the use of collection, entity, or complex types in any logical operators.\n\n5.1.1.1Logical Operators\nOData defines a set of logical operators that evaluate to true or false (i.e. a boolCommonExpr as defined in [OData-ABNF]). Logical operators are typically used to filter a collection of resources.\nOperands of collection, entity, and complex types are not supported in logical operators.\nThe syntax rules for the logical operators are defined in [OData-ABNF].\nThe six comparison operators can be used with all primitive values except Edm.Binary, Edm.Stream, and the Edm.Geo types.\n\nThis prevents expression of a request such as:\n\n  ~odata.svc/Suppliers?$filter=Address ne {\"Street\": \"NE 40th\", \"City\": \"Redmond\", \"State\": \"WA\", \"ZipCode\": \"98052\", \"Country\": \"USA\"}\n\nrequiring instead:\n ~odata.svc/Suppliers?$filter=Address.Street ne \"NE 40th\" or Address.City ne \"Redmond\" or Address.State ne \"WA\" or  Address.ZipCode ne \"98052\" or Address. Country ne \"USA\"\n\nServices that follow the ABNF and other examples may already support this in 4.0, and would be compliant in doing so, but we should remove the offending statement in 4.1.\n\n### Proposal\n\nClarify that eq, ne are supported in $filter with json respresentations of collection, entity, and complex types.\n\nImported from [ODATA-572](https://issues.oasis-open.org/browse/ODATA-572)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add annotation for properties that are (not) part of the default selection if no $select is specified",
    "body": "Part 1, section 11.2.4.1 allows services to return a subset of all properties if no $select option is specified.\n\nIt would be helpful if this default selection could be deduced from $metadata without actually querying the entity set or collection.\n\n### Proposal\n\nAdd Core term \n\n<Term Name=\"DefaultSelection\" Type=\"Collection(Edm.PropertyPath)\" AppliesTo=\"EntitySet\" />\n\nImported from [ODATA-571](https://issues.oasis-open.org/browse/ODATA-571)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify behavior of edm:UrlRef expression",
    "body": "We have (implicitly) stated, that the value of the edm:UrlRef is a URL. But we haven't clarified how to deal with relative URL's. We have to distinct different environments, in which the edm:UrlRef expression could be used: (A) Instance Annotations, (B) Metadata Document (C) separate CSDL Annotation Document\n\n### Proposal\n\n(A): Follow the format specific rules for relative URLs\n(B) and (C): Relative URLs follow the rules for XML. First using xml:base, then the location of the document for relative urls.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-570\n\nImported from [ODATA-570](https://issues.oasis-open.org/browse/ODATA-570)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow type-cast segment after function/action call in path expressions",
    "body": "Functions and actions can return collections of entities or complex type instances whose types belong to an inheritance hierarchy. So it should be possible to append a type-cast path segment to filter the collection to a type sub-tree.\n\n### Proposal\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-569\n\nImported from [ODATA-569](https://issues.oasis-open.org/browse/ODATA-569)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ABNF rules for headers list percent-encoded whitespace",
    "body": "Section 8. Header values re-uses punctuation rules OWS and BWS that were intended for raw URLs and thus allow percent-encoded spaces and tabs. Within headers these are not valid.\n\n### Proposal\n\nDefine special separator rules for header values (OWS is only used in headers, and \"bad whitespace\" is only used surrounding the EQ sign):\n\nOWS   = *( SP / HTAB )  ; \"optional\" whitespace \nBWS-h = *( SP / HTAB )  ; \"bad\" whitespace in header values \nEQ-h  = BWS-h EQ BWS-h \n\nUse these in header-related rules, e.g.:\n\ncallbackPreference = \"odata.callback\" OWS \";\" OWS \"url\" EQ-h DQUOTE URI DQUOTE\n\n\nImported from [ODATA-568](https://issues.oasis-open.org/browse/ODATA-568)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rule hour does not allow 22",
    "body": "The hour rule is incomplete and does not allow the value 22\n\nhour   = ( \"0\" / \"1\" ) DIGIT\n       / \"2\" ( \"1\" / \"2\" / \"3\" ) \n\n### Proposal\n\nhour   = ( \"0\" / \"1\" ) DIGIT\n       / \"2\" ( \"0\" / \"1\" / \"2\" / \"3\" ) \n\nImported from [ODATA-567](https://issues.oasis-open.org/browse/ODATA-567)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "6.2.4 Attribute Scale: clarify allowed range of Scale values",
    "body": "The current text says\n\n    A decimal property MAY define a non-negative integer value or variable for the Scale attribute. \n    This attribute specifies the maximum number of digits allowed to the right of the decimal point. \n    The value variable means that the number of digits to the right of the decimal point may vary from zero to the value of the Precision attribute.\n    The value of the Scale attribute MUST be less than or equal to the value of the Precision attribute.\n\nUnfortunately this conflicts with the ABNF rule decimalValue that makes the fractional part optional but requires at least one digit in the integer part, so if Precision limits the number of digits to e.g. 10, at most 9 digits can be to the right of the decimal point.\n\nAlso the text does not make clear that a numeric Scale value implies a fixed-point number with Scale fractional digits and Precision-Scale integer digits, and that the only variability is to remove leading zeroes from the integer part and trailing zeroes from the fractional part.\n\n\n### Proposal\n\nChange text to\n\n    A decimal property MAY define a non-negative integer value or the value variable for the Scale attribute. \n    This attribute specifies the maximum number of digits allowed to the right of the decimal point. \n    The value variable means that the number of digits to the right of the decimal point may vary from zero to the value of the Precision attribute minus one (at least one digit is required to the left of the decimal point).\n    An integer value means that the number of digits to the right of the decimal point may vary from zero to the value of the Scale attribute, and the number of digits to the left of the decimal point may vary from one to the value of the Precision attribute minus the value of the Scale attribute.\n    The value of the Scale attribute MUST be less than the value of the Precision attribute.\n\nExamples:\n  <Property Name=\"Amount\" Precision=\"3\" Scale=\"2\" /> \n  allowed Values: 1.23, 0.23, 3.14, 0.7 \n  not allowed values: 123, 12.3\n\n  <Property Name=\"Amount\" Precision=\"2\" Scale=\"2\" /> \n  not allowed, because .23 is not allowed anymore and  0.23 needs precision 3\n\n  <Property Name=\"Amount\" Precision=\"3\" Scale=\"variable\" /> \n  allowed Values: 1.23, 0.23, 0.7, 123, 12.3\n  not allowed values: 12.34, 1234, 123.4\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-566\n\nImported from [ODATA-566](https://issues.oasis-open.org/browse/ODATA-566)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "2: Clarify interpretation of path segments and query option values with respect to percent-encoded punctuation",
    "body": "Chapter 2 states the parsing rules for OData URLs. Unfortunately the last of the six rules\n\n - Interpret path segments, query option names, and query option values according to OData rules\n\nis rather fluffy and leaves it to the reader to decide what the \"OData rules\" are.\n\nLater sections mainly refer to the ABNF, and the ABNF accepts percent-encoded values for most of the OData-significant delimiters in section 9. Punctuation.\n\nThis in conjunction with the fifth parsing rule\n\n - Percent-decode path segments, query option names, and query option values\n\nmay mislead implementers into double-decoding OData delimiters.\n\n### Proposal\n\nMake clear that percent-decoding happens exactly once, and that the \"OData rules\" are the ABNF rules minus the percent-encoded representation of the punctuation characters.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-565\n\nImported from [ODATA-565](https://issues.oasis-open.org/browse/ODATA-565)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.1.4.28: define \"assignable\"",
    "body": "\n\n### Proposal\n\nAssignable means:\n- structured type instances can be assigned to their type or a direct or indirect base type\n- primitive types to same primitive type\n- Byte to Int16, Int32 and Int64\n- SByte to Int16, Int32 and Int64\n- Int16 to Int32 and Int64\n- Int32 to Int64\n- Single to Double\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-564\n\nImported from [ODATA-564](https://issues.oasis-open.org/browse/ODATA-564)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.1.4.29: Allow casting strings to primitive types if the string contains the literal representation of an instance of the target type",
    "body": "We allow casting of primitive types to string using the literal representation for the source type.\n\nUnfortunately we forgot to allow the inverted operation: casting a string containing the literal representation of e.g. a Date to Edm.Date, although this was explicitly mentioned in the examples given with [ODATA-365](https://issues.oasis-open.org/browse/ODATA-365).\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-563](https://issues.oasis-open.org/browse/ODATA-563)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.1.4.29: cast function is optional for first four rules",
    "body": "The second to last sentence refers to \"the first three rules\". These three rules were described in [ODATA-365](https://issues.oasis-open.org/browse/ODATA-365).\n\nUnfortunately a new rule was inserted in position 1 without adapting the sentence, now in fact the first four rules are optional.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-562\n\nImported from [ODATA-562](https://issues.oasis-open.org/browse/ODATA-562)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "odata.type shouldn't require \"#\" for primitive types",
    "body": "In JSON we currently require primitive types to be written as fragments, i.e.:\n\n\"@odata.type\":\"#Double\"\n\nThe hash is not really required in this case, and doesn't really make sense as it is not a reference within the metadata document. Note that, in Atom, it is written without the hash, as in:\n\n<metadata:Salary metadata:type=\"Double\">50000</metadata:Salary>\n\nIn order not to make a breaking change for JSON we should continue to allow, but not require, the \"#\" for primitive types.\n\nPerhaps even add to an implementation note for 4.0 that clients should support primitive types without the \"#\".\n\n### Proposal\n\nFor 4.01 responses, the # is optional for primitive types.\n\nResponses must only be returned without the \"#\" if the request does not specify odata.maximumversion=4.0.\n\nClients must only specify payloads that omit the \"#\" to services that support 4.01.\n\nAn @odata.type annotation that does not contain a # is a primitive type.\n\n\"@type\":\"String\"\n\"@type\": \"#Sales.Customer\"\n(note: as part of default namespaces, Customer doesn't need to be qualified):\n\"@type\": \"#Customer\"\n\n\nImported from [ODATA-561](https://issues.oasis-open.org/browse/ODATA-561)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow arbitrary properties in referential constraints",
    "body": "Referential constraints are currently limited to primitive properties, potentially nested within complex properties, which requires e.g. to \"resolve\" referential constraints between complex properties or single-valued navigation properties into one <ReferentialConstraint> element per primitive property of the complex property, and key property of the related entity type.\n\nAn obvious generalization is to also allow complex properties, meaning that each member property has the same value, and as a consequence single-valued navigation properties, meaning that the dependent navigation property has the same target as the principal navigation property. This is just a short-hand notation for adding referential constraints on all leaf structural / key properties.\n\n### Proposal\n\nFor non-4.0 clients, allow path expressions resolving to complex properties and navigation properties for the Property and ReferencedProperty attributes\n\nServices must not advertise constraints terminating in a property of a complex type or a single-valued navigation prop to clients specifying OData-MaxVersion:4.0. They can instead expand the leafs. For nav props to single entities, they can expand to the key field(s).\n\nImported from [ODATA-560](https://issues.oasis-open.org/browse/ODATA-560)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that Derived types inherit HasStream property",
    "body": "Spec describes inheritance of properties, but is unclear on HasStream. HasStream (which really should have been \"IsStream\" or \"IsMedia\" defines that the property has (is) a stream and so it's implied that it is inherited, but should be clarified. \n\n### Proposal\n\nIs inherited, can be set to true once in an inheritance path (prior to the first non-abstract type) and stays true further down the path.\n\nNOTE: SEE COMMENTS\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-559\n\nImported from [ODATA-559](https://issues.oasis-open.org/browse/ODATA-559)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Non-Material changes to V4.0_CSD03",
    "body": "List all the Non-Material changes to V4.0_CSD03.\n\nImported from [ODATA-558](https://issues.oasis-open.org/browse/ODATA-558)",
    "labels": [
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow exponential notation for Edm.Decimal",
    "body": "IEEE754 also defines the DECFLOAT data type for high-precision decimal arithmetic. They have 16 or 34 decimal digit mantissas and exponents between -383 and +384 or -6143 and +6144.\n\nRepresenting them exactly in current Edm.Decimal would result in at most 34 non-zero digits and several thousand zeroes. This waste can easily be avoided by allowing exponential notation also for Edm.Decimal.\n\n### Proposal\n\nAllow exponential notation for Edm.Decimal literals.\n\nAdd new symbolic value Scale=\"floating\" for DECFLOAT values. The Precision attribute will specify the number of digits in the mantissa.\n\nServices would only allow scale=\"floating\" for 4.01 and later versions of metadata, \n\nFor 4.01 JSON payloads, exponential decimals is always assumed and format parameter is not needed or used.\n\nImported from [ODATA-557](https://issues.oasis-open.org/browse/ODATA-557)",
    "labels": [
      "ABNF",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add \"in\" operator as syntactic sugar for a chain of \"or\" expressions",
    "body": "In data analysis it is common to retrieve data that matches one of several distinct values, reflected in SQL as the IN operator.\n\nThis is syntactic sugar, so we need to balance between a convenient notation and adding value to the expression syntax that we already have.\n\n1) Using JSON collections and a new \"in\" operator:\n\n    CountryCode in [\"US\",\"CA\",\"DE\"]\n\nor in a more URL-friendly notation (as double quotes and square brackets require percent-ending)\n\n    CountryCode in ('US','CA','DE')\n\n2) Allowing arbitrary collection expressions on the left side of lambda expressions:\n\n    [\"US\",\"CA\",\"DE\"]/any(c:c eq CountryCode)\n\n3) Adding an overload to the contains function:\n\n    contains([\"US\",\"CA\",\"DE\"], CountryCode)\n\n### Proposal\n\nSupport new \"in\" operator. Right side is a comma-separated list of literal primitive values enclosed by parens or an expression that resolves to a collection of the appropriate type.\n\nImported from [ODATA-556](https://issues.oasis-open.org/browse/ODATA-556)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether or not system query options can be used more than once in a URL",
    "body": "The ABNF allows system query options to be used more than once (not nested in an $expand), but none of the documents restrict this or provide an explanation of what the behavior would be when the same system query option is used more than once in the same URL.\n\n### Proposal\n\nProposal 1: Don't allow any system query options to be used more than once\n\nProposal 2:\n- Allow multiple $select where the resultant projection is the union of all the individual $selects.\n- Allow multiple $expand where the resultant expanded relationships is the union of all the individual $expands.\n- Allow multiple $filter where the resultant query is all the individual $filters composed with AND (and combined with all $searches)\n- Allow multiple $search where the resultant query is the individual $searches composed with AND (and combined with all $filters)\n- All other system query options cannot be used multiple times\n\nProposal 3:\nContinuing from proposal 2, also allow $orderby, $top and $skip to be used more than once:\n- $top and $skip, add the numbers together\n- Allow multiple $orderby where the resultant order by is the union of all the individual $orderbys where the $orderbys that appear earlier in the URL are given higher sort priority.\n\nProposal 1 is certainly the simplest.  Proposal 2 and 3 allow a more flexible request URL but they do not add any functionality that cannot be accomplished with proposal 1.\n\nProposal 1 was accepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/51209/odata-meeting-58_on-20131024-minutes.html#odata-555\n\n\nImported from [ODATA-555](https://issues.oasis-open.org/browse/ODATA-555)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state that OData supports language negotiation with Accept-Language",
    "body": "We talked about this several times in the TC calls, but unfortunately state that nowhere in the documents. Readers with investigative skills will doubtlessly deduce it from our mentioning of Content-Language dependency of ETags and the term Core.IsLanguageDependent, but we can make it easier to spot for the average reader.\n\n### Proposal\n\nMention it in Part 1: Protocol, and ideally also in the description of Core.IsLanguageDependent\n\nAccepted: https://www.oasis-open.org/committees/download.php/51209/odata-meeting-58_on-20131024-minutes.html#odata-553\n\nImported from [ODATA-553](https://issues.oasis-open.org/browse/ODATA-553)",
    "labels": [
      "Protocol",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that the serialization of odata.count is affected by IEE754Compatible flag",
    "body": "The IEEE754Compatible flag affects serialization of all Int64 and Decimal values, and odata.count is an Int64 value. As discussed in 2013-10-17 meeting, we wanted to explicitly call this out in the description of IEEE754Compatible.\n\n### Proposal\n\nExplicitly call out in the description of IEEE754Compatible that this affects odata.count as well as other Int64 and Decimal values.\n\nImported from [ODATA-552](https://issues.oasis-open.org/browse/ODATA-552)",
    "labels": [
      "JSON Format",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify ContextUrl patterns for projected/expanded singletons",
    "body": "In Section 10, ContextURL, of [Protocol] we define the context url for a singleton, but aren't as clear as we could be that the same constructions for select/expand can be applied to singleton as for an entity (i.e., that you can append the selected and expanded properties to the singleton).\n\nThis can, perhaps, be inferred from the existing patterns but it would be much better to spell them out.\n\n### Proposal\n\nClarify that the patterns for a projected or projected expanded entity apply to singletons as well:\n\nSection 10.8, Projected Entity:\n Existing template: {context-url}#{entity-set}{/type-name}{select-list}/$entity\n Add: {context-url}#{singleton}{select-list}\n\nSection 10.10 Projected Expanded Entity\nExisting template: context-url}#{entity-set}{/type-name}{select-list}/$entity\nAdd: {context-url}#{singleton}{select-list}\n\nIn ABNF:\n/ singletonEntity *( containmentNavigation )  [ \"/\" qualifiedEntityTypeName ] [ selectList ] \n\nAccepted: https://www.oasis-open.org/committees/download.php/51073/odata-meeting-57_on-20131017-minutes.html#odata-551\n\nImported from [ODATA-551](https://issues.oasis-open.org/browse/ODATA-551)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define \"transient entity\" in Part 1: Protocol",
    "body": "We mention transient entities in the two format specifications and define how they are represented, but we don't introduce this concept in the core specifications\n\n### Proposal\n\nIntroduce concept of transient entities in section 4.1\n\nAccepted: https://www.oasis-open.org/committees/download.php/51073/odata-meeting-57_on-20131017-minutes.html#odata-550\n\nImported from [ODATA-550](https://issues.oasis-open.org/browse/ODATA-550)",
    "labels": [
      "Protocol",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify use of IEEE754Compatible format parameter",
    "body": "In [ODATA-342](https://issues.oasis-open.org/browse/ODATA-342) we introduced the IEEE754Compatible for formatting Int64 and Decimal values as string. However, we didn't clarify or show examples of how this is used.\n\nAccording to http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.7:\n\n\"Parameters MAY follow the type/subtype in the form of attribute/value pairs (as defined in section 3.6).\"\n\nWhich seems to imply that Parameters MAY (or MAY NOT) follow the type/subtype, and if they do follow they would be in the form of attribute/value pairs.\n\nWe should therefore clarify that the IEEE754Compatible format parameter with a value of TRUE means Int64 and Decimal values are serialized as string, and a value of FALSE (or omitting the parameter) means that Int64 and Decimal are serialized as numbers.\n\n### Proposal\n\nClarify that the IEEE754Compatible format parameter with a value of TRUE means Int64 and Decimal values are serialized as string, and a value of FALSE (or omitting the parameter) means that Int64 and Decimal are serialized as numbers.\n\nAccepted: https://www.oasis-open.org/committees/download.php/51073/odata-meeting-57_on-20131017-minutes.html#odata-549\n\nImported from [ODATA-549](https://issues.oasis-open.org/browse/ODATA-549)",
    "labels": [
      "JSON Format",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify pattern for future odata-version and odata-maxversion numbers",
    "body": "Even for minimal conformance we require that\n\n    [...] the service MUST generate a response with an OData-Version less than or equal to the specified OData-MaxVersion.\n\nUnfortunately we don't state what comparison logic to use, and our pattern for the maxversion is overly restrictive, allowing only 4.0.\n\n### Proposal\n\nThe pattern for protocol versions is 1*DIGIT \".\" 1*DIGIT, using number comparison logic.\n\nThis change only removes doubt and does not add or remove a feature, so it is non-material.\n\nAccepted: https://www.oasis-open.org/committees/download.php/51005/odata-meeting-56_on-20131010-minutes.html#odata-548\n\nImported from [ODATA-548](https://issues.oasis-open.org/browse/ODATA-548)",
    "labels": [
      "ABNF",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that the standard resources $id, $entity, $batch etc. win over content-id referencing",
    "body": "Content-id referencing uses the magic character $ followed by a token to refer back to a request that specifies that token in its content-id header.\n\nUsing one of the standard resource names without a $ prefix as a content-id could lead to confusion as URLs relative to the batch request URL are also relative to the service root and the relative URL for the standard resources thus starts with a $:\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\nContent-Type: application/http \nContent-Transfer-Encoding:binary\nContent-ID: batch\n\nPOST Customers HTTP/1.1\n\n<new customer body>\n\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\nContent-Type: application/http \nContent-Transfer-Encoding:binary\nContent-ID: nested-batch\n\nPOST $batch HTTP/1.1 \nContent-Type: multipart/mixed;boundary=nested_batch_77162fcd-b8da-41ac-a9f8-9357efbbd \nContent-Length: ###       \n\n--nested_batch_77162fcd-b8da-41ac-a9f8-9357efbbd \n\n<content of nested batch\n\n\n--nested_batch_77162fcd-b8da-41ac-a9f8-9357efbbd--\n\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b--\n\n\nIn this (admittedly weird) example the second POST request URL would not be interpreted as a content-id reference but literally as a request to $batch.\n\n### Proposal\n\nSee summary: standard resource cannot be \"shadowed\" by content-id referencing\n\nThis change only removes doubt and does not add or remove a feature, so it is non-material.\n\nAccepted: https://www.oasis-open.org/committees/download.php/51005/odata-meeting-56_on-20131010-minutes.html#odata-547\n\nImported from [ODATA-547](https://issues.oasis-open.org/browse/ODATA-547)",
    "labels": [
      "Protocol",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Content-Id MUST be unique within Changeset, not within batch",
    "body": "According to section 11.7.3, Changesets in [Protocol]:\n\" In addition each request within a change set MUST specify a Content-ID header with a value unique within the batch request\"\n\n\"batch request\" in this sentence is actually an editorial mistake; each changeset is atomic, and the content-id unique within the scope of the changeset.\n\nImported from [ODATA-546](https://issues.oasis-open.org/browse/ODATA-546)",
    "labels": [
      "Protocol",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow applying Capability terms CountRestrictions, TopSupported, SkipSupported etc. to all resources returning collections",
    "body": "We allow paging on all collection-valued resources and would like to annotate all elements that define collection-valued resources.\n\n### Proposal\n\nAs we don't think we'll break clients, use \"EntitySet Collection\" in AppliesTo for these terms.\n\nImported from [ODATA-545](https://issues.oasis-open.org/browse/ODATA-545)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow annotating the ReturnType element",
    "body": "Currently the ReturnType element cannot be annotated, so we can't express that the returned string is a language-dependent text or a URL.\n\n### Proposal\n\n1. CSDL Section 14.3 : add ReturnType to list of annotatable elements\n2. edm.xsd: add ReturnType to list of annotatable elements and AppliesTo value list\n3. Core vocabulary: add ReturnType to AppliesTo value of IsLanguageDependent, IsURL, and potentially other terms targeting properties and terms\n\n\n\nImported from [ODATA-544](https://issues.oasis-open.org/browse/ODATA-544)",
    "labels": [
      "CSDL XML",
      "Vocabularies",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Nullable attribute on collection property should specify whether collection can contain null values",
    "body": "We currently state that the Nullable attribute is not allowed for collection-valued properties. Elsewhere we say that facets (such as maxlength, etc.) apply to the individual elements within a collection. It would be useful, and consistent, to say that the nullable attribute, when used on a collection-valued property, applies to elements in the collection and specifies whether the collection can contain nulls.\n\n### Proposal\n\nIn 6.2.1, Attribute Null of [CSDL], specify the following:\n\nIf the edm:Property element contains a Type attribute that specifies a collection, the property MUST always exist, but the collection MAY be empty. In this case, the Nullable attribute applies to members of the collection and specifies whether the collection can contain null values. \n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-543\n\nImported from [ODATA-543](https://issues.oasis-open.org/browse/ODATA-543)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that $selected Actions/Functions are included in [project-list] within a ContextUrl",
    "body": "The purpose of putting the project list in the context url is so that the client (i.e., a JSON parser) can differentiate between content that was omitted from a response because they weren't selected versus omitted because they weren't applicable (i.e., dynamic properties, functions and actions)\n\nWe support the project-list for properties but we don't specify whether or not it includes actions/functions that are explicitly requested by the client.\n\nIn general, the client knows that it can always try to invoke a bound action/function to an entity of the correct type, so it doesn't need to be advertised in the payload, but if a client explicitly selects a function/action then it must be included, if applicable, and the client knows that it's absence means that it is not applicable (can't be called) on the current entity.\n\nThis all works fine; we just failed to mention in [Protocol] and [ABNF] that functions/actions from the $select also appear in the project-list\n\n### Proposal\n\nClarify that functions/actions in that are explicitly $selected also appear in the [project-list] of the context url.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-542\n\nImported from [ODATA-542](https://issues.oasis-open.org/browse/ODATA-542)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow the If-Match header to reference the ETag that resulted from an earlier operation in a batch request",
    "body": "A client may want to group multiple data modification operations of a particular entity in a batch request and use ETags.  Currently, the client can use the ETag in the first data modification request but for all subsequent requests in the batch, it would have to use If-Match: *.\n\nWe should allow the If-Match header to reference the ETag that resulted in a previous data modification request in a batch (similar to how we use the Content-ID to refer to the URI of an entity).\n\n### Proposal\n\nIntroduce a new header, ETag-ID.  Allow the If-Match header value in batch requests to be $<ETag-ID> so that it can refer to the ETag that resulted from a previous data modification operation in the batch request.  The '$' prefix would signal to the batch processor that the If-Match header value is a reference to a previous ETag, rather than an ETag literal.\n\nImported from [ODATA-541](https://issues.oasis-open.org/browse/ODATA-541)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state that the Context URL locates (a specific portion of) the metadata document",
    "body": "It appears that Context URL is just a description, not a location, of a resource. Thus the term \"URL\" may be inappropriate, and \"URI\" may be more appropriate.\n\n### Proposal\n\nSee summary\n\n\nImported from [ODATA-540](https://issues.oasis-open.org/browse/ODATA-540)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Delta response encoding is unnecessarily verbose and change type is missing when odata.metadata=none",
    "body": "For a number of reasons, the encoding of delta responses is unnecessarily verbose, which will result in excessive network and CPU utilization, particularly for offline-enabled mobile devices.\n\n(1) To distinguish between changed entity, deleted entity, changed link, or deleted link requires use of the Context URL which, as described in [ODATA-538](https://issues.oasis-open.org/browse/ODATA-538), can be unnecessarily verbose.\n\n(2) The \"id\" in deleted entities and the \"source\"/\"target\" in added/deleted links is not required to use a relative URL, and clients cannot control whether the server will or will not use relative URLs.\n\nAdditionally, if odata.metadata=none, clients may be unable to decode delta responses, since odata.context may be omitted in that case. Interestingly, odata.deltaLink cannot be omitted from the response, although a delta response without change type for each of the included changes would be useless to a client.\n\n\n### Proposal\n\nClose without action.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-539\n\nOriginal proposal part (a) is covered by [ODATA-538](https://issues.oasis-open.org/browse/ODATA-538)\nOriginal proposal part (b) is covered by [ODATA-527](https://issues.oasis-open.org/browse/ODATA-527)\n\n\nOriginal proposal was:\n(a) Define a separate annotation for change type in delta responses, so that change type can be determined even when the Context URL is omitted.\n\nThe rationale being that Context URL is a hybrid of information that is otherwise known to a metadata-aware client (which can remember what it asked for in the GET request). Apart from odata.type (which is covered in [ODATA-538](https://issues.oasis-open.org/browse/ODATA-538)), the change type would appear to be the only information about delta responses that a metadata-aware client cannot determine from metadata it already holds, and the request it knows it sent. Having this information embedded within a Context URL, which the client does not need the rest of, is questionable.\n\n(b) Require servers to use relative URLs in id/source/target, or at least allow clients to \"indicate that they Prefer\" relative URLs.\n\nImported from [ODATA-539](https://issues.oasis-open.org/browse/ODATA-539)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify treatment of odata.type with derived types and odata.context for delta responses for odata.metadata=none",
    "body": "Suppose a service supports the addressing conventions (so a client would be able to formulate read/edit links from entity set names and key properties), and the client, being meta-data aware, wants to receive a large set of results (of declared type A, with possible subtype B) that is fairly compactly encoded. By metadata-aware, that means the client has already fetched the meta-data document.\n\nNow the client will still need to receive odata.type for any entities of subtype B, as in the general case this cannot be determined from the returned properties (unless or more of the returned properties can be used as proxy type marker).\n\nThe difficulty here is that such a client does not generally need to receive the context URL. And in the general case, odata.context URLs are going to be quite a bit larger than the odata.type, similar to the metadata uri in pre-V4 OData. For example, with this service:\n\n    https://sapes1.sapdevcenter.com/sap/opu/odata/IWFND/RMTSAMPLEFLIGHT/BookingCollection\n\nthe metadata uri can chew up nearly one third of the total JSON encoding. The client then must receive and parse a lot of information it does not need (GZIP can help with the network size of bloated context URLs, but they still need to be parsed which can chew up valuable CPU, especially on mobile devices).\n\nThere may be cases where a V4 context URI are somewhat more concise than a pre-V4 metadata uri, but odata.context is still generally \"bloated\" in comparison to odata.type.\n\nAnd none of the odata.metadata options are suitable to express the client requirements.\n\n(a) odata.metadata=minimal: the odata.type is not required to be present, and the odata.context URLmust be included in the response, even though the client does not need it\n\n(b) odata.metadata=full: the odata.type is present (when needed, e.g. for entities of subtype B) but odata.context URL must be included in the response, along with various links which the client does not need.\n\n(c) odata.metadata=none: the odata.type is not present\n\n### Proposal\n\nChange the description of JSON format section 3.1.3 \"odata.metadata=none\" to state explicitly:\n\nodata.metadata=none cannot be used in delta requests.\n\nChange section on odata.type to clarify that type MUST be included in minimal or full metadata for the listed conditions.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-538\n\nImported from [ODATA-538](https://issues.oasis-open.org/browse/ODATA-538)",
    "labels": [
      "JSON Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Ordering of navigationLink and associationLink annotations in JSON",
    "body": "Association Link specifies that if both navigationLink and associationLink are represented, for example in the odata.metadata=full case, that the associationLink MUST immediately precede the navigationLink.\n\nExample 10 however shows two cases were both links are represented however they are in the opposite order of what is specified in 8.2.\n\nUnless there is a specific reason why associationLink MUST precede the navigationLink, presuming an order needs to be enforced in the first place, I'd propose to have navigationLink precede the associationLink, as associationLink builds on, if following convention, the navigationLink.\n\n\n### Proposal\n\nRetain association link, but state that the only case that the service must return it is if it differs from the convention of appending /$ref to the navigation link.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-537\n\nImported from [ODATA-537](https://issues.oasis-open.org/browse/ODATA-537)",
    "labels": [
      "JSON Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Treatment of circular references when using $levels",
    "body": "Current documents don't describe how to deal with cases where expansion using $levels, especially the $levels=max case, runs into a circular reference.\n\nOptional solutions to this might be:\n\n1 - Omitting the navigation property that would otherwise result in the circular reference\n2 - Include the entity but no longer expand anything that was already expanded previously (very hard to track potentially)\n3 - Inject an entity reference if odata.allow-enityreferences preference has been specified or return an invalid request otherwise\n4 - A combination of 2 and 3 where an entity reference would be injected if the odata.allow-entityreferences preference had been specified or the entity, without any further expansions, would be returned otherwise\n\nIssues with these proposals:\n - The request is valid, the cycle could exist at one point and not at the other, so invalid request response would be flatout incorrect\n - Not expanding an entity further is at a minimum confusing as well as one would not be able to deduce from looking at it that the reason some navigation properties didn't get included was because of the circular reference\n - Always using a reference, even without the odata.allow-entityreferences preference, is not an option as consumers might not be prepared to deal with those\n\nWith all that in mind one might come to the conclusion, as we did in an initial discussion, that simply omitting the navigation property causing the circular reference would be the least astonishing solution. That would be fine for to 1 relationships but not for collections as you'd have one entry less in that case?\n\nEntity references overall seem to be the best solution here but we don't necessarily like the link with the odata.allow-entityreferences preference. This, i.c.w. the fact that it's not really a bad request anyway, lead us to propose that consumers that use $levels=max ought to be able to deal with entity references respectively of the use of the preference. Without the odata.allow-entityreferences preference an entity reference would only get injected if a circular reference would occur otherwise while with the preference presumably reference would get injected wherever a previously expanded entity might get referenced. This distinction is also important because the selected and expanded properties don't always have to line up between the various expands of the same entity.\n\n\n### Proposal\n\nConsumers using $levels=max MUST be prepared to handle entity references in cases were a circular reference would occur otherwise.\n\nProviders must solve circular dependency by injecting an entity reference somewhere in the circular dependency.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50877/odata-meeting-54_on-20131001-minutes.html#odata-536\n\nImported from [ODATA-536](https://issues.oasis-open.org/browse/ODATA-536)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define specialization for terms",
    "body": "When merging type terms and value terms we lost the possibility to define terms that are a specialization of other terms, e.g. \"a developer is a person with programming skills\".\n\nGiven:\n- term Person using complex PersonType\n\nWhat we can currently do:\n- define a complex DeveloperType that inherits from PersonType\n- annotate something with term Person and use a record of type DeveloperType\n\n<Annotation Term=\"X.Person\">\n  <Record Type=\"Y.DeveloperType\">\n    <PropertyValue Property=\"Name\" Path=\"Fullname\" /> <!-- defined on PersonType -->\n    <PropertyValue Property=\"ProgrammingSkills\" Path=\"ListOfSkills\" /> <!-- defined on DeveloperType -->\n  </Record>\n</Annotation>\n\nSo someone knowing the term Person will find this term with additional properties defined on the DeveloperType. \n\nDrawback: no term \"Developer\"; semantic \"is a developer\" is expressed indirectly.\nDrawback: supports only one level. If an Architect is a special Developer, then the \"is a developer\" semantics is lost because the record's type is \"Z.ArchitectType\" and Y.DeveloperType is no longer mentioned in the annotation.\n\nGoals:\n- define a term Developer and indicate in the term definition that it specializes term Person\n- annotate something with term Developer in a way that someone knowing only Person and with no access to the definition of term Developer can recognize a Developer as a Person. This should also work with longer specialization chains\n\nOther use cases:\n- a Team is a collection of Person instances\n- a DevelopmentTeam is a Team, and also a collection of Developer instances\n- a ScrumTeam is a DevelopmentTeam with a ScrumMaster\n- a ScrumMaster is a Developer which is a Person\n\n### Proposal\n\nAdd attribute BaseTerm to element Term to express term specialization.\n\nWhen applying a term with a base term, the base term MUST also be applied with the same qualifier, and so on until a term without a base term is reached.  If the type of the specialized term is structured and directly or indirectly inherits from the type of its base term, property values that already have been specified in the annotation(s) for the base type(s) need not be specified again.\n\nNote: this proposal only solves the third problem stated in the description. The other three problems can be solved by cooperatively annotating term applications, as sketched in the examples below with the terms custom.IsA and custom.ItemIsA. Even if we would allow to use terms interchangeably with types in Term and Property elements, the additional semantics would only be expressed in the definitions of the terms and structured types, and not in annotations using these terms, violating the second goal in the description.\n\n\nExamples\n========\n<Schema Namespace=\"X\">\n  <Term Name=\"Person\" Type=\"X.PersonType\" />\n  <Term Name=\"Team\" Type=\"Collection(X.PersonType)\">\n    <Annotation Term=\"custom.ItemIsA\" String=\"X.Person\" />\n  </Term>\n</Schema>\n<Schema Namespace=\"Y\">\n  <Term Name=\"Developer\" BaseTerm=\"X.Person\" Type=\"Y.DeveloperType\" />\n  <ComplexType Name=\"DeveloperType\" BaseType=\"X.PersonType\">\n    <!-- additional properties -->\n  </ComplexType>\n\n  <Annotations Target=\"Some.EntityType\">\n    <Annotation Term=\"X.Person\">\n      <Record>\n        <!-- property values defined on X.PersonType go here -->\n      </Record>\n    </Annotation>\n    <Annotation Term=\"Y.Developer\">\n      <Record>\n        <!-- property values not already specified in the base term annotation go here -->\n      </Record>\n    </Annotation>\n  </Annotations>\n\n  <Term Name=\"DevelopmentTeam\" Type=\"Collection(Y.DeveloperType)\">\n    <Annotation Term=\"custom.ItemIsA\" String=\"Y.Developer\" />\n    <Annotation Term=\"custom.IsA\" String=\"X.Team\" />\n    <!--\n      cannot express that with BaseType because it would be hard to have\n      both a DevelopmentTeam and a Team annotation and then correlate the records\n    -->\n  </Term>\n\n  <Annotations Target=\"Some.EntityType\">\n    <Annotation Term=\"Y.DevelopmentTeam\">\n      <Annotation Term=\"custom.IsA\" String=\"X.Team\" />\n      <Path>SomeNavProp/@Y.Developer</Path>\n    </Annotation>\n  </Annotations>\n\n  <Term Name=\"ScrumTeam\" BaseTerm=\"Y.DevelopmentTeam\" Type=\"Y.ScrumTeamType\" />\n  <ComplexType Name=\"ScrumTeamType\">\n    <Property Name=\"ScrumMaster\" Type=\"Y.DeveloperType\">\n      <Annotation Term=\"custom.IsA\" String=\"Y.Developer X.Person\" />\n    </Property>\n  </ComplexType>\n  <Annotations Target=\"Some.EntityType\">\n    <Annotation Term=\"Y.DevelopmentTeam\">\n      <Annotation Term=\"custom.IsA\" String=\"X.Team\" />\n      <Path>SomeNavProp/@Y.Developer</Path>\n    </Annotation>\n    <Annotation Term=\"Y.ScrumTeam\">\n      <Record>\n        <PropertyValue Property=\"ScrumMaster\">\n          <Annotation Term=\"custom.IsA\" String=\"Y.Developer X.Person\" />\n          <!--\n            cannot express that in complex type definition unless we make\n            terms and types interchangeably everywhere\n          -->\n          <Record>\n            <!-- property values for Y.DeveloperType go here -->\n          </Record>\n        </PropertyValue>\n      </Record>\n    </Annotation>\n  </Annotations>\n</Schema>\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-535\n\nImported from [ODATA-535](https://issues.oasis-open.org/browse/ODATA-535)",
    "labels": [
      "CSDL XML",
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Tag type definition in Core should have default boolean value = true",
    "body": "In the core vocabulary we define a type definition for terms used as tags as:\n\n      <TypeDefinition Name=\"Tag\" UnderlyingType=\"Edm.Boolean\">\n        <Annotation Term=\"Core.Description\" String=\"This is the type to use for all tagging terms\" />\n      </TypeDefinition>\n\nThe intention of this was to allow the mere presence of a term (such as IsLanguageDependent) to be true.\n\nHowever, we neglected to define the default value as part of the TypeDefinition, so each use of the Tag must ALSO specify the default value of true (which kinda defeats the purpose).\n\nPerhaps this was because we don't currently list DefaultValue (or Nullable) in the allowable facets for a type definition (why?)\n\n### Proposal\n\nClose without action\n\nAccepted: https://www.oasis-open.org/committees/download.php/50877/odata-meeting-54_on-20131001-minutes.html#odata-534\n\nImported from [ODATA-534](https://issues.oasis-open.org/browse/ODATA-534)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Restrict key property aliases to key properties nested in complex properties",
    "body": "We introduced aliases for key properties to allow primitive properties nested within a complex property to participate in the entity key. For those properties we require an alias, but we do not state whether or not we allow such an alias for properties declared directly within the entity type.\n\nThe alias does not add any value in this case, so we disallow it.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-533\n\nImported from [ODATA-533](https://issues.oasis-open.org/browse/ODATA-533)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether collections can contain null values",
    "body": "OData V3 clearly prohibited collections from containing null values.\n\nIn OData V4 we are not as clear. The Atom format specifically prohibits the metadata:null attribute on <element> elements, so we have said you can't have null values in Atom. We don't have the similar restriction in JSON.\n\nThere may be scenarios in applying annotations where a collection ends up containing a null value. i.e., \n\n                <Collection>\n                                <Path>BillingAddress</Path>\n                                <Path>ShippingAddress</Path>\n                </Collection>\n\nCould result in a null value within the collection if BillingAddress is null.. \n\nWe do not have a way to say whether or not an instance of a collection could contain null values (i.e., collection(Edm.Int32 nullable=true), nor would I propose we add one unless we think it is important for some clients to support nulls in collections but unreasonable for some services to support.\n\nOption 1: Clarify that an atom/json payload may contain null values, but don't support nulls in collection valued properties until 4.1.\nOption 2: Clarify that an atom/json payload may ALWAYS contain null values, include for collection valued properties.\n\nAlso, while we're at it, there was some confusion as to whether properties in atom whose value is null but whose underlying type was not string still needed the metadata:type attribute. The answer is yes; no-string primitive properties in Atom always need the metadata:type attribute, even if their value is null. The same rule applies to JSON with full metadata.\n\n### Proposal\n\nSupport null values in collections.\n1) Change the text in Atom for collection of primitive type and collection of complex type that says the <element> element must not have the metadata:null attribute to say that it may have the attribute. \n2) Add text to JSON for collections of primitive and complex type calling out that a null value within the collection is represented using the json null literal.\n3) Specify in csdl that collection properties may include nulls.\n4) Clarify that metadata:type attribute still needs to be written in Atom (and odata.type attribute in JSON with full metadata) even if the value is null.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-532\n\nImported from [ODATA-532](https://issues.oasis-open.org/browse/ODATA-532)",
    "labels": [
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify OptimisticConcurrency in Core vocabulary",
    "body": "The OptimisticConcurrencyControl term in the Core vocabulary currently defines a complex type that contains a single collection-valued property:\n\n<Term Name=\"OptimisticConcurrencyControl\" Type=\"Core.OptimisticConcurrencyControlType\" AppliesTo=\"EntitySet\">\n  <Annotation Term=\"Core.Description\" String=\"If present, the annotated entity set uses optimistic concurrency control\" />\n</Term>\n<ComplexType Name=\"OptimisticConcurrencyControlType\">\n  <Property Name=\"ETagDependsOn\" Type=\"Collection(Edm.PropertyPath)\" Nullable=\"true\">\n    <Annotation Term=\"Core.Description\" String=\"The ETag is computed from these properties\" />\n  </Property>\n</ComplexType>\n\nThis intermediate complex type means that applying the vocabulary requires an extra <Record> and <PropertyValue> wrapper:\n\n<EntitySet Name=\"Entities\" Type=\"Self.Entity\">\n  <Annotation Term=\"Core.OptimisticConcurrencyControl\">\n    <Record>\n      <PropertyValue Name=\"ETagDependsOn\">\n        <Collection>\n          <PropertyPath>LastModified</PropertyPath>\n        </Collection>\n      </PropertyValue>\n    </Record>\n  </Annotation>\n</EntitySet>\n\nThis is unnecessarily cumbersome. We can remove the extra complex type and just create a term whose type is Collection(Edm.NavigationPropertyPath), as in:\n\n<Term Name=\"OptimisticConcurrencyControlProperties\" Type=\"Collection(Edm.PropertyPath)\" AppliesTo=\"EntitySet\">\n  <Annotation Term=\"Core.Description\" String=\"The set of properties that are used to compute the ETag\" />\n</Term>\n\nWhich would be applied much more simply as:\n\n<EntitySet Name=\"Entities\" Type=\"Self.Entity\">\n  <Annotation Term=\"Core.OptimisticConcurrencyControlProperties\">\n    <Collection>\n      <PropertyPath>LastModified</PropertyPath>\n    </Collection>\n  </Annotation>\n</EntitySet>\n\nI think these annotations will be common, so having a simpler way to express is significant.\n\n\n\n\n\n### Proposal\n\nReplace the Core.OptimisticConcurrencyControl term in the Core vocabulary with the following:\n\n<Term Name=\"OptimisticConcurrency\" Type=\"Collection(Edm.PropertyPath)\" AppliesTo=\"EntitySet\"> \n  <Annotation Term=\"Core.Description\" \n    String=\"Data modification requires the use of Etags. A non-empty collection contains the set of properties that are used to compute the ETag\" /> \n</Term> \n\nAccepted: https://www.oasis-open.org/committees/download.php/50877/odata-meeting-54_on-20131001-minutes.html#odata-531\n\nImported from [ODATA-531](https://issues.oasis-open.org/browse/ODATA-531)",
    "labels": [
      "CSDL XML",
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Navigable capability term should apply to entityset, not navigationproperty directly",
    "body": "We decided to define all capabilities on either the entity set or the entity container, rather than type, so that we could share a type definitions across sets, and even services, and define the relative restrictions based on the actual exposed set.\n\nSomehow we missed the navigable term in doing this, the current definition of which is:\n\n      <Term Name=\"Navigable\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"NavigationProperty\">\n        <Annotation Term=\"Core.Description\" String=\"Supports navigation paths according to OData URL conventions\" />\n      </Term>\n\nAlso, note that many service support one level of navigation but not recursive navigation. We should capture that as well.\n\n\n\n### Proposal\n\nReplace the \"Navigable\" term in the Capabilities vocabulary with a \"NavigationRestrictions\" term that can be applied to the entity set:\n\n<!--NavigationRestrictions-->\n\n<Term Name=\"NavigationRestrictions\" Type=\"Capabilities.NavigationRestrictionsType\" AppliesTo=\"EntitySet\">\n  <Annotation Term=\"Core.Description\" String=\"Restrictions on navigating properties according to OData URL conventions\" />\n</Term>\n<ComplexType Name=\"NavigationRestrictionsType\">\n  <Property Name=\"Navigability\" Type=\"Capabilities.NavigationType\" >\n    <Annotation Term=\"Core.Description\" String=\"Supported Navigability\"/>\n  </Property>\n  <Property Name=\"RestrictedProperties\" Type=\"Collection(Capabilities.NavigationPropertyRestriction)\"/>\n</ComplexType>\n\n<ComplexType Name=\"NavigationPropertyRestriction\">\n  <Property Name=\"NavigationProperty\" Type=\"Edm.NavigationPropertyPath\">\n  <Annotation Term=\"Core.Description\" String=\"Navigation properties can be navigated to a single level\" />\n  </Property>\n  <Property Name=\"Navigability\" Type=\"Capabilities.NavigationType\">\n    <Annotation Term=\"Core.Description\" String=\"Navigation properties can be navigated to a single level\" />\n  </Property>\n</ComplexType>\n\n<EnumType Name=\"NavigationType\">\n  <Member Name=\"Recursive\">\n    <Annotation Term=\"Core.Description\" String=\"Navigation properties can be recursively navigated\" />\n  </Member>\n  <Member Name=\"Single\">\n    <Annotation Term=\"Core.Description\" String=\"Navigation properties can be navigated to a single level\" />\n  </Member>\n  <Member Name=\"None\">\n    <Annotation Term=\"Core.Description\" String=\"Navigation properties are not navigable\" />\n  </Member>\n</EnumType>\n\nImported from [ODATA-530](https://issues.oasis-open.org/browse/ODATA-530)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Single-parameter cast() and isof() functions",
    "body": "The single-parameter cast and isof functions are equivalent for calling the two-parameter versions with the recently introduced symbol $it:\n- cast(Some.Type) eq cast($it,Some.Type)\n- isof(Some.Type) eq isof($it,Some.Type)\n\n### Proposal\n\nRemove single-parameter overloads of cast and isof.\n\nImported from [ODATA-529](https://issues.oasis-open.org/browse/ODATA-529)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$entity should require cast segment in order to apply $select/$expand",
    "body": "Given an opaque id for an entity, the client can get the instance using the new /$entity resource and providing the id through the $id query option, such as:\n\nhttp://host.service/$entity?$id=urn:mysvc5304-98001-7832-4425\n\nThis can be cast to a particular type:\n\nhttp://host.service/$entity/myservice.Customer?$id=urn:mysvc5304-98001-7832-4425\n\nAnd any of the query options supported for a single resource can be applied:\n\nhttp://host.service/$entity/myservice.Customer?$id=urn:mysvc5304-98001-7832-4425?$select=LastName&$expand=Orders\n\nHowever the text current does no require the cast in order to apply $select and $expand. This is a bug, because without the cast a parser cannot determine whether the $select and $expand are valid without actually retrieving the object and discovering its type.\n\nEverywhere else we consistently require casting to the correct type in order to access members of that type.\n\nAlso, I think there is a bug in the ABNF as it doesn't appear to allow for the cast segment:\n\n'$entity' \"?\" entityOptions  \n\n### Proposal\n\n1. Clarify that the /$entity segment MUST be cast to a particular type in order to apply $select and $expand. Specifically reference section 11.2.8 of [Protocol], including example 61 which should be changed to include the required cast segment.\n\n2. Fix the abnf to allow the cast segment: \n'$entity' [ \"/\" qualifiedEntityTypeName ] \"?\" entityOptions  \n\nImported from [ODATA-528](https://issues.oasis-open.org/browse/ODATA-528)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Relative URLs in OData and the ability to put OData services behind an HTTP proxy",
    "body": "It is often necessary to place an OData producer behind a (reverse) proxy. \n\nHTTP proxies will alter request URLs. They typically change:\n- the scheme (http or https)\n- the host\n- the port\nThey can change the path, typically by exchanging a prefix portion.\nThey also can add, remove, or modify HTTP request and response headers.\n\nThey cannot alter message bodies without knowledge beyond HTTP, in our case knowledge of the OData formats\n- CSDL\n- Atom\n- JSON\n- anything we might want to add in the future\n\nSo message bodies should only contain URLs that need not be altered by HTTP proxies.\n\nThis affects request bodies created by OData consumers and response bodies created by OData producers.\n\nTwo typical candidates for such \"proxy-safe\" URLs are\n- absolute URLs outside of the domain shielded by the proxy\n- relative URLs that are relative to something the proxy can easily alter\n\nIn addition resolution of relative URLs should be possible with the information contained in the request-response message pair and no out-of-band knowledge beyond the OData specifications. Note that the service root is out-of-band knowledge: it cannot be calculated from the context URL which is based on the metadata URL, and the service root URL is not a specified part of the metadata document. \n\nProblems with the current rules for relative URLs\n- Content-Location header: this header is only available in responses. Also it has special meaning if it deviates from the request URL, so having it in the resolution chain only adds problems and does not add any value\n- Batch requests allow three formats for request URLs in the batch body, and the relative format is mentioned last.\n\n### Proposal\n\nProtocol\nThe metadata URL MUST be the service root URL followed by /$metadata.\n\nRelative URLs are ultimately relative to the request URL\nWithin a message the format-specific rules (xml:base, odata.context, odata.type) for resolving relative URLs apply. \n\nServices behind proxies should provide relative URLs using the format-specific rules whenever possible.\n\nClients MUST provide URLs relative to the service root in the $id system query option in requests for removing references to an entity whenever possible.\n\nClients MUST provide request URLs within batch requests relative to the request URL whenever possible (i.e. same scheme, host, and port as the request URL). This means relative to the service root because we fix /$batch at the service root.\n\n\nJSON\nThe outermost context URL is relative to the request URL, setting the base for all other relative URLs to the service root.\nThis is also the case if the outermost context URL is not specified, e.g. in metadata=none responses and in requests.\nSo the service root is effectively the base for all relative URLs other than the context URL in the outermost object.\n\nNested context URLs are relative to the next outer context URL.\n\nThe outermost odata.type URL is relative to the outermost context URL.\nNested odata.type URLs are relative to the next outer odata.type.\n\nAll other relative URLs are relative to the next context URL.\n\n\nAtom\nRelative URLs are always relative to the next xml:base.\n\nIf no xml:base attribute is present in the context of a relative reference, relative URLs are relative to the request URL.\nThis also applies to relative URLs in the xml:base attribute.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-527\n\nImported from [ODATA-527](https://issues.oasis-open.org/browse/ODATA-527)",
    "labels": [
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow specifying support for cross-joins",
    "body": "Services may not support cross-joins and reject any such request at runtime. If services advertize this capability by an annotation, consumers can proactively adjust their interaction behavior.\n\n### Proposal\n\nExtend capability vocabulary by a term describing cross-join support of a service:\n\n      <Term Name=\"CrossJoinSupported\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"EntityContainer\">\n        <Annotation Term=\"Core.Description\" String=\"Supports cross joins for the entity sets in this container\" />\n      </Term>\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-52\n\nImported from [ODATA-526](https://issues.oasis-open.org/browse/ODATA-526)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove Org.OData.Atom vocabulary",
    "body": "The Org.OData.Atom vocabulary defines the annotation terms that can be used to map properties to Atom elements. This is similar to an \"Entity Property Mapping\" feature in OData V3.\n\nThe rules in OData V3 for how to do the mapping, the semantics and results of the mapping, were pretty complex (which is why we removed them from the OASIS spec). People wanted to be able to map to structured terms, repeating terms, etc. \n\nThe vocabulary was introduced as a cleaner, simpler way to specify that properties of the entity can be mapped to some of the defined Atom elements (like title, author, etc.)\n\nHowever, there isn't really a description of the vocabulary, just a bunch of terms that don't really describe how they are intended to be used. Also, the terms are incomplete (they are missing the \"Author\" term, for example). \n\nFurthermore, our general intention is that vocabularies, which we expect to be more dynamic, be produced through the ecosystem, rather than through OASIS. The only exceptions to this rule are the Core, Capabilities and Aggregation vocabularies that we defined as part of the [Protocol] and [Aggregation] work products because we needed to normatively reference them.\n\n### Proposal\n\nRemove the Org.OData.Atom.xml vocabulary from the [Atom] work product.\n\nAlso remove the Atom vocabulary from the title page and the normative references\nRemove second paragraph of section 6.1\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-52\n\nImported from [ODATA-525](https://issues.oasis-open.org/browse/ODATA-525)",
    "labels": [
      "ATOM Format",
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "properties in [propertyList] of context URL may be qualified with type",
    "body": "Our current context URL for projected entities includes the selected properties:\n\n {context-url}#{entity-set}{/type-name}{property-list}\n\nThe abnf for property-list is:\npropertyList         = OPEN propertyListItem *( COMMA propertyListItem ) CLOSE\npropertyListItem     = STAR ; all structural properties\n                     / propertyListProperty\npropertyListProperty = primitiveProperty  \n                     / primitiveColProperty \n                     / navigationProperty [ '+' ] [ propertyList ]\n                     / selectPath [ \"/\" propertyListProperty ]\n\nHowever, we need to be able to support properties being prefixed with type for the following types of queries:\n\n~People?$select=ns.SalesPerson/Department,ns.Cashier/Register\n\nWhich should yield:\n\nhttp://host/service/$metadata#People(ns.SalesPerson/Department,ns.Cashier/Register)\n\n### Proposal\n\nClarify that the properties in the property list may have an optional type cast segment.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-524\n\nImported from [ODATA-524](https://issues.oasis-open.org/browse/ODATA-524)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "How do clients construct links from the context url for complex types?",
    "body": "Our current pattern for the context for a single complex types looks like this:\n\n{context-url}#{type-name}\n\nAnd a collection of complex types looks like this:\n\n{context-url}#Collection({type-name})\n\nHowever, in V4 we have add the ability for complex types to have relationships.Since one of the roles of the context is to provide the base for clients to construct links, how does the client compute relationship links using these context urls?\n\nFor example, if I do ~Customers(1)/ns.Address, and Address has navigations to Country, how do represent that?\n\nOption 1: For complex types/collections of complex types, if there are navigation properties, you have to put the navigation links in the payload.\nOption 2: We modify the context url for single-valued complex properties to include the property path from the entity in the entity set:\n\n{context-url}/{entity-set}/$entity/{propertyName}\n\nFor collection-valued complex properties and single- or collection-valued primitive properties we keep the current pattern. Collections of complex types MUST include links, as already stated in JSON section 8.1.\n\n\n### Proposal\n\nDefine the context url for single property value to be:\n\n{context-url}#{entity}/{property-path}\n\nWhere {entity} is the canonical URL off the entity and {property-path} is the path to a structural property of that entity.\n\nUse this pattern for operations that return a single property of an entity.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-523\n\nImported from [ODATA-523](https://issues.oasis-open.org/browse/ODATA-523)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that the has operator returns null if either operand is null.",
    "body": "\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-522](https://issues.oasis-open.org/browse/ODATA-522)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove typed null literals",
    "body": "Typed null literals in the form null'Edm.String' were introduced to disambiguate function overload resolution when overloads were still allowed to differ only in their parameter types. Since then we've required function overloads to differ in their non-binding parameter names, and applying [ODATA-496](https://issues.oasis-open.org/browse/ODATA-496) will remove the last mentioning of typed null literals outside of the ABNF and its test cases.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-521\n\nImported from [ODATA-521](https://issues.oasis-open.org/browse/ODATA-521)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Instance annotations should be prefixed with \"@\"",
    "body": "Instance annotations in JSON are differentiated from regular properties by the presence of one ore more dots (.) in the name.\n\nThis convention assumes that people won't typically have dots in their property names. However, it's come to my attention that there are cases where people are representing name/value pairs in JSON that have dots in the name.\n\nAdding the \"@\" prefix makes it much easier to distinguish annotations, and is consistent with assigning an annotation to a property (basically, prop@ns.annotation clearly means the annotation is applied to a property, while just @ns.annotation means it is applied to the containing object). \n\nFinally, adding the \"@\" sets up the opportunity for better alignment with JSON-LD, who also prefixes their \"annotations\" with \"@\".\n\n### Proposal\n\nInstance annotations in JSON are prefixed with the \"@\" sign (in addition to the existing rules of containing one or more periods). No change in Atom rules.\n\nImported from [ODATA-520](https://issues.oasis-open.org/browse/ODATA-520)",
    "labels": [
      "JSON Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define server-driven paging for collection-valued resources",
    "body": "We allow client-driven paging with $top and $skip for all collection-valued resources, but restrict server-driven paging (indicated by next links) to collections of entities or entity references.\n\nSemantically there's no reason for this restriction, and both Atom and JSON would naturally allow this with <link rel=\"next\" ../> or odata.nextLink in the collection wrapper.\n\nThe obvious work-around of returning a collection of transient entities with a dummy key is sub-optimal.\n\n### Proposal\n\nRemove restriction to collections of entities and entity references, allow for all collections\n\nDefine next link serialization in Atom and JSON\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-519\n\nImported from [ODATA-519](https://issues.oasis-open.org/browse/ODATA-519)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Use NavProp@<annotation-name> to reference annotations applied to a NavProp",
    "body": "Currently we are not able to reference an annotation applied to a navigation property.\nIn the following example the expression <Path>Supplier/@Core.Description#Bar</Path> references the annotation of the entitytype supplier. The annotation at the navigation property \"Supplier\" is not referencable. As of today the expression <Path>Supplier@Core.Description#Foo</Path> is not valid.\n\t\t\t<EntityType Name=\"SalesOrderItem\">\n\t\t\t\t<Key>\n\t\t\t\t\t<PropertyRef Name=\"soi_ID\" />\n\t\t\t\t</Key>\n\t\t\t\t<Property Type=\"Edm.String\" Name=\"soi_ID\" />\n\t\t\t\t<NavigationProperty Name=\"Supplier\" Type=\"X.Supplier\">\n\t\t\t\t\t<Annotation Term=\"Core.Description\" Qualifier=\"Foo\" String=\"Item is supplied by\" />\n\t\t\t\t</NavigationProperty>\n\t\t\t</EntityType>\n\n\t\t\t<EntityType Name=\"Supplier\">\n\t\t\t\t<Annotation Term=\"Core.Description\" Qualifier=\"Bar\"  Path=\"ID\" />\n\t\t\t\t<Key>\n\t\t\t\t\t<PropertyRef Name=\"ID\" />\n\t\t\t\t</Key>\n\t\t\t\t<Property Type=\"Edm.String\" Name=\"ID\" />\n\t\t\t</EntityType>\n\n\t\t\t<Annotations Target=\"X.SalesOrderItem\">\n\t\t\t\t<Annotation Term=\"Core.LongDescription\" Qualifier=\"First\">\n\t\t\t\t\t<Path>Supplier/@Core.Description#Bar</Path>\n\t\t\t\t</Annotation>\n\t\t\t\t<Annotation Term=\"Core.LongDescription\" Qualifier=\"Second\">\n\t\t\t\t\t<Path>Supplier@Core.Description#Foo</Path>\n\t\t\t\t</Annotation>\n\t\t\t</Annotations>\n\nSee also Ralf's comment at https://tools.oasis-open.org/issues/browse/[ODATA-320](https://issues.oasis-open.org/browse/ODATA-320)\n\n### Proposal\n\nExtend Path expression:\nA path segment with the pattern <navigation-property>@<qualified-term-name>(#<qualifier>) is valid and addresses the annotation of <qualified-term-name> at the navigation property <navigation-property> (with the optional qualifier <qualifier>) \n\nExample in Description:\n<Path>Supplier/@Core.Description#Bar</Path> evaluates to the value of \"ID\"\n<Path>Supplier@Core.Description#Foo</Path> evaluates to the \"Item is supplied by\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-518\n\nImported from [ODATA-518](https://issues.oasis-open.org/browse/ODATA-518)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow NavigationPropertyPath and PropertyPath expressions to end in annotations of appropriate type",
    "body": "Currently NavigationPropertyPath expressions must end with a navigation property name, and PropertyPath expressions must end with the name of a structural property.\n\nOn the other hand annotations add \"virtual (navigation)properties\", so a NavigationPropertyPath expression could as well end with an annotation of type Edm.EntityType or any concrete entity type (or a collection of these), and a PropertyPath expression could end with an annotation of types Edm.ComplexType, Edm.PrimitiveType, or a concrete primitive type, enumeration type, or complex type, or a type definition  (or a collection of these).\n\nAn example for  \"virtual navigation properties\" is given in https://tools.oasis-open.org/issues/browse/[ODATA-278](https://issues.oasis-open.org/browse/ODATA-278) . The aim was that we can use  \"virtual navigation properties\" (and  \"virtual properties\") also as a NavigationPropertyPath (and as a PropertyPath ).  Currently  the expressions\n           <PropertyValue Property=\"NavigationPath\" NavigationPropertyPath=\"@ACR.Supplier\" /> and \n           <PropertyValue Property=\"NavigationPath\" NavigationPropertyPath=\"@ACR.PurchaseOrders\" />\nin the example are invalid, because the  NavigationPropertyPath expressions must end with a navigation property name.\n\n### Proposal\n\nAllow a NavigationPropertyPath expression to end with an annotation of type Edm.EntityType, any concrete entity type or a collection of these.\n\nAllow a PropertyPath expression to end with an annotation of type Edm.ComplexType, Edm.PrimitiveType, a concrete primitive type, enumeration type, or complex type, a type definition, or a collection of these.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-517\n\nImported from [ODATA-517](https://issues.oasis-open.org/browse/ODATA-517)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add super types Edm.AnyPath and Edm.AnyPropertyPath",
    "body": "The three types Edm.PropertyPath, Edm.NavigationPropertyPath, and Edm.AnnotationPath take valid path expressions that end in a structural property, a navigation property, or an annotation.\n\nIn some cases we don't need to restrict the last path segment, we just want to be sure that the path is valid in its context, so we don't want to use Edm.String.\n\n### Proposal\n\nAdd two new abstract types:\n\nEdm.AnyPropertyPath is an Edm.PropertyPath or an Edm.NavigationPropertyPath\n\nEdm.AnyPath is an Edm.AnyPropertyPath or an Edm.AnnotationPath\n\nImported from [ODATA-516](https://issues.oasis-open.org/browse/ODATA-516)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Section 5.1.1.9 Operator Precedence: operators use wrong capitalization in precedence table",
    "body": "Most operators in the table are shown with the first letter in uppercase, e.g. Not and Mul. Yet the ABNF only allows all-lowercase spelling.\n\n### Proposal\n\nCorrect spelling to all-lowercase\n\nImported from [ODATA-515](https://issues.oasis-open.org/browse/ODATA-515)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 44: compare Price to a number instead of a string",
    "body": "Examples 44 and 45 are not consistent, and Price should be numeric in both examples\n\n### Proposal\n\nChange from\n    http://host/service/Products?$filter=Name eq 'Milk' and Price lt '2.55'\nto\n    http://host/service/Products?$filter=Name eq 'Milk' and Price lt 2.55\n\nImported from [ODATA-514](https://issues.oasis-open.org/browse/ODATA-514)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Special handling of derived types in the dynamic expression edm:Record. Why?",
    "body": "We have defined a special handling of derived types in dynamic expression edm:Record:\n\n14.5.14 Expression edm:Record\nThe edm:Record expression enables a new entity type or complex type instance to be constructed.\nA record expression contains zero or more edm:PropertyValue elements. For each single-valued property of the record construct's type that is neither nullable nor specifies a default value an edm:PropertyValue child element MUST be provided. For derived types this rule applies only to properties directly defined by the derived type. For collection-valued properties the absence of an edm:PropertyValue child element is equivalent to specifying a child element with an empty collection as its value.\n \nFor me this special handling of the derived types looks superfluous. \n\n### Proposal\n\nDelete the sentence \" For derived types this rule applies only to properties directly defined by the derived type. \" and add an example for derived types with a nullable property.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50924/odata-meeting-55_on-20131003-minutes.html#odata-513\n\nImported from [ODATA-513](https://issues.oasis-open.org/browse/ODATA-513)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.5.14: add example for specifying a value for a navigation property in a <Record> expression",
    "body": "We allow terms to be of any entity type or complex type, and both can have navigation properties, but we don't have an example of how to specify  a value for a navigation property.\n\n### Proposal\n\nExplicitly state that the <PropertyValue> element can be used for both navigation and structural properties.\n\nAdd example using the <PropertyValue> element for specifying a value for a navigation property using the Path attribute:\n\n  <PropertyValue Property=\"CostCenter\" Path=\"CurrentOrgUnit/CostCenter\" />\n\nAdd second example using the <UrlRef> expression:\n\n  <PropertyValue Property=\"CostCenter\">\n    <UrlRef>\n      <Apply Function=\"odata.fillUriTemplate\">\n        <String>http://host/anotherService/CostCenters('{CostCenterID}')</String> \n        <LabeledElement Name=\"CostCenterID\" Path=\"CCID\" /> \n      </Apply> \n    </UrlRef>\n  </PropertyValue>\n\nImported from [ODATA-512](https://issues.oasis-open.org/browse/ODATA-512)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "13.6 and 13.6.2: \"bound\" should hyperlink to section 12.2.3 instead of 12.1.3",
    "body": "Copy & paste error from similar text for ActionImport\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-511](https://issues.oasis-open.org/browse/ODATA-511)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 78: replace IsBindable with IsBound",
    "body": "Leftover from renaming this attribute\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-510](https://issues.oasis-open.org/browse/ODATA-510)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.1: Superfluous period at end of second sentence",
    "body": "\n\n### Proposal\n\nRemove second period\n\nImported from [ODATA-509](https://issues.oasis-open.org/browse/ODATA-509)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Delete leftover \"respectively\" from 6th paragraph of [JSON] Section 5, Service Document",
    "body": "The 6th paragraph in section 5, Service Document, used to read:\n\n         JSON objects representing a function or action import MUST contain this name/value pair with a value of FunctionImport or ActionImport, respectively.\n\nHowever, action imports should never appear in the service document, so we (correctly) removed the reference to Action Imports. However, we accidentally left in the trailing \",respectively\":\n\n              JSON objects representing a function import MUST contain the kind name/value pair with a value of FunctionImport, respectively.\n\n\n### Proposal\n\nRemove the extraneous \", respectively\" from the end of the paragraph.\n\nImported from [ODATA-508](https://issues.oasis-open.org/browse/ODATA-508)",
    "labels": [
      "JSON Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Editorial; text appears twice in section 11.2.6 of [Protocol]",
    "body": "In the last sentence of the first paragraph of Section 11.2.6., Requesting Related Entities, of [Protocol], the last part of the sentence is repeated:\n\n\"To request related entities according to a particular relationship, the client issues a GET request to the source entity's request URL, followed by a forward slash and the name of the navigation property representing the relationship. to the source entity's request URL, followed by a forward slash and the name of the navigation property representing the relationship.\"\n\n\n### Proposal\n\nRemove the trailing sentence fragment.\n\nImported from [ODATA-507](https://issues.oasis-open.org/browse/ODATA-507)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rule day does not allow the values 10 and 20",
    "body": "\n\n### Proposal\n\nChange rule to \n\nday   = \"0\" oneToNine\n      / ( \"1\" / \"2\" ) DIGIT\n      / \"3\" ( \"0\" / \"1\" )\n\nImported from [ODATA-506](https://issues.oasis-open.org/browse/ODATA-506)",
    "labels": [
      "ABNF",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove ReturnType attribute from Action and Function element",
    "body": "The ReturnType attribute is just a shorthand for a ReturnType element with only a Type attribute.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-505\n\nImported from [ODATA-505](https://issues.oasis-open.org/browse/ODATA-505)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Comment in line 456 should refer to rule lambdaVariableExpr",
    "body": "Currently the comment refers to the old name of the rule: lambdaPredicatePrefixExpr\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-504](https://issues.oasis-open.org/browse/ODATA-504)",
    "labels": [
      "ABNF",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Error in ABNF grammar: Edm prefix required for built-in primitive types",
    "body": "As per [ODATA-354](https://issues.oasis-open.org/browse/ODATA-354), the \"Edm.\" prefix is required in CSDL and URLs. We failed to update the [abnf] when applying this change. \n\n### Proposal\n\nUpdate the ABNF to show that the \"Edm.\" prefix is required for primitive types in the URL.\n\nImported from [ODATA-503](https://issues.oasis-open.org/browse/ODATA-503)",
    "labels": [
      "ABNF",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Fix use of hash (#) for category term attribute in Atom",
    "body": "In applying [ODATA-457](https://issues.oasis-open.org/browse/ODATA-457) to Atom, we clarified the rules around metadata:type being a fragment for non-primitive types but we neglected to update the description and examples for the term attribute of the category element of an entry, which also defines the type.\n\nExample 7 correctly shows #Model.VipCustomer being a fragment within an absolute reference, but example 6 (for instance) omits the hash.\n\n### Proposal\n\nAdd wording from metadata:type to section 6.3 and fix examples 5, 6, and 37. Also fix example 67 in [Protocol].\n\nImported from [ODATA-502](https://issues.oasis-open.org/browse/ODATA-502)",
    "labels": [
      "ATOM Format",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "has operator is missing from the operator precedence table",
    "body": "Section 5.1.1.9 defines operator precedence but doesn't mention the new \"has\" operator that can be used to determine if an enumeration value contains a particular member.\n\nEnums only support equality and comparison operators, so it probably doesn't make a lot of difference.\n\nIf we add it to Primary then::\n\n    Not style has Sales.Pattern'Yellow'\n\nwould be interpreted the same as::\n\n   Not (style has Sales.Pattern'Yellow')\n\n\n### Proposal\n\nAdd \"has\" operator to the \"Primary\" group for operator precedence.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-501\n\nImported from [ODATA-501](https://issues.oasis-open.org/browse/ODATA-501)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Require function/action overloads to differ by ordered set of parameter types",
    "body": "[CSDL] does function overload resolution by the unordered set of parameter names. Most languages do function overload resolution according to the ordered set of parameter types.\n\nCurrently, [CSDL] allows two function overloads with different parameter names to have the same types:\n\n<Function Name=\"Evaluate\" ReturnType=\"Integer\">\n <Parameter Name=\"Input\" Type=\"Edm.Integer\"/>\n</Function>\n<Function Name=\"Evaluate\" ReturnType=\"Integer\">\n <Parameter Name=\"Variable\" Type=\"Edm.Integer\"/>\n</Function>\n\nThis doesn't add significant value, could be confusing, and would not be supported in most programming languages.\n\nIt is okay for OData to be more restrictive than conventional programming languages, but having it arbitrarily less restrictive makes it difficult to expose a client side programming model in a conventional language.\n\n### Proposal\n\nRequire Function/Action overloads to differ by the ordered set of qualified parameter type names (in addition to unordered set of parameter names), treating type definitions based on the same primitive type as different types.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-500\n\nImported from [ODATA-500](https://issues.oasis-open.org/browse/ODATA-500)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "7.1.3 Nullable should refer to NavigationProperty, not Property",
    "body": "Section 7.1.3 of [CSDL] describes the use of the Nullable attribute with a NavigationProperty, but erroneously refers to \"Property\". This was a simple copy/paste error.\n\n### Proposal\n\nReword the first sentence of 7.1.3 Attribute Nullable as follows:\nThe edm:NavigationProperty element MAY contain the Nullable attribute whose Boolean value specifies whether a navigation target is required for the navigation property. \n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-499\n\nImported from [ODATA-499](https://issues.oasis-open.org/browse/ODATA-499)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Error with m:type in Example 31 of Atom",
    "body": "Example 31 of atom shows the encoding for a collection of addresses. The metadata:context attribute of the <edm:value> element shows the collection to be of type Collection(Model.Address), but erroneously has an m:type attribute of \"#Model.BaseAddress\". The first metadata:element has no m:type attribute (which is fine, if it is the base type of the collection type) and the second element explicitly says the type is Model.Address. \n\nSame problem in Part 1, example 67, with a JSON payload\n\n### Proposal\n\nmake the type of the collection in the metadata:context attribute Collection(Model.BaseAddress) and remove the m:type element from the <value> element, as in:\n\n<metadata:value xmlns:metadata=\"http://docs.oasis-open.org/odata/ns/metadata\"\n  metadata:context=\"http://host/service/$metadata#Collection(Model.BaseAddress)\"\n  xmlns=\"http://docs.oasis-open.org/odata/ns/data\"\n>\n  <metadata:element>\n    <Street>Obere Str. 57</Street>  \n    <City>Berlin</City>  \n    <PostalCode>D-12209</PostalCode>  \n  </metadata:element>\n  <metadata:element metadata:type=\"#Model.Address\">\n    <Street>12345 Grant Street</Street>  \n    <City>Taft</City>  \n    <Region>Ohio</Region>  \n    <PostalCode>OH 98052</PostalCode>  \n  </metadata:element>\n</metadata:value>\n\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-498\n\n\nPart 1, example 67, line 2, should be:\n\n  \"odata.type\":\"#Northwind.Manager\",\n\nImported from [ODATA-498](https://issues.oasis-open.org/browse/ODATA-498)",
    "labels": [
      "ATOM Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove type prefix and single quotes for URL literals of types Date, DateTimeOffset, Guid, and TimeOfDay",
    "body": "Currently we require literals for e.g. Date and DateTimeOffset to be prefixed with a type identifier, e.g.\n\n   $filter=StartDate ge date'2013-09-02'\n   $filter=ChangedAt lt datetimeoffset'2013-09-02T00:00Z'\n   $filter=EndTime lt time'23:59'\n   $filter=ID eq guid'01234567-89ab-cdef-0123-456789abcdef'\n\n  ~/Tasks(guid'01234567-89ab-cdef-0123-456789abcdef')\n\nIn most cases the type of the literal can be deduced from the context, e.g. type of other comparison operand. \n\nThe only case in which this cannot be done is when comparing two literals, which is rare.\n\nSo we can make the prefixes at least optional, or even completely get rid of them\n\n### Proposal\n\nRemove type prefix and single quotes for URL literals of types Date, DateTimeOffset, Guid, and TimeOfDay: \n\n   $filter=StartDate ge 2013-09-02\n   $filter=ChangedAt lt 2013-09-02T00:00Z\n   $filter=EndTime lt 23:59\n   $filter=ID eq 01234567-89ab-cdef-0123-456789abcdef\n\nThis also affects the key representation in the path part:\n\n  ~/Tasks(01234567-89ab-cdef-0123-456789abcdef)\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-497\n\nImported from [ODATA-497](https://issues.oasis-open.org/browse/ODATA-497)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Adapt outdated action/function overload resolution rules in Part 1 to current rules in Part 3",
    "body": "The latest change to the overload resolution strategy (type of binding parameter, set of names of non-binding parameters) didn't make it into the corresponding sections 11.5.3.2 and 11.5.4.2.\n\nAlso the Part 1 text still uses the former term \"bindable overload\" instead of \"bound overload\".\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-496\n\nImported from [ODATA-496](https://issues.oasis-open.org/browse/ODATA-496)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that Edm.Double and Edm.Single are 64-bit and 32-bit IEEE754 floating-point numbers",
    "body": "\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-495\n\nImported from [ODATA-495](https://issues.oasis-open.org/browse/ODATA-495)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define inheritance for enumeration types",
    "body": "We currently don't have a way for adding values to an enumeration type. This would be helpful for defining custom vocabularies that extend base vocabularies. \n\n It's sort of inheritance for enumerations, given the fact that some programming languages implement enumerations as classes/objects with members/properties for the enumeration values. \n\n So we could add an attribute \"BaseType\" or \"Extends\" for EnumType to add new enumeration values. \n\n### Proposal\n\nProposed  \nProposal   Allow EnumType to specify a BaseType to which the EnumType will add new members. BaseType and UnderlyingType cannot be both specified, the UnderlyingType. \n\n In metadata annotations the EnumMember syntax requires prefixing the member name with the fully qualified type name in all cases, so there's no ambiguity if the same base enum type is extended by more than one other enum type. \n\n For properties and instance annotations in request and response bodies enum members are represented only as the member name without the type name prefix if the member is defined by the declared type of the property. Members of a derived type must be prefixed with the qualified type name. This is consistent with the metadata annotation syntax and the URL syntax for accessing properties of derived types: \n\n \"PrimaryColor\":\"Yellow\" \n \"SecondaryColor\":\"org.example.ExtendedPattern/DarkRed\"  \n\n\nImported from [ODATA-494](https://issues.oasis-open.org/browse/ODATA-494)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Capabilities vocabulary: add term for SearchRestrictions",
    "body": "We forgot this when defining the query language for $search\n\n### Proposal\n\nAdd term\n\n      <Term Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\" AppliesTo=\"EntitySet\">\n        <Annotation Term=\"Core.Description\" String=\"Restrictions on $search expressions\" />\n      </Term>\n      <ComplexType Name=\"SearchRestrictionsType\">\n        <Property Name=\"Searchable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n          <Annotation Term=\"Core.Description\" String=\"$search is supported\" />\n        </Property>\n        <Property Name=\"UnsupportedExpressions\" Type=\"Capabilities.SearchExpressions\" DefaultValue=\"none\">\n          <Annotation Term=\"Core.Description\" String=\"Expressions supported in $search\" />\n        </Property>\n      </ComplexType>\n\n      <EnumType Name=\"SearchExpressions\" IsFlags=\"true\">\n        <Member Name=\"none\" Value=\"0\" />\n        <Member Name=\"AND\" Value=\"1\" />\n        <Member Name=\"OR\" Value=\"2\" />\n        <Member Name=\"NOT\" Value=\"4\" />\n        <Member Name=\"phrase\" Value=\"8\" />\n        <Member Name=\"group\" Value=\"16\" />\n      </EnumType>\n\nImported from [ODATA-493](https://issues.oasis-open.org/browse/ODATA-493)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for has\" operator to section 5.1.1.1.10",
    "body": "\n\n### Proposal\n\nAdd examples:\n\n$filter=style has Sales.Pattern'Yellow'\n$filter=style has Sales.Pattern'32'\n\n\nImported from [ODATA-492](https://issues.oasis-open.org/browse/ODATA-492)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Language-dependency of key property values",
    "body": "I never thought of this possibility (a key is a key is a key, or so I thought:-), but recently came across a case where people wanted to do this.\n\n### Proposal\n\nKey property values may be language-dependent as long as the key property value combination uniquely identifies the entity within its set at each given point in time.\n\nStill, servers must have a unique id that is independent of the language, and must write that in JSON minimal any time it doesn't match the convention based on the local of the keys being written.\n\nBoth Vienna and Wien uniquely identify the capital of Austria in the set of cities, and both Cape Canaveral and Cape Kennedy uniquely identify a landmark in Florida.\n\nImported from [ODATA-491](https://issues.oasis-open.org/browse/ODATA-491)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify Referential Constraints have UpdateRule=Cascade semantics",
    "body": "The current specification defines referential constraints that specify properties of the dependent entity must be the same as the corresponding properties of the principle entity. This is similar to a foreign key in a database which specifies that the property of a dependent row must match the (typically primary key) properties of a row in the principle table. Foreign keys in a database are defined through Referential Constraints which have a DeleteRule and an UpdateRule that specify what happens to dependent rows when the principle row is deleted or updated.\n\nIn OData, the referential constraint implicitly includes the navigation property which enforces the uniqueness constraint required in relational databases. This allows us to define referential constraints on sets of properties that may not be unique outside of the implicitly added to 0..1 navigation property.\n\nIn OData we also define an OnDelete rule that specifies what happens if the principle entity is deleted. However, we don't define an UpdateRule. We also don't say what happens if the client tries to update a dependent property (which would be an error if they didn't at the same time change the navigation property to point to a principle entity with the same value).\n\nThe reasonable behavior would be for updates to the dependent properties to be ignored by the service and for updates to the referenced property in the primary entity to \"cascade\" to the dependent entities. This fits well with the denormalization scenario we were trying to support in allowing the referential constraint to support non-key properties. We even imply this strongly in the insert case by saying that dependent properties may be omitted and must be ignored by the service in inserting a new entity, we just are not as clear in the updating section, when we talk about omitting \"key and non-updatable properties\" that this includes dependent properties defined within a referential constraint.\n\n### Proposal\n\nClarify that:\n1. Dependent properties that rely on non-key principle properties are ignored on update.\n2. Updating a dependent property that relies on key principle properties effectively updates the relationship as long as a related entity with the specified key value(s) exists; otherwise the update fails.\n3. If both a bind operation and a property value dependent upon a key of the principle of the same navigation are specified in an update payload, the bind operation \"wins\" and the dependent property is ignored.\n4. Changes to non-key principle properties \"cascade\" to all dependent entities\n5. If a nav prop is null, then the dependent property is null \n6. Having a nullable nav prop implies the dependent property is nullable. It is an error if it is declared as nullable=\"false\"\n7. Having a non-nullable nav prop with a non-nullable principle property requires that the corresponding dependent property is defined with nullable=\"false\" \n8. For purposes of PUT, the default value for dependent properties is the value of the principle property (i.e., they don't get reset). Make sure it's clear that all dependent properties are defaulted to properties of the principle on POST.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50877/odata-meeting-54_on-20131001-minutes.html#odata-490\n\nImported from [ODATA-490](https://issues.oasis-open.org/browse/ODATA-490)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify wording for OnDelete",
    "body": "The OnDelete element is intended to specify what happens to entities related by the containing navigation property when the entity containing the navigation property is deleted.\n\nIn the current specification we refer to the entity containing the navigation property as the \"source\" entity, but that term is not well defined as we have used that term in the past to indicate directionality of a relationship, not necessarily the object on which something is defined. Maybe say something like \"A navigation property MAY define one edm:OnDelete element. It describes the action the service will take on related entities when the entity on which the navigation property is defined is deleted.\"\n\nWe could be even more clear that it is the entities related according to the navigation property (not all related entities), but hopefully that should be apparent?\n\n### Proposal\n\nIn section 7.3 of [CSDL], Change the text:\n\"A navigation property MAY define one edm:OnDelete element. It describes the action the service will take on related entities when the source entity is deleted.\"\nto:\n\"A navigation property MAY define one edm:OnDelete element. It describes the action the service will take on related entities when the entity on which the navigation property is defined is deleted.\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-489\n\nImported from [ODATA-489](https://issues.oasis-open.org/browse/ODATA-489)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]