[
  {
    "title": " Be consistent in citing rules around namespace qualification",
    "body": "We need to be consistent wherever we reference namespace qualification:\n1) That aliases can be used, and\n2) Where the alias is defined (in $metadata for payloads, document local for CSDL)\n\nConsider putting this in one place and referencing it.\n\n### Proposal\n\nSee description\n\nImported from [ODATA-915](https://issues.oasis-open.org/browse/ODATA-915)",
    "labels": [
      "ATOM Format",
      "CSDL JSON",
      "JSON Format",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Comments from OASIS Technical Advisory Board (TAB)",
    "body": "See TAB comments: https://lists.oasis-open.org/archives/odata-comment/201602/msg00006.html\n\n### Proposal\n\nApply proposed changes to next draft revision\n\nImported from [ODATA-914](https://issues.oasis-open.org/browse/ODATA-914)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should we specify a default response format if neither Accept header nor system query $format are specified",
    "body": "Ref: Section 7 Formats\nRef: Section 11.2.10 System Query Option $format\n\n### Proposal\n\nif client doesn't specify Accept header, service can return any format (including OData JSON with no metadata)\n\nImported from [ODATA-913](https://issues.oasis-open.org/browse/ODATA-913)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify what clients should do if they see an unknown/invalid expression for a known annotation term.",
    "body": "In [ODATA-786](https://issues.oasis-open.org/browse/ODATA-786) we added new path expressions for OData 4.01, which brings up a question of what clients should do if they get an expression that they can't understand.  We already say clients should ignore terms they don't understand, but we need to provide direction on what clients should do if they don't understand the expression.  Or we need to make, i.e., the new expressions added to [ODATA-786](https://issues.oasis-open.org/browse/ODATA-786) only supported for clients that request ODATA 4.01 or greater.\n\n### Proposal\n\nClients should treat an invalid value (including invalid type, invalid literal expression, etc) as an unknown value for the term and not error.\n\nImported from [ODATA-912](https://issues.oasis-open.org/browse/ODATA-912)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Miscellanous feedback (public comment c201602e00003)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201602/msg00003.html.\n\nSummary\n- 4.1.1 prose text describing structure of \"keys\" array doesn't match example 6 \n(editor's note: example is correct, prose text is garbled)\n\n- 4.1.2.5 Nullable Properties, Example 36: \"format\":\"decimal\" seems to be missing\n(editor's note: it is missing, should be there according to table in 4.1.2.1)\n\n- a flag \"nullable\" would avoid the need to reverse-engineer this information from the type array tailored for validators\n(editor's note: this is currently discussed for Swagger, see https://github.com/OAI/OpenAPI-Specification/issues/229)\n\n- 4.5.3.2 Path Expressions: The 2nd list does not contain @odata.navigationPropertyPath\n(editor's note: needs to be added)\n\n- 4.5.3.6 Expression Apply: mismatch between prose text and example\n(editor's note: needs to be fixed)\n\n- 4.5.3.10 Expression Not: can this contain annotations?\n(editor's note: yes)\n\n- 4.5.3.11 Expression Null: Why do annotations not live next to @odata.null, like it is the case for @odata.if etc.? Comment gives two proposals for a simpler syntax\n(editor's note: if edm:Null is an item in a collection it needs to be represented as either just null or as an object. Could make that dependent on the existence of annotations within edm:Null or accept feature loss in JSON representation)\n\n- 4.5.3.12 Expression UrlRef: The text does not fit to the example, but I think the example is better and should win ;-)\n(editor's note: agreed :-)\n\n\n### Proposal\n\nApply to next draft revision\n\nIntroduce x-nullable keyword\n\nRepresent edm:Null just as null if it doesn't contain annotations\n\nImported from [ODATA-911](https://issues.oasis-open.org/browse/ODATA-911)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider format that is tailored for programmatic access (public comment c201602e00002)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201602/msg00002.html: \n\nHello!\n\nMy team is consuming OData v4 in the browser as part of OpenUI5 with the goal to support business applications. Here are some comments based on this background.\n\n“This JSON format for CSDL is based on JSON Schema.”\n\nI fully understand the idea to express CSDL as s.th. which can be validated by a tool, but I think this is only one aspect. There is for sure a need for code to inspect the CSDL and react on it programmatically, not with a focus on validation, but on generic UI support (derive type information, labels, structures of tables or forms, etc.). I believe this can benefit from a JSON format which is tailored for programmatic access and not constrained by some validation tool’s data structures. Such code would have some knowledge about OData and its semantics, in contrast to generic validators which are unaware of that.\n\nI appreciate that the chosen MIME type “application/schema+json” leaves room for coexistence of such formats.\n\n“If the structured type has a base type, the schema contains the keyword allOf whose value is an array with a single item: a JSON Reference to the definition of the base type.” This is fine for validators, but unwieldy for normal _javascript_ access.\n\n“4.1.3 Enumeration Types”: The emphasis on member names is fine for human readability, documentation, debugging etc., but it does not help to build applications which are really fast. To do so, integers would be much better, both in data and meta data.\nI also wonder how valuable the “pattern” is: it allows for arbitrary number representations and quite useless string representations like “Red,Red,Red,Red,Red,…”? Again, a simple integer with a range or a list of allowed values should be easier, faster, safer.\n\n(4.3) “The entityContainer object may contain name/value pairs entitySets, singletons, actionImports, and functionImports.” This is a nice way to tell entity sets and singletons apart, but on the other hand, if you only got a name you need to look into different maps until you find it. At times, it is more convenient to look into a single map and then inspect a type information contained inside the resulting object.\n\n“An object describing an entity set must have an entityType”, “An object describing a singleton must have a type”: This inconsistency hurts sometimes.\n\nCiao,\nThomas\n\n### Proposal\n\nInheritance: add \"x-baseType\" extension keyword in addition to \"allOf\" keyword.\n\n4.1.3 Enumeration Types: OpenAPI specification doesn't support \"anyOf\" keyword, so enumeration types are represented just as string enums without the ambiguous \"pattern\". \n\n4.3 Entity Container: use \"resources\" name/value pair whose value is an object with one name/value pair per entity container child. Add name/value pair \"kind\" to the object describing the container child\n\nEntitySet/@EntityType and Singleton/@Type: since we introduce keyless entity types for singletons we won't use complex types for singletons, so the JSON format can use the same keyword \"type\" for both resource kinds\n\nImported from [ODATA-910](https://issues.oasis-open.org/browse/ODATA-910)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ABNF for pathPrefix should also allow qualifiedComplexTypeName",
    "body": "$apply can be used on collections of entity types as well as collections of complex types, but rule pathPrefix only allows type-cast to entity types.\n\n### Proposal\n\nChange rule to \n\npathPrefix       = [ ( qualifiedEntityTypeName / qualifiedComplexTypeName ) \"/\" ] *( pathSegment \"/\" ) \n\n\nImported from [ODATA-909](https://issues.oasis-open.org/browse/ODATA-909)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Header Content-Type shouldn't be required for media types",
    "body": "This section misquotes RFC7231 and states that a Content-Type header MUST be present.\n\nhttps://tools.ietf.org/html/rfc7231#section-3.1.1.5 only says SHOULD\n\nNote that browsers may not specify a content type in some cases. This means that a client can upload a media type without specifying a content-type, the service can store it, and then return the media in a response but may not know what the content-type is (server could return application/octet-stream).\n\n\n\n\n### Proposal\n\nWhile we can be more restrictive in OData by requiring the Content-Type header in responses, we want to allow for cases where the upload client doesn't specify a content-type. \n\nTherefore, we should change Content-type from MUST to SHOULD for media types only. This allows a service to return content received with no content type as either application/octet-stream or without a content type.\n\nImported from [ODATA-908](https://issues.oasis-open.org/browse/ODATA-908)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider Swagger for describing OData metadata in JSON format (public comment c201602e00000)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201602/msg00000.html:\n\nHi,\n\nsince Swagger was donated to the Open API Initiative it seems to become the de facto standard for representing RESTful APIs. To reduce the number of alternatives I strongly recommend to consider Swagger for describing OData metadata in JSON format and to work with the Swagger team on needed enhancements,\n\nKarl\n\n\n\n### Proposal\n\n1) Base next draft of JSON CSDL on Swagger 2.0 (= OpenAPI.Current)\n\n2) Get in contact with OpenAPI Initiative and discuss possible extensions of Swagger that would make it easier to describe OData APIs with OpenAPI.Next \n\nImported from [ODATA-907](https://issues.oasis-open.org/browse/ODATA-907)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider how to specify an included namespace as a default in JSON CSDL",
    "body": "In [ODATA-812](https://issues.oasis-open.org/browse/ODATA-812) we added the concept of a default namespace, and allowed annotations from these default namespaces to be represented without namespace qualification.  We said that the service defined certain namespaces as default in $metadata by annotating the <Include> element.\n\nWhile <Include> is not currently an annotatable element, there doesn't seem to be any problem making it annotatable. However, we have to consider how we would annotate this element in JSON CSDL.\n\n### Proposal\n\nEmbed the corresponding annotation within the JSON object representing a schema or reference to an included schema:\n\n{\n    \"$Version\": \"4.01\",\n    \"$EntityContainer\": \"ODataDemo.DemoService\",\n    \"$Reference\": {\n        \"http://docs.oasis-open.org/odata/odata-vocabularies/v4.0/vocabularies/Org.OData.Core.V1.json\": {\n            \"$Include\": [\n                {\n                    \"$Namespace\":\"Org.OData.Core.V1.\",\n                    \"$Alias\": \"Core\",\n                    \"@Org.OData.Core.V1.DefaultNamespace\": true\n                }\n            ]\n        }\n    },\n    \"ODataDemo.\": {\n        \"$kind\": \"Schema\",\n        \"@Org.OData.Core.V1.DefaultNamespace\": true\n    },\n\nImported from [ODATA-906](https://issues.oasis-open.org/browse/ODATA-906)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 67: result row for USA, Sugar missing, Example 68: last total should be 7",
    "body": "\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-905](https://issues.oasis-open.org/browse/ODATA-905)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 55: clarify groupby in combination with relationships of instance cardinality zero",
    "body": "Example 55:\n\n  GET ~/Customers?$apply=groupby((Country,Sales/Product/Name))\n\nThe example result does not contain an entry for country France. The example data contains a customer in France that does not have any sales.\n\nThe prose text before the example states expansion \"in a left-outer-join fashion\".\n\nThis would suggest that a result row is missing:\n\n  { \"@odata.id\": null, \"Country\": \"France\", \"Sales\": [ { \"Product\": { \"Name\": null } } ] }\n\nThis would be consistent with both the left-outer-join statement and the URL conventions for path expressions where properties of related entities are treated as null if no entity is related:\n- the left-outer join would produce a single Sales row containing only null values, including the related product and its name\n- this would create a (\"France\",null) group during aggregation\n- folding back into the original shape would create the additional entry\n\n### Proposal\n\nExplicitly state what \"left-outer-join fashion\" means, i.e. not inventing dummy records with null values, instead use empty arrays that match the $expand structure:\n\n \n```json\n{ \"@odata.id\": null, \"Country\": \"France\", \"Sales\": [ ] }\n```\n \n\nFix the unbalanced curly braces in all result rows while we are at it.\n\nImported from [ODATA-904](https://issues.oasis-open.org/browse/ODATA-904)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ABNF: should allow cast segment following collection of complex types",
    "body": "OData supports a type segment following a single or collection of entity or complex types.  The ABNF erroneously omits the type cast segment for collections of complex types.\n\nHere is the current ABNF:\n\npropertyPath = entityColNavigationProperty [ collectionNavigation ]\n             / entityNavigationProperty    [ singleNavigation ]\n             / complexColProperty          [ collectionPath ]\n             / complexProperty             [ complexPath ]\n             / primitiveColProperty        [ collectionPath ]\n             / primitiveProperty           [ singlePath ]\n             / streamProperty              [ boundOperation ]\n\ncollectionPath = count / boundOperation\n\nsinglePath     = value / boundOperation\n\ncomplexPath    = [ \"/\" qualifiedComplexTypeName ] \n                 ( \"/\" propertyPath \n                 / boundOperation\n\n\n### Proposal\n\nCorrect the ABNF to allow a type cast segment to follow a collection of complex types, which can proceed the count or bound Operation for collections of complex types.\n\nALSO, clarify that prose is normative, abnf is minimal set of rules\n\nImported from [ODATA-903](https://issues.oasis-open.org/browse/ODATA-903)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "4.5.2: make \"annotations\" a hash-map with the target as key",
    "body": "Annotations with external targeting are currently represented as an array of objects with a \"target\" property. This forces consumers to loop over the array in order to find all annotations for a given target, a common use case in UIs.\n\nUsing an object that is a hash-map from target to all annotations for this target would be much more convenient.\n\n\n\n### Proposal\n\nThe value of \"annotations\" is an object with one name-value pair per target for which annotations exist. The name of this pair is the target, the value is an object that contains all annotations for this target.\n\nImported from [ODATA-902](https://issues.oasis-open.org/browse/ODATA-902)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "substring: Define negative index for substring function",
    "body": "This could be a \"bad request\" returning no results at all, or it could evaluate to null, which may just lead to excluding the offending instance from the result.\n\nOr a mix of both: negative start index is \"bad request\", start index or desired length beyond the end of the first argument is \"null\".\n\n### Proposal\n\nIn [ODATA-781](https://issues.oasis-open.org/browse/ODATA-781) we defined that a negative index in substring is explicitly undefined, since we did not define a behavior and there were at least two valid interpretations, and that interoperable clients should not use negative indexes. \n\nIn 4.01, we agreed that negative indexes should mean count from the end.\n\nin particular, substring(string,-n,m) is equivalent to substring(string,length(string)-n,m)\n\nImported from [ODATA-901](https://issues.oasis-open.org/browse/ODATA-901)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Cross-service navigation and service versioning",
    "body": "Assume Orders and Customers are in different services and have cross-service navigation properties to each other:\n  GET Customers('ALFKI')/Orders\n  GET Orders(4711)/Customer\n\nNow a new version v2 of the Customer service is published. \n\nIdeally the Order service now automatically navigates to the new (latest) Customer service without requiring a new version of the Order service, and in addition allows navigation to the old version:\n  GET Orders(4711)/Customer -> navigates to Customer v2\n  GET Orders(4711)/Customer;v1 -> navigates to Customer v1\n\n### Proposal\n\nClose without action\n\nImported from [ODATA-900](https://issues.oasis-open.org/browse/ODATA-900)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Type cast segment after $all",
    "body": "The $all resource path can optionally be followed by a type-cast segment to allow filtering, sorting, etc. This is specified in the prose specification Part 2: URL Conventions, section 4.12.\n\nThe ABNF for resource path $all does not contain this optional segment\n\n### Proposal\n\nABNF:\n\nresourcePath = entitySetName                  [ collectionNavigation ] \n             / singletonEntity                [ singleNavigation ]\n             / actionImportCall \n             / entityColFunctionImportCall    [ collectionNavigation ] \n             / entityFunctionImportCall       [ singleNavigation ] \n             / complexColFunctionImportCall   [ collectionPath ] \n             / complexFunctionImportCall      [ complexPath ] \n             / primitiveColFunctionImportCall [ collectionPath ] \n             / primitiveFunctionImportCall    [ singlePath ] \n             / crossjoin\n             / '$all'                         [ \"/\" qualifiedEntityTypeName ]\n\nlast line now allows type-cast segment\n\n\nURL Convention: adapt ABNF snippet in section 4.3 Addressing Entities\n\nImported from [ODATA-899](https://issues.oasis-open.org/browse/ODATA-899)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow the count of a filtered/searched collection in common expressions",
    "body": "The count of a collection-valued (structural or navigation) property can already be used in common expressions, e.g. in $orderby. \n\nIt would be useful to also allow the /$count segment followed by a nested filter or search option, e.g. \n\nGET entitySet?$filter=navigationProperty/$count($filter=YYY) gt 5&$expand=navigationProperty/$count($filter=XXX)&$orderby=navigationProperty/$count($filter=XXX) desc\n\nto get the entities with the highest number of related entities matching filter first.\n\nThis was proposed on the Olingo mailing list: http://mail-archives.apache.org/mod_mbox/olingo-user/201512.mbox/%3C5662B48C.7020305%40gmail.com%3E\n\n### Proposal\n\nExtend first alternative in rule collectionPathExpr with optional $filter and $search options, identical to $expand\n\ncollectionPathExpr = count [ OPEN expandCountOption *( SEMI expandCountOption ) CLOSE ]\n                   / \"/\" boundFunctionExpr\n                   / \"/\" anyExpr\n                   / \"/\" allExpr\n\nImported from [ODATA-897](https://issues.oasis-open.org/browse/ODATA-897)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Reconsider guidance on odata.count position (public comment c201512e00001)",
    "body": "In the JSON format, we say in section 12: \"The odata.count name/value pair represents the number of entities in the collection. If present, it MUST come before the value name/value pair. \"\n\nPer public feedback - https://lists.oasis-open.org/archives/odata-comment/201512/msg00001.html - we should consider softening this statement to SHOULD, and perhaps clarify which page(s) it should appear on.\n\n### Proposal\n\nFor Errata 3: clarify that ordering constraint is only enforced for odata.streaming=true.\n\nFor server-driven paging, for odata.streaming=false, the odata.count must appear on at least the first page and may appear on subsequent pages (in which case it may vary from page to page).\n\nImported from [ODATA-896](https://issues.oasis-open.org/browse/ODATA-896)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support keyless entities for singletons",
    "body": "Entity types that are used for singletons, or targets of a single-valued containment navigation property, don't need keys. Keys are only required when accessing an entity within a collection.\n\nWe could consider relaxing the requirement that entity types used exclusively for singletons/single-valued containment nav props have keys. We would have to carefully think through the ramifications of doing this, but they should always be able to be accessed through their canonical URL without a key. \n\n### Proposal\n\nRelax the requirement that only abstract entity types aren't required to have keys, but require that any entity type used in a collection must have a key. \n\nAllow a singleton or single-valued containment navigation property to use a type without having to define an arbitrary/meaningless key property.\n\nIt is a breaking schema change to add/modify/remove a key in an entity definition. \n\nImported from [ODATA-895](https://issues.oasis-open.org/browse/ODATA-895)",
    "labels": [
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support overwriting property in derived type with a property of a type derived from property in base type",
    "body": "Today we allow types to derive from base types and define new properties, but we don't allow overriding existing complex typed properties with derived complex typed properties.\n\nThat means I can define a type FOO with property bar of type BAR:\n\n<EntityType Name=\"FOO\" IsAbstract=\"True\">\n    <Property Name=\"bar\" Type=\"ns.BAR\"\n</EntityType>\n\n<ComplexType Name=\"BAR\">\n  <Property Name=\"property1\" Type=\"Edm.String\"/>\n</ComplexType>\n\nI can define type FOO2 that adds required properties to FOO, and I can define type BAR2 that adds required properties to BAR:\n\n<EntityType Name=\"FOO2\" BaseType=\"ns.FOO\">\n    <Property Name=\"requiredOnFOO2\" Type=\"Edn.String\" Nullable=\"false\"/>\n</EntityType>\n\n<ComplexType Name=\"BAR2\" BaseType=\"ns.BAR\">\n  <Property Name=\"requierdpropertyOnBAR2\" Type=\"Edm.String\" Nullable=\"false\"/>\n</ComplexType>\n\nBut I can't add require that instances of FOO2 have the required properties of BAR2 (i.e., that property bar be of type BAR2).\n\nWhat we would need to do in order to support this is to allow a property in a derived type to override a complex-typed property of the base type with a complex type that is derived from the type of the property in the base type.\n\nFor example:\n<EntityType Name=\"FOO2\" BaseType=\"ns.FOO\">\n    <Property Name=\"bar\" Type=\"ns.BAR2\" />\n</EntityType>\n\nThe definition of \"bar\" in FOO2 overrides the definition of \"bar\" in FOO, meaning that any property \"bar\" of an instance of FOO2 must be of type BAR2.\n\n### Proposal\n\nAllow a property in a derived type to override a property of the base type with a property that is derived from the type of the property defined in the base type.  i.e., complex type with derived complex type, edm.primitive with primitive, entity type of a nav prop with entity type of a nav prop.\n\nImported from [ODATA-894](https://issues.oasis-open.org/browse/ODATA-894)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Is @odata.type required on update of a derived type",
    "body": "The question came up recently as to whether the @odata.type attribute is required when updating a type derived from the type specified for a collection.\n\nCurrently in the protocol spec we say: \"The service ignores entity id and entity type values in the payload when applying the update.\"\n\nThis was added to clarify that:\n1) Clients couldn't change the type of an existing entity, and that\n2) Services weren't required to validate that the type specified in the update was the same as the actual type of the object; it could just apply the values and returned an error if any properties were invalid.\n\nHOWEVER, in the JSON format specification we say that:\n\n\"The odata.type annotation MUST appear in requests and in responses with minimal or full metadata, if the type cannot be heuristically determined, as described below, and one of the following is true:\n•         The type is derived from the type specified for the (collection of) entities or (collection of) complex type instances, or\n•         The type is for a property whose type is not declared in $metadata.\"\n\nAnd, in fact, some frameworks may require the type annotation in order to materialize an object of the correct type from the payload from which to apply the update.\n\nEither way, we should clarify the documents to be consistent.\n\n### Proposal\n\n11.4.3 Update an Entity, paragraph 8: \n\nEntity id and entity type cannot be changed when updating an entity. However, format-specific rules can require providing entity id and entity type values in the payload when applying the update.\n\nImported from [ODATA-893](https://issues.oasis-open.org/browse/ODATA-893)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify dynamic properties support in $filter, $orderby, $expand",
    "body": "Section 5.1.1.7 Path Expressions in [URL] describes how properties and navigation properties can be used as operands or function parameters.\n\nWe do not explicitly call out (as we do in $select) how dynamic properties are treated.\n\n\n### Proposal\n\nAdd to section 5.1.17 Path Expressions:\n\n\"If the property (or navigation property) is not defined for the type of the resource, and that type is defined supports dynamic properties (navigation properties), then the property (or navigation property) is treated as null for all instances on which it has no value.\"\n\n\"If the property (or navigation property) is not defined for the type of the resource, and that type does not support dynamic properties (navigation properties), then the request may be considered malformed.\"\n\nIn section 5.1.2, System Query Option $expand, replace:\n\"The navigationProperty segment MUST identify a navigation property defined on the entity type of the request, the derived entity type specified in the type cast, or the last complex type identified by the complex property path. \"\nwith:\n\"If the type does not support dynamic navigation properties, then the navigationProperty segment MUST identify a navigation property defined on the entity type of the request, the derived entity type specified in the type cast, or the last complex type identified by the complex property path. Otherwise, if the type does support dynamic navigation properties, if the navigationProperty segment does not identify a declared navigation property, the expanded property appears only for those instance on which it has a value.\"\n\n(more specifically: at any point in the path, if a segment does not match a member of the previous segment, then the type of the previous segment must allow dynamic properties.)\n\nImported from [ODATA-892](https://issues.oasis-open.org/browse/ODATA-892)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Misleading reference to \"open\" in description of $select",
    "body": "The description for the $select system query option says the following:\n\n\"If the selectItem is not defined for the type of the resource, and that type is defined as open, then the property is treated as null for all instances on which it is not defined.\"\n\n\"If the selectItem is not defined for the type of the resource, and that type is not defined as open, then the request is considered malformed.\"\n\nThis is misleading, as readers may interpret \"defined as open\" to mean that they have the \"OpenType\"=\"True\" attribute. However, In OData V4 we say that any type may have dynamic properties, and that OpenType tells the client whether or not they can add additional properties to an instance.\n\n\n### Proposal\n\n\"If the selectItem is not defined for the type of the resource, and that type supports dynamic properties, then the property is treated as null for all instances on which it is not defined.\"\n\n\"If the selectItem is not defined for the type of the resource, and that type does not support dynamic properties, then the request is considered malformed.\"\n\nImported from [ODATA-891](https://issues.oasis-open.org/browse/ODATA-891)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify how to get from a JSON message to a JSON schema for validating this message",
    "body": "Multiple options:\n- describe in the prose specification how to construct this validation schema from the context URL\n- include a $schema name-value pair linking to such a schema (which could be part of a larger file)\n- use link header with relation \"describedby\", see https://tools.ietf.org/html/rfc5988\n- ...\n\n### Proposal\n\nDescribe in the prose specification how to construct this validation schema from the context URL.\n\nImported from [ODATA-890](https://issues.oasis-open.org/browse/ODATA-890)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make edm.json a stand-alone schema",
    "body": "Don’t extend JSON Schema, instead make edm.json a stand-alone schema that in parts references JSON Schema draft 04, i.e. define “definitions” with pattern properties that have JSON Schema values plus OData keywords etc.\n\n\nImported from [ODATA-889](https://issues.oasis-open.org/browse/ODATA-889)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow $search for all collections",
    "body": "$search is currently restricted to collections of entities. It should also be allowed for collections of complex and primitive type instances, identical to the applicability of $filter.\n\nImported from [ODATA-888](https://issues.oasis-open.org/browse/ODATA-888)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should we allow multi-part namespace alias names?",
    "body": "Currently namespace aliases are defined as simple identifiers, while namespaces can (but are not required to) be multi-part.\n\nUnclear why there is this distinction; it's not possible to tell from a single-part name whether the name references a namespace or an alias, so why prohibit multi-part names (i.e., names containing a dot (\".\")) in aliases?\n\nThere are scenarios where a namespace is long that an application may want to use a shorter name but still represent some level of hierarchy in the naming scheme. \n\n### Proposal\n\ndon't allow multi-part alias names as it would break atom and likely not be supported in programming languages.\n\nImported from [ODATA-887](https://issues.oasis-open.org/browse/ODATA-887)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Need a stable reference to latest/current OASIS OData vocabularies",
    "body": "The latest published errata for all of our specs are available at http://docs.oasis-open.org/odata/odata/v4.0/ (for the protocol specification) and at http://docs.oasis-open.org/odata/odata-json-format/v4.0/ (for the odata json specification).\n\nWe don't have a way for applications to get to the latest versions of the vocabularies.\n\n### Proposal\n\nRequest a new standards track work product for \"Vocabularies\" that will contain a small prose document and pointer to the vocabularies as additional artifacts. \n\nImported from [ODATA-886](https://issues.oasis-open.org/browse/ODATA-886)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Permissions should apply to more than just properties",
    "body": "Currently the Permissions term includes the \"AppliesTo\" attribute with a value of \"Property\".  While \"AppliesTo\" is not prescriptive, it would be nice (if we keep it at all) to list some of the other places Permissions can be applied (NavigationProperty, type, etc.)\n\n### Proposal\n\nAdd to AppliesTo: EntityType, ComplexType, TypeDefinition, EntitySet, NavigationProperty, Action, Function \n\nAdd \"Invoke\" to the Permissions enum\n\nClarify that Invoke can not be combined with any of the other flags.\n\nImported from [ODATA-885](https://issues.oasis-open.org/browse/ODATA-885)",
    "labels": [
      "Vocabularies",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow describing possible responses to requests for a particular resource (public comment c201510e00019)",
    "body": "Jeff Wight proposes to add a term that allows describing possible code values in OData error responses, see [https://lists.oasis-open.org/archives/odata-comment/201510/msg00019.html]\n\nExample:\n```xml\n<Annotation Term=\"Core.ErrorCodes\">\n  <Collection>\n    <Record>\n      <PropertyValue Property=\"HttpMethod\" String=\"GET\" />\n      <PropertyValue Property=\"HttpStatusCode\" String=\"400\" />\n      <PropertyValue Property=\"ODataErrorCode\" String=\"QueryFilterFunctionNotSupported\" />\n      <PropertyValue Property=\"Description\"\n String=\"This error indicates that a request was made with a filter function that isn’t supported on this entity set. Please refer to the Capabilities.FilterFunctions annotation on this entity set for a list of supported functions, and the exact error message for which function usage triggered this error.\" />\n    </Record>\n  </Collection>\n</Annotation>\n```\nDefinition\n```xml\n<Term Name=\"ErrorCodes\" Type=\"Collection(Core.ErrorCodeType)\" AppliesTo=\"EntitySet Singleton ActionImport FunctionImport Action Function\">\n  <Annotation Term=\"Core.Description\" String=\"Describes possible error codes in OData responses\" />\n  <Annotation Term=\"Core.LongDescription\" String=\"The list need not be complete. It may be used to generate API documentation, so restricting it to the most common and most important errors may increase readability.\" />\n</Term>\n\n<ComplexType Name=\"ErrorCodeType\">\n  <Property Name=\"HttpMethod\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"Request verb of the HTTP request, e.g. GET, POST, PATCH, DELETE\" />\n  </Property>\n  <Property Name=\"HttpStatusCode\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"HTTP status code of the response, e.g. 400, 403, 501\" />\n  </Property>\n  <Property Name=\"ODataErrorCode\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"Language-independent, machine-readable OData error code\" />\n  </Property>\n  <Property Name=\"Description\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"Human-readable description of the error situation\" />\n  </Property>\n</ComplexType>\n```\n\n### Proposal\n\nAdd a property `ErrorResponses` to the `Capabilities` terms `InsertRestrictions`, `UpdateRestrictions`, `DeleteRestrictions`, `ReadRestrictions`, and `OperationRestrictions`:\n```xml\n<Property Name=\"ErrorResponses\" Type=\"Collection(Capabilities.HttpResponse)\">\n  <Annotation Term=\"Core.Description\" String=\"Possible HTTP Responses returned by the request.\" />\n</Property>\n```\nThe structure of this property is:\n```xml\n<ComplexType Name=\"HttpResponse\">\n  <Property Name=\"StatusCode\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"HTTP status code of the response, e.g. 400, 403, 501\" />\n  </Property>\n  <Property Name=\"Description\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"Human-readable description of the response code.\" />\n    <Annotation Term=\"Core.IsLanguageDependent\" />\n  </Property>\n</ComplexType>\n```\n\nImported from [ODATA-884](https://issues.oasis-open.org/browse/ODATA-884)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Validation Vocabulary: add MultipleOf term",
    "body": "Add a term that allows to specify the granularity of a temporal or numeric data type\n\n### Proposal\n\nAdd term MultipleOf:\n\n      <Term Name=\"MultipleOf\" Type=\"Edm.Decimal\" AppliesTo=\"Property Parameter Term\">\n        <Annotation Term=\"OData.Description\" String=\"The value of the annotated property, parameter, or term must be an integer multiple of this positive value. For temporal types the value is measured in seconds.\" />\n      </Term>\n\nImported from [ODATA-883](https://issues.oasis-open.org/browse/ODATA-883)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Mismatch between 11.2.6 Requesting Related Entities and 11.2.7 Requesting Entity References",
    "body": "11.2.6 defines that requests to nullable single-valued navigation properties return 204 No Content if no entity is currently related.\n\n11.2.7 defines that all requests for references to a single entity return 404 Not Found, not distinguishing between \"direct\" resource paths and resource paths to related entities.\n\nThis leads to:\n\nGET Employees('TheBigBoss')/Manager --> 204 No Content\nGET Employees('TheBigBoss')/Manager/$ref --> 404 Not Found\n\nClarify whether this is intentional:\nA) Of course, the related Manager is empty, so the reference does not exist, or\nB) Ooops, of course both requests should return the same response code because /$ref is just a briefer representation of the non-existing related entity\n\nAlso clarify what happens if other path segments are added, e.g. properties or navigation properties:\n\nGET Employees('TheBigBoss')/Manager/Name --> ???\nGET Employees('TheBigBoss')/Manager/Department --> ???\n\n\n### Proposal\n\nDefine:\n1)  /entity(exist)/null_nav_prop/$value – 404 (for nav to media entity)\n2)  /entity(exist)/null_structuralmedia_prop - 204\n3)  non_media_entity/$value is a bad request (i.e., 400)\n4) specify that some services may return 204 for /entity(exist)/null_nav_prop/$ref (and that we expect that to be the preferred response in 4.01). Therefore, clients should be prepared to receive either 204 or 404 for this condition.\n5) in 4.01, make 204 the preferred response for 4.01 clients. \n\nImported from [ODATA-882](https://issues.oasis-open.org/browse/ODATA-882)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add support for Edm.Untyped",
    "body": "We see a lot of scenarios where people are building REST services that return JSON payloads, but the JSON they need or want to generate is not supported by OData (for example, a mixed array or an array of arrays). This payload still has structure, it just can't necessarily be described by OData CSDL.\n\nFor such payloads we could add an Edm.Untyped data type. Services could use Edm.Untyped to advertise that there was a property of a particular name present, but there is no type to describe the structure of the schema. It is essentially treated as an open property.\n\nThe value of an Edm.Untyped property may be a primitive value, a structural value, or a collection. If a collection, it may contain any combination of primitive values, structural values, or collections (this is the only place a collection can contain a collection or a collection can contain a mix of primitive values, structural values, or collections).\n\nEdm.Untyped could also be used within a payload to specify that the current structured object has no declared type. It is either an anonymous structured (i.e., complex) type or an array.\n\nAll structured dynamic properties, and all children of an Edm.Untyped property, are assumed to be untyped unless they are annotated with the \"@odata.type\" term, in which case they must conform to the type described by the annotation.\n\n\n\n### Proposal\n\nAdd an Edm.Untyped data type that services can use to advertise (in metadata or payloads) that there is a property of a particular name present, but there is no type to describe the structure of the schema. It is essentially treated as a (named) dynamic property. \n\nThe value of an Edm.Untyped property may be a primitive value, a structural value, or a collection. If a collection, it may contain any combination of primitive values, structural values, or collections (this is the only place a collection can contain a collection or a collection can contain a mix of primitive values, structural values, or collections). \n\nEdm.Untyped could also be used within a payload to specify that the current structured object has no declared type. It is either an anonymous structured (i.e., complex) type or an array. \n\nAll structured dynamic properties, and all children of an Edm.Untyped property, are assumed to be untyped unless they are annotated with the \"@odata.type\" term, in which case they must conform to the type described by the annotation. \n\nThe Edm.Untyped property may only be returned in schema and payload responses that have been requested with an OData-MaxVersion header value of 4.01 or greater.  Services should omit such properties from schema requests with an OData-MaxVersion header of 4.0 and treat such properties in queries and responses as undeclared dynamic properties.\n\nImported from [ODATA-881](https://issues.oasis-open.org/browse/ODATA-881)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.5.10: edm:Null can have edm:Annotation child elements",
    "body": "Text says\n\nThe null expression MUST NOT contain any other elements or expressions.\n\nYet annotations are allowed as child elements\n\n### Proposal\n\nRevised proposal: Change the wording to \"The only allowed child element of the null expression is an edm:Annotation element.\".\n\nImported from [ODATA-880](https://issues.oasis-open.org/browse/ODATA-880)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 84: EntityContainer is a Singleton, not an EntitySet",
    "body": "The response in example 84 shows a \"value\":[{...}] wrapper that is only needed for collection-valued responses, not for the single-entity response appropriate for the EntityContainer singleton.\n\nAlso for Singletons and FunctionImports the key property Fullname was mistyped as QualifiedName.\n\n### Proposal\n\nRemove wrapper\n\nCorrect key property name\n\nImported from [ODATA-878](https://issues.oasis-open.org/browse/ODATA-878)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Must delta responses continue to track \"orphaned\" entities?",
    "body": "If the defining query for a delta response includes an expand, the expanded entities must also be tracked.\n\nBut, what happens if the expanded entity is deleted or removed from tracking, or if the relationship to a child entity is deleted? Must the delta response continue to track the related entities?\n\nFor example, given Customers with a relationship to Orders, and a query for Customers in Washington that expands Orders.  If I:\n  -delete a Customer\n  -change a Customer's state from Washington\n  -remove a relationship from a Customer to an Order\nDo I have to continue tracking changes to the related Order(s)?\n\nDoes the answer depend on whether it's a 1:many relationship (as above) versus a 1:1 (Spouse) or many:many (Orders/Products)?\n\nDoes the answer differ it's a containment relationship (Orders to OrderDetails)?\n\nDoes the answer depend on whether there are other relationships to the same entity?\n\nIt seems that, if the only path to an entity is through an expanded entity that is no longer tracked, or if it's no longer related to that expanded entity, then the service shouldn't have to continue tracking that entity.\n\nPut another way, if the defining query would no longer return the expanded entity due to reasons other than changes to the expanded entity (i.e., that make it no longer match a filtered expand) or the link from the expanded entity being explicitly removed, then the service should not need to (but may continue to) report changes to the \"orphaned\" entity.\n\nIf it does stop tracking, should it return a deleted entity with a reason saying that it's no longer in the graph?. I wouldn't think so, but we should be explicit.\n\n### Proposal\n\nIf a previously tracked related entity is orphaned because all paths to the entity as specified in the defining query have been broken (i.e., due to relationship changes and/or changes or deletions to parent entities) then the service MUST return the appropriate notifications for the client to determine that the entity has been orphaned (i.e., the changed relationships and removed parent entities) but the client should not assume that it will receive additional notifications for such an orphaned entity.\n\nImported from [ODATA-877](https://issues.oasis-open.org/browse/ODATA-877)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow services to return contained entities inline for delta responses",
    "body": "In a delta response for an expanded query we return a flattened result that includes any nested entities that have been added/changed/deleted, along with added/deleted links as appropriate.\n\nWe did this rather than returning expanded content in-line because the semantics of including them inline are unclear; does it mean that only the included inline elements changed, or is it a replacement for the entire set?  How do you represent a deletion of a related entity versus simply removing the relationship to that entity – do you have to have a deleted entry in the current collection for deletions? And what if that deleted entity had related entities, some of which were also changed/deleted; how do you return those in a nested result? \n\nWe generally allow the service to track only that a change has occurred to a given item, not what changed within that item. However, a store may well track contained items along with the entity and not be able to tell whether the set of contained items changed, only that a change occurred somewhere in the containment hierarchy.\n\nFor collections of non-entity types we say that the collection is treated as an atomic value – that, if present, the members represent the full membership of the collection. Services don't have to track individual changes to the collection, they just have to know that something changed and they can give the current membership of the collection.\n\nWe could say the same thing for containment navigation properties – that expanding them in-line means that the set of returned entities represents the full set of contained entities, and any previous entities not listed (and all relationships) are implicitly deleted. The client already has to delete contained entities when the parent is deleted so this shouldn't be too onerous. \n\nWe could consider allowing this for non-containment navigation properties, with the semantic that entities omitted from the collection were no longer related (but not deleted), but any related entities that *were* deleted would have to also be returned as (non-nested) deleted entities, and any changed entities/relationships nested below that deleted entity would have to be separately represented in the payload.\n\n### Proposal\n\nServices MAY return related entities inline in a delta response for expanded navigation properties to collections whose members are not otherwise referenced in the defining query. If a navigation property is present in the response then its value represents the current values for the full set of entities related according to that relationship and satisfying any specified expand options. Any entities not included are no longer members of that collection, either because the related entity has been removed from the collection, deleted, or changed such that it no longer satisfies the expand options in the defining query. In any case, the client SHOULD NOT receive additional notifications for those entities.\n\n1)\tA delta payload (in GET or PATCH) can have inline navigation values (collection or single, entity or ref) [ODATA-876](https://issues.oasis-open.org/browse/ODATA-876)\na.\tDefault semantics of inline collection of entities is replace membership and PATCH (upsert) individual members (existing members must include entity keys or @odata.id update (PATCH semantics), otherwise insert.) \nb.\tFor single-valued nav prop, update reference & PATCH semantics.\nc.\tYou can use contextUrl (ending in /$delta) on the navigation property to specify that the nested content is a delta content (partial update with patch semantics that can contain added/deleted links and tombstones).\ni.\tOpen issue: any restrictions on the added/deleted links?\nii.\tAs a shortcut for nested content in delta format you can specify #$delta as the context (gets context from parent).\n\n\n2)\tYou can GET deltas for/PATCH $all [ODATA-876](https://issues.oasis-open.org/browse/ODATA-876)\na.\tDelta response context URL is metadata-url#$delta\n\n\nImported from [ODATA-876](https://issues.oasis-open.org/browse/ODATA-876)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Use of $ref for referencing elements in a JSON Schema",
    "body": "Should we use $ref to reference the identify of something that must be externally defined (i.e., the function in a functionimport or entity type of an entity set or base term in a term)?\n\nIn places where we choose $ref: should additional keywords that refine/decorate the use of the referenced element be placed next to $ref within the reference object, or should the reference be wrapped in an \"allOf\":[{\"$ref\":\"...\"}] construct and the additional keywords be placed next to allOf?\n\n### Proposal\n\n1) Always use $ref to reference a named type (complex, entity, typedef, enum)\n2) We use odata paths to reference entity sets and singletons\n3) For functions and actions, use $ref\n\n\n\nImported from [ODATA-875](https://issues.oasis-open.org/browse/ODATA-875)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Edm.String as underlying type for enumeration types",
    "body": "While using non-negative integers for flag enum types is natural, some data sources support enumeration types that use strings as the underlying type.\n\nThis was also raised in https://issues.apache.org/jira/browse/OLINGO-803.\n\nImported from [ODATA-874](https://issues.oasis-open.org/browse/ODATA-874)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Define ContentID annotation for deep inserted entities",
    "body": "There is no defined order for expanded nested entities in the response to a request (POST, PUT or PATCH) that creates new entities by a deep insert.\n\n### Proposal\n\nIntroduce a new contentID annotation that the client can specify in the nested entities in the request.  A server advertises support for the contentID instance annotation through the Capabilities.DeepInsertSupport annotation.  Clients can specify the contentID instance annotation in the nested entities in the request.  Services that support the contentID instance annotation MUST annotate the corresponding nested entities in the response when the return=representation preference is applied.\n \nInstance annotation definition:\n \n<Term Name=”contentID” Type=”Edm.String”>\n    <Annotation Term=\"Core.Description\" String=”A unique identifier for nested entities within a request.\"/> \n</Term>\n \nIntroduce a new capabilities annotation for deep inserts:\n \n<Term Name=\"DeepInsertSupport\" Type=\"Capabilities.DeepInsertSupportType\" AppliesTo=\"EntityContainer\"> \n  <Annotation Term=\"Core.Description\" String=”Deep Insert Support for the service\"/> \n</Term> \n\n<ComplexType Name=\"DeepInsertSupportType\"> \n  <Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\"> \n    <Annotation Term=\"Core.Description\" String=\"Service supports deep inserts\" /> \n  </Property> \n  <Property Name=\"ContentIDSupported\" Type=\"Edm.Boolean\" DefaultValue=”true”> \n    <Annotation Term=\"Core.Description\" String=\"Service supports accepting and returning nested entities annotated with the contentID instance annotation.\" /> \n  </Property> \n</ComplexType> \n\nImported from [ODATA-873](https://issues.oasis-open.org/browse/ODATA-873)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider defining structure of bound actions/functions",
    "body": "Bound functions and actions appear in json payloads as properties that start with \"#\" and may contain target, url, etc.  These are not advertised as properties in JSON Schema, because such bound actions/functions can be \"externally defined\". This is okay because we specify additonalproperties=true, but we lack validation that the contents of a bound function or action is valid. Also, we prevent a service that knows it will never return additional properties from publishing that fact.\n\nWe could use patternproperties to enforce that the value of a property that starts with \"#\" is a valid payload for a function or action.\n\nThere is concern that adding this pattern property everywhere a bound function/action could appear might be heavy weight.  \n\nI would like to at least define the shape for an action/function, so that services that want to advertise actions/functions (either through pattern properties or by explicitly advertising actions/functions) can do so.\n\n### Proposal\n\n1) Define the structure of a function or action advertisement\n2) Define an bindableStructuredType that includes property patterns for:functions/actions (that uses the structure above) \n3) Define an annotatableStructuredType that includes property patterns for annotations \n\nImported from [ODATA-872](https://issues.oasis-open.org/browse/ODATA-872)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify odata.type for Compute and Aggregate",
    "body": "Properties computed using the Compute and Aggregate clauses are generally treated as dynamic properties, and thus require an odata.type in the response following the general rules for dynamic properties.  Call this out.\n\n### Proposal\n\nClarify that properties added with Compute or Aggregated MUST include the odata.type following rules defined for dynamic properties\n\n\n\nImported from [ODATA-871](https://issues.oasis-open.org/browse/ODATA-871)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Round-off description for creating related entities when creating an entity",
    "body": "Section 11.4.2.2 calls out two specific rules to be obeyed when creating related entities. They relate to computed properties and dependent properties. In contrast, section 11.4.2 on creating entities lists further rules for open entities. Under the assumption that all rules apply also for related entities, section 11.4.2.2 is incomplete.\n\n\n### Proposal\n\nDon't describe any rules in 11.4.2.2, but merely refer to 11.4.2, like this:\n\"A request to create an entity that includes related entities, represented using the appropriate inline representation, is referred to as a “deep insert”. Media entities, whose binary representation cannot be represented inline, cannot be created within a deep insert.\n\nThe entity is created observing the rules described in section 11.4.2 as if it was posted against the original target URL extended with the navigation property for this related entity. \n\nOn success, the service …”\n\"\n\nImported from [ODATA-870](https://issues.oasis-open.org/browse/ODATA-870)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state the location of the Content-ID header in a change set",
    "body": "Although the examples are clear where the Content-ID header should go in a change set, the text is not.  The multipart spec (RFC 2045 and 2046), do show that the Content-ID header is a MIME-part-header but it doesn't exclude it from being used in other places (consider the Content-Type header which is used both in the MIME-part-header and part of the OData request).\n\n### Proposal\n\nState explicitly that the Content-ID header MUST be part of the MIME-part-header section and not part of the inner OData request.\n\nImported from [ODATA-869](https://issues.oasis-open.org/browse/ODATA-869)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Describe HTTP encoding for streamed requests and responses",
    "body": "OData JSON Format has a format parameter for streaming scenarios but does not describe how these messages should be encoded.\n\nPart 1: Protocol, section 9.4 talks about in-stream errors in a format-independent way. Unfortunately we don't define how these should be represented in the JSON format.\n\nSituations where in-stream errors can occur include\n- metadata requests in XML or JSON\n- data request in JSON or XML\n- media resource requests with any content-type\n\n### Proposal\n\nThe server MUST leave the response as malformed (otherwise there is no way to portably assume the client can detect the error). So, invalid JSON must be returned.\n\nThe easiest way to handle this is for the server to stop serializing the response body.\n\nThe server MAY include information on the source of the error by including a trailing header (available in HTTP/1.1 chunked encoding and in HTTP/2) with name `odata-error` whose value is a header-encoded OData JSON error object.\n\nImported from [ODATA-868](https://issues.oasis-open.org/browse/ODATA-868)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove header Content-Transfer-Encoding, not used in HTTP",
    "body": "In V4 we use the Header Content-Transfer-Encoding:binary  together with the Content-Type: application/http in batch payloads (exactly as in V3 ) and in async responses.\n\nIn HTTP 1.1 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.1 and https://tools.ietf.org/html/rfc7230#section-8.3.2) the media type application/http is defined \"...Encoding considerations: HTTP messages enclosed by this type are in \"binary\" format; use of an appropriate Content-Transfer-Encoding is required when     transmitted via E-mail.\"\n\nAnd in a section about differences between HTTP and MIME entities, the spec states (http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.4.5 and https://tools.ietf.org/html/rfc7231#appendix-A.5): \"HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 2045. [...]\"\n\n\n\n### Proposal\n\nRemove mentioning of header field Content-Transfer-Encoding\n\nImported from [ODATA-867](https://issues.oasis-open.org/browse/ODATA-867)",
    "labels": [
      "Protocol",
      "V4.01_WD01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "3.14 Transformation compute: add reference to numeric promotion rules",
    "body": "Compute expressions are filter expressions that result in a simple value. We didn't explicitly cite the rules for infering the type, especially the rules for numeric promotion.\n\n### Proposal\n\nExplicitly refer to URL Conventions and add sentence:\n\nThe type of the property is determined by the rules for evaluating $filter expressions and numeric promotion defined in [OData-URL].\n\nImported from [ODATA-866](https://issues.oasis-open.org/browse/ODATA-866)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.2.1 Attribute Target: complete list of externally targetable CSDL elements",
    "body": "The bullet list of externally targetable CSDL elements is incomplete: actions, functions and their parameters are only mentioned in paragraphs below the list, easily overlooked. Also hidden below the list is the possibility to override property-level annotations via entity sets or singletons.\n\n### Proposal\n\nAdd bullet items\n\n- Action (applies to all overloads)\n- Function (applies to all overloads)\n- Parameter (applies to all overloads defining this parameter)\n\nChange bullet items\n\n- NavigationProperty (via type, entity set, or singleton)\n- Property (via type, entity set, or singleton)\n\nImported from [ODATA-865](https://issues.oasis-open.org/browse/ODATA-865)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Translate @Core.Description annotations into JSON Schema description keywords",
    "body": "JSON Schema defines keywords title and description, see\nhttp://json-schema.org/latest/json-schema-validation.html#anchor98. \nA \"title\" is short and seems to correspond to field labels or column headers, whereas \"description\" seems to correspond to an explanation shown as a tooltip. The latter seems in sync with use for Core.Description.\n\nCurrently the Core annotation Description is represented as an instance annotation:\n\n\"@Core.Description\": \"Some explanatory text explaining this model element and its use and/or restrictions\"\n\nInstead it could become a JSON Schema description:\n\n\"description\": \"Some explanatory text explaining this model element and its use and/or restrictions\"\n\nPro:\n- Recognizable by JSON Schema consumers\n\nCon:\n- Different representation as @Core.LongDescription which doesn't have a counterpart in JSON Schema\n\nImported from [ODATA-864](https://issues.oasis-open.org/browse/ODATA-864)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Represent Terms similar to Types",
    "body": "[ODATA-618](https://issues.oasis-open.org/browse/ODATA-618) proposes to allow term names in position of type names. As reusable types in JSON Schema have to be members of the \"definitions\" object, terms would also have to be represented there, and somehow tagged as being a \"term\".\n\nImported from [ODATA-863](https://issues.oasis-open.org/browse/ODATA-863)",
    "labels": [
      "CSDL JSON",
      "V4.0_CSD02",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Represent all type references as JSON Schema types/references",
    "body": "The value of the \"type\" keyword should always be a JSON Schema (reference) instead of a qualified type name.\n\nThis affects term definitions, parameters, return types, entity sets, singletons\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-862](https://issues.oasis-open.org/browse/ODATA-862)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define behavior when neither accept header or $format query parameter is specified",
    "body": "As far as I could find, the spec does not define what the expected behavior should be when neither an accept header nor a $format query parameter is specified in a request.  Does the server return the response in a spec defined default format or does the server get to choose which format to return results in.   \n\nWe should also cover the case of ambiguous Accept headers containing */*: currently the Olingo server library responds to requests from IE and Chrome with Atom-XML:\n- Internet Explorer sends Accept: text/html, application/xhtml+xml, */*\n- Chrome sends Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\nAs application/json isn't explicitly mentioned, they use application/xml\n\n### Proposal\n\nClarify in specification that, in absence of $format or accept header, service is allowed to return results in any format.\n\nThe current olingo behavior is, unfortunately, correct given the headers specified by IE and Chrome.\n\nImported from [ODATA-861](https://issues.oasis-open.org/browse/ODATA-861)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Move definition of Custom Aggregation Method to separate subsection.",
    "body": "The possibility to define custom aggregation methods was described in section 3.1.3 as a sub-topic of \"Aggregation Methods\", but all references to custom aggregation methods wrongly hyperlinked to section 6.2.3 Custom Aggregates\n\n### Proposal\n\nMove second paragraph of section 3.1.3 to separate subsection 3.1.3.5 and use this new subsection as the hyperlink target for  references to custom aggregation methods. \n\nAdd an example for a custom aggregation method.\n\nImported from [ODATA-860](https://issues.oasis-open.org/browse/ODATA-860)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define term, semantics for inserting error information into a (mostly) successful response",
    "body": "If a response returns successfully but there is an error within the payload, would we have some way to annotated the payload with an error?\n\n### Proposal\n\nAdd a term to the Core vocabulary that is shaped similar to the standard OData error response:\n\n      <Term Name=\"Messages\" Type=\"Collection(Core.MessageType)\"> \n        <Annotation Term=\"Core.Description\" String=\"Instance annotation for warning and info messages\" /> \n      </Term> \n      <ComplexType Name=\"MessageType\"> \n        <Property Name=\"code\" Type=\"Edm.String\" Nullable=\"false\" /> \n        <Property Name=\"message\" Type=\"Edm.String\" Nullable=\"false\"> \n          <Annotation Term=\"Core.IsLanguageDependent\" /> \n        </Property> \n        <Property Name=\"severity\" Type=\"Core.MessageSeverity\" Nullable=\"false\" /> \n        <Property Name=\"target\" Type=\"Edm.String\" Nullable=\"true\"> \n          <Annotation Term=\"Core.Description\" \n            String=\"A path to the target of the message detail, relative to the annotated instance\" /> \n        </Property> \n        <Property Name=\"details\" Type=\"Collection(Core.MessageType)\" Nullable=\"false\" /> \n      </ComplexType> \n      <TypeDefinition Name=\"MessageSeverity\" UnderlyingType=\"Edm.String\"> \n        <Annotation Term=\"Validation.AllowedValues\"> \n          <Collection> \n            <Record> \n              <PropertyValue Property=\"Value\" String=\"success\" /> \n            </Record> \n            <Record> \n              <PropertyValue Property=\"Value\" String=\"info\" /> \n            </Record> \n            <Record> \n              <PropertyValue Property=\"Value\" String=\"warning\" /> \n            </Record> \n            <Record> \n              <PropertyValue Property=\"Value\" String=\"error\" /> \n            </Record> \n          </Collection> \n        </Annotation> \n      </TypeDefinition> \n\nNotification details may target properties of the annotated structured type instance, related instances, or their properties\n\nImported from [ODATA-859](https://issues.oasis-open.org/browse/ODATA-859)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define meaning of MaxLength for String, Binary, and Stream",
    "body": "For String the most natural definition would be character length.\n\nFor Binary this is less clear: is it the number of octets, or the maximum length of the base64url-encoded string?\n\nFor Stream it would seem to be number of octets, i.e. content-length, but with [ODATA-482](https://issues.oasis-open.org/browse/ODATA-482) we might also see base64url-encoded strings in the payload.\n\n\n### Proposal\n\nIn XML, use character length for string and octet length for binary/stream\n\nIn JSON Schema, the maxlength of these string properties must be the maximum number of characters in the string representation, so we will add byteLength keywords for binary and stream values as the byte length in octets.\n\nImported from [ODATA-858](https://issues.oasis-open.org/browse/ODATA-858)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 5: use two aggregate expressions ",
    "body": "\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-857](https://issues.oasis-open.org/browse/ODATA-857)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add annotations for Min/Max/Pattern",
    "body": "These would map to equivalent concepts in JSON Schema.\n\n### Proposal\n\nStart a \"Validation\" vocabulary with the following:\n\n    <Schema xmlns=\"http://docs.oasis-open.org/odata/ns/edm\"  Namespace=\"Validation.1.0.0\">\n\n      <Term Name=\"Pattern\" Type=\"Edm.String\">\n        <Annotation Term=\"OData.Description\" String=\"The pattern that a string property or parameter must match.\"/>\n      </Term>\n      <Term Name=\"Minimum\" Type=\"Edm.Decimal\">\n        <Annotation Term=\"OData.Description\" String=\"Minimum value that a numeric property or parameter can have.\"/>\n      </Term>\n      <Term Name=\"Maximum\" Type=\"Edm.Decimal\">\n        <Annotation Term=\"OData.Description\" String=\"Maximum value that a numeric property or parameter can have.\"/>\n      </Term>\n  \n    </Schema>\n\nplus new term, \"Validation.Exclusive\", that can be applied to Validation.Minimum and Validataion.Maximum..\n\nImported from [ODATA-856](https://issues.oasis-open.org/browse/ODATA-856)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.0_WD01",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should we define patterns for some of the primitive types",
    "body": "In [ODATA-842](https://issues.oasis-open.org/browse/ODATA-842) we added format keywords for common primitive types. Do we also want to use the pattern keyword in the JSON CSDL format for some common string types?  in particular:\n-Binary\n-Guid\n-Date\n-TimeOfDay\n-Duration\n\nThe Precision facet of TimeOfDay and Duration is already translated into a pattern for the end of the string representation, so for these two types it would just result in a pattern for the complete string representation.\n \n\n### Proposal\n\nDefine and use \"pattern\" keyword values for the following primitive types:\n-Binary\n\"pattern\": \"^([A-Za-z0-9_-]{4})*([A-Za-z0-9_-]{3}[A-Za-z0-9_-]]([A-Za-z0-9_-){2}[AEIMQUYcgkosw048]=?]([A-Za-z0-9_-)[AQgw](==)?)?$\"\n\n-Guid\n\"pattern\": \"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\"\n\n-Date\n\"pattern\": \"^[0-9]{4,}-(0[1-9]](1[012))-(0[1-9]]([12)[0-9]](3[01))$\"\n\n-TimeOfDay including Precision\n\"pattern\": \"^([01][0-9]](2[0-3)):[0-5][0-9]:[0-5][0-9]$\" - for Precision=0\n\"pattern\": \"^([01][0-9]](2[0-3)):[0-5][0-9]:[0-5][0-9]([.][0-9]{1,12})?$\" for Precision=12\n\n-Duration including Precision\n\"pattern\": \"^-?P([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+S)?)?$\" - for Precision=0\n\"pattern\": \"^-?P([0-9]+D)?(T([0-9]+H)?([0-9]+M)?([0-9]+([.][0-9]{1,12})?S)?)?$\" - for Precision=12\n\n\nImported from [ODATA-855](https://issues.oasis-open.org/browse/ODATA-855)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "8.3.3: last sentence should use \"header\" instead of \"preference\"",
    "body": "The last sentence is\n\nThe syntax of the OData-EntityId preference is specified in [OData-ABNF].\n\nOData-EntityId is a header, not a preference.\n\n### Proposal\n\nChange sentence to \n\nThe syntax of the OData-EntityId header is specified in [OData-ABNF].\n\nImported from [ODATA-853](https://issues.oasis-open.org/browse/ODATA-853)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "8.3.1: superfluous text paragraph 3, sentence 1",
    "body": "The sentence is:\n\nAs OData allows multiple formats for representing the same structured information, services SHOULD use weak ETags that only depend on the format-independent entity state is recommended. \n\nThe last two words are a left-over.\n\n### Proposal\n\nRemove last two words, sentence should be\n\nAs OData allows multiple formats for representing the same structured information, services SHOULD use weak ETags that only depend on the format-independent entity state. \n\nImported from [ODATA-852](https://issues.oasis-open.org/browse/ODATA-852)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "groupby(): ABNF still allows more than two parameters",
    "body": "This is a relic from earlier working drafts, the prose text is strict and limits the number of parameters to one or two.\n\nFixing this is a non-material change as the prose text wins over the ABNF.\n\n### Proposal\n\nChange line 136 from\n\ngroupbyTrafo   = 'groupby' OPEN BWS groupbyList *( BWS COMMA BWS applyExpr)  BWS CLOSE\n\nto\n\ngroupbyTrafo   = 'groupby' OPEN BWS groupbyList [ BWS COMMA BWS applyExpr ] BWS CLOSE\n\nImported from [ODATA-851](https://issues.oasis-open.org/browse/ODATA-851)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve document structure for functions used in common expressions",
    "body": "$filter offers a long list of canonical function that can be applied in common expressions. The URL conventions document does not list them in alphabetical order, but by topic, which forces the reader of the document to scan the entire list in order to check for an appropriate function.\n\n\n### Proposal\n\nReplace section \"5.1.1.4 Canoncical Functions\" by multiple sections, one for each topic. These sections contain further sub-sections for all related functions, ordered alphabetically by function name.\n\nTopic sections are: \"String Functions\", \"Date and Time Functions\", \"Arithmetic Functions\", \"Type Functions\", \"Geo Functions”.\n\nImported from [ODATA-850](https://issues.oasis-open.org/browse/ODATA-850)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA03",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add possibility for enumeration types to \"extend\" another enumeration type",
    "body": "[Alternative to [ODATA-494](https://issues.oasis-open.org/browse/ODATA-494)]\n\nWe currently don't have a way for adding values to an enumeration type defined by a different schema. This would be helpful for defining custom vocabularies that extend base vocabularies. \n\nHowever, defining inheritance for enumerations introduces substitutability that is likely to break clients by returning new enumeration values not anticipated by the client (for instance, in a switch statement). \n\nAn alternative to inheritance would be to introduce the ability for an enumeration type to *definitionally* extend an existing enumeration type. This is similar to what we do with entity containers, which can extend the definition of an existing container without introducing any substitutability. \n\nWe could even use the same \"Extends\" attribute, rather than \"BaseType\" which implies inheritance. \n\n### Proposal\n\nIntroduce \"Extends\" attribute for enumerations. Enumerations defined with the \"Extends\" attribute have all of the enumeration values of the extended enumeration, plus the additional enumeration values defined. The extending enumeration must specify member values if, and only if, they are defined in the \"original\" type. \n\nImported from [ODATA-849](https://issues.oasis-open.org/browse/ODATA-849)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "ABNF construction rules don't permit empty functionParameters",
    "body": "With this definition:\n\nfunctionParameters = OPEN [ functionParameter *( COMMA functionParameter ) ] CLOSE\n\nUnfortunately, this definition prohibits an empty parameter list.\n\n\n\nImported from [ODATA-848](https://issues.oasis-open.org/browse/ODATA-848)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA03",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarification: use of Schema namespace aliases within URLs",
    "body": "CSDL spec section 3.4.2 states:\n\n\"An alias is only valid within the document in which it is declared; a referencing document has to define its own aliases with the edmx:Include element.\"\n\nProtocol spec section \"11.2.4.1 System Query Option $select\" states:\n\n\"The value of the $select query option is a comma-separated list of properties, qualified action names, qualified function names, the star operator (*), or the star operator prefixed with the namespace or alias of the schema in order to specify all operations defined in the schema.\"\n\nSo now we see that aliases can be valid/referenced outside their defining document.\n\nIf a URL uses an alias, is it limited to using an alias defined in the outermost CSDL document, i.e. it a URL prohibited from using aliases defined within referenced CSDL documents? If it is not so limited, then how do we resolve ambiguity of potentially multiple-defined aliases (defined with two different meanings in referncing and referenced CSDL documents)?\n\n\n\n### Proposal\n\nClarify that the aliases used in urls must be defined in the $metadata document of the service. Aliases defined in referenced documents are out of scope.\n\n\n\nImported from [ODATA-847](https://issues.oasis-open.org/browse/ODATA-847)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add version 4.01",
    "body": "This issue tracks all places that need to reflect the new version number in the  prose text.\n\nWe will also use this issue to track how we do version negotiation between a 4.0 and a 4.01 client and service.\n\n### Proposal\n\n1) Define an OData-Versions annotation that specifies the OData version(s) supported by the service:\n\n<Term Name=\"ODataVersions\" Type=\"Edm.String\" AppliesTo=\"EntityContainer\">\n  <Annotation Term=\"Core.Description\" String=\"A space-separated list of supported versions of the OData Protocol. Note that 4.0 is implied by 4.01 and does not need to be separately listed.\" />\n</Term>\n\n2) For new 4.01 features, we should:\n    a) define behavior/compatibility for 4.0 clients (see below), and\n    b) define vocabularies to test the presence of the new feature\n\nConformance Rules:\n\nOData 4.0 Compliant JSON Payloads\n-MUST not omit the odata. prefix ([ODATA-630](https://issues.oasis-open.org/browse/ODATA-630))\n-MUST not omit the # prefix for @odata.type values ([ODATA-561](https://issues.oasis-open.org/browse/ODATA-561))\n-SHOULD represent numeric value exceptions for single/double using \"INF\", \"-INF\", and \"NaN\" property values\n-MAY include the numericValueException annotation for any numeric value exceptions\n\nOData 4.01 Compliant JSON Payloads\n-MUST represent numeric value exceptions using the numericValueException annotation instead of \"INF\", \"-INF\", and \"NaN\" for numeric property values ([ODATA-920](https://issues.oasis-open.org/browse/ODATA-920))\n-MAY include or omit the odata. prefix ([ODATA-630](https://issues.oasis-open.org/browse/ODATA-630))\n-MAY include or omit the # prefix from odata.type values ([ODATA-561](https://issues.oasis-open.org/browse/ODATA-561))\n-MAY include related entities inline for a delta payload ([ODATA-876](https://issues.oasis-open.org/browse/ODATA-876))\n-MAY exclude TargetId for a deleted link in a 0..1 relationship for a delta payload ([ODATA-814](https://issues.oasis-open.org/browse/ODATA-814))\n\nOData 4.0 Compliant CSDL Payloads\n-MUST NOT contain new CSDL elements or attributes, or new values for elements/attribute with enumerated values\n-MUST NOT include properties in derived types that overwrite property of base type ([ODATA-894](https://issues.oasis-open.org/browse/ODATA-894))\n-MUST NOT include EDM.Untyped ([ODATA-881](https://issues.oasis-open.org/browse/ODATA-881))\n-MUST NOT include extended edm:Path expression ([ODATA-786](https://issues.oasis-open.org/browse/ODATA-786))\n-MUST NOT use Edm.AnyPath and Edm.AnyPropertyPath ([ODATA-516](https://issues.oasis-open.org/browse/ODATA-516))\n-MUST NOT specify referential constraints to complex types and navigation properties ([ODATA-560](https://issues.oasis-open.org/browse/ODATA-560))\n-MAY include new CSDL annotations\n\nOData 4.01 Compliant CSDL Payloads\n-MAY include properties in derived types that overwrite property of base type ([ODATA-894](https://issues.oasis-open.org/browse/ODATA-894))\n-MAY include EDM.Untyped ([ODATA-881](https://issues.oasis-open.org/browse/ODATA-881))\n-MAY include extended edm:Path expression ([ODATA-786](https://issues.oasis-open.org/browse/ODATA-786))\n-MAY include Edm.AnyPath and Edm.AnyPropertyPath ([ODATA-516](https://issues.oasis-open.org/browse/ODATA-516))\n-MAY include referential constraints to complex types and navigation properties ([ODATA-560](https://issues.oasis-open.org/browse/ODATA-560))\n-MAY include new/unknown values for the \"AppliesTo\" attribute ([ODATA-631](https://issues.oasis-open.org/browse/ODATA-631))\n\nCompliant 4.01 Services:\n-MUST return 4.0 for the Edmx:Version attribute (we are not defining a new version of Edmx)\n-MUST follow OData semantics or fail request for any 4.01 syntax or request payloads\n-MUST return 4.0-compliant JSON payloads when requested with the OData-MaxVersion=4.0 request header\n-MUST support 4.0-compliant JSON request payloads specified with the OData-Version=4.0 request header\n  -MUST support property@odata.bind in PATCH, PUT, POST ([ODATA-666](https://issues.oasis-open.org/browse/ODATA-666))\n-MUST return 4.01 compliant JSON payloads when requested using the OData-MaxVersion=4.01 request header\n-MUST support 4.01-compliant request payloads specified with the OData-Version=4.01 request header\n  -MUST support linking specified using \"property\":{\"@odata.id\":\"url...\"} instead of @odata.bind in PATCH, PUT, POST ([ODATA-666](https://issues.oasis-open.org/browse/ODATA-666))\n  -MUST honor the @odata.etag annotation within payloads, if specified ([ODATA-666](https://issues.oasis-open.org/browse/ODATA-666))\n-MUST reject a requests with an incompatible SchemaVersion header (if SchemaVersion is returned from $metadata)\n-SHOULD return the new ODataVersions annotation. \n-MUST return the AsyncResult header in the final response to an async request ([ODATA-809](https://issues.oasis-open.org/browse/ODATA-809))\n-MUST support a non-message format for final response of an async request ([ODATA-809](https://issues.oasis-open.org/browse/ODATA-809))\n-MAY support 4.01 syntax regardless of version (Does not necessitate a change in OData-Version of response)\n-MAY support 4.01 behavior, including returning 4.01 content and payloads, if the client does not specify the OData-MaxVersion=4.0 request header\n-MAY default to no metadata responses in absence of odata.metadata if OData-Maxversion is not specified\n\n-MUST support 4.01 variants for supported syntax\n  -MUST support both prefixed and non-prefixed variants for supported headers, preference values, and format parameters (See OData-937)\n  -MUST support eq/ne comparison to null for 0..1 nav props ([ODATA-617](https://issues.oasis-open.org/browse/ODATA-617))\n  -MUST support an empty object or no-content for the request body when invoking action with no non-binding parameters (See OData-938)\n  -MUST support enumeration and duration literals in URLs with and without the type prefix (See OData-834)\n  -MUST support invoking functions/actions with or without namespace qualification ([ODATA-812](https://issues.oasis-open.org/browse/ODATA-812))(?)\n  -MUST support invoking parameterless function imports with or without parens ([ODATA-664](https://issues.oasis-open.org/browse/ODATA-664))\n  -MUST support casting strings to primitive types (ODATA 563)\n  -MUST support the \"in\" operator in places where \"or\" would be supported ([ODATA-556](https://issues.oasis-open.org/browse/ODATA-556))\n-SHOULD support \"divby\" ([ODATA-918](https://issues.oasis-open.org/browse/ODATA-918)) (include in filterfunctions & improve definition?)\n-SHOULD support negative indexes for substring function ([ODATA-901](https://issues.oasis-open.org/browse/ODATA-901))\n-SHOULD support implicit aliasing of parameters (See [ODATA-763](https://issues.oasis-open.org/browse/ODATA-763))\n-MAY support PUT against single entity with nested content ([ODATA-924](https://issues.oasis-open.org/browse/ODATA-924))\n-MAY support DELETE/PUT to $ref of a collection-valued nav prop ([ODATA-922](https://issues.oasis-open.org/browse/ODATA-922))\n-MAY support the count of a filtered/searched collection in a common expression ([ODATA-897](https://issues.oasis-open.org/browse/ODATA-897))\n-MAY support deep update and deep insert operations ([ODATA-666](https://issues.oasis-open.org/browse/ODATA-666))\n-MAY support $search for all collections ([ODATA-888](https://issues.oasis-open.org/browse/ODATA-888))\n-MAY support eq/ne structural comparison ([ODATA-617](https://issues.oasis-open.org/browse/ODATA-617))\n-MAY support POST to collections of complex/primitive types ([ODATA-616](https://issues.oasis-open.org/browse/ODATA-616))\n-MAY support PATCH and DELETE with $filter ([ODATA-615](https://issues.oasis-open.org/browse/ODATA-615))\n-MAY support PATCH to entity sets using the delta-response format ([ODATA-613](https://issues.oasis-open.org/browse/ODATA-613))\n-MAY support Key-As-Segment url convention for single-part keys ([ODATA-799](https://issues.oasis-open.org/browse/ODATA-799))\n  -MUST also support key-in-parens or include urls in payload\n\nCompliant 4.01 Clients:\n-MUST send OData 4.0-compliant payloads to a services that don't advertise support for 4.01 or greater\n-MUST use appropriate syntax when sending a request body that specifies OData-Version=4.01\n   -MUST use \"property\":{\"@odata.id\":\"url...\"} instead of @odata.bind in PATCH, PUT, POST ([ODATA-666](https://issues.oasis-open.org/browse/ODATA-666))\n-MUST be prepared to receive any 4.0 or 4.01-compliant payloads (according to OData-Version request header)\n-MUST be prepared to receive any valid 4.01 CSDL\n-SHOULD use capabilities to determine if a 4.01 feature is supported but MAY attempt syntax (and receive either 501 not implemented or 400 bad request)\n\n\nAreas of the spec that talk about versioning:\nPart 1: Protocol\n- Section 5.1 Protocol Versioning\n- Chapter 12 Security Considerations\n\nPart 3: CSDL\n- Section 3.1.1 Attribute Version\n- Sections 2.1 and 2.2 XML Namespaces\n\nJSON Format\n- Chapter 21 Security Considerations\n\n\n\nImported from [ODATA-846](https://issues.oasis-open.org/browse/ODATA-846)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Translate edmx:Reference/edmx:Include into a schema reference",
    "body": "\n\n### Proposal\n\nInstead of literally translating the edmx:Include element into a sub-object of the translation of the edmx:Reference element make it a property of the \"schemas\" object that is a JSON reference to the referenced document.\n\nThis way all schemas in scope of the service are consistently represented as properties of the \"schemas\" object instead of just mimicking the XML document structure.\n\nIf the edmx:Include element has an @Alias attribute, a second reference to the same URL is generated for the alias.\n\nImported from [ODATA-845](https://issues.oasis-open.org/browse/ODATA-845)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Provide JSON versions of the Core, Capabilities, Measures, and Aggregation vocabularies",
    "body": "We need them if we want to provide a full alternative to XML\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-844](https://issues.oasis-open.org/browse/ODATA-844)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Nullable as anyOf or as OData-specific keyword",
    "body": "JSON Schema treats null as a separate data type, requiring an \"anyOf\" construct for nullable properties:\n\n        \"Supplier\":{\n          \"anyOf\":[{\n              \"$ref\":\"#/definitions/ODataDemo.Supplier\"\n            }, {\n              \"type\":\"null\"\n            }\n          ],\n\nIf we accept that OData-unaware JSON Schema validators will complain wrongly if they encounter a null value, we could shorten this to\n\n        \"Supplier\":{\n              \"$ref\":\"#/definitions/ODataDemo.Supplier\",\n              \"nullable\":true\n            }\n\nThis would increase readability for humans and OData-aware machines and significantly reduce the optical size of the JSON CSDL due to the reduced number of line breaks added by pretty printers and JSON Viewers. The actual byte size reduction isn't significant.\n\nCombined with [ODATA-842](https://issues.oasis-open.org/browse/ODATA-842) this would reduce\n\n        \"Created\":{\n          \"anyOf\":[\n            {\n              \"allOf\":[\n                {\n                  \"$ref\":\"http://docs.oasis-open.org/odata/odata-json-csdl/v4.0/edm.json#/definitions/Edm.DateTimeOffset\"\n                }\n              ],\n              \"pattern\":\"(^[^.]*$]([.)[0-9]{1,6}$)\"\n            },\n            {\n              \"type\":\"null\"\n            }\n          ]\n        }\n\nto just\n\n        \"Created\":{\n          \"type\":\"string\",\n          \"format\":\"date-time\",\n          \"precision\":6\n          \"nullable\":true\n        }\n\n### Proposal\n\nPropose: for primitive types, represent as:\n\"type\":[\"string\",\"null\"],\n\"format\":\"date-time\"\n\nFor non-primitive types, use existing json schema.\n\nSee if we can add \"nullable\" to json-schema.\n\nImported from [ODATA-843](https://issues.oasis-open.org/browse/ODATA-843)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Represent primitive types as JSON Schema formats",
    "body": "Many OData primitive types are JSON Schema primitive types combined with a set of restrictions, e.g. Edm.Int64 is\n- \"type\":\"integer\",\n- \"minimum\":-9223372036854775808,\n- \"maximum\":9223372036854775807\nor Edm.Guid is\n- \"type\":\"string\",\n- \"pattern\":\"^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$\"\n\nThere are basically three options:\n1) place these in definitions in edm.json and reference them there\n2) inline these definitions at each occurrence of the OData primitive type\n3) just combine the JSON Schema primitive type with an OData-specific format, e.g.\n- type: string\n- format: guid\nor\n- type: integer\n- format: int64\n\nThe third approach is the most readable and in sync with what Swagger does, see http://swagger.io/specification, section Data Types, and we can try to get these formats into the next version of JSON Schema, see https://github.com/json-schema/json-schema/wiki/%22format%22-suggestions\n\n### Proposal\n\nDefine specific formats for OData primitive types:\n- uuid\n- date\n- time\n- duration\n- uint8, int8, int16, int32, int64\n- double, single\n- base64url\n\nImported from [ODATA-842](https://issues.oasis-open.org/browse/ODATA-842)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Representation of Precision and Scale",
    "body": "JSON Schema offers the keywords minimum, maximum, and multipleOf for fine-tuning the value range of numeric properties.\n\nWhile it is possible to translate Precision=\"5\" and Scale=\"2\" into\n- multipleOf: 1e-2\n- minimum: -999.99\n- maximum: 999.99\nit is rather hard for an OData client to re-engineer the precision and scale\n\nSimilar for temporal values: here Precision=\"7\" would have to be -translated into a regular expression\n- \"pattern\":\"(^[^.]*$]([.)[0-9]{1,7}$)\"\n\nWe could add the original scale and precision as extension keywords.\n\nAnd we could additonally opt to omit the rather cryptic JSON Schema representation that would only benefit JSON Schema validators.\n\nFor example a property of type Edm.TimeOfDay with precision 9 would be represented as\n\n{\n  \"type\":\"string\", \n  \"pattern\": \"^([01][0-9]](2[0-3)):[0-5][0-9]:[0-5][0-9]([.][0-9]{1,9})?$\",\n  \"precision\":9\n} \n\n\n\n### Proposal\n\nAdd OData-specific keywords \"precision\" and \"scale\" with numeric values\n\nImported from [ODATA-841](https://issues.oasis-open.org/browse/ODATA-841)",
    "labels": [
      "CSDL JSON",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for $expand=NavProp/$count",
    "body": "This feature is somewhat hidden in the ABNF and takes some guessing on how to represent it in JSON responses.\n\n### Proposal\n\nAdd example to URL conventions using $expand=NavProp/$count.\n\nAdd section/example to JSON Format describing that in this case the navigation property is NOT represented other than via instance annotations, and that NavProp@odata.count annotation is part of the response.\n\nImported from [ODATA-840](https://issues.oasis-open.org/browse/ODATA-840)",
    "labels": [
      "JSON Format",
      "URL Conventions",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "A recursive hierarchy annotation may also contain a navigation property to the children nodes",
    "body": "Consider a client processing entities according to their hierarchical structure imposed by the given hierarchy annotation.\n\nIf the client wants to retrieve the descendants for the next three levels, this could be accomplished with a single request that makes use of a (cyclic) navigation property pointing to the children of a node. Assuming this navigation property has name childrenNodes, and the corresponding navigation property annotated as ParentNavigationProperty has name parentNode, the request would be:\n\n GET set(nodeId)?$expand=childrenNodes($levels=3;$select=parentNode/nodeId,nodeId) \n\nIn order to let clients detect the availability of such navigations, the existing RecursiveHierarchy term needs to be Extended as proposed. \n\n### Proposal\n\nExtend the RecursiveHierarchy term by a property `ChildrenNavigationProperty `of type `Edm.NavigationPropertyPath`. Added element with yellow background:\n```xml\n<ComplexType Name=\"RecursiveHierarchyType\">\n  <Property Type=\"Edm.PropertyPath\" Name=\"NodeProperty\" Nullable=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"Property holding the hierarchy node value\"/>\n  </Property>\n  <Property Type=\"Edm.NavigationPropertyPath\" Name=\"ParentNavigationProperty\" Nullable=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"Property for navigating to the parent node\"/>\n  </Property>\n```\n{code:xml|bgColor=#ffffce}\n  <Property Type=\"Edm.NavigationPropertyPath\" Name=\"ChildrenNavigationProperty\" Nullable=\"true\">\n    <Annotation Term=\"Core.Description\" String=\"Property for navigating to the children nodes\"/>\n  </Property>\n```\n```xml\n  <Property Type=\"Edm.PropertyPath\" Name=\"DistanceFromRootProperty\" Nullable=\"true\">\n    <Annotation Term=\"Core.Description\" String=\"Property holding the number of edges between the node and the root node\"/>\n  </Property>\n  <Property Type=\"Edm.PropertyPath\" Name=\"IsLeafProperty\" Nullable=\"true\">\n    <Annotation Term=\"Core.RequiresType\" String=\"Edm.Boolean\"/>\n    <Annotation Term=\"Core.Description\" String=\"Property indicating whether the node is a leaf of the hierarchy\"/>\n  </Property>\n</ComplexType>\n```\n\nImported from [ODATA-839](https://issues.oasis-open.org/browse/ODATA-839)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow inclusion of \"untyped JSON\" into JSON requests and responses",
    "body": "JSON allows more flexibility than OData, e.g. arrays that mix primitive values, objects, and other arrays, or property names that aren't SimpleIdentiifers.\n\nSome extension scenarios for OData services require adding JSON data to requests and responses that cannot be modeled with OData means.\n\n\n\n### Proposal\n\nAllow JSON payloads to contain \"untyped JSON\" in addition to OData declared and open properties.\n\nAdd annotation for structured types that announce the potential presence of untyped JSON, either as a tagging term or by explicitly listing the names of the \"untyped JSON\" properties:\n\n<Annotation Term=\"Xxx.ContainsUntypedJSON\" />\n \nOr\n\n<Annotation Term=\"Xxx.ContainsUntypedJSON\">\n  <Record>\n    <PropertyValue Property=\"Properties\">\n      <Collection>\n        <String>opaqueJsonProperty</String>\n        <String>Another-untyped/JSON;Property{with:a#weird name</String>\n      </PropertyValue>\n    </Collection>\n  </Record>\n</Annotation>\n\nAllow clients to tell whether they are willing to receive \"untyped JSON\" via a new preference odata.allow-untyped-json.\n\nImported from [ODATA-838](https://issues.oasis-open.org/browse/ODATA-838)",
    "labels": [
      "JSON Format",
      "Vocabularies",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Example 28: replace $deltaToken with a valid custom query option",
    "body": "At least one reader of the spec mistook the example custom query option $deltaToken for part of the standard\n\n### Proposal\n\nTreat $deltatoken (all lower-case) as a reserved token that services can use in delta links, similar to how we have reserved $skiptoken.\n\nImported from [ODATA-837](https://issues.oasis-open.org/browse/ODATA-837)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow applying actions to a filtered collection of entities",
    "body": "\n\n### Proposal\n\nAdd a $filter path segment that specifies a Boolean expression, where the expression is specified through a query parameter:\n\nPOST Products/$filter=@filter/Special.Discount?@filter=Age gt 3 \n\nThis can be used in conjunction with an action, a data modification statement, or any other statement.\n\nThis follows the existing semantics that, if the segment following a collection matches an OData segment, that segment takes precedence over a possible key value in key-as-segment.\n\nImported from [ODATA-836](https://issues.oasis-open.org/browse/ODATA-836)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1: PATCH missing in list of operations that do not allow system query options",
    "body": "\n\n### Proposal\n\nChange:\n\nPOST requests to entity sets as well as all PUT and DELETE requests do not allow system query options.\n\nto:\n\nPOST requests to entity sets as well as all PATCH, PUT and DELETE requests do not allow system query options.\n\nImported from [ODATA-835](https://issues.oasis-open.org/browse/ODATA-835)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make type prefix optional for enumeration and duration literals in URLs",
    "body": "Enumeration literals are represented as strings in JSON responses. Requiring the type name as a prefix in $filter expressions is a barrier for service exploration.\n\n\n\n### Proposal\n\n4.01 Services MUST support Implicit cast from string to enum in URL. This allows the use of the string value of the enum in place of the full value, as in:\n$filter=Color eq 'Yellow' in addition to the existing $filter=Color eq ns.Color'Yellow'.\n\nAlso apply to duration literals in URLs.\n\n\nImported from [ODATA-834](https://issues.oasis-open.org/browse/ODATA-834)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 40 applies term RecursiveHierarchy term incorrectly",
    "body": "Example 40 applies term Aggregation.RecursiveHierarchy to SalesModel.SalesOrganization and assigns a value to term property ParentNodeProperty, which was removed by the solution of issue https://issues.oasis-open.org/browse/[ODATA-728](https://issues.oasis-open.org/browse/ODATA-728).\n\n### Proposal\n\nReplace annotation property value ParentNodeProperty by the current ParentNavigationProperty.\n\nImported from [ODATA-833](https://issues.oasis-open.org/browse/ODATA-833)",
    "labels": [
      "Data Aggregation",
      "V4.0_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "15.6: typo in diagram (Function/Action swapped)",
    "body": "The boxes Function and Aciton are swapped: FunctionImport points to Action, ActionImport points to Function\n\n### Proposal\n\nSwap texts Action and Function\n\nImported from [ODATA-832](https://issues.oasis-open.org/browse/ODATA-832)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "MetadataService.edmx: type of OpenType property should be Edm.Boolean",
    "body": "\n\nImported from [ODATA-831](https://issues.oasis-open.org/browse/ODATA-831)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Header OData-EntityId: when required",
    "body": "Section 8.3.3 Header OData-EntityId states\n\nA response to a create operation that returns 204 No Content MUST include an OData-EntityId response header. The value of the header is the entity-id of the entity that was acted on by the request.\n\n\nSection 13.1.1 OData Minimal Conformance Level states\n\n24.  MUST include the OData-EntityId header in response to any POST/PATCH that returns 204 No Content (Section 8.3.3)\n\n\n### Proposal\n\n8.3.3: change \"create operation\" to \"create or upsert operation\"\n\n13.1.1 item 24: change \"POST/PATCH\" to \"create or upsert operation\"\n\nImported from [ODATA-830](https://issues.oasis-open.org/browse/ODATA-830)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Section 7.2, Examples 50: aggregate returns one item even for empty input set",
    "body": "Example 50 shows an empty collection value for the Sales navigation property in the third item, but according to the definition of aggregate() it will return a single instance even if the input set is empty. And according to the definition of aggregation method sum the sum over no values is null, hence the Sales navigation property will contain one item with a Total of null.\n\nThe important point is that the group for product \"Pencil\" exists because the aggregation base set is the Products entity set, not the Sales entity set.\n\n### Proposal\n\nChange third result item from\n\n    { \"@odata.id\": null, \"Name\": \"Pencil\", \"Sales\": [] },\n\nto\n\n    { \"@odata.id\": null, \"Name\": \"Pencil\", \"Sales\": [ { \"Total\": null } ] },\n\nand adapt note below the example.\n\nImported from [ODATA-829](https://issues.oasis-open.org/browse/ODATA-829)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Update I-JSON reference",
    "body": "The I-JSON draft has become RFC 7493\n\n### Proposal\n\nUpdate I-JSON reference from (OLD):\n\n[I-JSON]      Bray, T., Ed., \"The I-JSON Message Format\" draft-bray-i-json-01, 06 January 2014. http://tools.ietf.org/html/draft-bray-i-json-01\n\nto (NEW):\n\n[RFC7493]   Bray, T., Ed., \"The I-JSON Message Format\", RFC 7493, March 2015. https://tools.ietf.org/html/rfc7493\n\nalso add text like the following to the description that includes the DateTimeOffset and TimeOfDay values in section 7.1 Primitive Value\n\nThe DateTimeOffset and TimeOfDay data types as defined in [OData-ABNF] allow for the seconds component to be omitted.  For compatibility with [I-JSON], OData clients and servers SHOULD include the seconds component.\n\nImported from [ODATA-828](https://issues.oasis-open.org/browse/ODATA-828)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "introduce $compute query option",
    "body": "OData could be extended to allow derived computed values to be returned along with the properties of an entity.\n\nThis could be expressed as:\n\nhttp://odata.netflix.com/v2/Catalog/Titles?$compute=substring(ShortSynopsis,20) as Summary&$select=Name,Summary\n\nIn [ODATA-9](https://issues.oasis-open.org/browse/ODATA-9) we added support for an equivalent compute transformation in our Data Aggregation Extensions. \n\n\n### Proposal\n\nAdd \"$compute\" query option allowing additional computed properties to be added to each instance. The syntax is similar to the compute() transformation in Data Aggregation, i.e. $compute=<list of compute expressions>, but without the restriction to simple values: allowed compute expressions are any expressions valid in a $filter system query option on the input set.\n\nMore formally:\n  compute          = '$compute' EQ computeItem *( COMMA computeItem )\n  computeItem      = commonExpr RWS 'as' RWS computedProperty\n  computedProperty = odataIdentifier         \n\n$compute is also allowed as query option nested within $expand to add computed dynamic properties to expanded entities.\n\n$compute is logically evaluated first, so the computed dynamic properties can be used in $expand, $filter, $orderby, and $select.\n\nComputed structural properties SHOULD be added to the default selection (in absence of $select), and are treated as other dynamic properties:\n- $select=* includes computed structural properties\n- $expand=* includes computed navigation properties or computed entities/collections of entities\n- appear in context URL same way as other (dynamic) properties\n\nGET ~Customers?$expand=Orders($compute=price*qty as totalprice;$select=name,price,qty,totalprice)\n\nNote: in this example, totalprice is available outside of the expand as Orders/totalprice, as in:\nGET ~Customers?$filter=Orders/any(o:o/totalprice gt 100)&$expand=Orders($compute=price*qty as totalprice;$select=name,price,qty,totalprice)\n\n\n\nImported from [ODATA-827](https://issues.oasis-open.org/browse/ODATA-827)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Wrong Target attribute value in Edm.Metadata.Annotation/Target navigation property",
    "body": "\n\n### Proposal\n\nChange attribute value from \"Annotation\" to \"Annotations\"\n\nImported from [ODATA-826](https://issues.oasis-open.org/browse/ODATA-826)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "AnnotationPath expression: traversal of multiple collection-valued scalar or navigation properties",
    "body": "When applying https://issues.oasis-open.org/browse/[ODATA-481](https://issues.oasis-open.org/browse/ODATA-481) we missed to adapt CSDL 14.5.2. (edm:AnnotationPath): it still restricts path expressions to contain at most one multi-valued  structural or navigation property.\n\nSince an AnnotationPath traverses the object graph on structural level not on instance level, the cardinality of  structural or navigation properties is not relevant.\n\nImported from [ODATA-825](https://issues.oasis-open.org/browse/ODATA-825)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Header Content-Transfer-Encoding not used in HTTP",
    "body": "In Issue #823, applied to Errata 3 we cautioned clients and services that they should not rely on the Content-Transfer-Encoding header.\n\nThis is to track removal of the required Content-Transfer-Encoding header in 4.01. Clients and services are allowed to continue to include the header, but if included it must have the value binary.\n\n### Proposal\n\nIn Errata, specify that:\n1) Services should not rely on the header being there in batch requests because it is expected to be made optional in 4.01.\n2) Client should not rely on the header being there in the async/batch response for the same reason.\n\nIn 4.01, remove Header Field Content-Transfer-Encoding with value binary\nmake sure that we make the header optional in V4.01 and not forbid it\n\nImported from [ODATA-824](https://issues.oasis-open.org/browse/ODATA-824)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Header Content-Transfer-Encoding not used in HTTP",
    "body": "In V4 we use the Header Content-Transfer-Encoding:binary  together with the Content-Type: application/http in batch payloads (exactly as in V3 ) and in async responses.\n\nIn HTTP 1.1 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.1 and https://tools.ietf.org/html/rfc7230#section-8.3.2) the media type application/http is defined \"...Encoding considerations: HTTP messages enclosed by this type are in \"binary\" format; use of an appropriate Content-Transfer-Encoding is required when     transmitted via E-mail.\"\n\nAnd in a section about differences between HTTP and MIME entities, the spec states (http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html#sec19.4.5 and https://tools.ietf.org/html/rfc7231#appendix-A.5): \"HTTP does not use the Content-Transfer-Encoding (CTE) field of RFC 2045. [...]\"\n\n\n\n### Proposal\n\nIn Errata, specify that:\n1) Services should not rely on the header being there in batch requests because it is expected to be made optional in V4.01.\n2) Client should not rely on the header being there in the async/batch response fosr the same reason.\n\nIn V4.01, remove Header Field Content-Transfer-Encoding with value binary\n\nImported from [ODATA-823](https://issues.oasis-open.org/browse/ODATA-823)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Async Batch Request: Bug in example 85",
    "body": "We specified in 11.6 for asynchronous request in general :\n \"A GET request to the status monitor resource returns 200 OK once the asynchronous processing has completed. This response MUST include a Content-Type header with value application/http [...]. The response body MUST enclose a single HTTP response which is the response to the initial Data Service Request.\"\n\nIn [ODATA-240](https://issues.oasis-open.org/browse/ODATA-240) we decided to use the exact same pattern also for async Batch Processing. But the example 85 doesn't reflect this fact, we missed to start the response with an 200 OK followed by the Content-Type application/http\n\n### Proposal\n\nFix example 85 and include async wrapper (see description).\n\nSpell out explicitly in text of subchapter 11.7.5 (Asychrounous batch requests), that for async batch request the exact same pattern as for non-batch async requests is used.\n\nImported from [ODATA-822](https://issues.oasis-open.org/browse/ODATA-822)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.2.1 Attribute Target: targeting of nested properties of structured types",
    "body": "Section 14.2.1 describes possible values of the Target attribute. It allows an arbitrary number of property, navigation property, or type cast segments after an entity set or singleton to have different annotations depending of the use of a structured type. It doesn't state that for annotations on the type itself, e.g. having a specialized annotation on a property of a complex type when used within an entity type. \n\nThis is a clear omission as both path expressions within annotations as well as target paths via entity sets and singletons allow this\n\n### Proposal\n\nAdd rule\n- QualifiedName of a structured type followed by zero or more property, navigation property, or type cast segments, each segment starting with a forward slash\n\nAdd examples\nMySchema.MyEntityType/MyComplexProperty/MyProperty\nMySchema.MyEntityType/MyComplexProperty/MyNavigationProperty\nMySchema.MyComplexType/MyComplexProperty/MyProperty\nMySchema.MyComplexType/MyComplexProperty/MyNavigationProperty\n\nImported from [ODATA-821](https://issues.oasis-open.org/browse/ODATA-821)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow indexing into collections",
    "body": "Allow indexing into collections.\n\nIf servers can guarantee a stable order, they could advertise this via an annotation.\n\nThis could be combined with ETags to identify the state the client is referring to.\n\nThis might be combined with $orderby to let the client choose the order.\n\n### Proposal\n\n1)\tIntroduce array collections [[ODATA-820](https://issues.oasis-open.org/browse/ODATA-820)]\na.\tDefine new term, \"Ordered\", to advertise that a collection has a stable order. If it is a collection of primitive or complex types it can be indexed by ordinal: \n             < Term Name=\"Ordered\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"Property,NavigationProperty,EntitySet,ReturnType\"> \n                 < Annotation Term=\"Core.Description\" String=\"Collection has a stable order. Ordered collections of primitive or complex types can be indexed by ordinal.\"/> \n             < /Term>\nb.\tGET/PUT/PATCH/DELETE to the /{index} of an ordered collection of primitive or complex types retrieves/replaces/modifies/deletes just that item\ni.\t/index cannot be appended to collections of entities or non-ordered collections \nii.\tIndex is zero-based ordinal and follows JSONPointer syntax: collection/index\niii.    Clients can specify a negative index to say \"from the end\" with -1 being the last entry. services must not specify a negative value for an index.\nc.\tUpdate section 7.1.5 of the CSDL spec to note that it is possible to have an ordered collection of complex types with navigation properties.\n\n2) Define a new \"PositionalInsert\" term to advertise that a collection supports inserting at a given ordinal [[ODATA-820](https://issues.oasis-open.org/browse/ODATA-820)]\n              <Term Name=\"PositionalInsert\" Type=\"Core.Tag\" Default=\"true\" AppliesTo=\"Property, NavigationProperty, EntitySet\">\n                      <Annotation Term=\"Core.Description\" String=\"Items can be inserted at a given ordinal index.\"/>\n              </Term>\na.\tFor collections of entity, complex, or primitive types annotated with PositionalInsert, client may specify new ?$index= query parameter in POST request to collection to specify the non-negative, zero-based ordinal position where the item is inserted [[ODATA-820](https://issues.oasis-open.org/browse/ODATA-820)]\nI. Clients can specify a negative index to say \"from the end\" with -1 being \"insert before the last entry\".\n\nImported from [ODATA-820](https://issues.oasis-open.org/browse/ODATA-820)",
    "labels": [
      "URL Conventions",
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "10.2.2: Clarify whether enum types allow multiple members with the same value",
    "body": "CSDL section 10.2.2 only states that the value of the Value attribute is used for sorting.\n\nIt does not state whether values of the Value attribute have to be unique within an enum type, and it also does not state whether equality comparison of members of non-flag enum types is done by name or by value.\n\nFor flag enum types it states that member combination with the same value are equivalent.\n\n### Proposal\n\n\nAllow services to support multiple members with the same value.Require that (where supported) members with the same underlying value compare equal, and caution that the choice of which value the service returns is indeterminant. \n\nImported from [ODATA-819](https://issues.oasis-open.org/browse/ODATA-819)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Omit properties whose value is null or the $metadata-defined default value",
    "body": "Entities with many properties that are sparsely filled would benefit from optimizing the payload and omitting properties whose value is null.\n\nWith odata.metadata=minimal the client can deduce from the context URL whether a property is missing due to not being part of the projection or due to being null.\n\nMaybe switch this on/off via a new preference in the Prefer header.\n\n### Proposal\n\nProposal:\n1) Add a new preference \"odata.omit-values\" which can have the value \"nulls\" or \"defaults\".\n2) if clients specify \"omit-values=nulls\" the service MAY omit null values. If the service omits null values, it MUST specify the preference-applied response with the \"omit-values=nulls\" response.\n3) If clients specify \"omit-values=defaults\" the service MAY omit defaults, including nulls for properties without defaults. In this case, nulls are included in the payload if there is a non-null default value defined. Note that, in this case, there service MAY omit nulls for properties without a default defined, but include properties in the payload that are the default value.\n4) If the client doesn't specify an OData-MaxVersion header the service is free to omit nulls\n5) Nulls and defaults are always included if changed in delta payloads\n6) Missing values in a PUT or POST are assumed to be default (current behavior). Missing values in PATCH are assumed to be untouched (current behavior).  The response to a POST must include any values not set to their default. The response to a PUT/PATCH operation must include any properties whose values were changed as part of the operation.\n7) Services are always allowed to include nulls and defaults, regardless of the metadata level or preference specified.\n\n\nImported from [ODATA-818](https://issues.oasis-open.org/browse/ODATA-818)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add client-side function odata.matchesPattern",
    "body": "\n\n### Proposal\n\nAdd a client-side function odata.matchesPattern (to align with term Validation.Pattern) that can be used within the Apply dynamic expression. \n\nIt takes two arguments of type Edm.String and returns true if the first argument matches the regular expression in the second argument, using syntax and semantics of ECMA 262 (JavaScript) regular expressions, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions\n\nImported from [ODATA-817](https://issues.oasis-open.org/browse/ODATA-817)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add Capability term for filter expression restrictions",
    "body": "We regularly encounter situations where filter expressions on certain properties are restricted to\n- single-value: only a single “eq”clause is possible\n- multi-value: several  “eq” clauses, separated by or, are possible\n- interval: at most one “ge” and one “le” clause, separated by “and”, alternatively a single “eq” clause\n\n### Proposal\n\nExtend the term FilterRestriction with an additional property FilterExpressionRestrictions:\n\n      <Term Name=\"FilterRestrictions\" Type=\"Capabilities.FilterRestrictionsType\" AppliesTo=\"EntitySet\">\n        <Annotation Term=\"Core.Description\" String=\"Restrictions on $filter expressions\" />\n      </Term>\n      <ComplexType Name=\"FilterRestrictionsType\">\n        ...\n        <Property Name=\"FilterExpressionRestrictions\" Type=\"Collection(Capabilities.FilterExpressionRestrictionType)\">\n          <Annotation Term=\"Core.Description\" String=\"These properties only allow a subset of expressions\" />\n        </Property>\n      </ComplexType>\n      <ComplexType Name=\"FilterExpressionRestrictionType\">\n        <Property Name=\"Property\" Type=\"Edm.PropertyPath\" />\n        <Property Name=\"AllowedExpressions\" Type=\"Capabilities.FilterExpressionType\" />\n      </ComplexType>\n      <EnumType Name=\"FilterExpressionType\"> <!-- rewrite as allowable values for future extensibility-->\n        <Member Name=\"SingleValue\">\n          <Annotation Term=\"Core.Description\" String=\"Property can be used in a single eq clause\" />\n        </Member>\n        <Member Name=\"MultiValue\">\n          <Annotation Term=\"Core.Description\" String=\"Property can be used in a single in clause\" />\n        </Member>\n        <Member Name=\"SingleRange\">\n          <Annotation Term=\"Core.Description\"\n            String=\"Property can be used in at most one ge and/or one le clause, separated by and\" />\n        </Member>\n      </EnumType>\n\nNOTE: the enum should be rewritten as allowable values for future extensibility.\n\nImported from [ODATA-816](https://issues.oasis-open.org/browse/ODATA-816)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that the values of the format parameters odata.metadata etc. are case-insensitive",
    "body": "RFC6838 specifies in section 4.2 that type and sub-type of media types are case-insensitive https://tools.ietf.org/html/rfc6838#section-4.2, and in section 4.3 that media type parameter names are also case-insensitive, but leaves the syntax of the parameter values to the registering party.\n\nhttps://tools.ietf.org/html/rfc6838#section-4.2\nhttps://tools.ietf.org/html/rfc6838#section-4.3\n\n### Proposal\n\nSee summary\n\nApplied: https://www.oasis-open.org/committees/download.php/55883/odata-json-format-v4.0-wd08-2015-06-15.docx\n\nImported from [ODATA-815](https://issues.oasis-open.org/browse/ODATA-815)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Don't need TargetId in a deleted link for a to 0..1 relationship",
    "body": "Note: in OData 807 we added to errata 2 that clients should not expect targetid for deleted links for to 0..1 relationships. This allows 4.01 services to omit that information:\n\nThe JSON format spec provides specific ruled about when deleted links must be rendered:\n\nDelta responses MUST contain a deleted-link object for each deleted link that corresponds to a $expand path in the initial request, unless either of the following is true:\n•\tThe source or target entity has been deleted \n•\tThe maximum cardinality of the related entity is one and there is a subsequent link object that specifies the same source and relationship.\n\nThis makes sense, because with a single valued navigation property, the source and the relationship in the required link object uniquely identify the navigation property that is having it’s value replaced.\n\nThere is a similar case of when a single-valued navigation property has it’s link removed.  In that case, the only data needed to identify the link that should be removed is the source and the relationship. \n\nToday, however, the spec says that the target for the link being removed must also be provided:\n\nThe deleted-link object MUST include the following properties, regardless of the specified odata.metadata value\n•\todata.context – the context URL fragment MUST be #{entity-set}/$deletedLink, where {entity-set} is the entity set containing the source entity\n•\tsource – The id of the entity from which the relationship is defined, which may be absolute or relative\n•\trelationship – The name of the relationship property on the parent object\n•\ttarget – The id of the related entity, which may be absolute or relative\n\nThe requirement to include the target in this scenario raises the complexity and cost for the service to do “field level” tracking as this kind of relationship is typically implemented with a foreign key column.\n\n\n### Proposal\n\nIf a client does not specify an odata.maxversion=4.0 header, services may omit the target on a deleted link optional if the maximum cardinality of the related entity is one.\n\nImported from [ODATA-814](https://issues.oasis-open.org/browse/ODATA-814)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow no metadata for non-OData clients",
    "body": "We want simple rest services to support OData for interoperability without taxing them for non-interoperability requirements.\n\nThe easiest way to do this is to allow no-metadata for non-odata clients.\n\nWe can determine if the client is odata by:\n-Odata.maxversion header\n-Odata.version header\n-Odata media type parameters\n\n\n\n### Proposal\n\nIf a client sends an Accept header requesting JSON with a specific odata.metadata level, the service responds with that level.\n\nIf a client sends a request with OData-Version or OData-MaxVersion and does not specify an odata.metadata level, the service responds with odata.metadata=minimal.\n\nIf a client sends a request and does not specify OData-Version or OData-MaxVersion and does not specify an odata.metadata level, the service may respond with any format matching the Accept header, e.g. for application/json any JSON dialect, including OData JSON of the odata.metadata level preferred by that service.\n\nImported from [ODATA-813](https://issues.oasis-open.org/browse/ODATA-813)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]