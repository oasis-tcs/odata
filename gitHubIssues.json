[
  {
    "title": "How to search for double quotes",
    "body": "The ABNF rules for `$search` do not allow clear-text or percent-encoded double quotes (`\"`) in search words and search phrases.\n\nAs a consequence it is not possible to search for double quotes.\n\nNote: the prose specification and the ABNF allow to enclose an \"incomplete\" search expression in single quotes, but do not define how services should interpret \"incomplete\" search expressions.\n\n### Proposal\n\nAdd a sentence to OData-URL, section 5.1.8.1:\n> To support type-ahead use cases, incomplete search expressions can be sent as OData string literals enclosed in single-quotes, and single-quotes within the search expression doubled. _Such an expression can also be used to search for double quotes: `?$search='\"'`._\n> \n\n \n\nImported from [ODATA-1475](https://issues.oasis-open.org/browse/ODATA-1475)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for timeline entity set requiring an object key definition",
    "body": "\n\n### Proposal\n\nChapter 3: add example for annotation from [https://github.com/oasis-tcs/odata-vocabularies/pull/154]\n\nSection 4.3.2.2: add request example with data before and after the action\n\n \n\nImported from [ODATA-1474](https://issues.oasis-open.org/browse/ODATA-1474)",
    "labels": [
      "Temporal",
      "V4.0_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify: PATCH should allow changing type on nested complex type",
    "body": "We state that PATCH semantics to an entity also applies PATCH semantics to any provided complex-typed properties. However, we don't say whether a PATCH to an entity can change a complex-typed property to a different complex type.\n\nWhile we (explicitly) prohibit changing the type of an instance of an entity type (since an instance of an entity type has identity) it should be possible to change the a complex-typed property to a property of a value of a different type.\n\n### Proposal\n\nA complex-typed property can be set to different type in a PATCH request by specifying a different type in the payload.  Properties shared through inheritance, as well as dynamic properties, are retained (unless overwritten by new values in the payload). Other properties are discarded.\n\nImported from [ODATA-1473](https://issues.oasis-open.org/browse/ODATA-1473)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify: PATCH should allow changing type on nested complex type",
    "body": "We say that a PATCH request to an entity with a complex type in the payload also patches the nested complex type (i.e., it only affects the properties specified in the request).\n\nWe don't say whether or not the PATCH request can change the complex type of the nested property.\n\nWhile changing the type of an entity should not be allowed (and is, in fact, explicitly prohibited) because entities define an *instance*, the type of a complex-typed property should be able to be changed in a PATCH request by specifying a new complex type (i.e., @odata.type) in the payload.\n\n### Proposal\n\nA complex-typed property can be set to different type in a PATCH request by specifying a different type in the update payload.  Properties shared through inheritance, as well as dynamic properties, are retained (unless overwritten by new values in the payload). Other properties of the original type are discarded.\n\nImported from [ODATA-1472](https://issues.oasis-open.org/browse/ODATA-1472)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Core.ContentDisposition for media resources",
    "body": "Term `Core.ContentDisposition` allows specifying a proposed filename when \"downloading\" binary or stream data. The term can currently be applied to terms or properties.\n\n### Proposal\n\nAllow applying the term to media entity types for the corresponding media resource.\n\nImported from [ODATA-1471](https://issues.oasis-open.org/browse/ODATA-1471)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify value of @odata.mediaContentType if stream is null",
    "body": "The control information `mediaContentType` SHOULD match the media type of the binary stream represented by the `mediaReadLink` URL.\n\nWhat if the binary stream is \"null\", meaning there is no stream?\n\n### Proposal\n\nThe presence of `mediaContentType` with value `null` MAY be used to indicate the absence of a binary stream.\n\nImported from [ODATA-1470](https://issues.oasis-open.org/browse/ODATA-1470)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify $select behavior for properties of \"null\" instances",
    "body": "Section [5.1.4 System Query Option $select](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionselect) states that\n\n> \n> Each select item in the $select clause indicates that the response MUST include the declared or dynamic properties, actions and functions identified by that select item. \n> \n\n\nand\n\n> If a select item is a path expression requesting a component of a complex property and the complex property is null on an instance, then the component is treated as null as well.\n\n\nThis is misleading because we do _not_ expect the components of a \"null\" instance to be represented as \"null\" values.\n\n\n### Proposal\n\nChange to\n> Each select item in the $select clause indicates that the response MUST include the declared or dynamic properties, actions and functions identified by that select item. If a select item is a path expression requesting a component of <ins>an entity or</ins> complex property and the <ins>entity or</ins> complex property is null on an instance, then +the entity or complex property is included and represented as null+.\n> \n\nThat is pull up the last sentence of the section right after the first sentence in this issue.\n\nImported from [ODATA-1469](https://issues.oasis-open.org/browse/ODATA-1469)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Unified treatment of paths in aggregate, groupby and transformnested",
    "body": "Original description: The  [`groupby`](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016583) specification should also allow instance annotations as grouping properties.\n\nThis idea was rejected by TC 2022-03-10. Still, changes to the specification text are necessary.\n\n### Proposal\n\nIntroduce the following definition in [OData-Aggr, section 2.1]:\n> A _data aggregation path_ consists of one or more segments separated by a forward slash. Segments are names of declared or dynamic structural or navigation properties other than stream properties, or type-cast segments consisting of the (optionally qualified) name of a structured type that is derived from the type identified by the preceding path segment to reach properties declared by the derived type.\n> \n\nRephrase [OData-Aggr, section 3.1] (unchanged parts in {color:#57d9a3}green{color}):\n> {color:#57d9a3}The `aggregate` transformation takes a comma-separated list of one or more _aggregate expressions_ as parameters and returns an output set with a single instance{color} _containing one dynamic property per aggregate expression_ {color:#57d9a3}representing the aggregated value of the input set.{color}\n> \n> In the following, P is a _data aggregation path_ with single- or collection-valued segments. P is evaluated relative to the input set of the `aggregate` transformation, this must be well-defined for each instance in the input set.\n> \n> The allowed types of aggregate expressions are listed below. To compute the value of the dynamic property for a given aggregate expression, the `aggregate` transformation first determines a collection U of instances or primitive values, based on the input set of the `aggregate` transformation and a path P that occurs in the aggregate expression, as explained below. Each type of aggregate expression defines a function f(U) that then yields the dynamic property value.\n> \n> In types 1 and 2, the aggregate expression must be followed by the keyword `with` and an aggregation method g. In types 1, 2 and 3, it must be followed by the keyword `as` and an alias, which is then the name of the dynamic property. In types 1, 2 and 4, the aggregate expression can be followed by a `from` expression.\n> \n> _Types of aggregate expressions:_\n> 1. A path P whose last segment is an aggregatable property.\n>  f(U) = g(U).\n> 1. An aggregatable expression W built from arithmetic operations [OData-URL, section 5.1.1.2], unbound primitive function calls, numeric or duration values, and data aggregation paths with single-valued segments whose last segment is primitive.\n>  f(U) = g(W evaluated relative to each member of U). In this type, P is absent.\n> 1. A path P/`$count` with optional prefix P/ where the last segment of P is collection-valued.\n>  f(U) = cardinality(U). (`$count` behaves like a property having the value 1 followed by `with sum`.)\n> 1. A path P/c consisting of an optional prefix P/ where the last segment of P has a structured type and a custom aggregate c defined on the collection addressed by P.\n>  f(U) = c(U). The name of the dynamic property is the name of the custom aggregate.\n> \n> _Determination of U:_\n> \n> _If P is absent, let U = input set._\n> \n> -If P is present, it must be well-defined for all instances in the input set.-{color:#57d9a3} {color}_Otherwise,_{color:#57d9a3} let Q be the portion of P up to and including the last navigation property, if any, and let R be the remainder, if any, of P that contains no navigation properties, such that P equals the concatenated path Q/R. The aggregate transformation considers each entity reached via the path Q exactly once. To this end{color}\n> - {color:#57d9a3}if Q is non-empty, let E be the set of distinct entities reached via Q starting from the input set{color}\n> - {color:#57d9a3}if Q is empty, let E be the input set (which may contain multiple instances with the same value).{color}\n> \n> {color:#57d9a3}Then, if R is empty, {color}_let U = E_, {color:#57d9a3}otherwise {color}_let U be the collection containing_ {color:#57d9a3}all instances {color}_or primitive values (possibly with repititions)_{color:#57d9a3} addressed via R starting from E.{color}\n>  <del>Any aggregate expression that specifies an aggregation method MUST define an [alias](#sec_Keywordas) for the resulting aggregated value. The resulting instance contains one dynamic property per parameter representing the aggregated value. The properties of P do not appear in the result (see Example 64, with P = Q = Sales and R = empty).</del> \n\nRephrase [OData-Aggr, section 3.10.1]:\n> In its simplest form the first parameter of `groupby` specifies the _grouping properties_, a comma-separated list of one or more _data aggregation paths_ with single-valued segments that is enclosed in parentheses.\n> \n> ...\n> \n> If the <del>property</del> path leads to a single-valued navigation property, this means grouping by the entity-id of the related entities. <del>Other</del> navigation properties specified in grouping properties <del>paths</del> are expanded by default.\n> \n\nRephrase step 4:\n> In each set resulting from the previous step, each entity and complex _property_-type-, including nested complex and navigation properties, are augmented if necessary to include all primitive property values of the corresponding projection. _In case of grouping by entity-id of a related entity, they must include at least the key properties of the related entity (see example 61)._\n> \n\nRephrase [OData-Aggr, section 3.13]:\n> Their first parameter is a _data aggregation path_ with single- or collection-valued non-primitive segments where only the last segment may have an entity type, but it can instead have a complex type. This path is optionally followed by a type-cast segment to -expand-_select_ only related entities of that derived type or one of its sub-types. The sub-path starting with the last segment that is not a type-cast is called the final sub-path in this definition. \n>  This is -a generalization-_an extension_ of the definition in [OData-URL, section 5.1.3] in that it does not require a navigation property -or entity-valued instance annotation-.\n> \n\nRemove mentions of \"entity-valued instance annotation\" from sections 3.13.1 and 3.13.2.\n\nRephrase example 61:\n> Example 61: Grouping by navigation property Customer <del>is treated as groupby((Customer/$ref))</del> ```java\n> GET ~/Sales?$apply=groupby((Customer))\n> ```\n> may result in\n> ```java\n> {\n>   \"@odata.context\": \"$metadata#Sales(Customer)\",\n>   \"value\": [\n>     { \"Customer\": { \"ID\": \"C1\" } },\n>     { \"Customer\": { \"ID\": \"C2\" } },\n>     { \"Customer\": { \"ID\": \"C3\" } }\n>   ]\n> }\n> ```\n> depending on which properties the server includes when expanding `Customer` without `$select` or `$ref`.\n> \n\nAdd new example 63:\n> If both subtypes have a `Rating` property but their common base type does not,\n> ```java\n> GET ~/Products?$apply=groupby((SalesModel.FoodProduct/Rating,\n>     SalesModel.NonFoodProduct/Rating))\n> ```\n> results in\n> ```java\n> {\n>   \"@odata.context\": \"$metadata#Products(\n>     SalesModel.FoodProduct/Rating,\n>     SalesModel.NonFoodProduct/Rating)\",\n>   \"value\": [\n>     {\"@odata.type\": \"#SalesModel.FoodProduct\", \"Rating\": 5},\n>     {\"@odata.type\": \"#SalesModel.FoodProduct\", \"Rating\": null},\n>     {\"@odata.type\": \"#SalesModel.NonFoodProduct\", \"Rating\": \"average\"},\n>     {\"@odata.type\": \"#SalesModel.NonFoodProduct\", \"Rating\": null}\n>   ]\n> }\n> ```\n> Note that the `@odata.type` context information is needed to distinguish the two groups with `\"Rating\": null`.\n> \n\nRemove `with sum` after `$count` in example 67.\n\nMerge ABNF pull request [#75](https://github.com/oasis-tcs/odata-abnf/pull/75) and vocabularies pull request [#186](https://github.com/oasis-tcs/odata-vocabularies/pull/186).\n\nImported from [ODATA-1468](https://issues.oasis-open.org/browse/ODATA-1468)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarification: Delete supported for Nullable single-valued navigation properties",
    "body": "The existing text [OData Version 4.0 Part 1: Protocol (oasis-open.org)](https://nam06.safelinks.protection.outlook.com/?url=http%3A%2F%2Fdocs.oasis-open.org%2Fodata%2Fodata%2Fv4.0%2Fos%2Fpart1-protocol%2Fodata-v4.0-os-part1-protocol.html%23_Toc372793721&data=04%7C01%7Cmikep%40microsoft.com%7Ce612c9c5595f41a75ebc08d95617c237%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637635482313014844%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=oe2tLG1qQ3hcJZSSOI5d%2BbwW5vjsJuUo7xJEX%2FdomWQ%3D&reserved=0) says the following:\n\n{color:#0b5690}11.4.5 {color}[Delete an Entity](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_DeleteanEntity)\n\nTo delete an individual entity, the client makes a DELETE request to a URL that identifies the entity. Services MAY restrict deletes only to requests addressing the [edit URL](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_ReadURLsandEditURLs) of the entity.\n\nThe request body SHOULD be empty. *Singleton entities can be deleted if they are nullable. Services supporting this SHOULD advertise it by annotating the singleton with the term Capabilities.DeleteRestrictions (nested property Deletable with value true) defined in* *[[OData-VocCap]](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#VocCapabilities).*\n\n \n\n>>The highlighted text applies to top-level <Singleton> entities, not to single-valued navigation properties. Calling DELETE on the edit URL of a nullable single-valued navigation property sets that property to null.  Subsequent GET requests would return 404.\n\n \n\n### Proposal\n\nUpdate the highlighted text as follows:\n- *Top-level Singleton entities can be deleted if they are nullable. Services supporting this MAY advertise it by annotating the singleton with the term Capabilities.DeleteRestrictions (nested property Deletable with value true) defined in* *[[OData-VocCap]](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#VocCapabilities).*\n\nImported from [ODATA-1465](https://issues.oasis-open.org/browse/ODATA-1465)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Redundant section 14.4.4.3 Function odata.matchesPattern",
    "body": "Section [14.4.4.1 Canonical Functions](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_CanonicalFunctions) defines that all URL functions can be used with prefix `odata.`.\n\nWe added section [5.1.1.7.1 matchesPattern](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_matchesPattern) to the URL Conventions, making section [14.4.4.3 Function odata.matchesPattern](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_FunctionodatamatchesPattern) in the CSDL specifications redundant (and slightly confusing).\n\n### Proposal\n\nKeep section, clarify the redundancy, keep the example\n\nImported from [ODATA-1464](https://issues.oasis-open.org/browse/ODATA-1464)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "in operator should allow empty collection literals",
    "body": "Currently, the ABNF requires that a collection literal used in an \"in\" clause requires at least one element:\n\n \n\ninExpr = RWS \"in\" RWS ( listExpr / commonExpr )\n\nlistExpr = OPEN BWS primitiveLiteral BWS *( COMMA BWS primitiveLiteral BWS ) CLOSE\n\n \n\nThere may be scenarios in which the user intends to provide an empty collection (for example, to reflect that there are no items selected in a drop-down list box). This should evaluate to false.\n\nAlso, note that commonExpr may be empty, so it would seem we should have equal expressivity between commonExpr and listExpr\n\n### Proposal\n\nEnable empty collections in a literal expression for an in expression:\n\nlistExpr = OPEN BWS [primitiveLiteral BWS *( COMMA BWS primitiveLiteral BWS )] CLOSE\n\nImported from [ODATA-1462](https://issues.oasis-open.org/browse/ODATA-1462)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Term describing GeoJSON Feature Objects",
    "body": "OData defines primitive types for all GeoJSON [Geometry Objects](https://datatracker.ietf.org/doc/html/rfc7946#section-3.1), but it does not define a counterpart for the GeoJSON [Feature Object](https://datatracker.ietf.org/doc/html/rfc7946#section-3.2).\n\nFrom an OData perspective a Feature Object is just a complex type with properties `type`, `geometry`, `properties`, and optionally `id`.\n\n### Proposal\n\nDefine new term `GeometryFeature`, either in the `Core` vocabulary, or in a new `Geo` vocabulary, with a corresponding structured type.\n\nImported from [ODATA-1461](https://issues.oasis-open.org/browse/ODATA-1461)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Aggregation.ApplySupportedDefaults: use PATCH logic when overriding with ApplySupported",
    "body": "`ApplySupportedDefaults` allows to specify aggregation defaults on the entity container, applying to all entity sets. This default behavior can be overridden on entity-set level via `ApplySupported` whose type inherits from the type of `ApplySupportedDefaults`.\n\nClarify that this \"override\" uses PATCH semantics, i.e. values not specified via `ApplySupported` are \"inherited\" from `ApplySupportedDefaults`.\n\nImported from [ODATA-1460](https://issues.oasis-open.org/browse/ODATA-1460)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify representation of property paths in groupby with leading segments being null",
    "body": "The specification text contains an example for tranformation `outerjoin` whose result is applied to a subsequent `groupby` transformation:\n\nExample 66:\n```java\nGET ~/Customers?$apply=outerjoin(Sales as ProductSales)\n                       /groupby((Country,ProductSales/Product/Name))\n```\nreturning\n```java\n{\n  \"@odata.context\":\"$metadata#Customers(Country,ProductSales(Product(Name)))\",\n  \"value\": [\n     { \"Country\": \"Netherlands\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Paper\"  } } },\n     { \"Country\": \"Netherlands\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Sugar\"  } } },\n     { \"Country\": \"USA\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Coffee\" } } },\n     { \"Country\": \"USA\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Paper\"  } } },\n     { \"Country\": \"USA\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Sugar\"  } } },\n    { \"Country\": \"France\", \"ProductSales\": null }\n  ]\n}\n```\n—\n\nLooking at the first step, `outerjoin` returns combinations of customer instances and the related sales instances:\n```java\n[\n  { 'ID': 'C1', 'Name': 'Joe', 'Country': 'USA', 'ProductSales': { 'ID': '1', … } },\n  { 'ID': 'C1', 'Name': 'Joe', 'Country': 'USA', 'ProductSales': { 'ID': '2', … } },\n  …\n  { 'ID': 'C4', 'Name': Luc', 'Country': France', 'ProductSales': null }\n]\n```\nThe following `groupby` operates on two grouping properties: `Country` and `ProductSales/Product/Name`.\n\nThe latter property path is not defined for the last instance returned by `outerjoin`. Intuition says its value should be null.\n\nIt should be clarified\n1. that the value for such a property path is clearly defined in some specification, when a leading segment is already null\n1. how the `groupby` result should look like for the last instance returned by `outerjoin`:\n   1. like shown above:\n `'ProductSales': null`\n   1. returning the complete structure of the grouping property:\n \\{{ 'ProductSales': { 'Product': { 'Name': null }\n}}}\n\n \n\n \n\n \n\n### Proposal\n\nRephrase the beginning of section 3.10 as follows (insertions are indented or italicized.)\nh2. 3.10 [Transformation groupby](#sec_Transformationgroupby)\n\nThe `groupby` transformation takes one or two parameters _where the second is a list of set transformations, separated by forward slashes to express that they are consecutively applied._\nh3. 3.10.1 [Simple Grouping](#sec_SimpleGrouping)\n\nIn its simplest form the first parameter of `groupby` specifies the _grouping properties_, a comma-separated list of one or more single-valued property paths that is enclosed in parentheses. A path may consist of a sequence of single-valued navigation and complex properties. The same property path SHOULD NOT appear more than once; redundant property paths MAY be considered valid, but MUST NOT alter the meaning of the request. If the property path leads to a single-valued navigation property, this means grouping by the entity-id of the related entities. Other navigation properties specified in grouping property paths are expanded by default.\n> The output set is constructed in five steps:\n> 1. For each instance in the input set:\n>    1. Create a projection of the instance with all related entities included that are reached via navigation properties that occur in the grouping properties.\n>    1. Remove from the projection all structural and navigation properties that are not traversed by any grouping property.\n> 1. The input set is split into subsets where two instances are in the same subset if their projections are the same with null considered different from absent.\n> 1. The set transformations from the second parameter are applied to each subset, resulting in a new set of potentially different structure and cardinality. If the second parameter is absent, each subset is transformed into a set consisting of a single instance without properties. <del>Transformations may take into account the grouping properties for producing their result, e.g. aggregate removes properties that are used neither for grouping nor for aggregation.</del> 1. In each set resulting from the previous step, each entity and complex type, including nested complex and navigation properties, are augmented if necessary to include all primitive property values of the corresponding projection.\n> 1. The output set is the union of the augmented sets of the previous step.\n <del>If the service is unable to group by same values for any of the specified properties, it MUST reject the request with an error response. It MUST NOT apply any implicit rules to group instances indirectly by another property related to it in some way.</del> \n \n\nImported from [ODATA-1459](https://issues.oasis-open.org/browse/ODATA-1459)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify representation of navigation properties in response that are expanded by $apply",
    "body": "In the context of [ODATA-1449](https://issues.oasis-open.org/browse/ODATA-1449) we clarified that if the paths expanded by transformation e.g. `transformnested` include a navigation property, the resources addressed by that path are included in the output set of the transformation, but that it requires a dedicated `$expand` of that navigation property to include the resources also in the response to the request.\n\nThis is in line with the following para in section 3 System Query Option $apply of the [current WD of the spec:](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68846/odata-data-aggregation-ext-v4.0-wd05.docx): \"This means an output set can contain structural and dynamic properties as well as navigation properties, Navigation properties in the result of $apply can be further expanded using $expand (see [Evaluating $apply](#sec_Evaluatingapply)).\"\n\nHowever, transformation `groupby` behaves differently: Navigation properties part of a grouping property path are returned expanded in the response to the request - see examples in spec text.\n\nThis means the specification has two behaviors when processing paths with navigation properties. It should be clarified if this is intended.\n\nIn this context, the text at the end of section 3.10.2 should be sharpened. It says: \"Grouping properties that specify navigation properties are automatically expanded, and the specified properties of that navigation property correspond to properties specified in a $select expand option on the expanded navigation property. \" - It is unclear if it describes the effect for the output set of the `groupby` transformation or for the response to the request.\n\n### Proposal\n\nTreat the result structures with related entities expanded from all `$apply` transformations in a uniform manner.\n\nThe necessary changes to the specification text and examples are described in this [document](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/69011/[ODATA-1458)(https://issues.oasis-open.org/browse/ODATA-1458)%20-%20Proposal.docx]\n\nImported from [ODATA-1458](https://issues.oasis-open.org/browse/ODATA-1458)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Navigation path from instance to lambda operator",
    "body": "The section on [lambda operators](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_LambdaOperators) states:\n> Other path expressions in the Boolean expression neither prefixed with the lambda variable nor $it are evaluated in the scope of the collection instances at the origin of the navigation path prepended to the lambda operator.\n> \n\nBut the navigation path does not necessarily originate in a collection, it can also be an instance, for example\n```java\nProducts('Sugar')?$compute=Sales/any(p:p/Amount lt MinSalesVolume) as LongTail\n```\n \n\n### Proposal\n\nThe argument of a lambda operator is a case-sensitive lambda variable name followed by a colon (\\:) and a Boolean expression that uses the lambda variable name to refer to properties of _the instance or of_ members of the collection identified by the navigation path.\n\n...\n\nOther path expressions in the Boolean expression neither prefixed with the lambda variable nor $it are evaluated in the scope of the _instance or members of the_ collection <del>instances</del> at the origin of the navigation path prepended to the lambda operator.\n\nImported from [ODATA-1456](https://issues.oasis-open.org/browse/ODATA-1456)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Deprecate media entities in next minor version, and remove them in next major version",
    "body": "Media entities are left-overs from AtomPub, offer no benefit over entities with stream properties, are a constant source of confusion (when to use which), and need a lot of special rules and specification text.\n\nBetter get rid of them altogether.\n\n### Proposal\n\nDeprecate media entities in V4.02\n\nRemove media entities in V5\n\nImported from [ODATA-1455](https://issues.oasis-open.org/browse/ODATA-1455)",
    "labels": [
      "Protocol",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow upserts against media entities",
    "body": "Section 11.4.4 in protocol mentions that upserts are not supported against media entities and, more importantly, that services MUST fail an update request to a URL that would identify such an entity if it does not exist.\nGiven the fact that the service can't be using service-generated keys for these entities and the client apparently already knows how to compose/identify the individual media entities in such collection, why not allow upserts as well?\n\nPS Also noted that in v4.01 we've added \"single-valued non-containment navigation properties\" to the exclusions list as well. Couldn't quickly recall/figure out the issue but shouldn't that only be if there is no navigation property binding?\n\n### Proposal\n\nAllow a service to support upserts against media entities if and only if the media resource is inlined as a `$value` pseudo-property according to [JSON Format, 10. Media Entity](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_MediaEntity).\n\nImported from [ODATA-1454](https://issues.oasis-open.org/browse/ODATA-1454)",
    "labels": [
      "Protocol",
      "V4.02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "search('text') instead of search(text)",
    "body": "The current definition of the `search` transformation has no escaping mechanism so that one cannot search for a closing parenthesis, because `search())` gives a syntax error.\n\n### Proposal\n\nAdd a statement to [OData-Aggr, section 3.14]:\n> Closing parentheses in search expressions must be within single or double quotes in order to avoid syntax errors like `search())`.\n> \n\n\nImported from [ODATA-1452](https://issues.oasis-open.org/browse/ODATA-1452)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rephrase definitions for any, all and aggregate",
    "body": "The current specification of the `aggregate` function ([ODATA-1244](https://issues.oasis-open.org/browse/ODATA-1244)) leaves undefined what the \"input collection\" is in cases like\n```java\n$filter=Sales/any(p:aggregate(p/Amount mul TaxRate with sum) gt 5) \n```\nthat include property paths with and without lambda variable.\n\n### Proposal\n\n* The `aggregate` function is considered a [`collectionPathExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L556-L561) (rather than a `methodCallExpr`) and must be prepended with a navigation path that addresses the input collection (in the sense of [ODATA-1244](https://issues.oasis-open.org/browse/ODATA-1244)). In the argument of the `aggregation` function, common expressions are evaluated according to the rules for [lambda operators](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_LambdaOperators). (The lambda variable evaluates to the current instance within the addressed collection, whereas an unprefixed `Amount` would be evaluated in the context of the `Products` instance currently being filtered.)\n```java\nProducts?$filter=Sales/aggregate(s:s/Amount mul TaxRate with sum) gt 100```\n\n- Instead of a navigation path, the input collection can also be addressed by the keyword `$these`. A new kind of `[{{propertyPathExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L516-L523)}} is introduced in which `$these` addresses the \"current collection\" (defined below), in analogy with the current instance `$this` [OData-URL, section 5.1.1.14.6]. The current collection is also at the origin of the path `$these`, therefore `s/Amount` could be replaced by `Amount` in the following example.\n```java\nSales?$apply=groupby((Product),filter($these/aggregate(s:s/Amount) lt 100))```\n\n- `$these` can be prepended to collection path expressions like `any`, `all` and `aggregate`. (But we allow only `$these/aggregate` for now, so as not to touch the core spec.) See also [ODATA-1456](https://issues.oasis-open.org/browse/ODATA-1456).\n- In a system query option (possibly nested within `$expand` or `$select`), when evaluating the `boolCommonExpr` in a [`filter`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L313) or the `commonExpr` in an [`orderbyItem`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L316) or [`computeItem`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L281), the current collection is the collection being filtered or ordered or augmented.\n```java\nProducts?$select=Sales($filter=$these/aggregate(s:Price with avg) gt $this/Price)\n```\n\n- In an `$apply` transformation, when evaluating the `boolCommonExpr` in a [`filterTrafo`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-aggregation-abnf.txt#L145) or the `commonExpr` in a [`computeExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-aggregation-abnf.txt#L129), the current collection is the input set of the transformation.\n- When evaluating a `commonExpr` in its nearest [`collectionPathExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L556-L561), the current collection is the collection identified by the navigation path before the `collectionPathExpr`. This allows things like\n```java\nProducts?$filter=Sales/any(p:p/Amount gt $these/aggregate(q:Amount))\n```\n\nSee also [oasis-tcs/odata-abnf#37](https://github.com/oasis-tcs/odata-abnf/pull/37).\n\nThe third paragraph in [OData-Aggr, section 3.24 \"Function aggregate\"] must be rewritten to reflect the rules above. The `$these` keyword and \"current collection\" concept introduced in these rules are not mentioned outside of that section for now. See [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/69074/[ODATA-1451](https://issues.oasis-open.org/browse/ODATA-1451).docx]\n\nImported from [ODATA-1451](https://issues.oasis-open.org/browse/ODATA-1451)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Key with PropertyRef using navigation path incompatible with Protocol 11.4.2 \"Create an Entity\"",
    "body": "Consider this CSDL.\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<edmx:Edmx Version=\"4.01\" xmlns:edmx=\"http://docs.oasis-open.org/odata/ns/edmx\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://docs.oasis-open.org/odata/ns/edmx http://docs.oasis-open.org/odata/odata/v4.0/os/schemas/edmx.xsd http://docs.oasis-open.org/odata/ns/edm http://docs.oasis-open.org/odata/odata/v4.0/os/schemas/edm.xsd\">\n    <edmx:DataServices>\n        <Schema Namespace=\"example\" xmlns=\"http://docs.oasis-open.org/odata/ns/edm\" Alias=\"Self\">\n            <EntityType Name=\"Customer\">\n                <Key>\n                    <PropertyRef Name=\"ID\"/>\n                </Key>\n                <Property Name=\"ID\" Type=\"Edm.Int32\" Nullable=\"false\"/>\n                <NavigationProperty Name=\"Photo\" Type=\"Self.CustomerPhoto\" Partner=\"Customer\">\n                    <OnDelete Action=\"Cascade\"/>\n                </NavigationProperty>\n            </EntityType>\n            <EntityType Name=\"CustomerPhoneNumber\">\n                <Key>\n                    <PropertyRef Name=\"Customer/ID\" Alias=\"CustomerID\"/>\n                </Key>\n                <Property Name=\"PhoneNumber\" Type=\"Edm.String\" Nullable=\"false\"/>\n                <NavigationProperty Name=\"Customer\" Type=\"Self.Customer\" Nullable=\"false\"/>\n            </EntityType>\n            <EntityContainer Name=\"CustomerService\">\n                <EntitySet Name=\"Customers\" EntityType=\"Self.Customer\">\n                    <NavigationPropertyBinding Path=\"Photo\" Target=\"CustomerPhotos\"/>\n                </EntitySet>\n                <EntitySet Name=\"CustomerPhoneNumbers\" EntityType=\"Self.CustomerPhoneNumber\">\n                    <NavigationPropertyBinding Path=\"Customer\" Target=\"Customers\"/>\n                </EntitySet>\n            </EntityContainer>\n        </Schema>\n    </edmx:DataServices>\n</edmx:Edmx>\n```\nIf a client sends this request:\n\n```js\nPOST /CustomerPhoneNumber\n\n{\"Customer\":{\"ID\":123},\"PhoneNumber\":\"+18001234567\"}\n```\n\nthen per Protocol 11.4.2 \"Create an Entity\":\n\n*The entity representation MAY include references to existing entities as well as content for new related entities, but MUST NOT contain content for existing related entities.*\n\n... the above POST request MUST be interpreted as a deep insert. The client cannot portably create a CustomerPhoneNumber (except via a bind operation) as any attempt to specify its key (via the customer it relates to) will be interpreted as a deep insert.\n\nIf we were to relax the language in section 11.4.2 to allow an interpretation of relating a CustomerPhoneNumber to an existing Customer (rather than also creating the Customer by deep insert), then the specification is now ambiguous in regard to the correct interpretation of the above example payload.\n\nSimilar issues apply to 11.4.3.1 \"Update Related Entities When Updating an Entity\"\n\n*If a nested entity has the same id or key fields as an existing entity, the existing entity is updated according to the semantics of the PUT or PATCH request.*\n\nUsing the same payload for updating an existing CustomerPhoneNumber by PUT (in an attempt to link the photo to a different Customer) would be interpreted as a deep update to PUT the newly related customer (clearing its non-key properties, if any).\n\nThe key point of discussing the issue is to work out how to discourage implementers from treating inline relationships (with only the related entity's key) as a substitute for bind operations while at the same time not implementing bind operations the standard way.\n\n### Proposal\n\nExtend examples 76 and 77 in section [11.4.2.1 Link to Related Entities When Creating an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_LinktoRelatedEntitiesWhenCreatinganE) to also show a to-one association:\n\n> \n> _Example 76: using the JSON format, 4.0 clients can create a new manager entity with links to existing employees by applying the `odata.bind` annotation to the `Manager` and `DirectReports` navigation properties_\n> ```json\n> {\n>   \"@odata.type\":\"#Northwind.Manager\",\n>   \"ID\": 1,\n>   \"FirstName\": \"Pat\",\n>   \"LastName\": \"Griswold\",\n>   \"Manager@odata.bind\": \"http://host/service/Employees(0)\",\n>   \"DirectReports@odata.bind\": [\n>     \"http://host/service/Employees(5)\",\n>     \"http://host/service/Employees(6)\"\n>   ]\n> }\n> ```\n> \n> _Example 77: using the JSON format, 4.01 clients can create a new manager entity with links to existing employees by including the entity-ids within the `Manager` and `DirectReports` navigation properties_\n> ```json\n> {\n>   \"@type\":\"#Northwind.Manager\",\n>   \"ID\": 1,\n>   \"FirstName\": \"Pat\",\n>   \"LastName\": \"Griswold\",\n>   \"Manager\": { \"@id\": \"Employees(0)\" },\n>   \"DirectReports\": [\n>     {\"@id\": \"Employees(5)\"},\n>     {\"@id\": \"Employees(6)\"}\n>   ]\n> }\n> ```\n> \n\n\n\nImported from [ODATA-1450](https://issues.oasis-open.org/browse/ODATA-1450)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Split nest into three transformations",
    "body": "The `nest` transformation introduced with [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404) is too overloaded. Suggestion to split this into three transformations:\n- `nest(trans1 as alias1, ....)` as it was before [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404)\n- `transformnested(path, trans)` for one transformation without alias\n- `addnested(path, trans1 as alias1, ...)` for one or more transformations with alias.\n\n### Proposal\n\nhttps://www.oasis-open.org/apps/org/workgroup/odata/download.php/68838/[ODATA-1449](https://issues.oasis-open.org/browse/ODATA-1449).docx, sections 3.12, 3.13 and related examples\n\nAll examples with `transformnested` or `addnested` now have an `$expand` option in order to output the nested navigation property (mostly, `Sales`).\n\nImported from [ODATA-1449](https://issues.oasis-open.org/browse/ODATA-1449)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Re-allow CustomAggregate and ApplySupported targeting EntityType",
    "body": "At SAP, entity types carrying these annotations are not re-used across containers, therefore annotating the types directly is sufficient and simpler.\n\nThe alternatives (targeting EntitySets and Collections) would remain valid.\n\n### Proposal\n\nAddition to the `Core.AppliesViaContainer` tag:\n\nServers that apply the tagged term based solely on the entity type, structural or navigation property, independently of the container MAY additionally annotate the `EntityType`, `Property` or `NavigationProperty` model element in order to facilitate the annotation consumption by OData clients.\n\nSee also [PR #137](https://github.com/oasis-tcs/odata-vocabularies/pull/137).\n\nAfter reopening, see also [PR #153](https://github.com/oasis-tcs/odata-vocabularies/pull/153).\n\nImported from [ODATA-1448](https://issues.oasis-open.org/browse/ODATA-1448)",
    "labels": [
      "Data Aggregation",
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify applicability of terms Core.MediaType and Core.MediaAcceptableMediaType",
    "body": "Type definition [JSON.JSON](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.JSON.V1.xml#L75) from the the JSON vocabulary is annotated with terms [Core.MediaType](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L402) and [Core.AcceptableMediaTypes](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L397) from the Core vocabulary.\n\nIssues:\n1. The list of applicable model elements for both terms lacks TypeDefinition\n1. Along these lines, both terms should also be applicable to parameters and return types of functions and actions\n1. The description of Core.MediaType does not mention stream properties\n\n### Proposal\n\n* Add TypeDefinition to AppliesTo of terms [Core.MediaType](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L402) and [Core.AcceptableMediaTypes](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L397)\n  - Add the semantics of such an application to the description: The annotation of a TypeDefinition propagates to the model elements having this type\n- Add Parameter and ReturnType to AppliesTo of terms [Core.MediaType](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L402) and [Core.AcceptableMediaTypes](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L397)\n- Mention stream properties in the description of Core.MediaType\n\nImported from [ODATA-1447](https://issues.oasis-open.org/browse/ODATA-1447)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify usage of Edm.Stream-typed function and action return types",
    "body": "*1. Edm.Stream-typed function parameters in URLs*\n\nToday, the option to pass a value to an Edm.Stream-typed parameter in a request addressing a function import requires to look at different places and combine the individual steps (analogous for function calls):\n- Section on [Addressing Functions](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360941) in the URL conventions spec refers to certain ABNF rules (e.g., `primitiveFunctionImportCall`) that eventually lead to either rule `parameterAlias` or `primitiveLiteral`.\n- Following `parameterAlias`, section [5.3 Parameter Aliases](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#_Toc31361051) in the same spec explains the relation to ABNF rule `aliasAndValue`, which finally gets us to `parameterValue` with `arrayOrObject` as one of the options.\n- Section [5.1.1.14.2 Complex and Collection Literals](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#_Toc31361029) in the same spec defines the use of this ABNF rule `arrayOrObject` for complex and collection literals, but not for JSON documents as values of Edm.Stream-typed properties.\n- So, the only escape is to go the other route and use `commonExpr`, which is the other choice for `arrayOrObject`. This can become a `primitiveValue`, which includes a [comment](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L930) that strings can be used for JSON documents\n- So, finally we have found a rule to pass such a stream value\n\nIt should be discussed if the consumption of this feature could be simplified by making it more explicit in the URL conventions spec.\n\n \n\n*2. Edm.Stream-typed action parameters in request body and function and action* *return types* *in response body*\n\nSection [9        Stream Property](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457765) in the JSON Format spec defines the representation of stream _properties_ of media type JSON. It should be clarified that these rules are also applicable to function and action parameters as well as return types.\n\n \n\n \n\n \n\n### Proposal\n\nAdd to Protocol:\n- Return type Edm.Stream has same behavior as Stream properties: return content-type and raw octet-stream according to content-type, allow content negotiation via Accept.\n\n \n\nImported from [ODATA-1446](https://issues.oasis-open.org/browse/ODATA-1446)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow applying JSON.Schema to any model element that can be typed with Edm.Stream",
    "body": "The term JSON.Schema can be applied to model elements of type Edm.Stream that can contain \"raw\" JSON.\n\nThe current restriction to \"Property\" is an accident, it can also be applied to terms, type definitions, parameters, and return types.\n\nImported from [ODATA-1445](https://issues.oasis-open.org/browse/ODATA-1445)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "groupby algorithm does not cover \"select distinct\" case",
    "body": "The four-step algorithm given at the beginning of the groupby transformation does not describe what happens for `Products?$apply=groupby((Category))`. According to a later remark, this is supposed to select only the distinct `Categories`. But, after step 1, I have two subsets\n||ID||Category||Name||Color||TaxRate||\n|P1|PG1|Sugar|White|0.06|\n|P2|PG1|Coffee|Brown|0.06|\n\nand\n||ID||Category||Name||Color||TaxRate||\n|P3|PG2|Paper|White|0.14|\n|P4|PG2|Pencil|Black|0.14|\n\nStep 2 cannot be carried out due to lack of a second parameter. Step 3 has no effect. Step 4 concatenates these two subsets again, so that the overall effect is of `groupby((Category),identity)`.\n\nTo keep the case without second parameter within the four-step framework, step 2 must essentially produce an instance without properties, leading to subsets\n||ID||Category||Name||Color||TaxRate||\n| | | | | |\nand\n||ID||Category||Name||Color||TaxRate||\n| | | | | |\n\nwhich step 3 would then change to\n||ID||Category||Name||Color||TaxRate||\n| |PG1| | | |\nand\n||ID||Category||Name||Color||TaxRate||\n| |PG2| | | |\n\n### Proposal\n\nAdd a _sentence_ to step 2 of the four-step algorithm:\n\nApplies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality. _If the second parameter is absent, transforms each subset into a set consisting of a single instance without properties,_\n\nRephrase the later remark about \"select distinct\":\n\n_If_ the second parameter <del>can be</del> _is_ omitted, _steps 2 and 3 produce one instance containing only the grouping properties per_ <del>to request</del> distinct value combination of the grouping properties.\n\nImported from [ODATA-1444](https://issues.oasis-open.org/browse/ODATA-1444)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Aggregation vocabulary: Create container-level term for ApplySupported defaults",
    "body": "Currently, term ApplySupported can also be applied to entity containers, which the semantics that its settings propagate to all sets in the container except for those with their own annotation.\n\nA similar topic is discussed in [ODATA-1412](https://issues.oasis-open.org/browse/ODATA-1412), where the approach is to introduce a dedicated term for specifying set capabilities at container-level that describes only the common capabilities and does not reference individual properties of the sets.\n\nThe ways to describe core and aggregation capabilities at container level should be aligned.\n\n### Proposal\n\n* Create new term at container with all settings from existing terms that do not reference individual properties:\n- Refactor the existing complex types used by the existing terms to be derived from base types used for the properties of the new container-level term.\n- naming pattern for container-level types: <name>Base instead of proposed Common<name>Type\n\nImported from [ODATA-1443](https://issues.oasis-open.org/browse/ODATA-1443)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Update Aggregation ABNF with changes from previous issues",
    "body": "ABNF of Data Aggregation does not reflect current list of transformations defined in the specification.\n\nLikewise, test cases need to be updated.\n\nImported from [ODATA-1442](https://issues.oasis-open.org/browse/ODATA-1442)",
    "labels": [
      "ABNF",
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Aggregation.CustomAggregate applies to ComplexType still needed?",
    "body": "[https://github.com/oasis-tcs/odata-vocabularies/blob/58a00289375e83f577661c18d2025dbb45e58e35/vocabularies/Org.OData.Aggregation.V1.xml#L167-L168]\n\nAggregation.CustomAggregate has AppliesTo=\"ComplexType\", however, this contradicts what is stipulated by the Core.AppliesViaContainer tag.\n\n### Proposal\n\n[PR #124](https://github.com/oasis-tcs/odata-vocabularies/pull/124): Remove AppliesTo=\"ComplexType\"\n\nImported from [ODATA-1440](https://issues.oasis-open.org/browse/ODATA-1440)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve descriptions of property restrictions in term Aggregation.ApplySupported",
    "body": "[ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382) changed applicability of term `ApplySupported` from schema level to instances. Two new properties `GroupableProperties` and `AggregatableProperties` were added to its structure, and as a consequence, the property `PropertyRetrictions` and the terms `Groupable` and `Aggregatable` were deprecated.\n\nProblem is that the descriptions of these new properties `GroupableProperties` and `AggregatableProperties` still refer to the deprecated `PropertyRetrictions`. This causes confusion how to interpret their meaning in case an annotation omits the deprecated property.\n\n### Proposal\n\nMake the descriptions of these two properties independent from `PropertyRestrictions`.\n\nNew descriptions:\n- A non-empty `GroupableProperties` indicates that only the listed properties of the annotated target are supported by the groupby transformation\n- A non-empty `AggregatableProperties` indicates that only the listed properties of the annotated target can be used in the aggregate transformation together with the optionally specified restrictions on supported aggregation methods.\n\nReflect this change in the specification and in the vocabulary.\n\nImported from [ODATA-1439](https://issues.oasis-open.org/browse/ODATA-1439)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.4.9.4 Update a Collection Property: reference section 11.4.11 Positional Inserts",
    "body": "Section 11.4.9.4 [Update a Collection Property](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateaCollectionProperty) also describes inserting into a collection. The current description partially overlaps with the content of section 11.4.11 [Positional Inserts](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_PositionalInserts) and does not reference this section.\n\n \n\n### Proposal\n\nAdd a reference and align the text.\n> A successful POST request to the edit URL of a collection property adds an item to the collection. The body of the request MUST be a single item to be added to the collection. If the collection is ordered, the item is added to the end of the collection, and <ins>if the collection supports [positional insert](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_PositionalInserts)</ins> $index MAY be used to specify +the insert position+-a zero-based ordinal position to insert the new value, with a negative value indicating an ordinal position from the end of the collection-.\n> \n\nExplicitly mention that the success response for return=representation is the after-image of the collection, same as for a GET request to the collection property.\n> Upon successful completion the service responds with either [200 OK](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ResponseCode200OK) <ins>and a representation of the updated collection,</ins> or [204 No Content](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ResponseCode204NoContent). The client may request that the response SHOULD include a body by specifying a [Prefer header](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_Preferencereturnrepresentationandret) with a value of [return=representation](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_Preferencereturnrepresentationandret).\n> \n\n \n\nImported from [ODATA-1437](https://issues.oasis-open.org/browse/ODATA-1437)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "List of recommended navigation property bindings is incomplete.",
    "body": "Section 13.4 Navigation Property Binding  \nlists the cases when a navigation property binding should be provided:\n\n\n _An [entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet) or a [singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton) SHOULD contain a navigation property binding for each [navigation property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_NavigationProperty) of its entity type, including navigation properties defined on complex typed properties._\n\nIt does not state that a navigation property binding should also be provided for navigation properties reached through a chain of type casts, complex properties, or containment navigation properties.\n\nSection 13.4.1 does explain what are legal Paths but the section 13.4 seems to limit the need to declare the binding it to navigation properties of only the type of the entity set or singleton. \n\n### Proposal\n\nChange \n\n_An [entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet) or a [singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton) SHOULD contain a navigation property binding for each [navigation property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_NavigationProperty) of its entity type, including navigation properties defined on complex typed properties._\n\nto\n\n_An [entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet) or a [singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton) SHOULD contain a navigation property binding for each non-containment navigation property that can be reached from the entity type through a sequence of type casts, complex properties, or containment navigation properties._\n\nImported from [ODATA-1434](https://issues.oasis-open.org/browse/ODATA-1434)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify applicability of lambda operators to complex-typed collections",
    "body": "The URL Conventions spec describes in [5.1.1.13 Lambda Operators](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361024) that lambda operators are applicable to  instances of a collection addressed by a navigation path.\n\nI couldn't find a definition of navigation path in any of the specification documents. If my assumption that it is a property path ending in a navigation property is correct, then the description is too restrictive, because lambda operators are actually intended to be applied to all sorts of collections: entity-, complex- and primitive collections.\n\n### Proposal\n\n1. occurrence:\n\nBoth must be prepended with a path expression that identifies a collection.\n\n2. occurrence: identified by the path expression\n\n3. occurrence: ...origin of the path expression...\n\n \n\nImported from [ODATA-1433](https://issues.oasis-open.org/browse/ODATA-1433)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify wording in Section 7.2, Type Facets",
    "body": "Section 7.2, Type Facets, describes the use of applying facets to types when used in property definitions. Unfortunately, the same section is used to describe the application of facets, for example, in a Term definition.  When referenced from a term definition, the usage of the word \"property\" is confusing.\n\n### Proposal\n\nFix ambiguity in wording in Section 7.2, Type Facets, to clarify that it applies to the usage of the type regardless of whether it is part of a property definition, term definition, parameter/return type definition, type definition, etc.\n\nImported from [ODATA-1432](https://issues.oasis-open.org/browse/ODATA-1432)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Standard vocabulary does not always specify Nullable for collection typed properties",
    "body": "[Section 7.2]([OData Common Schema Definition Language (CSDL) XML Representation Version 4.01 (oasis-open.org)|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Nullable)] states\n\n_In OData 4.01 responses a collection-valued property MUST specify a value for the Nullable attribute._\n \nSome standard annotations don't follow the specification.\n\n\n \n```java\nvocabularies\\Org.OData.Capabilities.V1.xml:    452:         <Property Name=\"FilterExpressionRestrictions\" Type=\"Collection(Capabilities.FilterExpressionRestrictionType)\"    453:     977:       <Term Name=\"CustomHeaders\" Type=\"Collection(Capabilities.CustomParameter)\" AppliesTo=\"EntityContainer\">    978:         <Annotation Term=\"Core.Description\" String=\"Custom headers that are supported/required for the annotated resource\" />       984:    1005:       <Term Name=\"CustomQueryOptions\" Type=\"Collection(Capabilities.CustomParameter)\" AppliesTo=\"EntityContainer\">   1006:         <Annotation Term=\"Core.Description\" String=\"Custom query options that are supported/required for the annotated resource\" />      1014:  \n vocabularies\\Org.OData.Validation.V1.xml:   152:       <Term Name=\"AllowedTerms\" Type=\"Collection(Core.QualifiedTermName)\" AppliesTo=\"Term Property\">   153:         <Annotation Term=\"Core.Description\" String=\"Annotate a term of type Edm.AnnotationPath, or a property of type Edm.AnnotationPath that is used within a structured term, to restrict the terms that can be targeted by the path.\" /> \n   158:       <Term Name=\"ApplicableTerms\" Type=\"Collection(Core.QualifiedTermName)\">   159: ```\n\nImported from [ODATA-1431](https://issues.oasis-open.org/browse/ODATA-1431)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify handling of null values for complex-typed properties",
    "body": "The JSON Format specification describes in section [7.1 Primitive Value](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457753) how a null value is represented for a property of primitive type. However, an analogous description is not provided in section [7.2 Complex Value](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457754). \n\nThe case of complex-typed properties having null values is intended as the URL Conventions specification describes in  [5.1.1.1.1 Equals](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360958) how the eq-operator works for such properties to test against the null value.\n\nHence it seems to be a gap that section 7.2 of the JSON Format document does not explicitly mention null values.\n\n### Proposal\n\nAdd the sentence from section 7.1 in the JSON Format document also to section 7.2: \"Null values are represented as the JSON literal null.\"\n\nImported from [ODATA-1430](https://issues.oasis-open.org/browse/ODATA-1430)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify applicability of $expand options",
    "body": "In the protocol specification, section [11.2.5.2.1 Expand Options](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358944) lists applicable system query options without considering whether a single-valued or a collection-valued navigation property is expanded. In section [11.2.5.2.1.1     Expand Option $levels](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358945)  the statement that \"same expand options are applied at each level of the hierarchy\" is obviously not completely true. It has to be \"all but $levels\".\n\nThe URL conventions specification is not in sync: Section [5.1.3 System Query Option $expand](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361039), in the text after example 115, lists only a subset of the allowed system query options.\n\n### Proposal\n\nProtocol spec:\n- Add to section [11.2.5.2.1 Expand Options](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358944): Allowed system query options are $select, $expand, and $compute, as well as $filter, $orderby, $skip, $top, $count, $search, and $levels for collection-valued navigation properties.\n- Rephrase section [11.2.5.2.1.1     Expand Option $levels](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358945): \"All provided expand options except $levels are applied ...\"\n\n \n\nURL conventions spec:\n Allowed system query options are $select, $expand, and $compute, as well as $filter, $orderby, $skip, $top, $count, $search, and $levels for collection-valued navigation properties.\n\nImported from [ODATA-1429](https://issues.oasis-open.org/browse/ODATA-1429)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Definition of service-specific client-side functions",
    "body": "According to [OData-CSDL, section 14.4.4](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ApplyClientSideFunction) services can define client-side functions outside the `odata` namespace.\n- Can they be defined like server-side functions, through `edm:Function`? (I think yes, because the client should be able to delegate their execution to the server.)\n- Does `edm:Function` need an attribute `ClientSide=\"true\"`? (I think yes, if this means: can _only_ be executed by the client.)\n- Or perhaps a new core annotation (no need to wait for the next CSDL version):\n```xml\n<Term Name=\"ClientSideOnly\" AppliesTo=\"Function\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"true\">\n <Annotation Term=\"Core.Description\" String=\"Client-side function as in [OData-CSDL, section 14.4.4](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ApplyClientSideFunction) that cannot be executed by the server\"/>\n <Annotation Term=\"Core.LongDescription\" String=\"A function without this tag can also occur as a client-side function in an apply expression for an annotation. The client can then delegate the execution to the server by `$compute`-ing the function.\"/>\n</Term>\n```\nBut such a tag is dangerous, since clients that do not understand might wrongly invoke the function on the server.\n\nA function without this tag can occur in an annotation that is contributed by a proxy between OData client and server. Continuing the example from [ODATA-1420](https://issues.oasis-open.org/browse/ODATA-1420), assume the proxy contributes the following annotation:\n```xml\n<Schema Namespace=\"SalesOrderServer\">\n <EntityType Name=\"SalesOrderItem\">\n  <Property Name=\"Pieces\" Type=\"Edm.Int\"/>\n  <Property Name=\"Price\" Type=\"Edm.Decimal\"/>\n  <Annotation Term=\"PAngV.PriceSection2\">\n   <Apply Function=\"SalesOrderServer.PricePerPiece\">\n    <Path>Price</Path>\n    <Path>Pieces</Path>\n   </Apply>\n  </Annotation>\n </EntityType>\n</Schema>```\nThe proxy would then convert the request\n```java\nGET ~/SalesOrderItems?$select=ItemNo,@PAngV.PriceSection2\n```\ninto\n```java\nGET ~/SalesOrderItems?$select=ItemNo\n&$compute=SalesOrderServer.PricePerPiece(Price=Price,Pieces=Pieces) as PriceSection2\n```\nforward the converted request to the SalesOrderServer and rename JSON property `PriceSection2` to `@PAngV.PriceSection2` in the response, effectively handling the instance annotation `@PAngV.PriceSection2` like an additional property.\n\nThis examples assumes that the `SalesOrderServer.PricePerPiece` function is implemented on the server. If the server declared that function ClientSideOnly, or if the function was contributed by the proxy instead, then the proxy would send the following metadata to the client:\n```xml\n<Schema Namespace=\"SalesOrderServer\"> <!-- namespace of server -->\n <EntityType Name=\"SalesOrderItem\">\n  <Property Name=\"Pieces\" Type=\"Edm.Int\"/>\n  <Property Name=\"Price\" Type=\"Edm.Decimal\"/>\n  <Annotation Term=\"PAngV.PriceSection2\">\n   <Apply Function=\"PAngV.PricePerPiece\">\n    <Path>Price</Path>\n    <Path>Pieces</Path>\n   </Apply>\n  </Annotation>\n </EntityType>\n</Schema>\n<Schema Namespace=\"PAngV\"> <!-- namespace of proxy -->\n <Function Name=\"PricePerPiece\">\n  <Annotation Term=\"Core.ClientSideOnly\" Bool=\"false\"/>\n  ...\n </Function>\n</Schema>\n```\nand the proxy would request\n```java\nGET ~/SalesOrderItems?$select=ItemNo,Price,Pieces\n```\nfrom the server and perform the computation of `@PAngV.PriceSection2` itself.\n\nImported from [ODATA-1428](https://issues.oasis-open.org/browse/ODATA-1428)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify treatment of duplicates in OData-Aggr example 7",
    "body": "Example 7 in the [`aggregate ... as` specification](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016569) leaves unclear whether entities that are reachable via more than one instance path are considered once during aggregation or as often as they are reachable.\n\nDoes\n```java\nGET CainAndAbel?$apply=aggregate(Parents($count as c))\n```\ncount Adam and Eve once or twice ([https://www.bibleserver.com/KJV/Genesis4])? Is the result\n```java\n\"Parents\": [{\"c\": 2}]\n```\nor 4?\n\n### Proposal\n\nModify the relevant part of the specification as follows (deletions are striked out, insertions are in italics or indented). To be discussed whether the fifth alternative (the {color:#57d9a3}green{color} text) can be abolished and remove example 7. TC agrees to abolish it on 2021-06-10.\n\nThe aggregate transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for <del>all instances in</del> the input set.\n> In the following, P is a path made up of navigation properties, complex properties, and complex collection properties.\n> \n\nAn aggregate expression may be:\n- an aggregatable expression on the input set with a specified aggregation method,\n- an aggregatable property that can be reached via a path _P_ <del>consisting of a sequence of navigation properties, complex properties and complex collection properties,</del> with a specified aggregation method,\n- a custom aggregate that can be reached via a path _P_ <del>consisting of a sequence of navigation properties, complex properties and complex collection properties,</del> - any of the above, followed by a from expression,\n- <del>any of the above, enclosed in parentheses and prefixed with a navigation path to related entities, which serve as input set for the enclosed aggregate expression,</del> - $count, which is a shortcut for the expression 1 with sum\n\n> If P is present, it must be well-defined for all instances in the input set. Let Q be the portion of P up to and including the last navigation property, if any, and let R be the remainder, if any, of P that contains no navigation properties, such that P equals the concatenated path Q/R. The aggregate transformation considers each entity reached via the path Q exactly once. To this end\n> - if Q is non-empty, let E be the set of distinct entities reached via Q starting from the input set\n> - if Q is empty, let E be the input set (which may contain multiple instances with the same value).\n> \n> Then, if R is empty, the aggregated value is computed for all instances in E, otherwise the aggregated value is computed for all instances addressed via R starting from E.\n> \n> If no paths are present, the aggregated value is computed for all instances in the input set.\n> \n\nAny aggregate expression that specifies an aggregation method MUST define an alias for the resulting aggregated value. The resulting instance contains one dynamic property per parameter representing the aggregated value <del>across all instances within the input set-. -If paths are present, the corresponding navigation properties are implicitly expanded to make the properties part of the result representation.</del> > The properties of P do not appear in the result (cf. example 59, with P = Q = Sales and R = empty).\n> \n\n\nImported from [ODATA-1427](https://issues.oasis-open.org/browse/ODATA-1427)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow marking properties as required on insert or update",
    "body": "Some APIs need to tell clients that certain properties must be provided in create or update requests.\n\n### Proposal\n\nAdd property `RequiredProperties` to insert- and update-restrictions\n\nImported from [ODATA-1425](https://issues.oasis-open.org/browse/ODATA-1425)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Check uniform handling of entities reached via navigation in responses",
    "body": "When a transformation adds entities reached via navigation to its result, the request must specifically ask to expand them in order to have them appear in the response.\n\nExample from [ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409) that triggered the discussion: The join transformation in\n\n`GET ~/Products?$apply=join(Sales as Sale`) creates a `Sale` dynamic property with Sales instances as values which are entities. Another `$expand=Sale` is required to include these entities in the response.\n\nCross-check this with other cases such that all behave in the same way:\n- transformation `nest` that can be used to add related entities to the input set\n- transformation `groupby` applied to single-valued navigation properties (see [ODATA-971](https://issues.oasis-open.org/browse/ODATA-971))\n- transformation `aggregate` on related entities (see [ODATA-945](https://issues.oasis-open.org/browse/ODATA-945))\n\n### Proposal\n\n1. Rephrase wording in section 3 to have clear definitions referenced throughout the text:\n\n- input set  for the input of a transformation\n- output set for the result of a transformation\n- the final result of the $apply option is the output set of the last transformation\n\n2. Add general remark for the whole $apply section 3: Navigation properties in the final result set are carried over to the final result of the $apply option. Navigation properties in this final result can be further expanded using $expand. \n\n3. Section 3.1 and 3.12: Accompany \"mental bridge\" by more normative text. \n\nThe necessary text changes are provided in this [file](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68407/[ODATA-1423)(https://issues.oasis-open.org/browse/ODATA-1423).docx], marked with the ID of this issue as comments.\n\n\nImported from [ODATA-1423](https://issues.oasis-open.org/browse/ODATA-1423)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify $select behavior for stream properties",
    "body": "The $select behavior for stream properties is not explicitly stated.\n\nClarify whether property access to stream properties (e.g. `GET Entity(123)/Thumbnail`) is expected to be implemented by services.\n\n\n### Proposal\n\nJSON Format:\n- Stream properties requested with $select or included in the default selection are represented by their control information `odata.media*`.\n- Stream properties requested with $expand or implicitly expanded are represented as a property with its value.\n\nProtocol:\n- Services SHOULD support direct property access to a stream property's canonical URL (e.g. `GET Entity(123)/Thumbnail`). The response MAY be a redirect to the media read link of the stream property if the media read link is different from the canonical URL.\n- Note: if neither canonical URL nor media read link can be used and the stream value can only be accessed via $expand, the modeler should have used an Edm.Binary property instead.\n\nImported from [ODATA-1422](https://issues.oasis-open.org/browse/ODATA-1422)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add UpdateRestrictions property to specify update type",
    "body": "Clients can determine updatability by looking at the \"UpdateRestrictions\" capability annotation.  however, this annotation does not distinguish between PATCH and PUT.\n\n\n\n### Proposal\n\nAdd a new property to UpdateRestrictionsType to specify whether the service supports PATCH or PUT.  If not specified, PATCH Should be supported and PUT May be supported.\n\n```xml\n<Property Name=\"UpdateMethod\" Type=\"Capabilities.HttpMethod\" Nullable=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Supported HTTP Methods (PUT or PATCH) for updating an entity.  If null, PATCH SHOULD be supported and PUT MAY be supported.\" />\n</Property>\n\n<EnumType Name=\"HttpMethod\" IsFlags=\"true\">\n  <Member Name=\"GET\" Value = \"1\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP GET Method\" />\n  </Member>\n  <Member Name=\"PATCH\" Value = \"2\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP PATCH Method\" />\n  </Member>\n  <Member Name=\"PUT\" Value = \"4\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP PUT Method\" />\n  </Member>\n  <Member Name=\"POST\" Value = \"8\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP POST Method\" />\n  </Member>\n  <Member Name=\"DELETE\" Value = \"16\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP DELETE Method\" />\n  </Member>\n  <Member Name=\"OPTIONS\" Value = \"32\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP OPTIONS Method\" />\n  </Member>\n  <Member Name=\"HEAD\" Value = \"64\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP OPTIONS Method\" />\n  </Member>\n</EnumType>\n```\n\nImported from [ODATA-1421](https://issues.oasis-open.org/browse/ODATA-1421)",
    "labels": [
      "Vocabularies",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Path evaluation for annotations targeting annotations",
    "body": "[OData-CSDL, section \"Path evaluation\"](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_PathEvaluation) does not specify rules for annotations that target another annotation.\n\nImagine an annotation term `PAngV.PriceSection2` whose value is an amount.\n```xml\n<EntityType Name=\"SalesOrderItem\">\n <Property Name=\"Pieces\" Type=\"Edm.Int\"/>\n <Property Name=\"Price\" Type=\"Edm.Decimal\"/>\n <Annotation Term=\"PAngV.PriceSection2\">\n  <DivBy>\n   <Path>Price</Path>\n   <Path>Pieces</Path>\n  </DivBy>\n  <Annotation Term=\"Measures.ISOCurrency\">\n   <Path>Price/@Measures.ISOCurrency</Path>\n  </Annotation>\n </Annotation>\n</EntityType>\n```\nThis entity type computes the `PAngV.PriceSection2` as an annotation and wants to annotate this annotation with the corresponding currency. I would expect the evaluation of the path `Price/@Measures.ISOCurrency` to follow the rules for \"annotations embedded within a structural or navigation property of an entity type or complex type\", because the \"outer\" annotation has a primitive type and can thus be treated like a structural property.\n\nThis should be clarified in the specification.\n\n### Proposal\n\nh3. 14.4.1.2 Path Evaluation\n\nAnnotations MAY be embedded within their target, or specified separately, e.g. as part of a different schema, and specify a path to their target model element. The latter situation is referred to as _targeting_ in the remainder of this section.\n\nIf the value of an annotation is expressed dynamically with a path expression, the path evaluation rules for this expression depend on the _host of the annotation_ (roughly, the innermost model element other than an annotation) and its _hosting kind_ (roughly, embedded vs. targeting).\n- The host of an annotation embedded within or targeting another annotation or a collection, record or property value of another annotation is the host of that other annotation.\n- The host of an annotation embedded within or targeting another kind of model element is that model element.\n- The hosting kind of an annotation with external targeting whose target path starts with an entity container is \"container\".\n- The hosting kind of an annotation with external targeting whose target path starts with another kind of schema child is \"targeting\".\n- The hosting kind of an annotation embedded within another annotation or a collection, record or property value of another annotation is the hosting kind of that other annotation.\n- The hosting kind of an annotation embedded within another kind of model element is \"embedded\".\n\n||Host of annotation||Hosting kind||Path evaluation starts at||Remark||\n|Entity Container|container or embedded|the entity container|An empty path resolves to the entity container, and non-empty paths MUST start with a segment identifying a container child (entity set, function import, action import, or singleton). The subsequent segments follow the rules for path expressions targeting the corresponding child element.|\n|Entity Set or Singleton|container or embedded|the entity set or singleton|An empty path resolves to the entity set or singleton, and non-empty paths MUST follow the rules for annotations targeting the declared entity type of the entity set or singleton.|\n|Entity Type or Complex Type|embedded or targeting|the type|An empty path resolves to the type, and the first segment of a non-empty path MUST be a structural or navigation property of the type, a [type cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TypeCast), or a [term cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TermCast).|\n|Structural or navigation property|container|the declared type of the property|An empty path resolves to the declared type of the property, and non-empty paths MUST follow the rules for annotations targeting the declared type of the property. If the type is primitive, the first segment of a non-empty path MUST be a term cast or type cast.|\n|Structural or navigation property of an entity type or complex type|embedded|the directly enclosing type|This allows e.g. specifying the value of an annotation on one property to be calculated from values of other properties of the same type. An empty path resolves to the enclosing type, and non-empty paths MUST follow the rules for annotations targeting the directly enclosing type.|\n|Structural or navigation property of an entity type or complex type|targeting|the _outermost_ entity type or complex type named in the target|An empty path resolves to the outermost type, and the first segment of a non-empty path MUST be a structural or navigation property of the outermost type, a [type cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TypeCast), or a [term cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TermCast).|\n|Action, action import, function, function import, parameter, or return type|any|the action or function|The first segment of the path MUST be a parameter name or $ReturnType.|\n|Any other kind of model element|embedded|n/a|Path evaluation is not possible.|\n\nImported from [ODATA-1420](https://issues.oasis-open.org/browse/ODATA-1420)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Temporal",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Use of Core.ContentID by clients if service does not reference Core vocabulary",
    "body": "Section [11.4.2.2 Create Related Entities When Creating an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CreateRelatedEntitiesWhenCreatinganE) states\n\n> \n> Clients MAY associate an id with individual nested entities in the request by using the Core.ContentID term defined in [OData-VocCore]. \n> \n\n\n1. Are clients allowed or even required to use an alias defined in the service's `$metadata`?\n1. Are clients allowed to use this annotation if the service does not reference the Core vocabulary? Should they then use the fully qualified term name `Org.OData.Core.V1.ContentID`? Or are services required to reference the Core vocabulary when they advertise this feature via `Capabilities.DeepInsertSupport`?\n\nNote-to-self: if we had placed the term `ContentID` in the Capabilities vocabulary, the problem wouldn't exist.\n\n### Proposal\n\nServices advertising \n```java\n@Capabilities.DeepInsertSupport:{ContentIDSupported:true}```\nMUST reference the Core vocabulary in their $metadata.\n\nClients MUST use either the namespace of the Core vocabulary or the alias defined by the service's reference as the qualifier of `ContentID`.\n\nImported from [ODATA-1419](https://issues.oasis-open.org/browse/ODATA-1419)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities.UpdateRestrictions lacks a NonUpdatableProperties",
    "body": "Term Capabilities.UpdateRestrictions allows to restrict updatability for entities as a whole and in addition to specify [NonUpdatableNavigationProperties](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Capabilities.V1.xml#L720). But it does not allow to specify NonUpdatableProperties.\n\nThis prevents use cases with such constraints where only a subset of an entity type's properties may be updated. Moreover, it doesn't match the expressiveness of Capabilities.InsertRestrictions allowing to specify NonInsertableProperties.\n\n \n\n### Proposal\n\nExtend term type Capabilities.[UpdateRestrictionsType](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Capabilities.V1.md#UpdateRestrictionsType) with property NonUpdatableProperties of type [PropertyPath]\n\nImported from [ODATA-1418](https://issues.oasis-open.org/browse/ODATA-1418)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Inconsistencies in OData-CSDL section 14.2.2",
    "body": "[14.2.2 Target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#_Toc31805592) contains the following variant for a target path:\n> qualified name of an entity container followed by a segment containing a singleton or entity set name and zero or more property, navigation property, or type-cast segments\n> \n\nThe necessary forward slashes are not mentioned.\n\n\n### Proposal\n\nh3. 14.2.2 Target\n\nThe target of an annotation is the model element the term is applied to.\n\nThe target of an annotation MAY be specified indirectly by “nesting” the annotation within the model element. Whether and how this is possible is described per model element in this specification.\n\nThe target of an annotation MAY also be specified directly; this allows defining an annotation in a different schema than the targeted model element.\n\nThis external targeting is only possible for model elements that are uniquely identified within their parent, and all their ancestor elements are uniquely identified within their parent. These are the direct children of a schema with a unique name (i.e. except actions and functions whose overloads to not possess a natural identifier), and all direct children of an entity container.\n||Model element||Can be targeted with path expression (see also section 14.4.1.1)||Example (from ex. 42)||\n|[Action](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Action) overload|qualified name of action followed by parentheses containing the binding parameter type of a bound action overload to identify that bound overload, or by empty parentheses to identify the unbound overload| |\n|all overloads of an [Action](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Action)|qualified name of action| |\n|[Action Import](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ActionImport)|qualified name of entity container followed by a segment containing the action import name| |\n|[Annotation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Annotation) on a model element|path expression identifying the model element followed by a segment containing an at (@) prepended to the qualified name of a term, optionally suffixed with a hash (#) and the qualifier of an annotation| |\n|[Complex Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ComplexType)|qualified name of complex type| |\n|[Entity Container](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EntityContainer)|qualified name of entity container| |\n|[Entity Set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EntitySet)|qualified name of entity container followed by a segment containing the entity set name| |\n|[Entity Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EntityType)|qualified name of entity type| |\n|[Enumeration Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EnumerationType)|qualified name of enumeration type| |\n|[Enumeration Type Member](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EnumerationTypeMember)|qualified name of enumeration type followed by a segment containing the name of a child element| |\n|[Function](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Function) overload|qualified name of function followed by parentheses containing the comma-separated list of the parameter types of a bound or unbound function overload in the order of their definition in the function overload| |\n|all overloads of a [Function](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Function)|qualified name of function| |\n|[Function Import](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_FunctionImport)|qualified name of entity container followed by a segment containing the function import name| |\n|[Navigation Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_NavigationProperty) via container|qualified name of entity container followed by a segment containing a singleton or entity set name and zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Navigation Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_NavigationProperty) via structured type|qualified name of structured type followed by zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Parameter](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Parameter)|qualified name of entity container followed by a segment containing an action or function import name followed by a segment containing a parameter name| |\n|[Parameter](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Parameter)|qualified name of action or function optionally followed by a parenthesized expression as in the first row followed by a segment containing the name of a child element| |\n|[Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_StructuralProperty) via container|qualified name of entity container followed by a segment containing a singleton or entity set name and zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_StructuralProperty) via structured type|qualified name of structured type followed by zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Return Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ReturnType)|qualified name of entity container followed by a segment containing an action or function import name followed by a segment containing `$ReturnType`| |\n|[Return Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ReturnType)|qualified name of action or function optionally followed by a parenthesized expression as in the first row followed by a segment containing `$ReturnType`| |\n|[Singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Singleton)|qualified name of entity container followed by a segment containing a singleton name| |\n|[Type Definition](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_TypeDefinition)|qualified name of type definition| |\n\nAll [qualified names](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_QualifiedName) used in a target path MUST be in scope.\n\nExternal targeting of structural and navigation properties is possible \"via container\", i.e., for properties of singletons or entities in a particular entity set {color:#de350b}or in annotations thereof{color}. These annotations targeted via container override annotations on the structural or navigation properties targeted via the declaring structured type.\n\nImported from [ODATA-1417](https://issues.oasis-open.org/browse/ODATA-1417)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Dynamic capabilities for containment cases",
    "body": "Capabilities are annotated on entity sets, and for \"nested\" / contained entities they are expressed via Capabilities.NavigationRestrictions.\n\nThis works fine for static capabilities (can't ever update, can't ever delete), but does not allow expressing dynamic capabilities via boolean properties on the nested entities.\n\nExample:\n- `Orders` have (contained) `items`\n- Each `Item` has a property `isUpdatable`\n\nThe corresponding navigation restriction is (rather bulky):\n\n```xml\n<Annotations Target=\"MyService.EntityContainer/Orders\">\n  <Annotation Term=\"Capabilities.NavigationRestrictions\">\n    <Record Type=\"Capabilities.NavigationRestrictionsType\">\n      <PropertyValue Property=\"RestrictedProperties\">\n        <Collection>\n          <Record Type=\"Capabilities.NavigationPropertyRestriction\">\n            <PropertyValue Property=\"NavigationProperty\" NavigationPropertyPath=\"items\"/>\n            <PropertyValue Property=\"UpdateRestrictions\">\n              <Record Type=\"Capabilities.UpdateRestrictionsType\">\n                <PropertyValue Property=\"Updatable\" Path=\"isUpdatable\"/>\n              </Record>\n            </PropertyValue>\n          </Record>\n        </Collection>\n      </PropertyValue>\n    </Record>\n  </Annotation>\n</Annotations>\n```\n\nUnfortunately the above annotation is also wrong, because [14.4.1.2 Path Evaluation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_PathEvaluation) states\n\n> For annotations embedded within or targeting an entity set or a singleton, the path is evaluated starting at the entity set or singleton, i.e. an empty path resolves to the entity set or singleton, and non-empty paths MUST follow the rules for annotations targeting the declared entity type of the entity set or singleton.\n> \n\n\nThis means that the annotation would have to use `Path=\"items/isUpdatable\"` which is a collection of Boolean values and thus not type-compatible with the `Updatable` property, and the connection to the concrete item that is to be updated is lost.\n\n\n### Proposal\n\nAllow annotating capabilities at entity types, so paths can be expressed per the `Item` instance:\n\n```xml\n<Annotations Target=\"MyService.Item\">\n  <Annotation Term=\"Capabilities.UpdateRestrictions\">\n    <Record Type=\"Capabilities.UpdateRestrictionsType\">\n      <PropertyValue Property=\"Updatable\" Path=\"isUpdatable\"/>\n    </Record>\n  </Annotation>\n</Annotations>\n```\n\nExtend `AppliesTo` list to include `EntityType`, and add to description that this \"escape hatch\" should only be used for dynamic capabilities depending on a property of a related type.\n\n*New proposal after [ODATA-1420](https://issues.oasis-open.org/browse/ODATA-1420) has been resolved:* See PR #149.\n\nImported from [ODATA-1416](https://issues.oasis-open.org/browse/ODATA-1416)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify application of term Aggregation.ApplySupported on entity containers",
    "body": "Term `ApplySupported` is applicable to entity sets, complex types and entity containers. However, the definition does not describe the semantics when applied to a container.\n\n### Proposal\n\nAdd to description:\n\nAn annotation of this term to an entity container propagates to all sets in the container except for those with their own annotation.\n\n \n\nImported from [ODATA-1414](https://issues.oasis-open.org/browse/ODATA-1414)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarification of response to a request against a delta link",
    "body": "The current text mentions that a delta response spread across multiple pages must be ordered to guarantee consistent application on the receiving side (section [11.3.2 Using Delta Links](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358967), fourth para).\n\n\n For single-page delta responses no statement is made about ordering and the fact that a single entity may be included multiple times in the response, as added, updated, and deleted entity.\n\n### Proposal\n\nRephrase 11.3.2 \"The results of a request against the delta link may span *one or more pages and* ...\"\n\n \n\nImported from [ODATA-1413](https://issues.oasis-open.org/browse/ODATA-1413)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$expand: Discrepancy in argument descriptions",
    "body": "The documents refer to different values for `$expand`: property names or paths ending in a navigation property. This needs to be aligned:\n- Protocol spec: [11.2.5.2 System Query Option $expand](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html): “The value of the $expand query option is a comma-separated list of navigation +*property names*+, stream property names, or $value indicating the stream content of a media-entity.”\n- URL spec: [5.1.3 System Query Option $expand](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html): “An expand item is either a +*path*+ or … A +*path*+ can end with … +*a navigation property*+ to expand the related entity or entities”\n\n### Proposal\n\nAdapt text in Protocol to match text in URL Conventions\n\nImported from [ODATA-1411](https://issues.oasis-open.org/browse/ODATA-1411)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$expand: clarify that property *paths* must not appear twice",
    "body": "Current text on $expand in https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_SystemQueryOptionexpand says that\n\n> A property MUST NOT appear in more than one expand item.\n\n\nThis is misleading if e.g. a complex type is used multiple times.\n\nThe option `$expand=billToAddress/country,shipToAddress/country` should be valid even though the `country` navigation property of the `Address` complex type appears twice, but within different property paths.\n\n### Proposal\n\nChange text to \n\n> A {color:green}path{color} MUST NOT appear in more than one expand item.\n\n\nImported from [ODATA-1410](https://issues.oasis-open.org/browse/ODATA-1410)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add support for joining entities with instances of their related collections ",
    "body": "Such a feature would allow handling property paths with one or more collection-valued segments in it, i.e. collection-valued navigation or complex properties.\n\nThere are use cases in data aggregation that require to deal with such paths, e.g. to group by properties that can only be reached via a path involving a collection-valued navigation property like this:\n\n`GET ~/Products?$apply=groupby((Name,Sales/Customer/ID), aggregate(TaxRate with average as AverageTaxRate))`\n\n \n\n[ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206) declared support for such paths with collection-valued properties in groupby, however it lacks a description how to process them and furthermore [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404) withdraws this statement by restricting grouping properties to be reached via single-valued navigation and complex properties.\n\n### Proposal\n\nTo support such use cases, this gap could be closed by a new transformation `join` that allows decomposing the collections on the property path and hereby combining entities with instances of their related collections.\n\nThe proposal is described in section 3.21 and examples 57 and 58 in this file: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68332/[ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409)-2.docx](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68332/[ODATA-1409)(https://issues.oasis-open.org/browse/ODATA-1409)-2.docx]\n\nImported from [ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify behavior of aggregate on property paths with collection-valued properties",
    "body": "Example 53 illustrates a use case for such property paths:\n `GET ~/Products?$apply=`\n `groupby((Name),`\n `         ``aggregate(Sales/Amount with sum as Total))`\n\n[ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206) clarified that the aggregate transformation supports collection-valued navigation/complex properties in property paths.\n\nWhat is still missing for a complete definition is a description of the service behavior for the aggregate transformation applied on paths containing segments with collection-valued properties.\n\n### Proposal\n\nIn section 3.1, extend the third paragraph (insertions surrounded by *):\n If paths are present, the corresponding navigation properties are implicitly expanded to make the properties part of the result representation. \\*For every collection-valued navigation or complex property in the path, the aggregate transformation considers the concatenated list of all instances identified by that property for the remainder of the path.\\*\n\nImported from [ODATA-1406](https://issues.oasis-open.org/browse/ODATA-1406)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "groupby specification does not explain example 54",
    "body": "The specification of `groupby` in section 3.10 of the [Data Aggregation extension V4.0 CS02](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016582) cannot be used to explain the steps that must be carried out to compute an aggregation like in example 54 in [section 7.2](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016610).\n\n### Proposal\n\n* Fuse definitions of transformations `expand` and `nest` (replace section 3.12, delete section 3.18).\n  - Allow paths without a navigation property at the end\n  - Remove sentence about multi-level expansion\n- Move example 30 (nested `expand`) to section 7.2\n- Replace example 54 with two examples, one with `nest` (not `nestproperty`), another with `join` (transformation join is discussed in [ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409))\n- Revert [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206), only single-valued property paths are allowed in `groupby`\n\nDetails are described in [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68283/[ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404).docx]\n\nImported from [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Annotation of implicit entity sets",
    "body": "[NavigationPropertyBindings](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/os/odata-csdl-xml-v4.01-os.html#sec_NavigationPropertyBinding) are used to assign an entity set to a Path ending in a non-containment navigation property. The assigned entity set can then be the target for annotations like Aggregation.CustomAggregate (see https://issues.oasis-open.org/browse/[ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382)).\n\nPaths ending in a containment navigation property, which implicitly define an entity set, are treated totally different, however. In order to define a custom aggregate on this implicit entity set, the annotation Capabilities.NavigationRestrictions with type Aggregation.NavigationPropertyAggregationCapabilities/CustomAggregates must be used.\n\nAn easier alternative would be to use external targeting with a path that ends in a containment navigation property:\n \n```xml\n<Annotations Target=\"namespace.ContainerName/me/Mails\">\n <Annotation Term=\"Aggregation.CustomAggregate\" Qualifier=\"JunkRating\" String=\"Edm.Int32\"/>\n</Annotations>\n```\n\n\n\n### Proposal\n\nMake use of existing specification text in section [14.2.2 Target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Target).\n\nFor vocabulary terms `Aggregation.CustomAggregate` and `Aggregation.ApplySupported`, add `AppliesTo=\"Collection\"` and tag these terms with a new annotation in the `Core` vocabulary:\n```xml\n<Term Name=\"AppliesViaContainer\" Type=\"Core.Tag\" DefaultValue=\"true\" Nullable=\"false\" AppliesTo=\"Term\">\n <Annotation Term=\"Core.Description\" String=\"The target path of an annotation with this term must start with an entity container or the annotation must be embedded within an entity container, entity set or singleton\"/>\n</Term>\n```\nDeprecate terms `Groupable`, `Aggregatable`, complex type `NavigationPropertyAggregationCapabilities`.\n\nFor compatibility reasons, do not use this technique for annotations in the `Capabilities` vocabulary.\n\nImported from [ODATA-1403](https://issues.oasis-open.org/browse/ODATA-1403)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Correct Nullable attributes in Aggregation vocabulary terms",
    "body": "The structures of several terms lack the intended Nulable=\"false\" setting\n\nImported from [ODATA-1402](https://issues.oasis-open.org/browse/ODATA-1402)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add term Measures.UNECEUnit",
    "body": "Add new term to Measures vocabulary that allows pointing from a measured quantity to its UN/ECE unit code.\n\n \n\n \n\nImported from [ODATA-1401](https://issues.oasis-open.org/browse/ODATA-1401)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that Validation.DerivedTypeConstraint can be used to restrict Edm.Untyped",
    "body": "Type Edm.Untyped is [\"conceptually an abstract base type for any OData type\"]([https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_BuiltInAbstractTypes).]\n\nThis seems to imply that term [Validation.DerivedTypeConstraint](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Validation.V1.md#DerivedTypeConstraint) can be used to restrict this to a list of concrete(r) types.\n\n### Proposal\n\nSee pull request in Resolution\n\nImported from [ODATA-1400](https://issues.oasis-open.org/browse/ODATA-1400)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Close gap in definition of term JSON.Schema ",
    "body": "[ODATA-1323](https://issues.oasis-open.org/browse/ODATA-1323) clarified how term JSON.Schema shall be annotated. It says: \n\n\"\n\n [Use] a constant string expression for Edm.Stream with media types application/json or text/*\n\n[...]\n\nFor stream values the annotation (property) MUST be annotated with term `Core.MediaType` and the media type of the stream as its value.\n\n\"\n\nThe latter statement is not yet reflected in the term definition of [JSON.Schema](https://github.com/oasis-tcs/odata-vocabularies/blob/61542d91d01a8bade005317d922270011a89a0a1/vocabularies/Org.OData.JSON.V1.xml#L67)\n\n \n\n### Proposal\n\nExtend term JSON.Schema with annotation\n`<Annotation Term=\"Core.MediaType\" String=\"application/json\" />`\n\nImported from [ODATA-1399](https://issues.oasis-open.org/browse/ODATA-1399)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve text and examples for JSON and multipart batch",
    "body": "\n\n### Proposal\n\nFeedback from Martin Zurmuehl:\n\n1. [https://docs.oasis-open.org/odata/odata-json-format/v4.01/cos01/odata-json-format-v4.01-cos01.html#sec_BatchResponse]\n\nExample 50 only shows the body, the other response elements are missing, example 51 is more complete, as is the corresponding example 104 here: [https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_MultipartBatchResponse]).\n\nExtend it to \n```java\nHTTP/1.1 200 Ok\nOData-Version: 4.01\nContent-Length: ####\nContent-Type: application/json\n\n...here goes the current example...```\n \n\n2. The normative text doesn't state which HTTP response code to send for synchronous batch responses; for async responses (19.6.) it is explicitly stated. Part 1: Protocol states this explicitly in [https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_BatchRequestHeaders.](https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_BatchRequestHeaders)\n\nHowever this is (mis)placed under „Batch Request Headers“: move it up to 11.7 Batch Request because it is valid for all response formats.\n\n3. The statement „but the processing is yet to be completed“ suggests that processing is not finished when sending 200 OK. We should remove this and explicitly state that the request can also be streamed.\n\nText for 2. and 3. in 11.7 Batch Request\n> If the set of request headers of a batch request are valid the service MUST return a [200 OK](https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_ResponseCode200OK) HTTP response code to indicate that the batch request was accepted for processing-, but the processing is yet to be completed-. The individual requests within the body of the batch request may <ins>be processed as soon as they are received+-may subsequently fail or be malformed; however-, this enables +clients to stream batch requests, and</ins> batch implementations to stream the results. \n> \n> If the service receives a batch request with an invalid set of headers it MUST return a [4xx response code](https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_ClientErrorResponses) and perform no further processing of the batch request.\n> \n\n \n\n \n\nImported from [ODATA-1398](https://issues.oasis-open.org/browse/ODATA-1398)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Examples 86 and 87 apply an entity type as term",
    "body": "Example 86 shows an annotation and uses an entity type as term:\n\n{{{color:#000000}<Annotation Term=\"org.example.person.Employee\">{color}}}\n\n`...`\n\nThis is in conflict with [14.2 Annotation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#_Toc38530405) where the Term attribute is defined as a reference to a Term definition.\n\n### Proposal\n\nExtend the example to\n```xml\n<Annotations Target=\"org.example.Person\">\n  <Annotation Term=\"org.example.hcm.Employee\">\n    ...\n</Annotations>\n```\nExplain that the term `org.example.hcm.Employee` is of structured type. Introduce notion of an entity-valued annotation.\n\nThis may be less confusing because we use `org.example.hcm` as a term namespace in Example 5.\n\nGo all the way and give the definition of term `org.example.hcm.Employee` and its type in an additional code block within this example, maybe a subset of https://schema.org/Person.\n\nAlign the two example representations: the JSON representation has the `@type` control information, but the XML representation lacks the `Type` attribute.\n\nExplain that this annotation can be used in term-cast expressions in requests and give examples.\n\nImported from [ODATA-1397](https://issues.oasis-open.org/browse/ODATA-1397)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rules \"ordinalIndex\" and \"complexColPath\" are too restrictive: negative indexes and index with type-cast",
    "body": "4.01 added the ability to index into ordered collections from the end, using negative values for index segments, see [11.2.6.8 Requesting an Individual Member of an Ordered Collection.](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestinganIndividualMemberofanOrde)\n\nThe specification does not explicitly forbid this indexing after a type-cast segment, but it is not allowed by rule `complexColPath`. This seems to be an accident as it is also not mentioned in [ODATA-820](https://issues.oasis-open.org/browse/ODATA-820).\n\nTrivial: some optional path segments have empty alternatives, making them \"doubly optional\". This complicates automatic processing of the ABNF and is bad style.\n\n### Proposal\n\nAllow negative values for index segments in paths.\n\nAllow index segments after type-cast segments.\n\nRephrase optional path segments to not be empty.\n\nImported from [ODATA-1396](https://issues.oasis-open.org/browse/ODATA-1396)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify impact of applying expand to subsequent transformations ",
    "body": "Property paths used in a `$apply` transformation by default may refer to any instances that can be directly or indirectly reached via navigation properties. They are all part of the input set of the transformation.\n\nA preceding `expand` transformation limits the input set to those navigation paths constructed from the navigation property given as first argument to `expand`, possibly nested several times, reaching target instances that match the given filter expression.\n\nFrom the current text this limitation does not become clear.\n\nFurthermore, `groupby` may follow an expand transformation. The definition of `groupby` currently refers to an “initial” set, and it should be clarified that this is actually the input set, e.g. the result of the preceding `expand`.\n\n### Proposal\n\nCorrect [3.10 Transformation groupby](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016582), point 1: Replace “Splits the initial set...” with “Splits the input set ...”\n\nThe remaining parts of the reported issue have been addressed and resolved with [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404), which introduces transformation `nest`\n\nImported from [ODATA-1395](https://issues.oasis-open.org/browse/ODATA-1395)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rule \"index\" is too restrictive, needs to allow negative integers with 4.01",
    "body": "4.01 added the ability to index into ordered collections from the end, using negative values for the `$index` system query option, see [11.2.6.8 Requesting an Individual Member of an Ordered Collection](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestinganIndividualMemberofanOrde)\n\n### Proposal\n\nAllow negative values for `$index`\n\nImported from [ODATA-1393](https://issues.oasis-open.org/browse/ODATA-1393)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Point out aggregation of amounts in different currencies",
    "body": "\n\n### Proposal\n\n- remove currency from data model\n\n- rewrite all examples\n\n- section 6.2.4: until now we have ignored the reality of several currencies. Now we introduce currency to the model ...\n\n \n\nImported from [ODATA-1392](https://issues.oasis-open.org/browse/ODATA-1392)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enable usage of $this and $root in filter transformation",
    "body": "Literals $root and $this have been introduced in the URL Conventions spec for use with the $filter option. Their usage is likewise interesting for similar cases related to the filter transformation and therefore should be enabled there.\n\n### Proposal\n\nAlready allowed by $filter expressions\n\n \n\nAdd examples to ABNF test cases to ilustrate their usage\n\nImported from [ODATA-1391](https://issues.oasis-open.org/browse/ODATA-1391)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clean up annotation term RecursiveHierarchy",
    "body": "Term definition is not concise as it includes properties that are typical attributes of a recursive hierarchy but not required to create the recursive hierarchy: `ChildrenNavigationProperty`, `DistanceFromRootProperty`, `IsLeafProperty`\n\nThis raises the bar to adopt this capability. \n\n \n\n### Proposal\n\nLimit term `RecursiveHierarchy` to those properties that are essential for creating it: `NodeProperty`, `ParentNavigationProperty`.\n\nServices may choose to use dedicated annotations for further hierarchy attributes.\n\n \n\nReflect this change in the specification and in the vocabulary.\n\nImported from [ODATA-1390](https://issues.oasis-open.org/browse/ODATA-1390)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Difference between Asynchronous and Repeatable Requests",
    "body": "The term \"[Asynchronous Requests](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_AsynchronousRequests)\" invites comparison to the term \"Asynchronous SOAP communication\". The latter involves \"reliable messaging\", which is not implied by the former.\n\nHowever, readers of the OData specification who are acquainted with SOAP may not be aware of this difference.\n\n### Proposal\n\nClarify in the spec that Asynchronous OData Requests do not imply reliable messaging. Refer to the [Repeatable Requests](https://blogs.sap.com/2020/07/27/repeatable-requests-for-rest-apis/) specification for the latter.\n\nImported from [ODATA-1387](https://issues.oasis-open.org/browse/ODATA-1387)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add TypecastSegmentSupported to ReadRestrictions",
    "body": "Currently we can tell whether a cast segment is supported for insert/update/delete operations through the TypecastSegmentSupported boolean property on the respective types.  However, there is no way to tell whether the service supports appending the cast segment to a read request for a particular segment.\n\n### Proposal\n\nAdd TypecastSegmentSupported to ReadRestrictions. Default, if not specified, should be supported.\n\nAlso,in DeleteRestrictions fix FilterSegmentSupported and TypeCastSegmentSupported descriptions which both reference PATCH/Update.\n\n\nImported from [ODATA-1385](https://issues.oasis-open.org/browse/ODATA-1385)",
    "labels": [
      "Vocabularies",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify usage of annotation qualifiers as references to hierarchies",
    "body": "Section [6.3.2 Recursive Hierarchy](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016605) specifies that \"The value of the Qualifier attribute can be used to reference the hierarchy in Hierarchy Filter Functions.\"\n\nHierarchy filter functions make use of this concept, they accept a qualifier as first parameter.\n\nAll examples in the document apply this approach with top-level entities, i.e. part of the collection addressed by the resource path. E.g.:\n `GET ~/SalesOrganizations?`$filter=$it/Aggregation.isdescendant(}}\n \\`      Hierarchy='SalesOrgHierarchy',Node='EMEA')`\n\nUsing this approach also for hierarchies on entity collections _related_ to the top-level entities would require identifying the node set on which the function operates, which is not possible (example: `GET ~/Sales?`\n `$filter=$it/SalesOrganization/Aggregation.isdescendant(`\n `     Hierarchy='SalesOrganization/SalesOrgHierarchy',Node='EMEA')` leaves the set of sales orgs to consider as hierarchy unspecified )\n\nTherefore it needs to be clarified if/that these functions with the references to hierarchies always operate on top-level entities given by the resource path.\n\nThis issue is also relevant for [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218), which introduces transformations for hierarchy processing that also expect such a qualifier as call argument.\n\n \n\n### Proposal\n\n*Regarding hierarchy predicate functions:*\n\nThe node set on which these functions operate should be explicitly specified with an additional argument addressing the entity set containing the hierarchy nodes. This will then also cover the interesting use case to use the functions for related hierarchies. For example,\n```java\nGET ~/Sales?\n $filter=$it/SalesOrganization/Aggregation.isdescendant(\n      Nodes='SalesOrganizations',Hierarchy='SalesOrgHierarchy',Node='EMEA')\n```\nreturns those sales entities whose sales organization is a descendant of EMEA.\n\nNecessary changes:\n1. Extend functions in the Aggregation vocabulary: Add `Nodes` as new first parameter to `isroot`, `isdescendant`, `isancestor`, `issibling`, `isleaf`.\n  - The `Nodes` parameter takes the name of an entity set exposed by the service.\n  - The `Hierarchy` parameter receives the qualifier of a `RecursiveHierarchy` annotation attached to the entity type of the set whose name is specified in `Nodes`.\n1. Adjust examples 42-46 to reflect point 1.\n1. Add the example above to illustrate application of a predicate function on a related hierarchy.\n\n*Regarding transformations for recursive hierarchy processing originally introduced with [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218):*\n\n[Proposal ](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/69651/[ODATA-1384)(https://issues.oasis-open.org/browse/ODATA-1384).docx] to extend definitions of transformations `ancestors` and `descendants` to receive a recursive hierarchy via parameters that may differ from the input set.\n\nProposal to rewrite section about hierarchical functions:\nh4. 6.5.2.1 Hierarchy Functions\n\nFor testing the position of a given entity in a recursive hierarchy, the Aggregation vocabulary defines functions. These have\n- a parameter pair `HierarchyNodes`, `HierarchyQualifier` where `HierarchyNodes` is a collection and `HierarchyQualifier` is the qualifier of a `RecursiveHierarchy` annotation on its entity type. The node values in this collection define the recursive hierarchy\n- a parameter `Node` that contains the node value of entity to be tested. Note that the test result depends only on this node value, not on any other property of the given entity\n- additional parameters, depending on the type of test (see below)\n- a boolean return value for the outcome of the test.\n\nThe following functions are defined:\n- `isroot` tests if the given entity is a root of the hierarchy,\n- `isdescendant` tests if the given entity is a descendant of an ancestor node (whose node value is given in a parameter `Ancestor`) with a maximum distance `MaxDistance`, or equals the ancestor if `IncludeSelf` is true,\n- `isancestor` tests if the given entity is an ancestor of a descendant node (whose node value is given in a parameter `Descendant`) with a maximum distance `MaxDistance`, or equals the descendant if `IncludeSelf` is true,\n- `issibling` tests if the given entity and another entity (whose node value is given in parameter `Other`) have the same parent node or both are roots, but are not the same,\n- `isleaf` tests if the given entity is without descendants.\n\nImported from [ODATA-1384](https://issues.oasis-open.org/browse/ODATA-1384)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Complete the cardinalities in data model",
    "body": "The diagram does not include the target cardinalities for the navigation between entity types.\n\n### Proposal\n\n* All \"Sales\" navigation properties have a 0..* target cardinality\n- \"Category/Products\" has a 0..* target cardinality\n- \"SalesOrganization/Superordinate\" has a 0..1 target cardinality\n- All others have a 1 target cardinality\n\n[Revised models in UML](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/67762/[ODATA-1383)(https://issues.oasis-open.org/browse/ODATA-1383)%20Example%20Model%20in%20UML.vsdx]\n\nAdjust the text in the document:\n- Replace \"Sales\" entity type with \"Sale\" (singular)\n- In section [2.3 Example Data](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016565) extend the description \"The following *entity sets and* sample data will be used to...\"\n\nImported from [ODATA-1383](https://issues.oasis-open.org/browse/ODATA-1383)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add EntitySet to the list of possible target for terms ApplySupported, CustomAggregate",
    "body": "The current definitions of terms `ApplySupported` and `CustomAggregate` do not include `EntitySet`, but only `EntityType` (amongst others). This prevents services to provide different apply capabilities and different custom aggregates for two entity sets of the same type.\n\n### Proposal\n\n1.\n\nReplace `EntityType` with `EntitySet` to the list of model elements applicable for these two terms.\n\nRemove EntityType from related terms CustomAggregate, ApplySupported, Aggregatable, Groupable.\n\n2.\n\nExtend complex type `NavigationPropertyRestriction` in the `Capabilities` vocabulary to describe the different aggregation support and restrictions between different navigation path, including collections that can only be reached from containment navigation properties. Add this type definition to the `Aggregation` vocabulary.\n\nImported from [ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "New term Core.ContentDisposition",
    "body": "Allow defining the values of the [`Content-Disposition`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) header for binary and stream properties:\n\n\n```json\n\"attachment\": {\n  \"$Type\": \"Edm.Stream\",\n  \"@Core.ContentDisposition\": { \n    \"Filename\": { \"$Path\": \"attachmentFilename\" } \n  }\n},\n\"attachmentFileName\": {\n  \"@Core.Description\": \"This string property contains proposed download filename for `attachment`\"\n}\n```\n\nThis means that \n```\nGET /foo/1/attachment\n```\nreturns the header\n```\nContent-Disposition: attachment; filename=\"<content of attachmentFilename property>\"\n```\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-vocabularies/pull/87/files\n\nImported from [ODATA-1381](https://issues.oasis-open.org/browse/ODATA-1381)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.4.1.2 Handling of DateTimeOffset Values: replace \"i.e. UTC\" with \"for example UTC\"",
    "body": "See summary\n\nImported from [ODATA-1380](https://issues.oasis-open.org/browse/ODATA-1380)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify use of $root with function imports",
    "body": "Section [5.1.1.14.5 $root](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_root) says:\n  \n> The $root literal can be used in expressions to refer to resources of the same service.\n> \n\nHowever the [ABNF](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L501) currently limits this to singletons, entities within an entity set, and everything reachable from there, including bound functions:\n> `rootExpr = '$root/' ( entitySetName keyPredicate / singletonEntity ) [ singleNavigationExpr ]`\n> \n\nAre function imports intentionally omitted?\n\n### Proposal\n\nExtend ABNF to include function imports\n\nImported from [ODATA-1378](https://issues.oasis-open.org/browse/ODATA-1378)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$all not available for rolling up named hierarchies",
    "body": "`$all` is defined in [3.10.2 Grouping with rollup and $all](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016584). For unnamed leveled hierarchies it may be used to introduce a virtual root level that allows to aggregate over all specified hierarchy levels. In other words, this feature offers a “grand total” for unnamed leveled hierarchies.\n\nThe feature is equally interesting for named hierarchies, where the hierarchy is specified by the qualifier of a LeveledHierarchy annotation. However, in this case, `$all` cannot be expressed and thus no “grand total” can be requested from a named hierarchy.\n\nThe same limitation applies to `groupby((rollup(HierQual)),...)`, if `HierQual` refers to a qualifier of an annotation with term `RecursiveHierarchy`, which is discussed in [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218).\n\n \n\nSimply allowing `$all` also for named hierarchies does not work as the following example shows:\n\nRollup with named leveled hierarchy:\n `GET Sales?$apply=groupby(rollup(Product/ProductHierarchy), T)`\n is equivalent to unnamed leveled hierarchy\n `GET Sales?$apply=groupby(rollup(Product/Name,Product/Category/Name), T)`\n\nAdditionally rolling up the root levels:\n- For unnamed leveled hierarchy\n `GET Sales?$apply=groupby(rollup($all,Product/Name,Product/Category/Name), T)`\n- For named hierarchy this does not work, because the qualifier may clash with property name, e.g.\n `GET Sales?$apply=groupby(rollup($all,Product/ProductHierarchy), T)`\n\n### Proposal\n\n1.\n\nIntroduce a further grouping operator `rollupall` that combines `rollup`/`$all` and replaces `$all`:\n- Rollup an unnamed leveled hierarchy incl. root level\n `GET Sales?$apply=groupby(rollupall(Product/Name,Product/Category/Name), T)`\n- Rollup an named leveled hierarchy incl. root level\n `GET Sales?$apply=groupby(rollupall(Product/ProductHierarchy), T)`\n- <del>Rollup a named recursive hierarchy incl. root nodes</del> // not needed. For details see this comment: <del>https://issues.oasis-open.org/browse/[ODATA-1377](https://issues.oasis-open.org/browse/ODATA-1377)?focusedCommentId=79188&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-79188</del>  -`GET SalesOrganizations?$apply=groupby(rollupall(SalesOrgHierarchy), T)`-\n\n2.\n\nUpdate handling for leveled hierarchies. In [3.10.2  Grouping with rollup and $all](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016584):\n- Replace the mentions of `$all` with `rollupall`\n- Replace processing rule for groupby((rollup($all,  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image028.png|width=16,height=21! )),  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! ) with: groupby((rollupall(p1)),,  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! ) is equivalent to concat(groupby((  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image021.png|width=13,height=21! ),  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! ),  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! )\n <del>3.</del>  // not needed. For details see this comment: https://issues.oasis-open.org/browse/[ODATA-1377](https://issues.oasis-open.org/browse/ODATA-1377)?focusedCommentId=79188&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-79188\n <del>Update handling for recursive hierarchies. [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218) specifies groupby(rollup(...),...) for recursive hierarchies. In the [proposed extension](https://1drv.ms/w/s!AlFcFKQNWuoXimvZ8LDIG-AdfOvQ?e=Sg7sxN), add these processing rules for the given input set:</del> - <del>The result of `groupby((rollupall(RHQ),R),T)` is defined as</del>  -{\\{ concat (groupby((R),T),groupby((rollup(RHQ), R), T))}}-\n- <del>The result of `groupby((rollupall(RHQ)),T)` is defined as</del>  -{\\{ concat (T,groupby((rollup(RHQ)), T))}}-\n\n4.\n\nServices announce support for rollup via annotation of term `ApplySupported` with property `Rollup` of type `RollupType`.\n\nProposal is to keep this and treat `rollup`/`rollupall` as a single capability and to express this in the documentation of the `RollupType` enumeration:\n\n`SingleHierarchy` - Only one rollup or rollupall operator per groupby\n `MultipleHierarchies` - Full support for rollup and rollupall\n\nImported from [ODATA-1377](https://issues.oasis-open.org/browse/ODATA-1377)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify terminology where unbound functions can be invoked",
    "body": "Section [12.5 Bound or Unbound Action or Function Overloads](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#_Toc38530387) in the CSDL spec states that “Unbound functions are invoked as static functions within a filter or orderby expression,...”\n\nIf confused with $filter/$orderby system query options one could draw wrong implications, e.g. functions cannot be invoked within a key predicate from parameter alias assignment.\n\n### Proposal\n\nSuch expressions are referred to as common expressions in the URL spec. Rephrase the above to “as static functions within a common expression, cf. [OData-URL], section 5.1.1”\n\nLikewise, proposal includes a change to section [4.5.2 Addressing Functions](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360941) in the URL spec. In the fourth point, replace references to filter and orderby grammar rules by a reference to common expressions ([OData-URL], section 5.1.1).\n\nImported from [ODATA-1376](https://issues.oasis-open.org/browse/ODATA-1376)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify location of custom aggregates in $apply results",
    "body": "This problem occurs twice:\n\n1.\n\nThe current text in [7.3 Custom Aggregates](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016611) states that the dynamic property with the result of a custom aggregate “MUST always be in the same set as the original property.”\n\nExample 61 following this statement puts the result of the custom aggregate Forecast into the nested Sales structure although the request uses a path expression:\n\n`GET ~/Products?$apply=groupby((Name), ... Sales/Forecast))`\n\n2.\n\nThe same statement appears in section [7.4 Aliasing](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016612). Here, it is not wrong, but may draw wrong conclusions , if it is applied to a variation of the request in example 64:\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/Amount with sum as Total))`\n\nThen, `Total` MUST be placed at the top result level.\n\n \n\nFurthermore, we should clarify this semantics in the sentence from [3.1.1 Keyword as](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016569): \"The introduced dynamic property is added to the type containing the original expression _or custom aggregate_. \"\n\n### Proposal\n\nad 1.\n\nTo comply with what we have decided in [ODATA-945](https://issues.oasis-open.org/browse/ODATA-945) (see [red-lined document](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/67246/[ODATA-945)(https://issues.oasis-open.org/browse/ODATA-945)%20-%20Proposal%20for%20Spec%20Update.docx]), the Forecast dynamic property must be placed at the top level of the result entities. Correct the response in example 61.\n\nad 2.\n\nRemove \"The introduced dynamic properties MUST always be in the same set as the original property.\".\n\nTo illustrate the rules, replace the request in example 64 with a variation of it:\n\n`GET ~/Products?$apply=groupby((Name),`\n `                   aggregate(Sales/Amount with sum as Total,`\n `                             Sales(Amount with average as AvgAmt)))`\n\nAccordingly, move `Total` to the top-level entities in the result.\n\n \n\nFurthermore, the sentence in [3.1.1 Keyword as](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016569) should read: \"The introduced dynamic property is added to the context where the aggregate expression is applied to\". This covers custom aggregates, which are also aggregate expressions.\n\nImported from [ODATA-1375](https://issues.oasis-open.org/browse/ODATA-1375)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify service-defined bound functions used as $apply transformations",
    "body": "The current text in [3        System Query Option $apply](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016567) makes an incomplete statement about the return type of such a function in a sequence of $apply transformations: “If it returns an entity set, further transformations can follow the bound function.” This leaves room to use also functions that return a value of a complex or primitive type, which does not fit to the general principle of “set in/set out” for all transformations and the result of $apply being a collection of instances.\n\n### Proposal\n\nRephrase the definition of such functions:\n\nCurrent: \nService-defined bound functions that take an entity set as their binding parameter MAY be used as set transformations within $apply if the type of the ...\n\nNew: \nService-defined bound functions that take a collection of instances of a structured type as their binding parameter and return a collection of instances of a structured type MAY be used as set transformations within $apply if the type of the ...\n\n\nImported from [ODATA-1374](https://issues.oasis-open.org/browse/ODATA-1374)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Examples 60, 61: Missing aggregation method for $count on related entities",
    "body": "The examples make use of `$count` applied to a path expression in an aggregate expression without specifying an aggregation method, e.g. `aggregate(Sales/$count as SalesCount)`\n\nThis syntax construct and its semantics has been introduced in the Core specification, section [11.2.6.1 System Query Option $filter](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358948) and must not be confused with the virtual property `$count` defined in the Data Aggregation extension specification, section [3.1.5 Virtual Property $count](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016573). It represents a common expression that, if used in the `aggregate` transformation, must be complemented with an aggregation method.\n\n### Proposal\n\n*Ex 60: Replace*\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count as SalesCount))`\n\nwith\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count with sum as SalesCount))`\n\n*Ex 61: Replace*\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count as SalesCount,``Sales(Amount with sum as TotalAmount)))`\n\nwith\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count with sum as SalesCount,``Sales(Amount with sum as TotalAmount)))`\n\nImported from [ODATA-1373](https://issues.oasis-open.org/browse/ODATA-1373)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify term \"filter function\"",
    "body": "Term \"filter function\" suggests function isdefined and the predicate functions for hierarchies are only valid within $filter. Actually, as Boolean method call expression/Boolean functions they can be used in more cases.\n\n### Proposal\n\nName them \"functions\".\n\nImported from [ODATA-1372](https://issues.oasis-open.org/browse/ODATA-1372)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve structure of CSDL clause 4",
    "body": "The subclause levels of this section suggest that Included Schema and Included Annotations are independent declarations from the $Reference declaration.  However, they should be documented as parts of the $Reference declaration.\n\nRelated to this, 4.1 Reference asserts that it is used to bring in part of the referenced document.  However, both $Include and $IncludedAnnotations is documented as optional.  Either $Reference can bring in all of a referenced document, or at least one of $Include or $IncludedAnnotations must be specified.\n\nNote that edmx.xsd does not resolve this issue since it also allows the possibility that neither Include or IncludeAnnotations is specified.  \n\nA trivial issue is that both 'include' and 'included' are used to refer to the same functionality in this section.\n\n### Proposal\n\nReword section 4.3 along similar lines as 4.2:\n\"In addition to including whole schemas with all model constructs defined within that schema, _a reference may include_ annotations.\"\n\nMake both references to *references* be links to section 4.1.\n\nImported from [ODATA-1371](https://issues.oasis-open.org/browse/ODATA-1371)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 30: Wrong context",
    "body": "The request addresses the Categories set, so the context URL must refer to this set and not to the Customers set.\n\n### Proposal\n\nsee description\n\nImported from [ODATA-1369](https://issues.oasis-open.org/browse/ODATA-1369)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify Term applicability",
    "body": "The following text may be misconstrued to be a require that limits the term to the listed model elements.\nh3. [14.1.2 Applicability](#sec_Applicability)\n\nThe applicability of a term MAY be restricted to a list of model elements. If no list is supplied, the term is not intended to be restricted in its application. The list of model elements MAY be extended in future versions of the vocabulary.\n\n \n\n### Proposal\n\nChange the text as follows:\nh3. [14.1.2 Applicability](#sec_Applicability)\n\nApplicability specifies a list of model elements to which the term MAY be applied.  If no list is supplied, the term MAY be applied to any model element. The list of model elements MAY be extended in future versions of the vocabulary.\n\nImported from [ODATA-1368](https://issues.oasis-open.org/browse/ODATA-1368)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve the layout of vocabularies markdown to indicate that shown annotations are not exhaustive",
    "body": "Markdown tables in the vocabularies markdown files are typically not showing all the possible annotations. When they are shown because they are notable, the table gives the impression that they are the only allowed annotations, which is not the case.\n\n \n\n \n\n### Proposal\n\nSuggestion is to split the table in two: one for regular properties, one for annotation properties. The table header for the second should indicate that these are not the only allowed annotations.\n\n \n\ne.g.\n\nFrom:\n\n!image-2020-05-14-09-33-15-133.png|width=618,height=132!\n\n \n\nTo:\n\n!image-2020-05-14-09-32-41-327.png|width=649,height=213!\n\nImported from [ODATA-1367](https://issues.oasis-open.org/browse/ODATA-1367)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove redundant text to improve readability",
    "body": "In the CSDL documents, the struck-through words below are redundant.\n\n*$EntityContainer*\n\nThe value of $EntityContainer -{color:#de350b}is value{color}- is the namespace-qualified name of the entity container of that service. This is the only place where a model element MUST be referenced with its namespace-qualified name and use of the alias-qualified name is not allowed.\n\n### Proposal\n\nRemove the redundant words.\n\nImported from [ODATA-1366](https://issues.oasis-open.org/browse/ODATA-1366)",
    "labels": [
      "CSDL JSON",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enhance Validation.AllowedValue to have optional symbolic name",
    "body": "In some cases EnumType is undesirable because adding a member constitutes a backwards-incompatible change.\n\nIf Validation.AllowedValue had an optional Name property (Type=\"Edm.String\" Nullable=\"true\") then Validation.AllowedValues inside a TypeDefinition could be used to define \"better enums\" (including String-valued enums) that would allow graceful evolution of services without backwards-incompatible changes.\n\n            <TypeDefinition Name=\"Colour\" UnderlyingType=\"Edm.Int32\">\n                <Annotation Term=\"Validation.AllowedValues\">\n                    <Collection>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Red\"/>\n                            <PropertyValue Property=\"Value\" Int=\"1\"/>\n                        </Record>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Blue\"/>\n                            <PropertyValue Property=\"Value\" Int=\"2\"/>\n                        </Record>\n                    </Collection>\n                </Annotation>\n            </TypeDefinition>\n\nor using String:\n\n            <TypeDefinition Name=\"Colour\" UnderlyingType=\"Edm.String\">\n                <Annotation Term=\"Validation.AllowedValues\">\n                    <Collection>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Red\"/>\n                            <PropertyValue Property=\"Value\" String=\"ff0000\"/>\n                        </Record>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Blue\"/>\n                            <PropertyValue Property=\"Value\" String=\"0000ff\"/>\n                        </Record>\n                    </Collection>\n                </Annotation>\n            </TypeDefinition>\n\n\nTBD (possibly should be spun off to another JIRA issue): how to mark an AllowedValues to indicate that it provides the equivalent of a Flags-style EnumType.\n\n\n### Proposal\n\nDefine a new SymbolicName annotation that can be applied to the AllowedValues annotation (or other places) of type SimpleIdentifier (a new TypeDef with underlying type of string).\n\nAdd SymblicName to the list of ApplicableTerms for AllowedValues.\n\nImported from [ODATA-1365](https://issues.oasis-open.org/browse/ODATA-1365)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Missing comma in JSON metadata example",
    "body": "In 16.1 Products and Categories Example, there’s a “,” missing after “$Nullable”: true for the \"Country\" navigation property on \"Address\":\n\n\n\"Country\": {\n        \"$Kind\": \"NavigationProperty\",\n        \"$Nullable\": true\n        \"$Type\": \"self.Country\",\n        \"$ReferentialConstraint\": {\n          \"CountryName\": \"Name\"\n        }\n      }\n\n\n\n### Proposal\n\nAdd the missing comma.\n\nImported from [ODATA-1363](https://issues.oasis-open.org/browse/ODATA-1363)",
    "labels": [
      "CSDL JSON",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ABNF: preference omit-values missing",
    "body": "The preference `omit-values` is missing from the ABNF\n\nImported from [ODATA-1362](https://issues.oasis-open.org/browse/ODATA-1362)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "CSDL TimeOfDay literals inconsistent with XSD",
    "body": "CSDL XML 4.01 sectin 14.3.12 Time of Day\n\nThe edm:TimeOfDay expression evaluates to a primitive time value. A time-of-day expression MUST be assigned a value conforming to the rule timeOfDayValue in [OData‑ABNF].\n\nABNF shows:\n\ntimeOfDayValue      = hour \":\"   minute [ \":\"   second [ \".\" fractionalSeconds ] ]\n\n(so the second can be omitted)\n\nBut in http://docs.oasis-open.org/odata/odata/v4.0/os/schemas/edm.xsd\n\n<xs:simpleType name=\"time\">\n  <xs:restriction base=\"xs:time\">\n    <xs:pattern value=\"([01][0-9]](2[0-3)):[0-5][0-9]:[0-5][0-9](\\.[0-9]{1,12})?\"/>\n  </xs:restriction>\n</xs:simpleType>\n\ndoesn't allow the seconds portion to be omitted, so is inconsistent with the ABNF timeOfDay references by CSDL spec.\n\n### Proposal\n\nFix the edm:time definition in the xsd\n\n\nImported from [ODATA-1361](https://issues.oasis-open.org/browse/ODATA-1361)",
    "labels": [
      "CSDL XML",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that clients have to do content-ID replacing to interpret Location headers in batch results",
    "body": "A server is allowed to return a URI in the Location header that is relative to the request URL.  In a batch request, a request URL can contain a content-ID reference, like $1/Orders to create an order to a not yet created customer.  The server can return a Location header of ../Orders(2020) in the response.  For the client to be able to determine the correct location of the new Order it MUST perform the content-ID replacement in the request URL (because $1 is not necessarily a single path segment).\n\nWe should clarify this by explicitly stating that these steps are required by clients under these circumstances.\n\n### Proposal\n\nAdd a sentence to JSON Format, section 19.2 (and the corresponding section on Multipart Batch in Protocol):\n> If the `Location` header in the response contains a relative URL, clients MUST be able to resolve it relative to the request's URL even if that contains such a reference.\n> \n\n\nImported from [ODATA-1360](https://issues.oasis-open.org/browse/ODATA-1360)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "19.4, second paragraph, first sentence: missing \"in\"",
    "body": "\n\n### Proposal\n\n> The service MAY process the individual requests and atomicity groups within a batch request, or individual requests within an atomicity group, {color:#00875a}*in*{color} any order that is compatible\n> \n\n\nImported from [ODATA-1359](https://issues.oasis-open.org/browse/ODATA-1359)",
    "labels": [
      "JSON Format",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add descriptions to system query option restrictions in Capability vocabulary",
    "body": "There are cases when a custom description for system query options can help service consumers to better understand the supported functionality. For example, they could be used to explain special constraints stemming from the service model that cannot be expressed otherwise.\n\n### Proposal\n\nAllow application of term Core.Description to:\n - BatchSupportType\n - FilterRestrictionsType\n - SortRestrictionsType\n - ExpandRestrictionsType\n - SearchRestrictionsType\n\nAllow application of term Core.LongDescription to:\n - BatchSupportType\n\nDocument this via Validation.ApplicableTerms.\n\nRationale:\n - BatchSupportType describes an operation and thus has both a Description and a LongDescription, similar to InsertRestrictionsType, UpdateRestrictionsType, DeleteRestrictionsType, and ReadRestrictionsBase.\n - The other four types describe query options, similar to type CustomParameter, which also only has a Description, no LongDescription\n\nImported from [ODATA-1357](https://issues.oasis-open.org/browse/ODATA-1357)",
    "labels": [
      "Vocabularies",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "13.2, paragraph 5: typo \"indicatet\" instead of \"indicated\"",
    "body": "See summary\n\nImported from [ODATA-1356](https://issues.oasis-open.org/browse/ODATA-1356)",
    "labels": [
      "CSDL XML",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Generalize Validation.Minimum and Validation.Maximum to Edm.PrimitiveType",
    "body": "Currently Validation.Minimum and Validation.Maximum are of type Edm.Decimal.\n\nIn principle these terms can apply to any totally ordered primitive type, e.g. Edm.Duration.\n\n### Proposal\n\nChange type of term from Edm.Decimal to Edm.PrimitiveType (and remove the Scale facet).\n\nImported from [ODATA-1355](https://issues.oasis-open.org/browse/ODATA-1355)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarity for \"@odata.type\" in request payloads",
    "body": "We ran into an interoperability issue where servers don't accept \"@odata.type\" in request payload (this is for a case where there is no inheritance in model).\n\nClient is sending \"@odata.type\" because previously we encountered servers that required \"@odata.type\".\n\nNow we were hoping to argue that servers not accepting \"@odata.type\" in request payload were non-compliant with the spec, however...\n\nThe “minimal” and “full” metadata are defined in subsections of OData 4.01 JSON section 3.1 Controlling the Amount of Control Information in *Responses*.\n\nNowhere do we appear to define the amount of control information in *requests*.\n\nAlthough we could take it as an unstated assumption that \"@odata.type\" MAY appear even where it isn’t required to appear, it would be best if we have a separate section describing what control information MAY (and MUST, in the case of entity inheritance) appear in request payloads.\n\n\n\n\nImported from [ODATA-1353](https://issues.oasis-open.org/browse/ODATA-1353)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify format for $value",
    "body": "Section 11.2.4.1 says that the format is text/plain but does not specify the exact format for the primitive types.  We should clarify that the format is xxxValue from OData-ABNF.\n\n### Proposal\n\nChange the sentence:\n\nThe default format for single primitive values except Edm.Binary and the Edm.Geo types is text/plain.\n\nto (roughly)\n\nThe default format for single primitive values except Edm.Binary and the Edm.Geo types is text/plain and follows the rules xxxValue defined in [ODATA-ABNF].\n\nImported from [ODATA-1352](https://issues.oasis-open.org/browse/ODATA-1352)",
    "labels": [
      "Protocol"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify IEEE754Compatible applies to request payloads as well",
    "body": "Section 3.2 in the JSON format does not make it clear that IEEE 754 Compatibility applies to both response and requests.  Reword the section to make it more clear by stating explicitly which component (client and/or service) can add the IEEE754Compatible format parameter to the Accept and Content-Type headers.\n\n### Proposal\n\nChange:\n\"OData JSON payloads that format Edm.Int64 and Edm.Decimal values as strings MUST specify this format parameter in the media type returned in the Content-Type header.\"\nto:\n\"OData JSON request and response payloads that format Edm.Int64 and Edm.Decimal values as strings MUST specify this format parameter in the media type returned in the Content-Type header.\"\n\n(or other clarifications as editor deems appropriate)\n\nImported from [ODATA-1351](https://issues.oasis-open.org/browse/ODATA-1351)",
    "labels": [
      "JSON Format",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]