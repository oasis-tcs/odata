[
  {
    "title": "Add an example of a delta payload used in a PATCH request to the Delta Payload section ",
    "body": "Section 14, Delta Payload in the OData 4.01 JSON format document was updated to indicate that a Delta Payload can be used as both a response to a GET request to a delta link and as the body of a PATCH request.  All of the examples in that section are for responses to a delta link.  An example of the Delta Payload being used in a PATCH request would be useful in this section.\n\nImported from [ODATA-1022](https://issues.oasis-open.org/browse/ODATA-1022)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Are additional values needed for the reason property of a removed Annotation",
    "body": "In a nested Delta Payload, a removed annotation can include a reason property that indicates why the item was removed.  Currently the value can be one of deleted or changed.  The changed value can be used in one of two cases\n\n1) If a property of the item changed such that the item no longer fits the filter of the delta query \n2) The item is no longer linked to the collection being acted on \n\nThe question came up as to whether an additional value is needed to distinguish between the two cases above.  In the discussion there was concern that not all data sources would be able to distinguish between the to cases.  \n\nAdditionally when the Delta Payload is passed as the body of a PATCH request, only the second case above is valid.  In the discussion the question came up about whether the meaning of reason could be different when used as a request and a response.  The concern there is that it is desirable to be able to pass the Delta Payload received from one service on to a second service\n\n### Proposal\n\nClose without fixing.\n\nReasoning:\n\n- Additional values are unnecessary from the point of view of a client applying a delta response because the net result in both cases is the same.\n\n- Having a different value for the reason for a delta response and a delta upload request is an unnecessary complication that doesn’t add value and prevents easily passing the a delta response as a delta upload request.\n\n- \"change\" is a very generic term that we did discuss changing to something more meaningful.  However, we were unable to come up with something better.  Further, changing this value could break backwards compatibility between 4.0 and 4.01 so it's best to leave it as is.\n\nImported from [ODATA-1021](https://issues.oasis-open.org/browse/ODATA-1021)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Remove / in reference in instance annotation in filter and orderby expression",
    "body": "In [ODATA-933](https://issues.oasis-open.org/browse/ODATA-933) we allowed using instance annotations in $filter. In doing so we ended up treating annotations as a path segment, matching the path syntax.\nAlthough perhaps perfectly aligned with the path syntax it looks weird to have two separators, both / and @ sign separating the property to which the annotation applies to and the annotation itself. Everywhere else where we, in our JSON payloads, have an annotation, we use property@annotation.\nI'd propose we'd amend the resolution of [ODATA-933](https://issues.oasis-open.org/browse/ODATA-933) accordingly and omit the / from the reference to the annotation and therefore address an annotation value on a property as \nNavigationPropertyName@Term#Qualifier instead. \n\n\nImported from [ODATA-1020](https://issues.oasis-open.org/browse/ODATA-1020)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add term Core.ComputedDefaultValue",
    "body": "We sometimes have properties that are \"auto-filled\" by the service if the client provides no value on insert, and the auto-filled value is not static, so it cannot be specified as a DefaultValue.\n\n### Proposal\n\nTerm definition\n\n<Term Name=\"ComputedDefaultValue\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"Property\">\n  <Annotation Term=\"Core.Description\" String=\"A value for this property is can be provided on insert and update. If no value is provided on insert, a non-static default value is generated\" />\n</Term>\n\n\nImported from [ODATA-1019](https://issues.oasis-open.org/browse/ODATA-1019)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow $expand, $select and $filter with modifying requests that return a collection in combination with return=representation to specify the response shape",
    "body": "This is a clone of [ODATA-614](https://issues.oasis-open.org/browse/ODATA-614) in which we allowed to use $expand and $select already for single entities.\nWhile discussing this in our meeting on December 1st, we concluded that there is no reason to not allow this for collections either.\n\nThe proposed solution is pretty much just allowing what we already allowed for requests returning a single resource to collections as well. Re-reading the proposal though I wonder if it is obvious that returning 'No Content' implies it couldn't return what was requested but still executed the request. I'm not proposing to fail the request just not sure if the response is in line with what one expects/what a GET request would do if it were asked the same???\n\n### Proposal\n\nExtend allowing use of $select, $filter and $expand to data modification requests that return a collection\n1) if $expand/$select/$filter are present, implies return=representation\n2) if $expand/$select/$filter are present and return=minimal is specified, then service SHOULD NOT return a result and MUST include preference-applied if they DON'T return a result\n3) if it returns a result, $expand and $filter MUST be applied if specified and MUST include at least the $selected columns\n4) the service MUST NOT fail the request due to the $expand/$select/$filter; if the service cannot return a result with the appropriate $expand, $filter and $select it MUST return No Content\n\n\n\nImported from [ODATA-1018](https://issues.oasis-open.org/browse/ODATA-1018)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Extend FilterExpressionRestrictions with \"SearchExpression\"",
    "body": "Filter expression restrictions where introduced in [ODATA-816](https://issues.oasis-open.org/browse/ODATA-816) to express restricted filter capabilities on individual properties that can only be used in equality comparison or interval comparison.\n\nAnother important class of restrictions is for operators on character large objects (CLOB, NCLOB, TEXT). Many data stores only support null check and pattern matching on columns of this type and do not support equality or greater-than comparison.\n\n\n\n### Proposal\n\nAdd new allowed value\n\n  <Record>\n    <PropertyValue Property=\"Value\" String=\"SearchExpression\" />\n    <Annotation Term=\"Core.Description\" String=\"String property can be used as first operand in startswith, endswith, and contains clauses\" />\n  </Record>\n\nfor properties representing character large objects.\n\nImported from [ODATA-1017](https://issues.oasis-open.org/browse/ODATA-1017)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.2.9: clarify /$count segment and system query options",
    "body": "Part 1, section 11.2.9 on the /$count path segment states:\n\nThe returned count MUST NOT be affected by $top, $skip, $orderby, or $expand. \n\nPart 2, section 5.1 states that only $filter and $search are allowed for paths ending in /$count.\n\n\"Not allowed\" is clearer than \"must not be affected by\", so rephrase part 1.\n\n### Proposal\n\nReplace\n\nThe returned count MUST NOT be affected by $top, $skip, $orderby, or $expand. Content negotiation using the Accept request header or the $format system query option is not allowed with the path segment /$count.\n\nwith\n\nClients SHOULD NOT combine system query options $top, $skip, $orderby, $expand, and $format with the path segment /$count. The result of such a request is undefined.\n\nImported from [ODATA-1016](https://issues.oasis-open.org/browse/ODATA-1016)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Reference Atom format from Version 4.01 documents?",
    "body": "The Atom format hasn't been revised and extended to support new V4.01 features.\n\nShould we still reference it from 4.01 documents?\n\nImported from [ODATA-1015](https://issues.oasis-open.org/browse/ODATA-1015)",
    "labels": [
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "How does client find out if implicit parameter aliases are supported?",
    "body": "[ODATA-763](https://issues.oasis-open.org/browse/ODATA-763) added syntax for implicit parameter alias, but makes them optional.  How does a client find out that implicit parameter aliases are supported? We could make them mandatory, provide a capability to discover them, or just say that interoperable clients should always use the parens form.\n\nImported from [ODATA-1014](https://issues.oasis-open.org/browse/ODATA-1014)",
    "labels": [
      "V4.01_CSD02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Selected nav props in a defining query should specify interest in added/deleted links of a delta query",
    "body": "Today we say that expanded properties in the defining query define the scope of the graph for which the client is interested in receiving changes.\n\nIt could be that the client is interested in knowing about added/deleted links, but doesn't care about the contents of the entities related through those links.\n\nThis could easily by supported by saying that navigation properties in the select list define the links that the client is interested in knowing about changes for. If the service represents deltas to related entities through an inline collection, that inline collection would contain (minimally) the entity references (or key properties of entities) representing the current membership.\n\n### Proposal\n\nNav properties specified in the select list of a defining query are not used to define the scope or contents of the items being tracked. Clients can specify /$ref in $expand in order to specify interest in the set of related entities without interest in changes to the content of those related entities.\n\nDelta responses contain AddedLinks and DeletedLinks entries (or, for nested collections, (at least) entity references representing the current membership) for navigation properties expanded with $ref in the defining request.\n\nImported from [ODATA-1013](https://issues.oasis-open.org/browse/ODATA-1013)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Represent nested deltas as an annotation",
    "body": "In 4.01 CSD01 we have proposed that a nested collection within a delta payload can be represented either as a replacement of the collection (where omitted values are removed from the collection) or as a delta payload (where only enumerated values are changed, and removed entities are represented as tombstones).\n\nThe way we differentiate between these two is, in the case of a nested delta, by annotating the collection property with a context url specifying a delta:\n\n    \"members@contextUrl\":\"#$delta\",\n    \"members\": [ ... ]\n\nAlternatively, we could just use a delta annotation prefixed with the property name, as in:\n\n    \"members@delta\": [ ... ]\n\nWhich wouldn't require using the contextUrl annotation to interpret the property.\n\n### Proposal\n\nExpose nested deltas as a delta representation on the property, rather than through a context url.\n\nImported from [ODATA-1012](https://issues.oasis-open.org/browse/ODATA-1012)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Represent deleted entities similar to added/changed entities",
    "body": "Allow representing deleted entities similar to added/changed entities\n\n\n    {\n      \"@odata.context\":\"#Orders/$entity\",\n      \"@odata.id\":\"Orders(10643)\",\n      \"ShippingAddress\":{\n        \"Street\":\"23 Tsawassen Blvd.\",\n        \"City\":\"Tsawassen\",\n        \"Region\":\"BC\",\n        \"PostalCode\":\"T2F 8M4\"\n      },\n    },\n    {\n      \"@odata.context\":\"#Customers/$entityDeletion\",\n      \"@odata.id\":\"Customers('ANTON')\",\n      \"@odata.reason\":\"deleted\",\n      /* optionally properties of the deleted entity */\n     \"CustomerID\": \"ANTON\",\n     ...\n    }\n\nThis would allow using the same serialization template. And it looks more consistent :-)\n\n### Proposal\n\nSupport the new representation with the existing /$deletedEntity everywhere in 4.01. Nest @odata.removed with a reason and additional annotations. \n\nImported from [ODATA-1010](https://issues.oasis-open.org/browse/ODATA-1010)",
    "labels": [
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify context url of delta responses for containment navigation properties",
    "body": "If the defining query of a delta request targets a containment navigation property, then the delta response context url should be the context URL of the response of the defining query suffixed with /$delta, e.g.\n\nhttp://host/service/$metadata#Orders(4711)/Items/$delta \n\nThis can only be guessed from the current specification text.\n\n### Proposal\n\nChange current text:\n\nThe context URL of a delta response is the same as the context URL of the root entity set, followed by /$delta.\n\n\nto new text:\n\nThe context URL of a delta response is the context URL of the response to the defining query, followed by /$delta.\n\nIf the entities are contained, then entity-set is the top-level entity set followed by the path to the containment navigation property of the containing entity.\n\n\n\n\nImported from [ODATA-1009](https://issues.oasis-open.org/browse/ODATA-1009)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider deprecating symbolic \"max\" length",
    "body": "We currently allow specifying \"max\" as the maximum length of a string property. This is of dubious value, and we don't want to support it in the JSON format. Should we deprecate it from the XML format?\n\n### Proposal\n\nThe OData 4.0 use of the symbolic value max in place of an integer value is deprecated in OData 4.01. While OData 4.0 clients MUST be prepared for this value, OData 4.01 and greater services MUST NOT return a value of max for the MaxLength attribute and MAY instead specify the concrete maximum length supported for the type by the service, or omit the attribute entirely. \n\nImported from [ODATA-1008](https://issues.oasis-open.org/browse/ODATA-1008)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider how to handle namespace conflicts in JSON CSDL format",
    "body": "In our XML format we are able to define aliases for namespaces referenced in external metadata documents, which allows us to disambiguate cases where referenced metadata documents may use the same namespace name.\n\nIn the JSON format we want to make things indexed by the namespace-qualified name, which makes it easy and natural to lookup by name.\n\nWe need to figure out if/how we address the (presumably uncommon) scenario where two referenced metadata documents use the same name.\n\n### Proposal\n\nClarify in Part 3: CDSL that a namespace-qualified name must be unique within a scope (document plus directly referenced documents) and that a schema cannot be included twice via different URIs.\n\nThis follows from existing normative text that aliases are only shortcuts, alias-qualified names are interchangeable with namespace-qualified names, and that a schema cannot span more than one document.\n\nImported from [ODATA-1007](https://issues.oasis-open.org/browse/ODATA-1007)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Unicode facet for terms, parameters, and return types",
    "body": "The Unicode facet is currently only defined for string properties, not for terms, parameters, and return types of type string.\n\nThis is odd because structured terms, parameters, and return types can have string properties with the Unicode facet. Why only for \"wrapped\" strings and not for plain unwrapped strings?\n\n### Proposal\n\nClarify that the Unicode facet can also be used for terms, parameters, and return types of type Edm.String for 4.01 responses.\n\nImported from [ODATA-1006](https://issues.oasis-open.org/browse/ODATA-1006)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make sure we have capabilities for all new 4.01 functionality",
    "body": "Do this in conjunction with conformance, so clients have a way to determine which optional parts of 4.01 are supported by a service.\n\nThings already covered:\n- POST/PATCH/PUT with system query options to shape response: [ODATA-1216](https://issues.oasis-open.org/browse/ODATA-1216)\n- $select with nested query options: [ODATA-1176](https://issues.oasis-open.org/browse/ODATA-1176)\n- $compute with insert/update: [ODATA-1216](https://issues.oasis-open.org/browse/ODATA-1216)\n- Deep update: `DeepUpdateSupport`\n\nThings covered by the referenced pull request:\n - Upsert: `UpdateRestrictions/Upsertable`\n - PATCH on collection using delta format: `UpdateRestrictions/DeltaUpdateSupported`\n - PATCH with filter path segment: `UpdateRestrictions/FilterSegmentSupported`\n - PATCH with typecast segment: `UpdateRestrictions/TypecastSegmentSupported`\n - DELETE with filter path segment: `DeleteRestrictions/FilterSegmentSupported`\n - DELETE with typecast segment: `DeleteRestrictions/TypecastSegmentSupported`\n - POST with type cast segment: `InsertRestrictions/TypecastSegmentSupported`\n - POST to collections of complex/primitive types: `CollectionPropertyRestrictions/Insertable`\n - /$filter segment for invoking bound actions/functions: OperationRestrictions/FilterSegmentSupported\n - Operators `in`, `divby`: `FilterFunctions`, mention that empty list means \"just try\"\n - $compute with read: `ComputeSupported` on entity set\n - $expand for stream properties and media resources: `ExpandRestrictions/StreamsExpandable`\n - /$query segment: `QuerySegmentSupported`\n\n \n\nImported from [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005)",
    "labels": [
      "New in OData",
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Sign of Modulo for positive right operand",
    "body": "The current description of Modulo reads:\n\n\"If the right operand is negative, the sign of the result is the same as the sign of the left operand. If the right operand is zero, the request fails.\"\n\nThis leaves (intentionally?) ambiguous what the sign of the result should be if the right operand is positive.\n\nMost programming languages appear to always use the sign of the left operand (C/C++, CoffeeScript, Fortran, Java, JavaScript, PHP, SQL, VB, XBase++,...) while some use the sign of the right operand (Ada, COBOL, Common LISP, Haskell, Excel, PERL, Python, R, Ruby,...) and some return a positive result always, but I didn't find any examples where the result was the sign of the left operand if, and only if, the right operand was negative.\n\nNote that MOST of the languages that use the sign of the right operand have variants for returning the sign of the left operand.\n\nWe could specify:\n1) Sign is always the sign of the left operand (most commonly supported)\n2) Sign is always the sign of the right operand (less commonly supported)\n3) Sign is always positive\n4) Sign is explicitly undefined\n\n\n### Proposal\n\nState that the result of the mod operation has the same sign as the left operand.\n\nImported from [ODATA-1004](https://issues.oasis-open.org/browse/ODATA-1004)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow casting of entities and complex type instances to arbitrary structural type",
    "body": "Currently we allow casting, by means of a type segment, which implicitly filters or, in expressions in our query options, by using the cast function.\nWhereas the cast function allows, optionally, casting to an arbitrary structured type, there is no way to request for an instance of a type and have it, before returning it, be cast to a different arbitrary, typically sibling (read: same base type) type.\nBTW if a cast would be not supported/allowed I'd simply expected a 400 Bad Request to be returned by the server.\n\nImported from [ODATA-1003](https://issues.oasis-open.org/browse/ODATA-1003)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add build in functions operating on collections of primitive (and complex?) types",
    "body": "I'm getting more asks for people wanting to filter against properties representing a collection of primitive type, most notably Collection(Edm.String).\nThings like equal to, not equal to and containing a value or subset are the operations that people are looking to do the most. The size of the array they can get around by using /$count.\nShort of coming up with something ourselves I was wondering if this is a more generic ask and if we could maybe guide implementations as to how to support this kind of functionality in a more generic way.  \n\n### Proposal\n\nSpecify equality for collections of primitive types and extend the syntax, using the comma-separated list of literal primitive values enclosed by parens notation, to allow for comparison of arrays.\nEquality for ordered collections would be defined as:\n - same number of items\n - all items in the array, at the same index, compare as equal\nEquality for unordered collections would be defined as:\n - same number of items\n - all items in the array, after the server enforcing the same ordering on both collections, compare as equal, at the same index\n\nSee also [ODATA-1075](https://issues.oasis-open.org/browse/ODATA-1075)\n\nImported from [ODATA-1002](https://issues.oasis-open.org/browse/ODATA-1002)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that lambda expression, 'any' and 'all', can be applied to collections of all types.",
    "body": "In Section 5.1.1.10 Lambda operators the sentence\n\"a Boolean expression that uses the lambda variable name to refer to properties of the related entities identified by the navigation path\"\nseems to suggest that one would only be apply our Lambda expressions against collections of entity type.\nQuick check with Ralf confirmed my impression that we should be able to apply lambda expressions on collections of any and all types. \n\n\n### Proposal\n\nClarify that lambda expressions can be applied to all collections of any type. \n\nImported from [ODATA-1001](https://issues.oasis-open.org/browse/ODATA-1001)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider adding support for 'aliases' on Entity sets, Singletons and Properties ",
    "body": "The idea behind allowing aliases is primarily driven by having shorter names for various entity sets, singletons and properties of complex and entity types. Ideally these aliases could be used in request as well as be returned by the server in response payloads.\n\nImported from [ODATA-999](https://issues.oasis-open.org/browse/ODATA-999)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Specify comparable types for comparison operators",
    "body": "\n\n### Proposal\n\nSpecify which types can be compared with eq, ne, le, lt, ge, gt\n\na) values of same primitive type can be compared (except Edm.Binary, Edm.Stream, and the Edm.Geo types) \nb) numbers compared with each other using casting rules\n\nImported from [ODATA-998](https://issues.oasis-open.org/browse/ODATA-998)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define modulo operator for non-integral numeric values",
    "body": "The div operator is defined for numeric operands.\n\nThe mod operator is only defined for integral operands, but the section on the mod operator contains rules for decimal operands.\n\nClarify whether mod supports non-integral numeric operands, and how it is calculated, e.g. a mod b = a sub b mul floor(a div b)\n\n### Proposal\n\nClarify that mod supports non-integral numeric operands, and that it is defined as \n\n a mod b eq a sub b mul floor(a div b)\n\n(i.e., the remainder after dividing a by b the maximum integral number of times)\n\nImported from [ODATA-997](https://issues.oasis-open.org/browse/ODATA-997)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Added/deleted links: \"relationship\" should be navigation property path",
    "body": "Sections 14.3 and 14.4 define the format for added/deleted links and state that the property \"relationship\" contains the name of the navigation property that is changed.\n\nThe name alone isn't sufficient for navigation properties nested within complex properties, \"relationship\" should instead contain the path to the navigation property.\n\nCollection-valued complex properties with nested navigation properties need special attention.\n\nMaybe restrict change tracking to ordered collections of complex instances with nested navigation properties, or require \"nested delta\" format for these in V4.01\n\n### Proposal\n\nUse\n- relationship – The path to the navigation property on the source object (traversing zero or more complex properties and terminating on a navigation property).\n\ninstead of\n- relationship – The name of the navigation property on the source object\n\nFor ordered collection-valued complex properties use nested representation.\n\n\nImported from [ODATA-996](https://issues.oasis-open.org/browse/ODATA-996)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Resolve inconsistencies in JSON streaming property ordering",
    "body": "Section 18.2 states that annotations must be \"adjacent to\" the properties they annotate.\n\nSection 4.4 states that annotations must come before the property they annotate.\nSection 4.4 also states that navigation annotations must come after structural properties, which seemed unnecessary\n\n### Proposal\n\nUpdate 18.2 to state that annotations must come before the property\nUpdate 4.4 to say that 4.0 services MUST return nav annotations after structural properties, 4.01 clients MUST NOT assume this ordering. \n\n\nImported from [ODATA-995](https://issues.oasis-open.org/browse/ODATA-995)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "consider replacing SchemaVersion header with $SchemaVersion query option, or root URL versioning",
    "body": "In OData-980 we clarified how odata.type is annotated, but this brought up the question as to whether we should be using a SchemaVersion request header or a $SchemaVersion query option to request a particular version of data.  A queryoption (or root url versioning) has the advantage of making the response cacheable, we just need to make sure composition rules are well thought-out (i.e., for using contexturl as base for relative references)\n\n### Proposal\n\nIf the only difference between two request is the SchemaVersion Header value, the response is not cachable in all today-browser-implementations (the 'vary' header is not treated correct). \n--> To enable caching of responses we need differentiating URL's. We should use a $SchemaVersion query option. It is superior to adding a segment to the root url, because clients are anyhow familiar with adding query options.\nThe usage of a $SchemaVersion query option in the relative contextURLs is save; according to rfc3986 query options on the base URI are not kept during reference resolution for all relevant cases.\nDepending on the value of the SchemaVersion it may be necessary to percent-encode it before the URI is formed.\n\nRevised proposal:\nRemove SchemaVersion header in place of a $SchemaVersion query option.\nLimit characters in SchemaVersion to things that don't have to be percent encoded:\nCharacter set: unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\nImported from [ODATA-994](https://issues.oasis-open.org/browse/ODATA-994)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.2: Explicitly allow annotations on deleted entities",
    "body": "The delta format identifies deleted entities via their entity id.\n\nFor legacy systems that don't store the entity id and only know the underlying  key values it would be helpful if the sender would annotate the deleted entity JSON objects with the original key values, e.g.\n\n    {\n      \"@odata.context\":\"#Customers/$deletedEntity\",\n      \"id\":\"Customers('ANTON')\",\n      \"@Legacy.entityKey\":{\n        \"ID\":\"ANTON\"\n      },\n      \"reason\":\"deleted\"\n    }\n\n### Proposal\n\nSupport annotations in the following:\n-AddedLinks\n-DeletedLinks\n-Deleted Entries\n-References\n\nIn JSON, clients should be prepared for annotations in any object and any name/value pair in a json payload. Clients should never error on an unexpected annotation.\n\nImported from [ODATA-993](https://issues.oasis-open.org/browse/ODATA-993)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Numeric enumerations should use AllowedValues",
    "body": "Part 3: CSDL states that enumeration values are sorted and compared using their numeric value because it allows synonym symbolic names with the same numeric value.\n\nPart 3: CSDL also only allows symbolic values in annotations.\n\nJSON Format on the other hand states that the symbolic name, represented as a string, is preferred.\n\nThis makes life unnecessarily complicated for clients to evaluate conditional annotation expressions based on enums as they can't compare enum values in annotations and payloads without internally translating them into numeric values, which they can only know after reading vocabulary files.\n\n### Proposal\n\nLeave enumeration types as they are. If no flags or synonyms/symbolic names are required/desired, use annotation Validation.AllowedValues instead.\n\nCall out that services that want a discrete set of numeric should use AllowedValues.\n\nImported from [ODATA-992](https://issues.oasis-open.org/browse/ODATA-992)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve MayImplement by defining a TypeDefinition for qualified name",
    "body": "\n\n### Proposal\n\nAdd a typedefinition for QualifiedTypeName that is a string that represents a qualified type name.\nImprove the definition of MayImplements to be of this type, rather than string.\n\nImported from [ODATA-991](https://issues.oasis-open.org/browse/ODATA-991)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.2 $expand: state that $levels=1 is equivalent to omitting it",
    "body": "We don't explicitly state that $levels=1 has no effect.\n\nThis can only be deduced from Example 99: all employees with their manager, manager's manager, and manager's manager's manager\n\nhttp://host/service/Employees?$expand=ReportsTo($levels=3)\n\nThis would mean that $expand=ReportsTo(levels=1) is all employees with their manager, i.e. same as just $expand=ReportsTo\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-989](https://issues.oasis-open.org/browse/ODATA-989)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Produce lightweight JSON CSDL and separately define Swagger/OAI generation",
    "body": "For the past year we have investigated defining a JSON representation of metadata based on JSON Schema and, more recently, Swagger.  Because this was to serve as a JSON alternate to XML for describing the service it had to have full fidelity with the XML representation.\n\nJSON Schema was defined as a validation language and lacks many of the core concepts necessary for defining a service model, such as inheritance, relationships, identity, etc. While JSON Schema itself is extensible, the desire to align with Swagger further restricted how we could define OData extensions.\n\nThe current draft for a Swagger/JSON Schema aligned metadata representation is a compromise both from a Swagger/JSON Schema perspective as well as from an OData perspective. Limitations in JSON Schema and Swagger make trying to describe OData concepts through extensions cumbersome and verbose for OData consumers. The added extensions also make it verbose for JSON Schema/Swagger tools and community.\n\nOAI is itself investigating relaxing its reliance on JSON Schema, allowing other suitable formats to be plugged in based on supported payload formats.\n\n### Proposal\n\nCreate two separate documents. A JSON CSDL document that is a concise representation of CSDL in JSON that is 1:1 with the XML representation, and a separate Committee Note specifying how to generate a clean Swagger/OAI description of an OData service.  Because we have the native JSON representation of CSDL the Swagger/OAI description does not have to fully represent the CSDL data model but describes the service in a way that can be consumed by API management, documentation, and client tools built around Swagger/OAI and is suitable for validation of OData JSON payloads.\n\nImported from [ODATA-988](https://issues.oasis-open.org/browse/ODATA-988)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow digits in search phrases",
    "body": "The ABNF for $search unintentionally restricts search phrases to letters and excludes digits. \n\n  ?$search=1984\n  ?$search=2x4\n\n### Proposal\n\nExtend ABNF to allow digits, dot, and comma in $search terms. add test cases\n\nImported from [ODATA-987](https://issues.oasis-open.org/browse/ODATA-987)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support POST/PATCH/DELETE to cast segment following a collection",
    "body": "Today we support:\n    GET ~Employees/ns.Manager\n\nin order to retrieve only those employees from the Employees entity set that are managers.\n\nIt would be consistent to support:\n    POST ~Employees/ns.Manager\nTo add a manager to the Employees entity set without having to specify in the payload that the employee was an @odata.type=ns.Manager\n\nThis would be particularly useful in cases where the cast segment specified a \"marker type\" that was trivially derived from the collection type.\n\n### Proposal\n\nSupport posting/patching/deleting to a type cast segment following a collection. \n\nFor Post, the payload must be an instance of the type specified by the cast segment (or a type derived from the type specified by the cast segment) and does not require the @odata.type attribute unless it is of a derived type of the type specified in the type cast segment.\n\nFor PATCH/DELETE, only those instances matching or derived from the cast segment are updated/deleted.\n\nImported from [ODATA-986](https://issues.oasis-open.org/browse/ODATA-986)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "The HTTP Specification document referenced in the OData Protocol Spec has been obsoleted",
    "body": "The Normative References section in the OData Protocol spec  (http://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793589) includes the following reference\n\n[RFC2616]                  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, RFC 2616, June 1999. http://www.ietf.org/rfc/rfc2616.txt.\n\nThe page https://www.rfc-editor.org/info/rfc2616 shows that RFC2616 has been obsoleted by the following six RFCs\n\nRFC 7230 - Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing, JUNE 2014\nRFC 7231 - Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content, JUNE 2014\nRFC 7232 - Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests, JUNE 2014\nRFC 7233 - Hypertext Transfer Protocol (HTTP/1.1): Range Requests, JUNE 2014\nRFC7234 - Hypertext Transfer Protocol (HTTP/1.1): Caching, JUNE 2014\nRFC7235 - Hypertext Transfer Protocol (HTTP/1.1): Authentication, JUNE 2014\n\nAdditionally the following items are also referenced in the Normative References section of the Protocol spec\n\n[HTTP-Prefer]            Snell, J., \"Prefer Header for HTTP\", draft-snell-http-prefer-18, January 2013. https://datatracker.ietf.org/doc/draft-snell-http-prefer/.\n[HTTP-Message]        Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing” draft-ietf-httpbis-p1-messaging-22, 23 February 2013. https://datatracker.ietf.org/doc/draft-ietf-httpbis-p1-messaging/.\n[HTTP-Semantics]     Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content” draft-ietf-httpbis-p2-semantics-22, 23 February 2013 https://datatracker.ietf.org/doc/draft-ietf-httpbis-p2-semantics/.\n[HTTP-Conditional]    Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests” draft-ietf-httpbis-p4-conditional-22, 23 February 2013 https://datatracker.ietf.org/doc/draft-ietf-httpbis-p4-conditional/.\n\nThese have been replaced as follows\n\n\"Prefer Header for HTTP\", draft-snell-http-prefer is now RFC 7240.\n\nHypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing” draft-ietf-httpbis-p1-messaging is now RFC 7230\n\nHypertext Transfer Protocol (HTTP/1.1): Semantics and Content” draft-ietf-httpbis-p2-semantics is now RFC 7231\n\nHypertext Transfer Protocol (HTTP/1.1): Conditional Requests” draft-ietf-httpbis-p4-conditional is now RFC 7232\n\n### Proposal\n\nSubstitute [RFC2617] by [RFC7617] Reschke, J., \"The 'Basic' HTTP Authentication Scheme\", RFC 7617, September 2015. http://www.ietf.org/rfc/rfc7617.txt\n\n\nImported from [ODATA-985](https://issues.oasis-open.org/browse/ODATA-985)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make $-prefix optional for system query options",
    "body": "In OData V1, when we originally defined query options for filter, ordering, expand, etc., we prefixed them with \"$\" so as not to conflict with \"custom\" query options that a service might implement.\n\nIn reality, it is highly unlikely that an OData-compliant service would need to implement a query option named \"filter\" that is different than \"$filter\", or \"expand\" that is different than \"$expand\", etc.\n\nAt the same time, we've been getting pushback that services don't want to have query options prefixed with \"$\".  In fact, this has been an adoption blocker in cases, especially since it apparently raises issues with some tools.  \n\nPrefixing query options with \"$\" just creates one more difference between how customers want to implement a service and how they have to implement the service in order to be OData-compliant.\n\n### Proposal\n\nMake the \"$\" optional in 4.01.  A 4.01 compliant service MUST support query options both with and without the \"$\" prefix. Clients that want to work with 4.0 services MUST specify the \"$\" prefix.\n\nImported from [ODATA-984](https://issues.oasis-open.org/browse/ODATA-984)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 15/16: advertise actions on collection-valued properties",
    "body": "Bound actions and functions can be advertised:\n- within the representation of the instance if the binding parameter is single-valued\n- within the representation of a collection if the binding parameter is collection-valued\n\nThe representation for single-valued binding also works if the single instance is embedded within another response, e.g. for expanded entities.\n\nWhat's missing is a representation of the collection-valued binding, e.g. for navigation properties where the action would take all related entities as binding parameter value.\n\n### Proposal\n\nPrefix the advertisement with the primitive- or collection-valued property name and place it next to the property, similar to annotations on navigation properties:\n\n  \"NavProp#Model.SomeAction\": {\n    \"title\": \"Do Something\",\n    \"target\": \"Managers(22)/Employees/DoSomething\"\n    },\n    \"NavProp\": [ ... ]\n\nServices must only returned this syntax in an OData 4.01 response.\n\nThese advertisement can appear any time.\nThey don't need to be included in an expand if not explicitly requested.\nThey must appear if explicitly requested (i.e., through expand that explicitly selects the action/function).\nIf only the function/action is selected in the expand, then the nav property itself does not need to be included in the response; only the action/function advertisements.\n\nImported from [ODATA-983](https://issues.oasis-open.org/browse/ODATA-983)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 11: Annotations on properties in single-property messages",
    "body": "Annotations on properties within structured instances are represented as \n\n  \"PropName@Namespace.Term\": <annotation value>\n  \"PropName\": <property value>\n\nHow to represent annotations on properties if the message represents just a single property?\n\n\n\n### Proposal\n\nFor primitive/collection-valued properties:\n\nAs the property name is not part of the single-property response and the property's value is represented as \n\n  \"value\": <property value>\n\nthe annotations should be next to \"value\" and not prefixed with \"value\":\n\n  \"@Namespace.Term\": <annotation value>\n  \"value\": <property value>\n\n\nImported from [ODATA-982](https://issues.oasis-open.org/browse/ODATA-982)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ETag Header: Clarify meaning of \"individual resource\".",
    "body": "Chapter 11.5.4.1 \"Invoking an Action\" reads:\n\"...\nTo request processing of the action only if the binding parameter value, an entity or collection of entities, is unmodified, the client includes the If-Match header with the latest known ETag value for the entity or collection of entities. The ETag value for a collection as a whole is transported in the ETag header of a collection response.\n...\"\n\n--> We support ETags for collections via the standart ETag Header. \n\nLooking at the chapter 8.3.1 \"Header ETag\" we never mentioned collections; we described the usage of ETags for metadata responses, service document reponses and for requests that returns an \"individual resource\".\nThe formulation \"individual resource\" is fuzzy and needs to be clarified.\n\n### Proposal\n\nClarify that etags MAY be on collections.  If present on the collection, the service MUST support if-match/if-not-match on get, if-match on post; client MUST specify if-match when posting to the collection (i.e., action) (and can use if-match=* to force operation).\n\nImported from [ODATA-981](https://issues.oasis-open.org/browse/ODATA-981)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "SchemaVersion header, $SchemaVersion query option, or root URL versioning",
    "body": "The SchemaVersion header and accompanying annotation are intended to allow breaking changes without having to change the service root URL.\n\nHow does this combine with type referencing in the @odata.type annotation?\n\nWe could annotate the @odata.type annotation with the @Core.SchemaVersion:\n\n    \"@odata.type\":\"https://some.whe.re/$metadata\"\n    \"@odata.type@Core.SchemaVersion\":\"2.0.1\",\n\nOr we could add a system query option and make the schema version part of the URL:\n\n    \"@odata.type\":\"https://some.whe.re/$metadata?$SchemaVersion=2.0.1\",\n\nOr we could reconsider this and fall back to root URL versioning:\n\n    \"@odata.type\":\"https://some.whe.re;v=2.0.1/$metadata\",\n\n### Proposal\n\nProposal: for CSD01, clarify how the type is annotated, as below, leaving the rest of the semantics as in the current draft.  Annotations are a nice way for the client to know what schema version was used without having to parse a URL and get the query option. For CSD02, consider replacing the SchemaVersion request header with a query option.\n\nImported from [ODATA-980](https://issues.oasis-open.org/browse/ODATA-980)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Recursive containment navigation properties and Partner attribute",
    "body": "An entity cannot be referenced by more than one containment relationship, and cannot both belong to an entity set declared within the entity container and be referenced by a containment relationship. \n\nCurrent rules around recursive containment and partner navigation properties seem to be sufficient to achieve this goal. but may not be necessary, i.e. seem overly restrictive.\n\nA counter-example to the current rules can be constructed by redefining a partner navigation property with a more specific type, which is allowed now:\n\n- EntityType Name=FileSystemEntry\n  - NavigationProperty Name=Parent Type=this.FileSystemEntry Nullable=true\n\n- EntityType Name=Folder BaseType=this.FileSystemEntry\n  - NavigationProperty Name=Children Type=Collection(this.FileSystemEntry) Partner=Parent\n\n- EntityType Name=File BaseType=this.FileSystemEntry\n  - NavigationProperty Name=Parent Type=this.Folder Nullable=false\n\n### Proposal\n\nClarify prose text:\n\nContainment navigation properties MAY specify a Partner attribute. If the containment is recursive, the relationship defines a tree; thus the navigation property on the type defined as the partner MUST specify a single entity type and MUST be nullable (for the root of the tree). If the containment is not recursive, the partner navigation property MUST NOT be nullable because it leads back to the containing entity.\n\nAn entity type inheritance chain MUST NOT contain more than one navigation property with a Partner attribute referencing a containment relationship.\n\nCurrent prose text:\n\nContainment navigation properties MAY specify a Partner attribute. If the containment is recursive, the partner navigation property MUST be nullable and specify a single entity type. If the containment is not recursive, the partner navigation property MUST NOT be nullable.\n\nAn entity type hierarchy MUST NOT contain more than one navigation property with a Partner attribute referencing a containment relationship.\n\nImported from [ODATA-979](https://issues.oasis-open.org/browse/ODATA-979)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Advertise non-availability of bound actions/functions",
    "body": "Actions and functions that are not available on all instances can be advertised in responses, see http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part1-protocol/odata-v4.0-errata03-os-part1-protocol-complete.html#_Toc453752309.\n\nProblem with current approach: does absence of an advertisement mean that an action/function is not available, or does it mean that the service doesn't advertise its availability?\n\n### Proposal\n\nAdvertise non-availability by providing null as the advertisement value:\n\n\"#Model.FirstAction\": {} --> available\n\"#Model.SecondAction\": null --> not available\n\nNote that services must only return the null value in a 4.01 or greater response.\n\nImported from [ODATA-978](https://issues.oasis-open.org/browse/ODATA-978)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support partial keys",
    "body": "In [ODATA-954](https://issues.oasis-open.org/browse/ODATA-954) we added support for composite keys expressed through key-as-segment, which begged the question what happens if only part of the key is specified.  It seems reasonalbe that, in this case, we would do a partial filtering of the results.\n\ni.e.;\n\n    AccountingDocuments/SAP/2016\n\nwould identify the subset of accounting documents for a company and year, and\n\n    AccountingDocuments/SAP\n\nwould identify the subset of accounting documents for a company.\n\nServices could optionally support this as a shorthand for \n\n   GET AccountingDocuments?$filter=CompanyCode eq 'SAP' and Year eq '2016'\n\nand\n\n   GET AccountingDocuments?$filter=CompanyCode eq 'SAP'\n\nIf supported, we should define consistent semantics across both key-as-segment and parens-syntax.\n\nNote that the rules for disambiguation would be a little inconsistent. Normally we interpret a path segment first as a property, then as a function/action, then as a property.  If we support partial keys then the resolution rules become a bit tricky -- if the previous segment matches a partial key value then the next segment would be matched as a partial key value before anything else.\n\nNote also that the same scenarios could be supported through filter.\n\n### Proposal\n\nSee description\n\nImported from [ODATA-976](https://issues.oasis-open.org/browse/ODATA-976)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Consider allowing use of instance annotations in $select and $expand",
    "body": "Instance annotations are rather similar to dynamic properties with a pre-known expressive name, i.e. the client can deduce from the name what type the dynamic property has.\n\nIn OData-933 we added use of instance annotations to $filter.  It seems consistent to support in $select (and $expand), but we don't have a use case.\n\nOpening this issue to track the fact that we considered, and are open, to adding support to $select (and perhaps $expand) if we come up with some interesting use cases.\n\nIf supported, make sure we consider contextUrl, etc.\n\nImported from [ODATA-975](https://issues.oasis-open.org/browse/ODATA-975)",
    "labels": [
      "URL Conventions",
      "V4.02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Flesh out recommendations around OAuth support in OData",
    "body": "Today there is no interoperable way to consume an OData service that supports authentication.  We recommend, in Chapter 20, the use of basic auth (which is more interoperable, but less secure than something more common like oauth).\n\nIf we could provide information, perhaps through a vocabulary, that would describe the authentication flow of the service, it would hugely improve interoperability across authenticated services.\n\nOne option would be to advertise in $metadata action annotated as an authorization action, with (well-known) parameters for the information it needs (clientid, secret, scope, etc.). I.e., when the client invokes the \"Login\" action with the appropriate parameter values, the service would build the authentication url using the parameter values with a redirect url to itself, redirect the client to that authentication url, and then wait to be called back on its own supplied redirect url.\n\nNote that Swagger/OneAPI defines some auth flow here, but it is unclear whether this is would work for all cases (the only listed auth types are \"basic\", \"apiKey\", and \"OAuth2\" -- OAuth1, at least, is absent) https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityDefinitionsObject\n\n\n### Proposal\n\nDefine an Authorization vocabulary as follows:\n\n      <Term Name=\"Authorizations\" Type=\"Collection(Auth.Authorization)\" AppliesTo=\"EntityContainer EntitySet NavigationProperty\">\n        <Annotation Term=\"Core.Description\" String=\"Lists the methods available to authorize access to the annotated resource.\"/>\n      </Term>\n\n      <ComplexType Name=\"Authorization\" Abstract=\"true\">\n        <Annotation Term=\"Core.Description\" String=\"Base type for all Authorization types.\"/>\n        <Property Name=\"Description\" Type=\"Edm.String\"/>\n      </ComplexType>\n\n      <ComplexType Name=\"OpenIDConnect\" BaseType=\"Auth.Authorization\">\n        <Property Name=\"IssuerUrl\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Issuer location for the OpenID Provider. Configuration information can be obtained by appending /.well-known/openid-configuration to this Url.\"/>\n        </Property>\n      </ComplexType>\n\n      <ComplexType Name=\"Http\" BaseType=\"Auth.Authorization\">\n        <Property Name=\"Scheme\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"HTTP Authorization scheme to be used in the Authorization header, as per RFC7235.\"/>\n        </Property>\n        <Property Name=\"BearerFormat\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"Format of the bearer token.\"/>\n        </Property>\n      </ComplexType>\n\n      <ComplexType Name=\"OAuthAuthorization\" BaseType=\"Auth.Authorization\" Abstract=\"true\">\n        <Property Name=\"Scopes\" Type=\"Collection(Auth.AuthorizationScopes)\">\n          <Annotation Term=\"Core.Description\" String=\"Available scopes.\"/>\n        </Property>\n        <Property Name=\"RefreshUrl\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"Refresh Url.\"/>\n          <Annotation Term=\"IsURL\"/>\n        </Property>\n      </ComplexType>\n\n      <ComplexType Name=\"OAuth2ClientCredentials\" BaseType=\"Auth.OAuthAuthorization\">\n        <Property Name=\"TokenUrl\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Token Url.\"/>\n          <Annotation Term=\"IsURL\"/>\n        </Property>\n      </ComplexType>\n\n      <ComplexType Name=\"OAuth2Implicit\" BaseType=\"Auth.OAuthAuthorization\">\n        <Property Name=\"AuthorizationUrl\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Authorization URL.\"/>\n          <Annotation Term=\"IsURL\"/>\n        </Property>\n      </ComplexType>\n\n      <ComplexType Name=\"OAuth2Password\" BaseType=\"Auth.OAuthAuthorization\">\n        <Property Name=\"TokenUrl\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Token Url.\"/>\n          <Annotation Term=\"IsURL\"/>\n        </Property>\n      </ComplexType>\n      \n      <ComplexType Name=\"OAuth2AuthCode\" BaseType=\"Auth.OAuthAuthorization\">\n        <Property Name=\"AuthorizationUrl\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Authorization URL.\"/>\n          <Annotation Term=\"IsURL\"/>\n        </Property>\n        <Property Name=\"TokenUrl\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Token Url.\"/>\n          <Annotation Term=\"IsURL\"/>\n        </Property>\n      </ComplexType>\n\n      <ComplexType Name=\"AuthorizationScopes\">\n        <Property Name=\"Scope\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Scope name.\"/>\n        </Property>\n        <Property Name=\"Description\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"Description of the scope.\"/>\n        </Property>\n      </ComplexType>\n      \n      <ComplexType Name=\"ApiKey\" BaseType=\"Auth.Authorization\">\n        <Property Name=\"KeyName\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"The name of the header or query parameter\"/>\n        </Property>\n        <Property Name=\"Location\" Type=\"Auth.KeyLocation\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\" String=\"Whether the API Key is passed in the header or as a query option\"/>\n        </Property>\n      </ComplexType>\n\n      <EnumType Name=\"KeyLocation\">\n        <Member Name=\"Header\"/>\n        <Member Name=\"QueryOption\"/>\n      </EnumType>\n\n    </Schema>\n  </edmx:DataServices>\n</edmx:Edmx>\n\nExample of usage:\n\n<Annotation Term=\"Auth.Authorizations\">\n  <Collection>\n    <Record Type=\"Auth.Http\"/>\n    <Record Type=\"Auth.OpenIDConnect\">\n      <PropertyValue Name=\"IssuerUrl\" String=\"https://example.com/issuer1\"/>\n    </Record>\n    <Record Type=\"Auth.OAuth2AuthCode\">\n      <PropertyValue Name=\"AuthorizationUrl\" String=\"http://myauth/authorize\"/>\n      <PropertyValue Name=\"TokenUrl\" String=\"http://myauth/token\"/>\n      <PropertyValue Name=\"Scopes\">\n        <Collection>\n           <Record>\n             <PropertyValue Name=\"Scope\" String=\"write:pets\"/>\n             <PropertyValue Name=\"Description\" String=\"modify pets\"/>\n           </Record>\n        </Collection>\n      </PropertyValue>\n    </Record>\n  </Collection>\n</Annotation>\n\nImported from [ODATA-974](https://issues.oasis-open.org/browse/ODATA-974)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Should we relax prohibiting Collection(Edm.ComplexType) and Collection(Edm.Untyped)",
    "body": "When we introduced Edm.PrimitiveType and Edm.ComplexType, we prohibited the use of them in collection-valued properties and return types because in JSON there is no way to annotate the members of an array of primitive types.  Complex types don't have the same issue (since they are internally annotated), but IIRC we made the restriction across both primitive and complex types for consistency (and because we knew we could relax it later).\n\nIn [ODATA-881](https://issues.oasis-open.org/browse/ODATA-881) we add support for Edm.Untyped, collections of which would naturally have the same restrictions as Edm.PrimitiveType and Edm.ComplexType (i.e., not be allowed in properties or as return type of function).\n\nAre we still okay with these restrictions? Should we relax these constraints for collections of complex types?  For collections of Edm.Untyped that don't contain primitives? For collections of Edm.Primitive that have \"heuristically determinable\" types (i.e., Boolean, string, or number)?\n\nOr, do we say that collections of primitive, complex, or untyped are modeled as Edm.Untyped (which could be a collection)?\n\n### Proposal\n\nAllow Collection(Edm.ComplexType) and Collection(Edm.Untyped).\n\n\nImported from [ODATA-973](https://issues.oasis-open.org/browse/ODATA-973)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 30: wrong result",
    "body": "Result shows nested Sales with ID: 8 and Amount: 2 - should not be present due to filter on Sales with Amount gt 3\n\n### Proposal\n\nSee description\n\nImported from [ODATA-972](https://issues.oasis-open.org/browse/ODATA-972)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "7.1: Add example for grouping by single-valued navigation property",
    "body": "Section 7.1 defines the result of grouping by a single-valued navigation property without giving an example.\n\nAny example in this section that groups by the key property of a related entity could be rephrased to group by the navigation property instead. Here's how example 52 would look like:\n\n```\nGET ~Sales?$apply=groupby((Customer,Product))\n```\n\nand results in\n\n```json\n{\n  \"@odata.context\": \"$metadata#Sales(Customer,Product)\",\n  \"value\": [\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C1')\" }, \"Product\": { \"@odata.id\": \"Products('P2')\" } },\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C1')\" }, \"Product\": { \"@odata.id\": \"Products('P3')\" } },\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C1')\" }, \"Product\": { \"@odata.id\": \"Products('P1')\" } },\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C2')\" }, \"Product\": { \"@odata.id\": \"Products('P2')\" } },\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C2')\" }, \"Product\": { \"@odata.id\": \"Products('P3')\" } },\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C3')\" }, \"Product\": { \"@odata.id\": \"Products('P3')\" } },\n    { \"@odata.id\": null, \"Customer\": { \"@odata.id\": \"Customers('C3')\" }, \"Product\": { \"@odata.id\": \"Products('P1')\" } }\n  ]\n}\n```\n\n### Proposal\n\nProposal amended during meeting 2018-7-19: treat group by NavProp as group by NavProp/$ref and return the nested @odata.id values\n\nSince section 3.10.1 only mentions grouping by navigation properties, but lacks a definition that is then finally given by example in section 7.1, move the relevant statements from section 7.1 to 3.10.1\n\nImported from [ODATA-971](https://issues.oasis-open.org/browse/ODATA-971)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.5.2: also mention advertising operations on collections",
    "body": "JSON Format defines how to advertise actions and functions bound to collections of entities.\n\nPart 1 Protocol only mentions advertisement for operations bound to single entities.\n\n### Proposal\n\nRephrase text in 11.5.2 to cover all cases specified in JSON Format\n\nImported from [ODATA-970](https://issues.oasis-open.org/browse/ODATA-970)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 15, Example 32: syntax of \"target\" URL",
    "body": "The example shows \n\n    \"target\": \"Employees(2)/RemainingVacation(Year=@Year)\"\n\nThe prose text says:\n\nThe target name/value pair contains a bound function or action URL. If the URL in the target name/value pair cannot be used to invoke all overloads for the function, then the function name MUST be distinguished by appending the parentheses-enclosed, comma-separated list of non-binding parameter names.\n\nThis implies that the example should show\n\n    \"target\": \"Employees(2)/RemainingVacation(Year)\"\n\nProblem is that this URL would be quite useless for invoking the function. Also the specific function overload is already identified by the advertisement\n\n \"#Model.RemainingVacation(Year)\": {...}\n\nIf the intention of \"target\" is to provide a URL for invoking the function, then a better approach would be to build on [ODATA-763](https://issues.oasis-open.org/browse/ODATA-763) and require that \"target\" is a URL without trailing parens and parameter names that can be invoked by appending the default aliases for the parameters listed in the advertisement.\n\n### Proposal\n\nClarify in text that functions are invoked by adding the named parameters as query options. The syntax of the url is up to the service (could be implicit parameters or explicit as in the example)\n\nImported from [ODATA-969](https://issues.oasis-open.org/browse/ODATA-969)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "3.1.4: add example for from in aggregate() with multiple arguments",
    "body": "Explain how in aggregate() with multiple arguments the \"from\" keyword can be resolved into a groupby/aggregate sequence by initially grouping by all \"from\" properties appearing in any argument.\n\nWill probably work only if all \"from\" chains are compatible, i.e. there exists a \"super-chain\" so that any from chain is a sub-chain of this super-chain. \n\n1) from A from B from D,from A from C from D works with super-chain from A from B from C from D (B and C can be swapped to get another possible super-chain.\n\n2) from A from B, from B from A won't work\n\n\n\n\n### Proposal\n\nrequire that all explicitly mentioned \"from\" properties appear in the same order in all arguments\n\nImported from [ODATA-968](https://issues.oasis-open.org/browse/ODATA-968)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 3: remove restriction for input type of bound functions",
    "body": "When generalizing $apply from \"entities\" to \"instances\" of any type we forgot to reformulate the paragraph on service defined \"custom functions\".\n\n \n\nAnd better use \"structured values\" instead of \"instances\".\n\n### Proposal\n\nProse spec chapter 3, second-to-last paragraph new:\n\nService-defined bound functions that take a collection as their binding parameter MAY be used as set transformations within $apply if the type of the binding parameter matches the type of the result set of the preceding transformation. If it returns a collection, further transformations can follow the bound function. The parameter syntax for bound function segments is identical to the parameter syntax for bound functions in resource path segments or $filter expressions. See section 7.6 for an example.\n\nold:\n\nService-defined bound functions that take an entity set as their binding parameter MAY be used as set transformations within $apply if the type of the binding parameter matches the type of the result set of the preceding transformation. If it returns an entity set, further transformations can follow the bound function. The parameter syntax for bound function segments is identical to the parameter syntax for bound functions in resource path segments or $filter expressions. See section 7.6 for an example.\n\n\n\nABNF new:\n\n  customFunction = namespace \".\" ( entityColFunction / complexColFunction / primitiveColFunction ) functionExprParameters\n\nold:\n\n  customFunction = namespace \".\" entityColFunction functionExprParameters\n\nImported from [ODATA-967](https://issues.oasis-open.org/browse/ODATA-967)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "13.4 Add example for navigation property bindings for containment navigation property",
    "body": "Add example along the following lines:\n- Bar has NavigationProperty Baz of type Foo with ContainsTarget=True \n- Foo has NavigationProperty Gux of type Ser with ContainsTarget=False\n\n<EntitySet Name=“Bars“ EntityType=“_this.Bar“>\n  <NavigationPropertyBinding Path=”Baz/Gux” Target=”Sers”\n</EntitySet>\n\n<EntitySet Name=”Sers” EntityType=”_this.Ser” />\n\n\n### Proposal\n\nwhere Orders contained OrderDetails: \n\n<EntitySet Name=\"Orders\" Type=\"Sales.Order\"> \n   <NavigationPropertyBinding Path=\"OrderDetails/Product\" Target=\"Products\"/> \n</EntitySet> \n\n\nImported from [ODATA-966](https://issues.oasis-open.org/browse/ODATA-966)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "UpdateGeoJSON Reference to RFC7946",
    "body": "The GeoJSON community submitted it's standard as an internet draft to IETF. \n\nThis lead to the foundation of the IETF Geographic JSON Working Group (https://datatracker.ietf.org/wg/geojson/charter/). \n\nAs of August, 11 2016 the GeoJSON specification now is the RFC 7946 (on the internet standards track). \nWe should reference this one instead of the intermediate draft (after evaluation of the changes cited below from the RFC, Appendix B):\n\nAppendix B.  Changes from the Pre-IETF GeoJSON Format Specification\n\n   This appendix briefly summarizes non-editorial changes from the 2008\n   specification [GJ2008].\n\nB.1.  Normative Changes\n\n   o  Specification of coordinate reference systems has been removed,\n      i.e., the \"crs\" member of [GJ2008] is no longer used.\n\n   o  In the absence of elevation values, applications sensitive to\n      height or depth SHOULD interpret positions as being at local\n      ground or sea level (see Section 4).\n\n   o  Implementations SHOULD NOT extend position arrays beyond 3\n      elements (see Section 3.1.1).\n\n   o  A line between two positions is a straight Cartesian line (see\n      Section 3.1.1).\n\n   o  Polygon rings MUST follow the right-hand rule for orientation\n      (counterclockwise external rings, clockwise internal rings).\n\n   o  The values of a \"bbox\" array are \"[west, south, east, north]\", not\n      \"[minx, miny, maxx, maxy]\" (see Section 5).\n\n   o  A Feature object's \"id\" member is a string or number (see\n      Section 3.2).\n   o  Extensions MAY be used, but MUST NOT change the semantics of\n      GeoJSON members and types (see Section 6).\n\n   o  GeoJSON objects MUST NOT contain the defining members of other\n      types (see Section 7.1).\n\n   o  The media type for GeoJSON is \"application/geo+json\".\n\nB.2.  Informative Changes\n\n   o  The definition of a GeoJSON text has been added.\n\n   o  Rules for mapping 'geo' URIs have been added.\n\n   o  A recommendation of the I-JSON [RFC7493] constraints has been\n      added.\n\n   o  Implementers are cautioned about the effect of excessive\n      coordinate precision on interoperability.\n\n   o  Interoperability concerns of GeometryCollections are noted.  These\n      objects should be used sparingly (see Section 3.1.8).\n\n\n### Proposal\n\nReplace the existing reference to GeoJSON:\n\n[GeoJSON] Howard Butler, Martin Daly, Alan Doyle, Sean Gillies, Tim Schaub and Stefan Drees, \"The GeoJSON Format\" draft-butler-geojson-02, 15 March 2014\nURL=http://tools.ietf.org/html/draft-butler-geojson-02\n\nnow that the final specification has been published as RFC 7946 with:\n\n[GeoJSON] Howard Butler, Martin Daly, Alan Doyle, Sean Gillies, Stefan Hagen and Tim Schaub, \"The GeoJSON Format\" RFC 7946, August 2016\nURL=http://tools.ietf.org/html/rfc7946\n\n\nImported from [ODATA-965](https://issues.oasis-open.org/browse/ODATA-965)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Need to clarify nested delta representation",
    "body": "In OData-876 we defined a format for representing nested changes in-line within a delta format. In OData-613 we said you could use PATCH to update a collection using a delta format, and added the following to [ODATA-876](https://issues.oasis-open.org/browse/ODATA-876):\n\n\"You can use contextUrl (ending in /$delta) on the navigation property to specify that the nested content is a delta content (partial update with patch semantics that can contain added/deleted links and tombstones).\"\n\nThe above text implies that you can have a delta format nested within a navigation property for an otherwise non-delta format. However, this brings up some issues, since the delta format was defined as a flat format. In particular, \n1) what is the format/content of the contextUrls required for added links, deleted links, and deleted entries\n2) are there any restrictions on the scope of the added/delete links (and tombstones); do they have to be at all related to the nav prop?\n\nOption 1 would be to use contextUrls such as the following:\n{ \n  \"@odata.type\":\"#Northwind.Manager\",\n  \"FirstName\" : \"Patricia\",\n  \"DirectReports@odata.contextUrl\" : \"#Employees(1)/DirectReports/$delta\",\n  \"DirectReports\": [\n    {\n      \"@odata.context\":\"#Employees/$deletedEntity\",\n      \"id\":\"Employees(3)\",\n      \"reason\":\"deleted\"\n    },\n    {\n      \"@odata.context\":\"#Employees/$deletedLink\",\n      \"source\":\"Employees(1)\",\n      \"relationship\":\"DirectReports\",\n      \"target\":\"Employees(4)\"\n    },\n    {\n      \"@odata.context\":\"#Employees(1)/$link\",\n      \"source\":\"Employees(1)\",\n      \"relationship\":\"DirectReports\",\n      \"target\":\"Employees(5)\"\n    },\n    {\n      \"@odata.context\":\"#Employees/DirectReports/$entity\",\n      \"FirstName\": \"Suzanne\",\n      \"LastName\": \"Brown\"\n    }\n  ]\n}\n\nOption 2 would be to prohibit use of delta format for nested nav props within a non-delta format.\n\n\n### Proposal\n\nAdded/Deleted links only appear at the root.\n\nNested content with \"#$delta\" is applied as a delta. Entities are upserted, deleted entities are removed from the collection. If reason:deleted is specified, client knows the related entity is deleted, otherwise (in a non-containment case) all the client knows is that the entity is no longer a member of that collection.  The contextUrl for the nested deleted entity is the same as it would be in the flattened representation.\n\n\nImported from [ODATA-964](https://issues.oasis-open.org/browse/ODATA-964)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make query options, built-in functions, and built-in operators case insensitive",
    "body": "Today, query options in OData are case-sensitive (all lower case). I've personally seen (and at times experienced) getting tripped up by using the wrong casing of query options and getting unexpected results.\n\nCertain programming languages and APIs have casing rules (InitialCaps, camelCase, lowercase, etc.) that they might want to be consistent across system-defined and custom query options.\n\nServices should support system-defined query options regardless of casing.\n\n### Proposal\n\n4.01 services must support case insensitive system query options. built-in functions, and built-in operators\nInteroperable 4.01 clients must continue to use the 4.0 defined casing.\n\nImported from [ODATA-963](https://issues.oasis-open.org/browse/ODATA-963)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "10.10 Projected Expanded Entity - be more explicit in combined $select/$expand cases",
    "body": "10.9 describes that a navigation property appears twice in the context URL if it is specified in $select as well as in $expand with a nested $select. The text is somewhat vague, but one of the examples \n\n10.10 doesn't repeat that (almost) explicit statement, and also lacks a corresponding example\n\n### Proposal\n\nClarify text of 10.9 -- \nif nav prop is in select, appears without parens. \nif nav prop is in expand with no select, expand, or recursion MAY NOT appear in the context url for 4.0, MUST appear for 4.01 (with empty parens if no nested select).\nIf nav prop is in expand with recursion, it's followed by a +\nIf nav prop is in expand with select list (or expand with select) then it's followed by parens (following the +, if present)\nIf both, both appear\n\nMake sure 10.10 is consistent with clarified wording from 10.9.\n\nImported from [ODATA-961](https://issues.oasis-open.org/browse/ODATA-961)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Absolute paths in annotations, e.g. capabilities depending on properties of a singleton",
    "body": "We'd like to use a Singleton to control capabilities of an entity set, e.g. use a property of a singleton to tell whether the authenticated user is allowed to create new entities in a given entity set. This means we'd like to use a Path construct for the value of @Capabilities.InsertRestrictions/Insertable, e.g.\n\n<Annotations Target=\"My.Container/SalesOrders\">\n  <Annotation Term=\"Capabilities.InsertRestrictions\">\n    <Record>\n      <PropertyValue Property=\"Insertable\" Path=\"/My.Container/Me/Permissions/CanCreateOrders\" />\n    </Record>\n  </Annotation>\n</Annotations>\n\n### Proposal\n\nExtend Path syntax to allow absolute paths that start with a top-level model element (schema child).\n\nNatural syntax would be a path starting with a forward slash.\n\nNote: current \"relative\" paths can already start with a type-cast segment which is a qualified type name, so the / prefix or something similar is needed to distinguish \"absolute\" paths.\n\nImported from [ODATA-960](https://issues.oasis-open.org/browse/ODATA-960)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow path in an edm:key to also use a primitive property of a non null-able navigation property (recursively) of the entity type.",
    "body": "Currently a key can only be made up of properties that are either in the entity type directly or in a complex property recursively. It therefore explicitly excludes the use of these properties in a, non null-able, navigation property. This causes the modeler to expose the underlying data structure as he'll have to add these primitive properties to the entity directly and keeping them in sync using referential constraints.\nAn example that shows this would be a situation like in graphs where nodes are connected by edges and where an edge gets particular properties associated to it. Here the edge will have to, apart from the two navigation properties representing the nodes it is connecting also two primitive properties that contain the node IDs to be able to form a key for an edge.\nObviously many m-n relationships exist which have additional properties describing the relationship exist that would benefit.\n\n### Proposal\n\nAllow the path expression to include references to unique, immutable, primitive (i.e., key) properties of non null-able, immutable navigation properties (recursively).\n\n8.3.1 Attribute Name could be simply amended as in:\nThe edm:PropertyRef element MUST specify a value for the Name attribute which MUST be a path expression resolving to a primitive property of the entity type itself or to a primitive property of a complex or a single-valued, non-nullable navigation property (recursively) of the entity type. The names of the properties in the path are joined together by forward slashes.\n\nSemantics:\nIn JSON payloads:\n1)\tThe id must be written, even in minimal metadata, or\n2)\tThe nav properties must be expanded to include at least the related ids (service *could* default expand to include the related id fields.)\nYou can only create the entity if:\na.\tYou include a link to an existing related entity containing the key value, or \nb.\tYou do a deep insert that includes the related entity\nYou can't change the relationship to the related entity containing the key value (so it would have to be single, non-nullable, and immutable)\nThe referenced property(ies) on the related entity must be immutable and must be unique (i.e., are generally a key of the related entity)\nDeleting the related entity deletes the entity whose key referenced a property of that entity\n\n\nImported from [ODATA-959](https://issues.oasis-open.org/browse/ODATA-959)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities: FilterRestrictions and SortRestrictions for navigation properties",
    "body": "With the addition of cross-service navigation we need means to express that a navigation property cannot be used in filter or sort expressions.\n\n### Proposal\n\nAdd three new properties, FilterFunctions, FilterRestrictions, and SortRestrictions, to Capabilities.NavigationPropertyRestriction, such that the full definition becomes: \n\n<ComplexType Name=\"NavigationPropertyRestriction\">\n  <Property Type=\"Edm.NavigationPropertyPath\" Name=\"NavigationProperty\">\n    <Annotation Term=\"Core.Description\" String=\"Navigation properties can be navigated\"/>\n  </Property>\n  <Property Type=\"Capabilities.NavigationType\" Name=\"Navigability\">\n    <Annotation Term=\"Core.Description\" String=\"Navigation properties can be navigated to this level\"/>\n  </Property>\n  <Property Type=\"Collection(Edm.String)\" Name=\"FilterFunctions\">\n    <Annotation Term=\"Core.Description\" String=\"List of functions and operators supported in $filter. If null, all functions and operators may be attempted.\"/>\n  </Property>\n  <Property Type=\"Capabilities.FilterRestrictionsType\" Name=\"FilterRestrictions\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $filter expressions\"/>\n  </Property>\n  <Property Type=\"Capabilities.SortRestrictionsType\" Name=\"SortRestrictions\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $orderby expressions\"/>\n  </Property>\n</ComplexType>\n\nImported from [ODATA-958](https://issues.oasis-open.org/browse/ODATA-958)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Do we impose a format for SchemaVersion?",
    "body": "Should we impose a format for the schema version? i.e., major.minor.errata?\n\nDoes Swagger impose any format for versioning?\n\n### Proposal\n\nWe should not mandate the format of the version string. Swagger recommends semantic versioning but does not require it; any string can be used as the version.\n\nImported from [ODATA-957](https://issues.oasis-open.org/browse/ODATA-957)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Do we need to add SchemaVersion to ContextURL?",
    "body": "In [ODATA-928](https://issues.oasis-open.org/browse/ODATA-928) we added the ability for a service to make breaking changes to metadata, and for a client to request a specific version of the metadata using the new SchemaVersion header.\n\nDo we need a way to encode the schemaversion as part of the contextUrl, or must the client processing the response know the schemaversion to use when requesting the metadata (including for nested contextUrls)?\n\nPerhaps using the SchemaVersion annotation as an instance annotation on the result payload?\n\n### Proposal\n\nA service MAY return the schemaVersion annotation as an instance annotation to specify the version of the schema the response was generated from. For streamed JSON this annotation, if present, MUST immediately follow the context property.\n\nschemaVersion MAY be included in embedded contextURLs or in odata.type annotations with full URLs.\n\nIf a service returns a payload whose schema is not compatible with the \"unversioned\" schema, it MUST include the schemaVersion instance annotations, as appropriate, in the payload.\n\nALSO, support the schemaVersion annotation as a child of the <References> element.\n\nImported from [ODATA-956](https://issues.oasis-open.org/browse/ODATA-956)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specifying odata.type on a collection of entities",
    "body": "Section 12 of the JSON spec says:\n\nA collection of entities is represented as a JSON object containing a name/value pair named value. It MAY contain odata.context, odata.count, odata.nextLink, or odata.deltaLink annotations.\n\nIn the event of a dynamic navigation property, a collection of entities would also presumably need an odata.type annotation.\n\n\n### Proposal\n\nAdd odata.type to the list of supported annotations here and other relevant places.\n\nImported from [ODATA-955](https://issues.oasis-open.org/browse/ODATA-955)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Key-As-Segment for multi-part keys",
    "body": "Generalize the rules in [ODATA-799](https://issues.oasis-open.org/browse/ODATA-799) to allow key-as-segment notation also for multi-part keys.\n\nExample: an accounting document is identified by the company code, the year, and the (auto-incremented) document number:\n\n      <EntityType Name=\"AccountingDocument\">\n        <Key>\n          <PropertyRef Name=\"CompanyCode\" />\n          <PropertyRef Name=\"Year\" />\n          <PropertyRef Name=\"DocumentNumber\" />\n        </Key>\n      </EntityType>\n\nTaking into account the order of <PropertyRef> elements within the <Key> element a single accounting document can be identified as\n\n    GET AccountingDocuments/SAP/2016/4329043280\n\nOpen a new issue ([ODATA-976](https://issues.oasis-open.org/browse/ODATA-976)) to track behavior of partial key specification. In the meantime, specification of partial keys is undefined, and if one segment is resolved as a partial key value then the subsequent segments should be resolved as any remaining key values.\n\n\n### Proposal\n\nSee description\n\nImported from [ODATA-954](https://issues.oasis-open.org/browse/ODATA-954)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider deprecating structural casting",
    "body": "Section 5.1.1.8.1, cast, of [URL Conventions] currently says that the cast function can be used to cast to types outside of a type hierarchy using structural casting--whatever names (and types) match are cast to the new type:\n\n•\tServices MAY support structural casting of entities and complex type instances to a derived type, or arbitrary structured type, by assigning values of identically named properties and casting them recursively. The cast fails if one of the property-value casts fails or the target type contains non-nullable properties that have not been assigned a value.\n\nMinimally, we need to clarify that this only applies to the cast function and not appending a cast segment, i.e., to a collection, since we count on appending cast segments to filter the collection according to those types that are of the particular type.\n\nWe could go one step further and deprecate the structural casting from the cast function as something that seemed like a safe enough thing at the time but turned out not to be a great idea. \n\n### Proposal\n\nRemove current language around structural casting.\n\nImported from [ODATA-953](https://issues.oasis-open.org/browse/ODATA-953)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Replace multiple batch capability term with single \"BatchSupport\" term",
    "body": "In the current published vocabulary we have two different capabilities terms related to batch (Supported and ContinueOnErrorSupported). We at least three more already lined up for 4.01:\n\"BatchContentIdReferencingInRequestBodiesSupported\" ([ODATA-479](https://issues.oasis-open.org/browse/ODATA-479)), \n\"ContentIdReferencingAcrossChangeSetsSupported\" ([ODATA-480](https://issues.oasis-open.org/browse/ODATA-480)),  and \n\"EtagReferencingSupported\" (OData-541) \n\nIn most cases (filter, expand, etc.) we have grouped related terms together under a single capability.  I would suggest we do the same for $batch.\n\n\n### Proposal\n\nRemove before publishing the following capability term:\n-BatchContentIdReferencingInRequestBodiesSupported\n\nDeprecate the following capabilities terms:\n-BatchSupported\n-BatchContinueOnErrorSupported\n\nDefine a new \"BatchSupport\" term in the capabilities vocabulary for putting these and other capabilities related to batch:\n\n<Term Name=\"BatchSupport\" Type=\"Capabilities.BatchSupportType\" AppliesTo=\"EntityContainer\">\n  <Annotation Term=\"Core.Description\" String=\"Batch Support for the service\"/> \n</Term>\n\n<ComplexType Name=\"BatchSupportType\">\n  <Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n    <Annotation Term=\"Core.Description\" String=\"Service supports requests to $batch\" />\n  </Property>  \n  <Property Name=\"ContinueOnErrorSupported\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.Description\" String=\"Service supports the continue on error preference\" />\n  </Property>\n  <Property Name=\"ReferencesInRequestBodiesSupported\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.Description\" String=\"Service supports Content-ID referencing in request bodies\" />\n  </Property>\n  <Property Name=\"ReferencesAcrossChangeSetsSupported\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.Description\" String=\"Service supports Content-ID referencing across change sets\" />\n  </Property>\n  <Property Name=\"EtagReferencesSupported\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.Description\" String=\"Service supports referencing Etags from previous requests\" />\n  </Property>\n</ComplexType>\n\n\n\n\nImported from [ODATA-952](https://issues.oasis-open.org/browse/ODATA-952)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "4.5: Explicitly state that Edm.EntityType cannot be used as the type of a containment navigation property",
    "body": "\n\n### Proposal\n\nContainment navigation properties define entity sets, and keyless abstract entity types cannot be used as the type of an entity set, which includes Edm.EntityType. That's rather hard to deduce from the current spec, so spell it out in section 4.5\n\nImported from [ODATA-951](https://issues.oasis-open.org/browse/ODATA-951)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify what requests can be delta enabled",
    "body": "The spec explicitly mentions returning delta links only in the context of retrieve entity set requests.  It doesn't explicitly state whether or not other types of requests can be delta enabled.  For example, can a function that returns a collection be delta enabled?  Can a request for a singleton with all related entities expanded be delta enabled (for this case it isn't clear the spec would actually allow a delta link to be returned)?\n\nWe should clarify what requests can be delta enabled.\n\n### Proposal\n\n- Clarify that any GET request to retrieve one or more entities MAY be delta enabled by the service.  A service MAY support delta enabling additional GET requests.\n\n- Add Singleton, Navigation Property, and Funtion to the AppliesTo of the ChangingTracking term.\n\nReasoning:\n\n- The entity set scenario is already well documented so nothing new there.\n\n- The reason for the single entity case is mainly for singletons.  If a service has a singleton, a natural defining query would be for the singleton entity possibly with expands.  You could make the same argument for just single entities that are not singletons.  The main reason I see for allowing a single entity (singleton or otherwise) without any nested entities to be delta enabled is in the case where the entity is very large (i.e. lots of large properties).  In that case, the delta protocol could be used to return only the properties that have changed.\n\n- A function can return a collection of entities so it should be able to return a delta link.\n\nAdd Singleton, NavigationProperty, and Function to AppliesTo of ChangeTracking term.\n\nImported from [ODATA-950](https://issues.oasis-open.org/browse/ODATA-950)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify the effect Accept-Language header has on a delta response",
    "body": "A client could issue a defining request with one value of the Accept-Language header and then use the returned delta link with a different Accept-Language.  The spec isn't clear as to whether the delta response should ignore the Accept-Language or return unchanged entities but with the language dependent properties reflecting the newly specified language.\n\n### Proposal\n\nRevised proposal from 2016-7-28: Clients SHOULD specify the same Accept-Language header when querying the delta link as was specified in the defining query. Services MAY return Not Acceptable if a different Accept-Language is specified. \n\nIf a service does support an Accept-Language header it MAY return changes only visible in that language, or MAY return records that have changes not visible in the requested language.\n\nImported from [ODATA-949](https://issues.oasis-open.org/browse/ODATA-949)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Versions of vocabularies and their relation with a version of the specification",
    "body": "Need to specify more clearly what the versioning scheme is for vocabularies and how they relate to versions of the specification. For one current vocabularies refer to version 4.0 of the edmx namespace as is (<edmx:Edmx xmlns:edmx=\"http://docs.oasis-open.org/odata/ns/edmx\" Version=\"4.0\">) which kind of ties them to a specific version of the specification anyway. Would we add version 4.01 here as well (see [ODATA-846](https://issues.oasis-open.org/browse/ODATA-846))?\n\nWe have parked [ODATA-545](https://issues.oasis-open.org/browse/ODATA-545) and made it dependent on this issue as discussion of that issue surfaced the issues to be resolved here.\n\n### Proposal\n\n1) We should not add 4.01 to the edmx Version element, as we are not defining a new version of the edmx (i.e., no new elements or attributes).\n2) Tell 4.01 clients that they should be prepared for the set of valid applies to elements to expand in the future.  \n\nImported from [ODATA-948](https://issues.oasis-open.org/browse/ODATA-948)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Transformation for computing ratios with aggregated values",
    "body": "It is interesting to get the ratio between an individual and an aggregated value from the same input set. \n Examples:\n 1. Customer classification: Revenue per customer in relation to total revenue\n 2. Revenue trend: Revenue per year in relation to total revenue for any given customer\n 3. Order size: Order volume relative to average order volume\n\nThey cannot be expressed with combining groupby/aggregate, because the individual entity values are no longer available after these transformations have produced an aggregated value.\n The ratio transformation takes a comma-separated list of one or more parameters describing a value, an aggregate expression, and an alias:\n ratio(valueExpression to aggregateExpression as alias, …)\n\nA valueExpression may be an expression valid in a $filter system query option on the input set that results in a simple value. The aggregateExpression is an aggregate expression as defined for transformation aggregate (section 3.1). The alias introduces a dynamic property for the ratio values in the result set that are of type Edm.Decimal with unspecified precision and variable scale.\n\nThe transformation first determines the aggregated value for the input set by applying the aggregateExpression. Then, it calculates for every entity in the input set the ratio between the valueExpression and the aggregated value and adds the result as dynamic property to the entity that is put into the result set.\n\nApplied to examples:\n Re 1:\n GET ~/Sales?$apply=\n groupby((Customer),aggregate(Amount with sum as CustomerAmount)) \n /ratio(CustomerAmount to CustomerAmount with sum as RevenueContribution)\n Re 2:\n GET ~/Sales?$apply=\n groupby((Customer,Year) aggregate(Amount with sum as CustomerYearAmount))\n /groupby((Customer),ratio(CustomerYearAmount to CustomerYearAmount with sum as RevenueTrend)\n Re 3:\n GET ~/Sales?$apply=ratio(Amount to Amount with average as RelativeOrderSize)\n\nIn all these example, the value expression is identical with the base in the aggregate expression, that is, they follow the pattern: ratio(X to X with M as A). If there were no other use cases, the syntax could be simplified to: ratio(X with M as A).\n\nImported from [ODATA-947](https://issues.oasis-open.org/browse/ODATA-947)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify scope for $apply",
    "body": "The $expand system query option allows to use $apply as an option parameter. This is only meaningful when expanding collection-valued navigation properties. Single expanded entities are excluded. In order to avoid confusion, it should be clarified that $apply can be applied to collection of entities only. This also relates to resource paths addressing single entities.\n\n### Proposal\n\nAdjust section 3, first sentence. Changes are enclosed with \\*: “Aggregation behavior \\*on a collection of instances\\* is triggered…”\n\nImported from [ODATA-946](https://issues.oasis-open.org/browse/ODATA-946)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Correct examples 53, 54, and 61",
    "body": "Example 53 requests aggregation of property *path* Sales/Amount, but the response shows the dynamic property Total nested inside Sales. Rightly, it should have been “added to the type containing the original expression” (section 3.1.1).\nIn example 54, the response payload shows the dynamic property Total nested within Sales. According to the request, which uses the path expression Sales/Amount for aggregation, the Total property should be at the top level.\n\n\n### Proposal\n\n# Updates to sections 3.1 and 3.1.1 in the specification: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/67246/[ODATA-945](https://issues.oasis-open.org/browse/ODATA-945)%20-%20Proposal%20for%20Spec%20Update.docx] \n1. Update examples in document:\n\nReplace response payload of example 53 with\n\n{\n \"@odata.context\": \"$metadata#Products(Name,Total)\",\n \"value\": [\n\n{ \"@odata.id\": null, \"Name\": \"Coffee\", \"Total\": 12 }\n\n,\n\n{ \"@odata.id\": null, \"Name\": \"Paper\", \"Total\": 8 }\n\n,\n\n{ \"@odata.id\": null, \"Name\": \"Pencil\", \"Total\": null }\n\n,\n\n{ \"@odata.id\": null, \"Name\": \"Sugar\", \"Total\": 4 }\n\n]\n }\n\nExample 54: Modify request to properly reflect the nesting shown in the response: \n GET ~/Products?$apply=groupby((Name,Sales/Currency/Code),\n aggregate(Sales(Amount with sum as Total)))\n\nCorrect Example 61 as\n```\n{ \"Name\": \"Coffee\", \"Forecast\": 6, \"Sales\": [ { \"Actual\": 12 } ] }\n```\n\nImported from [ODATA-945](https://issues.oasis-open.org/browse/ODATA-945)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify scope of property paths in transformations",
    "body": "Property paths in transformations always relate to the structure of the immediate input set, which is either the collection identified by the request resource path or the output of the preceding transformation. \nFor some transformations, this has been specified explicitly, e.g. in section 3.1 for the aggregate transformation: “an expression valid in a $filter system query option on the input set”. But not for all, e.g. section 3.12 does not make a statement for the expand transformation. In order to avoid any possible misinterpretation or confusion, the document should spell this out clearly.\n\n\n### Proposal\n\nAdd another sentence to section 3, at the end of the third para (enclosed with \\*): \n\"So the actual (or relevant) structure of each intermediary result will resemble a projection of the original data model that could also have been formed using the standard system query options $expand and $select defined in [OData-Protocol], with dynamic properties representing the aggregate values. The parameters of set transformations allow specifying how the result instances are constructed from the input instances. \\*This especially means that all property paths relate to the structure of the immediate input set.\\*\"\n\n\nImported from [ODATA-944](https://issues.oasis-open.org/browse/ODATA-944)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Correct broken link for Groupable Property",
    "body": "Section 2.1 includes a definition for the term groupable property. The link behind it does not point to section 6.2.1 as expected.\n\nImported from [ODATA-943](https://issues.oasis-open.org/browse/ODATA-943)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "How should headers applied to a batch affect statements within a batch?",
    "body": "Today we don't spell out how setting a header on a batch affects individual statements of the batch, nor do we specify what happens if the same header is specified on the batch and the individual statement with different values.\n\nDo we ignore headers on the batch? Do we define a precedence rule where headers on the batch define defaults, but headers on the individual statements take precedence.  For something like include-annotations, does a precedence rule imply that, if an annotation is included in the batch and not specified in the individual request, it is included, if an annotation is excluded in the batch and not specified in the individual request it is excluded, if an annotation is included in the batch and excluded in the individual request it is excluded, and if an annotation is excluded in the batch but included in the request it is included?\n\n### Proposal\n\nThe following is a proposal for the use of headers in batch requests and responses.  \n\nCommon Headers\n===============\nContent-Type     - Each request in the batch must have a content type header as per section 11.7\nContent-Encoding - Value on requests in batch overrides the batch value\nContent-Language - Value on requests in batch overrides the batch value\nContent-Length   - Value on requests in batch specify the length of that request\nOData-Version    - Value on requests in batch overrides the batch value. Typically wouldn't vary from request to request.\n\nRequest Headers\n===============\nAccept           - Value on requests in batch overrides the batch value\n\nAccept-Charset   - Value on requests in batch overrides the batch value\n\nAccept-Language  - Value on requests in batch overrides the batch value\n\nIf-Match\t\t - MUST NOT specify on the overall batch\n\nIf-None-Match    - MUST NOT specify on the overall batch.\n\nOData-Isolation  - Applies to the overal batch only.  Ignored on requests in the batch (per section 8.2.6)\n\nOData-MaxVersion - Value on requests in batch overrides the batch value.\n\nPrefer:odata.allow-entityreferences  - Value on requests in batch overrides the batch value\n\nPrefer:odata.callback                - Async on batch level; track-changes at request level. \n\nPrefer:odata.continue-on-error       - MUST NOT be specified on requests in the batch\n\nPrefer:odata.include-annotations     - Value on requests in batch overrides the batch value\n\nPrefer:odata.maxpagesize\t\t - SHOULD NOT be specified on batch\n\nPrefer:odata.track-changes           - SHOULD NOT be specified on batch\n\nPrefer:return                        - SHOULD NOT be specified on batch\n\nPrefer:respond-async                 - SHOULD NOT be specified (and is ignored) on requests in the batch (per section 8.2.8.8)\n\nPrefer:wait                          - On batch, applies to overall batch. On statement applies to individual statement. This is the only header that should be used on a changeset.\n\nSchema-Version (OData 4.01)          - Value on requests in batch overrides the batch value\n\n\nResponse Headers\n=================\nETag                 - Can be applied to responses in a batch response.  SHOULD NOT be returned for batch.  \n\nLocation             - Can be applied to responses in a batch response. SHOLD NOT be returned for batch.\n\nOData-EntityId       - Can be applied to responses in a batch response.  SHOULD NOT be returned for batch.\n\nPreference-Applied   - Can be applied to responses in a batch response and also the overal batch\n\nRetry-After\t\t- Applies to the overal batch response only.\n\nImported from [ODATA-942](https://issues.oasis-open.org/browse/ODATA-942)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Attempting to modify a property with read-only permissions should fail",
    "body": "Currently, in 11.4.3, Update an Entity, we say that \"Key and other non-updatable properties, as well as dependent properties that are not tied to key properties of the principal entity, can be omitted from the request. If the request contains a value for one of these properties, the service MUST ignore that value when applying the update.\"\n\nWe don't explicitly say how to handle properties that are read-write, but for which the user doesn't have permissions.  Are they considered \"non-updatable\" or are they considered updatable properties for which the user lacks the permission to update?\n\nThe reason that we say read-only properties in the payload are ignored is so that a client can take what they read and write it back without having to remove certain properties. For the general case, we didn't want to burden (and slow) the service by requiring it to do a validity check on the read-only properties (type, id, etc.), and we wanted to be able to \"copy\" an entity by reading it and then doing a POST and having the id ignored.\n\nHowever, for cases where the user doesn't have permission to write a property it's probably wrong to return success if the final state of the property doesn't match the request. We still want the user to be able to PUT/PATCH the value they have read, without having to edit out certain values, but in this case we should probably raise an exception if the current value of the property was not the value specified by the user.\n\n### Proposal\n\nClarify that \"non-updatable\" in 11.4.3, Update an Entity, means \"marked as computed or read-only in metadata\".\n\nSpecify that services should error if an insert or update contains an updatable property that cannot be changed by this user at this time (i.e., given the current state of the object, or for which the user doesn't have permission to update), and the value of the property does not match the value specified by the user. In this case, the service MAY return an error even if the property does match the value specified by the user.\n\nAs a result, clients should use PATCH and only specify the properties that they want to change.\n\nUpdating a specific property (identified as the target of the update URL) should fail if the property is not updatable.\n\nImported from [ODATA-941](https://issues.oasis-open.org/browse/ODATA-941)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define a validation term for valid values",
    "body": "[ODATA-849](https://issues.oasis-open.org/browse/ODATA-849) proposes allowing enumerations to extend other enumerations.\n[ODATA-494](https://issues.oasis-open.org/browse/ODATA-494) similarly proposes allowing enumerations to derive from other enumerations.\n[ODATA-874](https://issues.oasis-open.org/browse/ODATA-874) proposes allowing string as an underlying type\n\nWe have also had requests to support enumerations that don't conform to the rules for simple identifiers (i.e., they may have spaces, dashes, etc. in the names) \n\nAll of these are good suggestions, but they don't play well with enumerations in programming languages.\n\nAs an alternative to trying to introduce rules that don't work well with programming languages, we could simply extend the validation vocabulary with a term that could be applied to any property in order to limit the domain of valid values for that property, or defined as a type definition such that any property that used that type definition would have the constraint.\n\nThe semantics of this new construct would be clear up front that it could change over time, so applications would need to account for unexpected values.\n\nThis could be used where an enumeration was not appropriate, for example:\n1) Where the allowable values needed to change over time\n2) Where the allowable values needed to extend an existing allowable values\n3) Where the allowable values were not (all) strings\n4) Where the allowable values did not satisfy simple identifier rules\n\n### Proposal\n\nDefine a new term for \"AllowedValues\", as part of the Validation vocabulary:\n\n      <Term Name=\"AllowedValues\" Type=\"Collection(Validation.AllowedValue)\">\n        <Annotation Term=\"Core.Description\"\n          String=\"A collection of valid values for the annotated property, parameter, or type definition\" />\n      </Term>\n\n      <ComplexType Name=\"AllowedValue\">\n        <Property Name=\"Value\" Type=\"Edm.PrimitiveType\">\n          <Annotation Term=\"Core.Description\" String=\"An allowed value for the property, parameter, or type definition\" />\n        </Property>\n      </ComplexType>\n\nThat could then be used, for example:\n\n      <TypeDefinition Name=\"Weekdays\" UnderlyingType=\"Edm.String\">\n        <Annotation Term=\"Validation.AllowedValues\">\n              <Collection>\n                <Record>\n                  <PropertyValue Property=\"Value\" String=\"Monday\" />\n                </Record>\n                <Record>\n                  <PropertyValue Property=\"Value\" String=\"Tuesday\" />\n                </Record>\n                <Record>\n                  <PropertyValue Property=\"Value\" String=\"Wednesday\" />\n                </Record>\n                <Record>\n                  <PropertyValue Property=\"Value\" String=\"Thursday\" />\n                </Record>\n                <Record>\n                  <PropertyValue Property=\"Value\" String=\"Friday\" />\n                </Record>\n              </Collection>\n        </Annotation>\n      </TypeDefinition>\n\nImported from [ODATA-940](https://issues.oasis-open.org/browse/ODATA-940)",
    "labels": [
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for groupby single-valued navigation property",
    "body": "groupby allows grouping by single-valued navigation properties, meaning that the results are grouped by the entity id of the related entity.\n\nImported from [ODATA-939](https://issues.oasis-open.org/browse/ODATA-939)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "In 4.01 decide if we can support invoking actions with no params with no body",
    "body": "We currently say that parameters to an action are passed in the body of a json request as a json object where each parameter is a property of the object.\n\nI recently had someone ask how they should invoke an action request with no (non-binding) parameters. In particular, they were wondering if they should just pass no content (as opposed to content containing an empty json object).\n\n\n### Proposal\n\nOData 4.01 services MUST support no content (as well as empty object), but as this was not called out until 4.01 clarify that interoperable clients should pass an empty json object in the body of the request.\n\nImported from [ODATA-938](https://issues.oasis-open.org/browse/ODATA-938)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider making odata- prefix optional in headers, preference values, format parameters",
    "body": "We defined our own namespacing mechanism for things like preferences and headers by prefixing with odata.  Specifically:\n\nOData Headers:\nOData-Version\nOData-MaxVersion\nOData-Isolation\nOData-EntityId\nOData-SchemaVersion\n\nOData Preferences:\nodata.allow-entityreferences\nodata.callback\nodata.continue-on-error\nodata.include-annotations\nodata.maxpagesize\nodata.track-changes\nodata.omit-values\n\nOData format parameters:\nodata.metadata\nodata.streaming\n\nIn the interest of making some of these conventions and behaviors more broadly adopted, should we consider supporting some of them without the \"odata\" prefix?\n\n### Proposal\n\nFor all except OData-Version and OData-MaxVersion, define the forms without the OData- prefix as aliases to the OData forms.\n\nRegister the non-OData forms of the headers and preferences with IANA.\nFrom 2016/6/2:  Omit OData prefix from new headers, preferences, and format parameters added in 4.01 and beyond that have a generic meaning (in particular, omit-values and SchemaVersion). \n\nImported from [ODATA-937](https://issues.oasis-open.org/browse/ODATA-937)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "CSDL errata02 11.1.3 Type Definition Facets references nonexistent standard vocabulary",
    "body": "Org.OData.Measurements.V1.Unit should be Org.OData.Measures.V1.Unit in:\n\n<TypeDefinition Name=\"Length\" UnderlyingType=\"Edm.Int32\"> \n  <Annotation Term=\"Org.OData.Measurements.V1.Unit\"\n              String=\"Centimeters\" /> \n</TypeDefinition> \n\n<TypeDefinition Name=\"Weight\" UnderlyingType=\"Edm.Int32\"> \n  <Annotation Term=\"Org.OData.Measurements.V1.Unit\"\n              String=\"Kilograms\" /> \n</TypeDefinition> \n\n\n### Proposal\n\nChange to using Org.OData.Measures.V1.Unit\n\nImported from [ODATA-936](https://issues.oasis-open.org/browse/ODATA-936)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow singletons to be members of an entity set",
    "body": "Sometimes candidates for singletons are also members of entity sets, e.g. \"Me\" will also be in \"People\", \"Contoso\" will also be in \"Companies\".\n\n### Proposal\n\nAllow singletons to be members of entity sets.\n\nImported from [ODATA-935](https://issues.oasis-open.org/browse/ODATA-935)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify invoking an action with no parameters",
    "body": "We currently say that parameters to an action are passed in the body of a json request as a json object where each parameter is a property of the object.\n\nI recently had someone ask how they should invoke an action request with no (non-binding) parameters. In particular, they were wondering if they should just pass no content (as opposed to content containing an empty json object).\n\n\n### Proposal\n\nClarify that (although a service may support no content), clients invoke an action with no non-binding parameters by passing an empty json object in the body of the request.\n\nImported from [ODATA-934](https://issues.oasis-open.org/browse/ODATA-934)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow using instance annotations in $filter",
    "body": "Instance annotations are rather similar to dynamic properties with a pre-known expressive name, i.e. the client can deduce from the name what type the dynamic property has.\n\nFor example: People?$filter=Age@numericValueException eq 'NaN'\nwould retrieve all people for which age is not a number.\n\nIf [ODATA-735](https://issues.oasis-open.org/browse/ODATA-735) gets accepted, clients can know up-front which instance annotations to expect, and can use them in filter conditions.\n\nOpen a separate issue ([ODATA-97](https://issues.oasis-open.org/browse/ODATA-97)) to consider use in $select,/$expand.\n\n### Proposal\n\nSee summary and description\n\nImported from [ODATA-933](https://issues.oasis-open.org/browse/ODATA-933)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Typo in example 44: missing T in duration literal",
    "body": "\n\n### Proposal\n\n<Annotation Term=\"org.example.task.duration\" Duration=\"P7D\" />\n\n<Annotation Term=\"org.example.task.duration\">\n  <Duration>P11DT23H59M59.999999999999S</Duration>\n</Annotation>\n\nImported from [ODATA-932](https://issues.oasis-open.org/browse/ODATA-932)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Typo in Example 32: An entity container aggregates entity sets, singletons, action imports, and function imports.",
    "body": "Example 32 in CSDL section 13 \"Entity Container\" shows incorrect target paths in 4 cases, e.g.\n\n    <NavigationPropertyBinding Path=\"Category\" Target=\"Self.DemoService.Categories\" />\n\nshould have slash in place of last \".\". e.g.\n\n    <NavigationPropertyBinding Path=\"Category\" Target=\"Self.DemoService/Categories\" />\n\n13.4.2 Attribute Target states:\n\nA navigation property binding MUST specify a SimpleIdentifier or TargetPath ...\n\nand section 17.5 TargetPath says:\n\nThe allowed path expressions are:\n·         The QualifiedName of an entity container, followed by a forward slash and the name of a container child element\n\n\n\n### Proposal\n\nFix the examples in section 13 to use correctly qualified target paths.\n\n\nImported from [ODATA-931](https://issues.oasis-open.org/browse/ODATA-931)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Ensure that errata03 vocabularies have explicit Nullable facet for collection-typed properties",
    "body": "See https://issues.oasis-open.org/browse/[ODATA-929](https://issues.oasis-open.org/browse/ODATA-929) for background.\n\nStandard vocabularies should not imit the Nullable facet for collection types.\n\n(Now [ODATA-929](https://issues.oasis-open.org/browse/ODATA-929) proposes that 4.01 should have a default of false, but since errata03 specifies a default of \"unspecified\", the errata03 vocabularies must be explicit).\n\n### Proposal\n\nInclude an explicit Nullable facet in all errata03 standard vocabularies where a collection type is used.\n\nImported from [ODATA-930](https://issues.oasis-open.org/browse/ODATA-930)",
    "labels": [
      "Vocabularies",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Nullable facet should default to false for collection types, rather than being unspecified",
    "body": "For the Nullable facet, CSDL errata03 states:\n\n- If no value is specified for a property whose Type attribute specifies a collection, the client cannot assume any default value.\n\n- The absence of the Nullable attribute means it is unknown whether the collection can contain null values.\n\nHowever evidence from common examples shows that schema authors commonly omit the Nullable facet for collection-valued properties, when they intend/assume that Nullable defaults to false. Also, since it is quite unusual to permit nullable items in a list, if the default Nullable facet for collections were \"true\", it would result in unnecessary extra work for schema authors.\n\nIt is undesirable for it to be so easy for schema authors to accidentally permit this important facet to have an undefined value.\n\nEvidence (from errata02 standard vocabularies) has 16 properties and 4 terms with no Nullable facet. However it would appear that none of these intended to allow nullable collection items.\n\nSearching for: Type=\"Collection(\nv4_0.errata02.Org.OData.Capabilities.V1.xml(128): <Term Name=\"SupportedFormats\" Type=\"Collection(Edm.String)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(133): <Term Name=\"AcceptableEncodings\" Type=\"Collection(Edm.String)\" AppliesTo=\"EntityContainer\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(161): <Property Name=\"CallbackProtocols\" Type=\"Collection(Capabilities.CallbackProtocol)\" />\nv4_0.errata02.Org.OData.Capabilities.V1.xml(186): <Property Name=\"FilterableProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(189): <Property Name=\"ExpandableProperties\" Type=\"Collection(Edm.NavigationPropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(203): <Property Name=\"NonCountableProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(206): <Property Name=\"NonCountableNavigationProperties\" Type=\"Collection(Edm.NavigationPropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(218): <Property Name=\"RestrictedProperties\" Type=\"Collection(Capabilities.NavigationPropertyRestriction)\" />\nv4_0.errata02.Org.OData.Capabilities.V1.xml(255): <Term Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\" AppliesTo=\"EntityContainer EntitySet\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(269): <Property Name=\"RequiredProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(273): <Property Name=\"NonFilterableProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(285): <Property Name=\"AscendingOnlyProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(288): <Property Name=\"DescendingOnlyProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(291): <Property Name=\"NonSortableProperties\" Type=\"Collection(Edm.PropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(303): <Property Name=\"NonExpandableProperties\" Type=\"Collection(Edm.NavigationPropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(337): <Property Name=\"NonInsertableNavigationProperties\" Type=\"Collection(Edm.NavigationPropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(349): <Property Name=\"NonUpdatableNavigationProperties\" Type=\"Collection(Edm.NavigationPropertyPath)\">\nv4_0.errata02.Org.OData.Capabilities.V1.xml(361): <Property Name=\"NonDeletableNavigationProperties\" Type=\"Collection(Edm.NavigationPropertyPath)\">\nv4_0.errata02.Org.OData.Core.V1.xml(145): <Term Name=\"AcceptableMediaTypes\" Type=\"Collection(Edm.String)\" AppliesTo=\"EntityType Property\">\nv4_0.errata02.Org.OData.Core.V1.xml(161): <Term Name=\"OptimisticConcurrency\" Type=\"Collection(Edm.PropertyPath)\" AppliesTo=\"EntitySet\">\nFound 20 occurrence(s) in 2 file(s)\n\nEvidence from Microsoft TripPin sample: 3 collection-valued properties (2 of which are missing the Nullable facet)\n\nC:\\projects\\xscript\\src\\test\\xs\\data\\Microsoft.OData.SampleService.Models.TripPin.xml(61): <Property Name=\"Emails\" Type=\"Collection(Edm.String)\"/>\nC:\\projects\\xscript\\src\\test\\xs\\data\\Microsoft.OData.SampleService.Models.TripPin.xml(62): <Property Name=\"AddressInfo\" Type=\"Collection(Microsoft.OData.SampleService.Models.TripPin.Location)\"/>\nC:\\projects\\xscript\\src\\test\\xs\\data\\Microsoft.OData.SampleService.Models.TripPin.xml(142): <Property Name=\"Tags\" Type=\"Collection(Edm.String)\" Nullable=\"false\"/>\n\n\n### Proposal\n\nNew proposal from meeting: To be compliant, 4.01 Services MUST specify Nullable for collections.  Since this is a new 4.01 requirement, clients SHOULD be prepared for collections that do not specify the value.\n\nImported from [ODATA-929](https://issues.oasis-open.org/browse/ODATA-929)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow client to use OData-SchemaVersion header to indicate the metadata version it is using",
    "body": "Once we define a standard annotation term to allow the metadata author to define a schema version, it would be extremely useful for clients to be able to indicate to the server which version of the metadata document the client is working with (since no matter when the client received the metadata, it may since have changed at the server).\n\n### Proposal\n\nMoving accepted proposal from comments. Note that (as per [ODATA-937](https://issues.oasis-open.org/browse/ODATA-937) we dropped the OData- prefix):\n 1) Services MUST NOT make breaking changes to $metadata responses requested without an SchemaVersion header \n 2) Services MUST interpret requests (and return payloads) made without an SchemaVersion according with this unbroken $metadata \n 2) Clients that retrieve $metadata containing the SchemaVersion annotation SHOULD include the SchemaVersion header in all requests for data, and MAY include SchemaVersion in requests for $metadata \n 3) The value of the SchemaVersion header, if specified, MUST be a value returned in the SchemaVersion annotation in a previous request to $metadata, or the special value \"Latest\" to interpret the request for data or metadata according to the latest schema. \n 4) If the SchemaVersion header is present in a request for data, services must interpret requests and return responses compatible that version of metadata. \n 5) If the SchemaVersion header is present in a request for $metadata, services must return metadata compatible with (i.e., with no breaking changes from) the specified version. \n 6) If the specified version is invalid, the service should return a 400 error. \n\n\nClient can set an OData-SchemaVersion header in requests.\n\nServer may (these are example possibilities, possibilities, not requirements) use this information in a number of ways:\n\n(1) Refuse requests from the client if the server's metadata version is now incompatible with the version the client has indicated it is using.\n\n(2) Include extra metadata in responses, e.g. \"@odata.type\" for properties which weren't in the client's versin of the metadata, but now exist in the server's version (e.g. this allows the client to correctly treat those properties as dynamic, while knowing their proper type).\n\n\n\nImported from [ODATA-928](https://issues.oasis-open.org/browse/ODATA-928)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly disallow existing nested items in Deep Insert",
    "body": "In OData-666 we deprecated @odata.bind in favor of just using references in the related collection. This allows us to create a new entity that either creates nested entities (if the entire resource is new) or relates to existing entities (by providing just the reference).\n\nWe should be clear that it is an error to include the content of an existing resource (not just its reference) in a POST.\n\n### Proposal\n\nClarify that, when doing a POST:\n1) You can include new entities and references to existing entities, but not content for existing entities\n2) The end result of the POST is that the existing (references) and new (entities) are the full set of entities related according to that relationship.\n\nImported from [ODATA-927](https://issues.oasis-open.org/browse/ODATA-927)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "OData should not require 202 response to be empty",
    "body": "Section 11.6, Asynchronous Operations, currently states that\n\"Responses that return 202 Accepted MUST have an empty response body\"\n\nWhile OData does not define a response body, we should allow services to provide their own response bodies (for example, status of the asynchronously executing operation).\n\n### Proposal\n\nRemove restriction that response body must be empty.\n\nImported from [ODATA-926](https://issues.oasis-open.org/browse/ODATA-926)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define Core term for service/schema/model version",
    "body": "Part 1 Protocol describes rules for compatible changes to the data model of a service. \n\nYet clients may need to know which version of the model they are accessing.\n\n\n\n### Proposal\n\nAdd a Core term for a service/schema/model version.\n\n    <Term Name=\"SchemaVersion\" Type=\"String\" AppliesTo=\"Schema\">\n        <Annotation Term=\"Core.Description\" String=\"Version of the schema (not to be confused with the protocol version)\" />\n    </Term>\n\nClarify relationship between version and metadataEtag: first is semantic, second could be technically derived (timestamp of development artifacts), so the latter may change without the former changing, but if the former changes, the latter SHOULD/MUST change.\n\nImported from [ODATA-925](https://issues.oasis-open.org/browse/ODATA-925)",
    "labels": [
      "CSDL JSON",
      "Vocabularies",
      "V4.0_CSD02",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define semantics for PUT against a single entity with nested content",
    "body": "In [ODATA-666](https://issues.oasis-open.org/browse/ODATA-666) we defined semantics for a PATCH request to a single entity or collection of entities that contained nested entities.\n\nWe said it didn't make sense to do a PUT against a collection of entities, but need to define the semantics (if allowed) of a PUT operation against a single entity where the payload contains nested entities.\n\n### Proposal\n\nAlign Semantics of PUT with PATCH, as specified in [ODATA-876](https://issues.oasis-open.org/browse/ODATA-876), by specifying that, when you do a PUT,\n1) You can include new nested entities, existing entities, and references to existing entities\n2) Existing entities are updated using PUT semantics\na) entities to be updated must have either @odata.id or key fields, otherwise interpreted as an insert\nb) if @odata.id and key fields both exist but don't match, then request is invalid\n3) The end result of the PUT is that the specified entities and entity references are the full set of entities related according to that relationship.\n\nImported from [ODATA-924](https://issues.oasis-open.org/browse/ODATA-924)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support DELETE/PUT to $ref of a collection-valued nav prop to remove/replace all links",
    "body": "Today you can \"unlink\" a resource from a single-valued nav prop using DELETE ~/EntitySet(key)/SingleNav/$ref.\n\nWith the new set operations, we could support deleting all references from a collection-valued nav prop using DELETE ~/EntitySet(key)/CollectionNav/$ref.\n\nWe should also consider supporting PUT ~/EntitySet(key)/CollectionNav/$ref with an array of keys to replace the links with those provided in the payload.\n\nFor containment, the specified links would have to already be in the collection; any links not in the collection would be removed (and, because it's containment, deleted). \n\n### Proposal\n\nhttps://www.oasis-open.org/apps/org/workgroup/odata/download.php/59028/odata-v4.01-wd01-part1-protocol.docx\nhttps://www.oasis-open.org/apps/org/workgroup/odata/download.php/59030/odata-json-format-v4.01-wd01.docx\n\nImported from [ODATA-922](https://issues.oasis-open.org/browse/ODATA-922)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify operations for keyless nav props",
    "body": "Current rules around navigation properties of keyless (abstract) entity types (including Edm.EntityType) need elaborating.\n\nNavigation properties that are typed as Edm.EntityType or a keyless abstract entity type don't have a key, so referencing an instance of a collection valued navigation property of Edm.EntityType (or any abstract entity type that doesn't define a key) is only meaningful after casting the nav prop to a non-abstract entity type with a key.\n\nAlso, since keys uniquely identify an entity within a collection, and a containment navigation property defines an entity within a collection, it doesn't make sense to have a containment navigation property of a keyless abstract type (including Edm.EntityType) (just as it doesn't make sense to have an entity set of an abstract type). This is implied by the current rules for an entity set, but we should spell out that this also applies to containment nav props (which define implicit entity sets).\n\nWe *could* say that a collection + type + key uniquely identifies a resource, and require casting in such cases, but unless we have scenarios that require entity sets/containment nav props of different types with different keys then that doesn't seem worth the extra complexity.\n\n### Proposal\n\nClarify:\n-Can't have containment nav props of abstract types w/o keys (including Edm.EntityType)\n-add note to url conventions: if you have a navigation property with no navigation property binding, the canonical URL (formed by appending the key of the child member to the navigation property path) may not uniquely identify a members (note implications for containment)\n\nImported from [ODATA-921](https://issues.oasis-open.org/browse/ODATA-921)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify overflow for int data types (-INF, INF, NaN)",
    "body": "See [ODATA-785](https://issues.oasis-open.org/browse/ODATA-785) for a description of the issue --> Comments Section.\n\n### Proposal\n\nNew Proposal:\n\n1) Because annotating numeric values of arrays is problematic, and we are no longer trying to use JSON Schema as our schema language, revert application of the numericValueException annotation and continue the 4.0 literal \"INF\", \"-INF\", and \"NaN\" values.\n2) Support these values all numeric types. --> reduced to Decimal with floating scale by [ODATA-1091](https://issues.oasis-open.org/browse/ODATA-1091)\n3) Support -INF and INF for Edm.Date and Edm.DateTimeOffset --> OData Temporal Extension\n\n\nPreviously applied proposal from 2016-5-12:\n\n1) Add a new annotation, \"odata.numericValueException\", with valid values \"INF\", \"-INF\" and \"NaN\".\n2) Services don't return the property, just the property annotation specifying the value exception:\n  \"NumberOfODataUsers@odata.numericValueException\":\"INF\"\n3) Could be applied to any numeric type.\n4) For 4.01 clients, always return this for all numeric types, including single/double, instead of as property values.\n\nImported from [ODATA-920](https://issues.oasis-open.org/browse/ODATA-920)",
    "labels": [
      "JSON Format",
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add operator \"divby\" that always results in a decimal.",
    "body": "See [ODATA-785](https://issues.oasis-open.org/browse/ODATA-785) for a description of the issue --> Comments Section.\n\n### Proposal\n\nAdd operator \"divby\" that does mathematical division and always results in a decimal (as if both operands were promoted to decimal).\n\na divby is identical to cast(a,Edm.Decimal) div cast(b,Edm.Decimal)\n\nServices that support div and cast SHOULD also support divby\n\nServices MAY advertise it with Capabilities.FilterFunctions\n\nImported from [ODATA-918](https://issues.oasis-open.org/browse/ODATA-918)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.1.2.1 Addition and 5.1.1.2.2 Subtraction: Date add/sub Duration is DateTimeOffset - but in which time zone?",
    "body": "The cited sections allow these operations but fail to provide guidance on how to implement them.\n\nDateTimeOffset must have a time zone, date cannot have a time zone.\n\nIt would be better to \n- disallow these operations altogether\n- define the result type as Date and specify how to round or ignore sub-day duration portions\n\n### Proposal\n\nRules are actually present in XML Schema 1.1 Part 2: E.3.3 Adding Durations to DateTime.\n\nRules:\n1) Convert date to datetime (in any timezone) with zero hh:mm:ss\n2) Add/subtract duration\n3) Convert to date by dropping fractional days and timezone\n\nThus today + 1 second is today. Today minus 1 second is yesterday.\n\nImported from [ODATA-917](https://issues.oasis-open.org/browse/ODATA-917)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define what services (and clients?) do with unknown format parameters",
    "body": "Need to define how clients/services deal with unknown (as opposed to not supported) type parameters in Accept and Content-Type headers.\n\n### Proposal\n\nif accept header contains an unknown (as opposed to not supported) type parameter, the service should not choose that option.\n\nServices should not add format parameters not specified in request header.\n\nFor each format parameter, we can specify whether it is allowable for the service to return something according to the format parameter without the format parameter being specified.\n\nClients/services should not expect that they can ignore unknown format parameters when matching types in content type.\n\nImported from [ODATA-916](https://issues.oasis-open.org/browse/ODATA-916)",
    "labels": [
      "CSDL JSON",
      "JSON Format",
      "Protocol",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]