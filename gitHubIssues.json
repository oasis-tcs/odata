[
  {
    "title": "Substitute references to obsolete RFC2616",
    "body": "RFC2616 is obsolete since  6.6.2014 and was substitute by six specifications (see https://www.mnot.net/blog/2014/06/07/rfc2616_is_dead)\n\nThe HTTP-Prefer Draft was changed into the RFC7240 at  6.6.2014. \n\n### Proposal\n\nDelete reference to RFC2616 and include the appropriate up-to-date specification(s):\n\nWe have 16 references to RFC2616.\nFrom the six new specifications only rfc7230, rfc7231, and rfc 7232 are required.\n\nList of proposed changes (section, current reference and new reference):\n\n1.2 Normative References\nCurrent:  [RFC2616]                  Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P., and T. Berners-Lee, “Hypertext Transfer Protocol -- HTTP/1.1”, RFC 2616, June 1999. http://www.ietf.org/rfc/rfc2616.txt.\nNew:    [RFC7230]                  Fielding, R., and J. Reschke, “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing”, RFC 7230, June 2014. http://www.ietf.org/rfc/rfc7230.txt\n        [RFC7231]                  Fielding, R., and J. Reschke, “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content”, RFC 7231, June 2014. http://www.ietf.org/rfc/rfc7231.txt\n        [RFC7232]                  Fielding, R., and J. Reschke, “Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests”, RFC 7232, June 2014. http://www.ietf.org/rfc/rfc7232.txt\n\n7. Formats\nCurrent: The client MAY request a particular response format through the Accept header, as specified in [RFC2616], or through...\nNew:     The client MAY request a particular response format through the Accept header, as specified in [RFC7231], or through...\n\n8.1.1 Header Content-Type\nCurrent: As specified in [RFC2616], the format of an individual request or response body MUST be specified in the Content-Type header of the request or response.\nNew:     As specified in [RFC7231], the format of an individual request or response body MUST be specified in the Content-Type header of the request or response.\n\n8.1.2 Header Content-Encoding\nCurrent: As specified in [RFC2616], the Content-Encoding header field is used as a modifier to the media-type (as indicated in the Content-Type).\nNew:     As specified in [RFC7231], the Content-Encoding header field is used as a modifier to the media-type (as indicated in the Content-Type).\n\n8.1.3 Header Content-Language\nCurrent: As specified in [RFC2616], a request or response can include a Content-Language header to indicate the natural language of the intended audience for the enclosed message body\nNew:     As specified in [RFC7231], a request or response can include a Content-Language header to indicate the natural language of the intended audience for the enclosed message body\n\n8.1.4 Header Content-Length\nCurrent: As specified in [RFC2616], a request or response SHOULD include a Content-Length header when the message's length can be determined prior to being transferred.\nNew:     As specified in [RFC7230], a request or response SHOULD include a Content-Length header when the message's length can be determined prior to being transferred.\n\n8.2.1 Header Accept\nCurrent: As specified in [RFC2616], the client MAY specify the set of accepted formats with the Accept Header.\nNew:     As specified in [RFC7231], the client MAY specify the set of accepted formats with the Accept Header.\n\n8.2.2 Header Accept-Charset\nCurrent: As specified in [RFC2616], the client MAY specify the set of accepted character sets with the Accept-Charset header.\nNew:     As specified in [RFC7231], the client MAY specify the set of accepted character sets with the Accept-Charset header.\n\n8.2.3 Header Accept-Language\nCurrent: As specified in [RFC2616], the client MAY specify the set of accepted natural languages with the Accept-Language header.\nNew:     As specified in [RFC7231], the client MAY specify the set of accepted natural languages with the Accept-Language header.\n\n8.2.4 Header If-Match\nCurrent: As specified in [RFC2616], a client MAY include an If-Match header in a request to GET, PUT, PATCH or DELETE.\nNew:     As specified in [RFC7232], a client MAY include an If-Match header in a request to GET, PUT, PATCH or DELETE.\n\n8.2.5 Header If-None-Match\nCurrent: As specified in [RFC2616], a client MAY include an If-None-Match header in a request to GET, PUT, PATCH or DELETE. \nNew:     As specified in [RFC7232], a client MAY include an If-Match header in a request to GET, PUT, PATCH or DELETE.\n\n9.1.5 Response Code 3xx Redirection\nCurrent: As per [RFC2616], a 3xx Redirection indicates that further action needs to be taken by the client in order to fulfill the request.\nNew:     As per [RFC7231], a 3xx Redirection indicates that further action needs to be taken by the client in order to fulfill the request.\n\n9.1.6 Response Code 304 Not Modified\nCurrent: As per [RFC2616], a 304 Not Modified is returned when the client performs a GET request containing an If-Match or If-None-Match header and the content has not changed.\nNew:     As per [RFC7231], a 304 Not Modified is returned when the client performs a GET request containing an If-Match or If-None-Match header and the content has not changed.\n\n9.2.2 Response Code 405 Method Not Allowed\n405 Method Not Allowed indicates that the resource specified by the request URL does not support the request method.\nCurrent: In this case the response MUST include an Allow header containing a list of valid request methods for the requested resource as specified in [RFC2616].\nNew:     In this case the response MUST include an Allow header containing a list of valid request methods for the requested resource as specified in [RFC7231].\n\n9.3 Server Error Responses\nCurrent: As specified in [RFC2616], error codes in the 5xx range indicate service errors.\nNew:     As specified in [RFC7231], error codes in the 5xx range indicate service errors.\n\n12    Security Considerations\nCurrent: For HTTP relevant security implications please cf. the relevant sections of [RFC2616] (15 Security Considerations) and for the HTTP PATCH method [RFC5789] (5. Security Considerations) as starting points.\nNew:     For HTTP relevant security implications please cf. the relevant sections of [RFC7231] (9 Security Considerations) and for the HTTP PATCH method [RFC5789] (5. Security Considerations) as starting points.\n\n\nImported from [ODATA-706](https://issues.oasis-open.org/browse/ODATA-706)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Move example 19 to section 10.9",
    "body": "See summary, example is valid but in wrong subsection\n\nImported from [ODATA-705](https://issues.oasis-open.org/browse/ODATA-705)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Missing comma in JSON Delta Response example",
    "body": "The line in “14 Delta Response” example that has this text:\n\n  \"City\":\"Tsawassen\"\n\nIs missing a trailing comma.\n\n\n### Proposal\n\nAdd the comma.\n\n\nImported from [ODATA-704](https://issues.oasis-open.org/browse/ODATA-704)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 31: wrong description",
    "body": "Example 30 and 31 have the same description. \nDescription of example 31 was copied from example 30.\n\n### Proposal\n\nUpdate the text after the example number 31.to describe Example 31.\n\nApplied: https://www.oasis-open.org/committees/document.php?document_id=56041&wg_abbrev=odata\n\nImported from [ODATA-703](https://issues.oasis-open.org/browse/ODATA-703)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define the behaviour of system query option $count and path segment /$count in combination with $apply ",
    "body": "Assume GET ~/Products/$count results in 100.\nAssume GET ~/Products?$apply=groupby((Name), aggregate(Sales/Amount with sum as Total)) results in a set with 4 entries (see example 50)\n\nWhat is the response for GET ~/Products/$count?$apply=groupby((Name), aggregate(Sales/Amount with sum as Total))?\n\nWhat is the value of @odata.count in the response for GET ~/Products?$apply=groupby((Name), aggregate(Sales/Amount with sum as Total))&$count=true?\n\nMy proposal is: in both cases 4.\n\n### Proposal\n\nAdapt 3.15 \"Evaluating $apply\" accordingly.\n\n$apply on resource paths ending in /$count acts on the set \"preceding\" the /$count, the result is the plain-text number of items in the result of $apply, similar to the combination of /$count and $filter\n\n$count system query option is executed after $apply, @odata.count contains the number of items in the result of $apply\n\nApplied: https://www.oasis-open.org/committees/document.php?document_id=56041&wg_abbrev=odata\n\nImported from [ODATA-702](https://issues.oasis-open.org/browse/ODATA-702)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Bug in Example 38: terms for LeveledHierarchy and  RecursiveHierarchy incorrectly annotated",
    "body": "There is a mismatch betwen the terms defined in http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs01/vocabularies/Org.OData.Aggregation.V1.xml and the usage in example 38. The term definitions are correct and fit to the normative text.\nWrong is (snipped from example 38):\n<Annotations Target=\"SalesModel.Product\">\n    <Annotation Term=\"Aggregation.LeveledHierarchy\"\n                Qualifier=\"ProductHierarchy\">\n     <Record>\n      <PropertyValue Property=\"Levels\">\n        <Collection>\n          <String>Category/Name</String>\n          <String>Name</String>\n        </Collection>\n      </PropertyValue>\n     </Record>\n    </Annotation>\n   </Annotations>\n\n   <Annotations Target=\"SalesModel.Time\">\n    <Annotation Term=\"Aggregation.LeveledHierarchy\"\n                Qualifier=\"TimeHierarchy\">\n     <Record>\n      <PropertyValue Property=\"Levels\">\n       <Collection>\n         <String>Year</String>\n         <String>Quarter</String>\n         <String>Month</String>\n       </Collection>\n      </PropertyValue>\n     </Record>\n    </Annotation>\n   </Annotations>\n\n   <Annotations Target=\"SalesModel.SalesOrganization\">\n    <Annotation Term=\"Aggregation.RecursiveHierarchy\"\n                Qualifier=\"SalesOrgHierarchy\">\n     <Record>\n      <PropertyValue Property=\"NodeProperty\" String=\"ID\" />\n      <PropertyValue Property=\"ParentNodeProperty\" \n                     String=\"Superordinate/ID\" />\n     </Record>\n    </Annotation>\n   </Annotations>\n\n\n### Proposal\n\nCorrect is:\n   <Annotations Target=\"SalesModel.Product\">\n    <Annotation Term=\"Aggregation.LeveledHierarchy\"\n                Qualifier=\"ProductHierarchy\">\n        <Collection>\n          <PropertyPath>Category/Name</PropertyPath>\n          <PropertyPath>Name</PropertyPath>\n        </Collection>\n    </Annotation>\n   </Annotations>\n\n   <Annotations Target=\"SalesModel.Time\">\n    <Annotation Term=\"Aggregation.LeveledHierarchy\"\n                Qualifier=\"TimeHierarchy\">\n       <Collection>\n         <PropertyPath>Year</PropertyPath>\n         <PropertyPath>Quarter</PropertyPath>\n         <PropertyPath>Month</PropertyPath>\n       </Collection>\n    </Annotation>\n   </Annotations>\n\n   <Annotations Target=\"SalesModel.SalesOrganization\">\n    <Annotation Term=\"Aggregation.RecursiveHierarchy\"\n                Qualifier=\"SalesOrgHierarchy\">\n     <Record>\n      <PropertyValue Property=\"NodeProperty\" \n                     PropertyPath=\"ID\" />\n      <PropertyValue Property=\"ParentNodeProperty\" \n                     PropertyPath=\"Superordinate/ID\" />\n     </Record>\n    </Annotation>\n   </Annotations>\n\n\nApplied: https://www.oasis-open.org/committees/document.php?document_id=56041&wg_abbrev=odata\n\nImported from [ODATA-701](https://issues.oasis-open.org/browse/ODATA-701)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Annotations to target propertypath/navpropertypath rooted at entity set",
    "body": "See related issue.\n\nIn some cases, it is desirable for an annotation to target the property or navigation property of an entity within a particular entity set.\n\nSo:\n<Annotations Target=\"myschema.myentitytype/mynavproperty\"/>\n\nwould target the \"mynavproperty\" element of myentitytype, while\n\n<Annotations Target=\"myschema.mycontainer/myentityset/mynavproperty\"/>\n\nwould target the \"mynavproperty\" element of an entity returned from the myentityset entity set, and\n\n<Annotations Target=\"myschema.mycontainer/myentityset/myschema.myderivedType/mynavproperty\"/>\n\nwould target the \"mynavproperty\" element of an entity of type \"myschema.myderivedType\" returned from the \"myentityset\" entity set.\n\n### Proposal\n\nDescribe support for properties/navproperties rooted at entityset and (optionally) including type cast segments.\n\nImported from [ODATA-700](https://issues.oasis-open.org/browse/ODATA-700)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Include Action and Function as targets for Annotations",
    "body": "We accidentally omitted Action and Function from the list of identifiable schema elements that can be targeted in an Annotations element in 14.2.1 of [CSDL].\n\n### Proposal\n\nAdd action and function to the list of identifiable schema elements in 14.2.1.\n\nImported from [ODATA-699](https://issues.oasis-open.org/browse/ODATA-699)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify rules around handling of custom query options when building URLs",
    "body": "OData defines custom query options as an extensibility mechanism for services to support service-specific behavior. However, semantics around how services inject, and clients respect, custom query options is not clearly spelled out.\n\nIn particular, when services advertise URLs (in service document, navigation links, read/edit, and media read/edit urls) that include custom query options, clients should preserve those custom query options whether invoking those urls directly or appending segments/additional query options.\n\nFor example, if a service advertises an edit link for an entity as a url with a custom query option, and the client wants to append a property segment to retrieve an individual property from that entity, it should include the custom query option when invoking the url.\n\n### Proposal\n\nClarify that clients should preserve custom query options included in urls advertised by the service in service documents, $metadata, and payloads, when invoking or appending to those urls.\n\nImported from [ODATA-698](https://issues.oasis-open.org/browse/ODATA-698)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define how/where $<content-id> can be used within a changeset",
    "body": "Currently, in 11.7.3.1, Referencing Requests in a ChangeSet, we say:\n\"New entities created by an Insert request within a change set can be referenced by subsequent requests within the same change set by referring to the value of the Content-ID header prefixed with a $ character. When used in this way, $<Content-ID> acts as the resource path that an alias for the URI that identifies the new entity unless $<Content-ID> is identical to the name of a top-level system resource ($batch, $crossjoin, $all, $entity, $id, $metadata, or other system resources defined according to the OData-Version of the protocol specified in the request).\"\n\nHowever, we don't say where/how this \"alias\" can be used, and it's not really described in the abnf.\n\nAlso, for completeness we should reference $root as one of the top-level system resources that the name can't conflict with.\n\n### Proposal\n\nRather than introduce the term \"alias\" here (which may be confused with other aliases) just say that this defines a resource path for the new entity that can be used anywhere other resource paths are valid.\n\nAlso, add \"root\" to the list of top level resources that the name doesn't conflict with.\n\nImported from [ODATA-697](https://issues.oasis-open.org/browse/ODATA-697)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support \"interfaces\" for casting entities to multiple different types",
    "body": "OData's single-inheritance type model works well for many types of ontologies where new types are specializations of existing types, and maps well to class definitions in popular programming languages. However, single inheritance does not describe the fact that an instance of a type can play multiple different roles.\n\nVocabularies were introduced to OData in order to enable the definition of common schemas that could be shared across a particular industry or enterprise. Vocabularies allow the ability to share semantic information, such as the fact that a particular instance represents some generic concept.\n\nEntity models can use these shared schema in defining a data model, for example through derivation, or can map properties of a defined entity to properties of an entity from a shared model. However, we don't have a common way for a service to specify that an entity can be treated (i.e., cast) to another entity outside of the single-inheritance hierarchy, and requiring inheritance to model ontologies is overly restrictive in many cases. Also, some ontologies (like schema.org) make use of multiple inheritance, making it difficult for an entity to derive, for example, from both an individual and an organization.\n\nOdata defines clear semantics for casting entities of one type to a different type in requests urls, filters, etc. Services can support casting instances to any type, but can currently only advertise the ability to cast to a single (derived) type.\n\nAdding a new \"implements\" annotation term to the Core vocabulary allows a service to advertise the fact that one type can be cast to one or more other types using existing cast rules. This rule is entirely backward compatible; it doesn't introduce any incompatible behavior and is entirely safe for a client to ignore.\n\n\n\n### Proposal\n\nServices MAY support casting any entity type, complex type, primitive type, or type definition to a type outside of the type hierarchy, following standard cast semantics including path constructs in URLs. If an instance of the type doesn't support the cast, a null is returned.\n\nThe target type of the cast may have some or no properties in common with the source type, and properties with the same name may have different values and even different types. \n\nIf casting to an entity type, the entity type may have an entity key which may or may not match the entity key of the type that implements it.\n\nA new term is added to the Core vocabulary to advertise the set of types outside of the type hierarchy that a type may be cast to:\n\n<Term Name=\"MayImplement\" Type=\"Collection(Edm.String)\">\n  <Annotation Term=\"Core.Description\" \n              String=\"A collection of types that this type may be cast to.\"/>\n</Term>\n\nServices MUST support casting instances of the annotated type to the target type(s) using existing cast segments and semantics. If an instance of the type doesn't support the cast, the cast results in a null value.\n\nOpened [ODATA-953](https://issues.oasis-open.org/browse/ODATA-953) to consider structural casting\n\nImported from [ODATA-696](https://issues.oasis-open.org/browse/ODATA-696)",
    "labels": [
      "CSDL XML",
      "URL Conventions",
      "Vocabularies",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Returning 200 in placeof 204 no content",
    "body": "OData-585 proposes supporting the ability to return 200, with a special structure providing more information, in place of 204 No Content for various scenarios. If we expect to do this we should make clients aware of this potential pattern in 4.0.\n\nAnother option for carrying additional status information would be a specially defined header.\n\nImported from [ODATA-695](https://issues.oasis-open.org/browse/ODATA-695)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Dynamic actions/functions in errata",
    "body": "OData-579 contemplates the addition of dynamic actions/functions to a payload. We should consider calling out this case, at least for parameterless actions/functions, in the errata..\n\nImported from [ODATA-694](https://issues.oasis-open.org/browse/ODATA-694)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "ReturnType should support annotations",
    "body": "We accidentally omitted ReturnType from the list of annotatable schema elements. we should fix that.\n\nImported from [ODATA-693](https://issues.oasis-open.org/browse/ODATA-693)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Future versions are expected to support referential constraints to complex/nav properties",
    "body": "OData 560 suggests allowing referential constraints to reference complex properties (or even nav) properties.\n\nWe should consider giving 4.0 clients a heads up by calling out this anticipated usage.\n\nImported from [ODATA-692](https://issues.oasis-open.org/browse/ODATA-692)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Call out that services may support the use of term names in place of type names",
    "body": "ODATA=618 calls that term names could be used in place of type names. We should alert V4 clients that this may be coming.\n\n### Proposal\n\nCall out that services may support the use of term names in place of type names in [CSDL].\n\n\"Clients should be aware that future versions of OData are expected to support the use of term names in CSDL in place of type names to convey the type plus added semantics.\n\nImported from [ODATA-691](https://issues.oasis-open.org/browse/ODATA-691)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Alert clients to new symbolic scale value \"float\"",
    "body": "[ODATA-557](https://issues.oasis-open.org/browse/ODATA-557) proposes adding a new symbolic value \"float\" to the scale attribute for decimals to specify that values will be returned in exponential notation.\n\nIn OData V4 we should add text to make clients aware of this expected change;\n\n\"The Scale attribute value of \"float\" is reserved for future use for decimal types with precision of 16 or 34 to specify that values will be returned using exponential notation.\"\n\nImported from [ODATA-690](https://issues.oasis-open.org/browse/ODATA-690)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Deep Insert and Media Entities",
    "body": "Media entities are created implicitly when POSTing the media resource.\nThis seems to imply that media entities cannot be created as nested entities in a deep-insert request.\n\n### Proposal\n\nState explicitly that media entities cannot be created in a deep-insert request\n\nImported from [ODATA-689](https://issues.oasis-open.org/browse/ODATA-689)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "DELETE requests to raw property values, media resources, and stream properties",
    "body": "We don't specify the meaning of DELETE requests to raw property values (PropertyName/$value), stream properties, and media resources.\n\n### Proposal\n\nDelete on the raw property value sets a nullable property to null and results in an error for non-nullable properties.\n\nDelete on a stream property sets it to \"empty\", resulting in 204 No Content. This is in sync with the behavior for GET StructuralProperty/$value if the structural property is null\n\nDelete on the media resource deletes the media resource. It could also implicitly delete the media entity. AtomPub seems to allow both, see http://tools.ietf.org/html/rfc5023#section-9.4:\n\n    9.4.  Deleting Resources with DELETE\n   To delete a Member Resource, a client sends a DELETE request to its\n   Member URI, as specified in [RFC2616].  The deletion of a Media Link\n   Entry SHOULD result in the deletion of the corresponding Media\n   Resource.\n\nMember Resource == media resource\nMember URI == read/edit-media link\nMedia Link Entry == media entity\n\n\nImported from [ODATA-688](https://issues.oasis-open.org/browse/ODATA-688)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Prepare clients to deal with type annotations without the leading \"#\"",
    "body": "[ODATA-561](https://issues.oasis-open.org/browse/ODATA-561) calls out the fact that the leading \"#\" is not really required (and doesn't really make sense) for primitive types (because they are not really a fragment located within the metadata document) and suggests (for backward compatibility) allowing, but not requiring, services to omit the \"#\" for primitive types.\n\nWe should make clients aware that this change is expected, so that they can write their code appropriately.\n\nIdeally we would say: \"Services should not include a leading # for primitive types but clients should be prepared to handle primitive types with or without a leading\"\n\n\n### Proposal\n\nIn 4.5.3, Annotation odata.type, of the OData JSON format document, change the existing line:\n\"For built-in primitive types the value is the unqualified name of the primitive type, specified as a URI fragment.\"\nto:\n\"For built-in primitive types the value is the unqualified name of the primitive type. In OData 4.0 this is specified as a URI fragment, but clients should be aware that future versions of OData are expected to make the leading \"#\" optional.\"\n\n\nImported from [ODATA-687](https://issues.oasis-open.org/browse/ODATA-687)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Alert clients that odata may be default namespace in future versions of the protocol",
    "body": "OData control information is represented in a JSON payload as an annotation within the \"odata\" namespace. However, many services would like to return such control information without specifying the default \"odata\" namespace. [ODATA-630](https://issues.oasis-open.org/browse/ODATA-630) proposes allowing services to omit the \"odata\" namespace for OData control information, effectively making OData the default namespace. This would be more consistent with other formats such as JSON-LD.\n\nIt would be nice to make clients aware that this change is likely, to allow them to anticipate it when implementing their V4 implementations.\n\n### Proposal\n\nIn Section 4.5, Control information, of the OData JSON format doc.\n\nAdd to the existing sentence:\n\"In addition to the “pure data” a message body MAY contain control information that is represented as annotations whose names start with odata followed by a dot.\"\n\nthe following:\n\n\"Clients should be aware that future versions of OData are expected to allow omitting the odata prefix for control information, and should consider property names prefixed with the \"@\" symbol, and not containing a dot, to be the same as property names prefixed with \"@odata.\".\n\nImported from [ODATA-686](https://issues.oasis-open.org/browse/ODATA-686)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Prepare clients in 4.0 to deal with nav property binding on containment",
    "body": "OData V4 has a hole in that we never defined how navigation property bindings related to containment. OData-674 seeks to address that issue as a natural extension to current behavior, but because it couldn't be considered a non-material change we were unable to add it to 4.0.\n\nHowever, understanding how this will be addressed in the future, it would be nice to give direction to clients today such that they can anticipate the change and not break when services add support for navigation property bindings to contained nav props, and allow referencing contained sets as the target of a navpropbinding.\n\n### Proposal\n\nApproved Proposal:\nDescribe how PropertyPath and Target can traverse complex types, cast segments, and containment navigation properties as long as Property Path terminates on a non-containment nav prop and Target terminates on a containment nav prop, singleton, or entity set.. \n\nImported from [ODATA-685](https://issues.oasis-open.org/browse/ODATA-685)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define what it means for an added property to conflict with an existing dynamic property",
    "body": "Section 5.2 of Protocol currently says that adding properties/nav props are \"safe\" schema changes (not requiring a version change) as long as the added property/nav prop  \"does not conflict with an existing dynamic property\".\n\nHowever, we don't say what \"conflict\" means.\n\n### Proposal\n\nIt should be allowed to add a new prop/nav prop as long as any existing dynamic properties with that name are the same type, or derived from the same type, as the type defined for the new property. (Note: I was tempted to use \"type-compatible\" but I think that definition is a little too loose).\n\nImported from [ODATA-684](https://issues.oasis-open.org/browse/ODATA-684)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clients should be prepared to deal with new derived types",
    "body": "In metadata versioning we currently say that it's safe to add a new type as long as it \"does not derive from any entity types exposed by existing entity sets, or returned by existing functions or actions\"\n\nThis implies that it is not safe to add a new entity type that derives from an entity type used in an entity set/function/action. But this restriction is unnecessary, as clients should always be prepared for new types not specified in $metadata (for example, types of dynamic properties).\n\nThe same is true for complex types.\n\nFor such derived types, the payload will contain the @odata.type annotation with the qualified name of the metadata describing the type, and clients should always be prepared for such types.\n\n### Proposal\n\nClarify that clients should be prepared to see new types in the payload by extending the paragraph following the bulleted list of accepatable changes in 5.2, Model Versioning, with the following:\n\n\"Clients SHOULD be prepared for services to make such incremental changes to their model. In particular, clients should be prepared to receive properties and types, including derived types, not previously defined by the service.\"\n\nRemove the misleading verbage \"that does not derive from any entity types exposed by existing entity sets, or returned by existing functions or actions. \n\nImported from [ODATA-683](https://issues.oasis-open.org/browse/ODATA-683)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.4.1.5 Returning Results from Data Modification Requests - media resources and stream properties",
    "body": "The new section 11.4.1.5 Returning Results from Data Modification Requests specifies that the default response to data modification is the \"after-image\" of the modified resource.\n\nThis contradicts the behavior for updating media resources specified in section 11.4.7.2 Editing a Media Entity Stream:\n\n  If the request to edit a media stream returns a non-empty response body,\n  the response body MUST contain the updated media entity.\n\nThis special behavior for updating media resources is consistent with the special behavior for creating media resources, where also the media entity, i.e. the structured twin is returned.\n\nThis deviating \"default\" behavior raises the question whether stream properties also should have a different default and use 204 no content if not specified otherwise.\n\n### Proposal\n\nUpdates to media entity streams return the media entity, by default and on return=representation.\n\nUpdates to stream properties return nothing by default, and the media stream  on return=representation.\n\nImported from [ODATA-682](https://issues.oasis-open.org/browse/ODATA-682)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "What happens if an alias has the same name as an included namespace?",
    "body": "When a schema <include>s a namespace through the <references> element, it can optionally assign an alias to that namespace. Elements defined within the included namespace can be referenced qualified with the full namespace name or the alias name, if provided.\n\nWe have rules that the alias, if used, must be unique within the schema, and that the same namespace cannot be included more than once.\n\nIn most cases we expect shared namespaces to be disambiguated through a multi-part name, such as \"Org.OData.V1\", but we don't require namespaces to contain a period, and non-shared namespaces are likely to be a simple identifier.\n\nWe don't currently say what happens if an alias is introduced that matches the name of an included namespace. Does the alias take precedence, or does the namespace take precedence, or is this a schema validation error.\n\nSince the schema designer has control over the alias name, and not the namespace they are importing, an argument could be made for saying that the alias takes precedence over the namespace.\n\nWe should think through what happens if a schema includes a namespace and uses a type that has a property whose type is defined in a third (non-included) namespace that conflicts with an included namespace or alias. Right now I think we say that the namespace of the namespace containing the type of the property must also be included, but I don't know how practical that is in all cases.\n\nTo be backward compatible we should probably say that services SHOULD NOT use aliases that conflict with included namespaces, and that clients SHOULD assume that, in such cases, the alias takes precedence.\n\n### Proposal\n\nProhibit namespaces from clashing with aliases. Describe behavior of referenced documents.\n\nImported from [ODATA-681](https://issues.oasis-open.org/browse/ODATA-681)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify use of if-match with actions",
    "body": "Section 8.2.4, Header If-Match, states the following:\n\n\"If an entity set is annotated with the term Core.OptimisticConcurrency (see [OData-VocCore]) and the client does not specify an If-Match request header in a Data Modification Request  or Action Request, the service MUST respond with a 428 Precondition Required and MUST ensure that no observable change occurs as a result of the request.\"\n\nThis is true for data modification requests, but not generally true for action requests; an action request may operate on a single entity, a set of entities, or data unrelated to any entities. And, action requests may be invoked without having previously retrieved an entity from which to obtain an etag.\n\nThe most we can say is that an etag should be specified when invoking an action bound to a single entity for which an etag has been retrieved (i.e., an \"advertised\" action).\n\nAlso, it's always bugged me that we tie this to the OptimisticConcurrency annotation, as opposed to the presence of an etag in the response. The general rule should be: if you get an etag, provide it in an if-match header of any update/action on that entity.\n\n### Proposal\n\nClarify that, when invoking data modification request or an action advertised on an entity that has an associated etag, the etag should be specified in an if-match header when invoking the action.\n\nImported from [ODATA-680](https://issues.oasis-open.org/browse/ODATA-680)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.7.1, Example 78: OData-Version and OData-MaxVersion should be 4.0",
    "body": "\n\nImported from [ODATA-679](https://issues.oasis-open.org/browse/ODATA-679)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify delta responses with containment, OnDelete, or referential constraints",
    "body": "If an entity is deleted, related entities will be implicitly deleted if a navigation property specifies <OnDelete Action=\"Cascade\" /> or ContainsTarget=\"true\".\n\nIt is not explicitly specified if in this case the service has to include a deleted-entity object for each deleted entity in a delta response, or whether it is sufficient to notify clients of the deletion of the principal entity.\n\nSimilarly in the presence of referential constraints added the changed entities already carry the necessary information and the added/deleted link objects are redundant.\n\nThe JSON Format design goal of omitting everything from the payload that can be deduced from $metadata would indicate to just notifying the deletion of the principal entity.\n\n### Proposal\n\nServices can omit tombstones for contained and dependent entities. \n\nNote that services must still return added/deleted links if a dependent property changes and if a link changes there must be a dependent property change.\n\nImported from [ODATA-678](https://issues.oasis-open.org/browse/ODATA-678)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that clients should not validate based on applies to attribute",
    "body": "Clients are told to ignore annotations that they don't know about in order to allow vocabularies to evolve. One such evolution is the application of an annotation to a new type of entity. Clients should treat annotations applied to elements not defined in the AppliesTo attribute as \"unknown\" annotations and not raise an error.\n\n### Proposal\n\nClients should not raise an error if an annotation is applied to an element not listed in AppliesTo.\n\nImported from [ODATA-676](https://issues.oasis-open.org/browse/ODATA-676)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enumeration member values SHOULD be represented using the member name and not the integer member value",
    "body": "See summary\n\n### Proposal\n\nUse symbolic member name if it exists, use numeric value otherwise\n\nImported from [ODATA-675](https://issues.oasis-open.org/browse/ODATA-675)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify navigation property binding combined with containment",
    "body": "This combination is not explicitly covered in the specification.\n\nThere are two sides to this problem: \n- target entity sets for contained entities\n- contained entity sets as target entity sets\n\nBoth problems can be solved by allowing <NavigationPropertyBinding> elements as children of the structured type that defines the containment navigation property.\n\nExample 1: navigation property of a contained entity targets a top-level entity set:\n  <NavigationProperty Name=\"Items\" Type=\"Collection(Model.OrderItem)\" ContainsTarget=\"true\" />\n  <NavigationPropertyBinding Path=\"Items/Product\" Target=\"Model.Container/Products\"/>\n\nExample 2: assume an Order contains Items and Shipments, and an Item refers to a single Shipment of the same Order and vice versa. Using paths that start at the type defining the containment navigation property, the Target would be \"Shipments\" and \"Items\".\n<EntityType Name=\"Order\">\n  <NavigationProperty Name=\"Items\" Type=\"Collection(Model.OrderItem)\" ContainsTarget=\"true\" />\n  <NavigationPropertyBinding Path=\"Items/Shipment\" Target=\"Shipments\"/>  \n  <NavigationProperty Name=\"Shipments\" Type=\"Collection(Model.Shipment)\" ContainsTarget=\"true\" />\n  <NavigationPropertyBinding Path=\"Shipments/ShippedItems\" Target=\"Items\"/>\n</EntityType>\n\n<EntityType Name=\"OrderItem\">\n  <NavigationProperty Name=\"Shipment\" Type=\"Model.Shipment\" Partner=\"ShippedItems\"/>\n</EntityType>\n\n<EntityType Name=\"Shipment\">\n  <NavigationProperty Name=\"ShippedItems\" Type=\"Collection(Model.OrderItem)\" Partner=\"Shipment\"/>\n</EntityType>\n\n\n### Proposal\n\nNote: as per [ODATA-1030](https://issues.oasis-open.org/browse/ODATA-1030), for annotating an entity or complex type, use a new membership constraint annotation in the validation vocabulary.\n\n1) Support NavigationPropertyBinding element as a child of EntityType, ComplexType or Singleton.\n\n2) When used in a NavigationPropertyBinding within an EntityType or ComplexType, \"Path\" is a path starting with a property or navigation property on the type containing the NavigationPropertyBinding element, traversing zero or more containment navigation properties, complex types, or collections of complex types, and terminating on a non-containment navigation property. If the path includes a collection of complex types or a collection-valued navigation property, then the binding applies to all members of that collection. Also support cast segments as in NavigationPropertyBinding Path today. \n\n3) Clarify in current use of NavigationPropertyBinding that Path may traverse collections of complex types, and that when traversing collections of complex types or collection-valued navigation properties, the binding applies to all members of that collection. \n\n4) Rules 2 & 3 mean that the Path attribute has the same syntax and semantics whether the NavigationPropertyBinding is under an EntitySet, Singleton, EntityType, or a ComplexType. \n\n5) When used in a NavigationPropertyBinding within an EntityType or ComplexType, \"Target\" is a path starting with a property or navigation property on the type containing the NavigationPropertyBinding element, traversing zero or more single-valued containment navigation properties or complex types, and terminating on a containment navigation property. \n\n6) Support cast segments in the Target attribute of NavigationPropertyBindings, both in current usage and when child of an Singleton or Entity/Complex type element declaration. Note that a cast segment both casts and filters, so you could have the same navigationpropertybinding for the same navigation property cast (in Path) to different types, meaning members of the collection that are one type come from one entity set while members of the collection that are a different type come from a different entity set.\n\n7) Clarify in current usage of NavigationPropertyBinding that Target may only traverse single-valued containment navigation properties or complex types.\n\n8) When used in a NavigationPropertyBinding within an EntitySet or Singleton, Target may identify an entity set, singleton, or containment navigation property, but when used within an EntityType or ComplexType it must terminate in a containment navigation property. This is by design and prevents type definitions from being tied to a container. All other semantics and syntax of Target are the same whether the NavigationPropertyBinding element is the child of an EntitySet, Singleton, EntityType, or ComplexType.\n\n9) The new usage is only allowed in a 4.01 schema:\na. Can only have NavigationPropertyBinding as a child of Singleton, EntityType, or ComplexType in 4.01 responses\nb. Services should only use cast segments in Target attribute in 4.01 responses\nc. Services should only return navigation property bindings whose Path traverses collections of complex types in 4.01 responses\n\nImported from [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Annotation target path syntax insufficient to annotate contained entity sets",
    "body": "Section 17.5 does not allow target paths for contained entity sets.\n\n### Proposal\n\nClose without action, topic is addressed in [ODATA-631](https://issues.oasis-open.org/browse/ODATA-631)\n\nImported from [ODATA-673](https://issues.oasis-open.org/browse/ODATA-673)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clean up definition of TargetPath and description of Target in navigation property binding, action import, and function import",
    "body": "TargetPath is defined overly general. It is used in \nAnnotations/@Target and NavigationPropertyBinding/@Target both refer to the TargetPath section, but use different subsets of the overly general syntax, and parts of this syntax aren't used at all. \n\n### Proposal\n\nClearly separate the two distinct usages and clean up the definition\n\nImported from [ODATA-672](https://issues.oasis-open.org/browse/ODATA-672)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "The signature of the cast function uses an incorrect return-type.",
    "body": "In 5.1.1.4.29 the signature of the cast function specifies the non-existing return type Edm.Any.\nThe return type of the cast function is determined by the type parameter of the function, so the correct signature is\n  type cast(type)\n  type cast(expression,type)\n(as stated by the description \"The single parameter cast function returns the current instance cast to the type specified. The two-parameter cast function returns the object referred to by the expression cast to the type specified.\")\n\n### Proposal\n\nCorrect the signature to \n  type cast(type)\n  type cast(expression,type)\n\n\nImported from [ODATA-671](https://issues.oasis-open.org/browse/ODATA-671)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify behavior wrt If-Match header on a GET request",
    "body": "Section 9.1.6 of protocol incorrectly implies that a request containing an If-Match header should return a 304 Not Modified in the case the ETag specified in the If-Match header matches, which is incorrect.\nClarify that if the If-Match header is used on a GET request and the content has changed that the server MUST return a 412 Precondition Failed and otherwise process the request as normal.\n\n### Proposal\n\nSee Description.\n\nImported from [ODATA-670](https://issues.oasis-open.org/browse/ODATA-670)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that metadataEtag should be supported in minimal metadata",
    "body": "Minimal metadata allows the removal of annotations that can be computed by the client. metadataEtag cannot be computed by the client, so it must be included in minimal metadata (if the service supports versioned metadata).\n\n### Proposal\n\nexplicitly add metadataEtag to the minimal convomrance level in 3.1.1\n\nImported from [ODATA-669](https://issues.oasis-open.org/browse/ODATA-669)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Fix minor editorial issues",
    "body": "Fix various minor editorial nits found in editorial review of the documents.\n\nImported from [ODATA-668](https://issues.oasis-open.org/browse/ODATA-668)",
    "labels": [
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add support for NavigationPropertyBindings for contained entities",
    "body": "Currently we have no way of expressing in which set an entity lives (read: is contained) if that set is not an EntitySet but rather a set contained by another entity.\n\nImported from [ODATA-667](https://issues.oasis-open.org/browse/ODATA-667)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Define Deep Update and Deep Upsert operations",
    "body": "Similar to Deep Insert allow including nested entities that may already exist, in which case they are updated.\nAlso allow nested \"tombstones\" to remove entities.\nAllow entity references to just create relations as an alternative to odata.bind (in the long run: retire odata.bind and use references everywhere).\nUse odata.etag annotation for conditional update of nested entities.\n\nOriginal Proposal for sanity check:\nDocument changes\npart1-protocol\n \n11.4.3 Update an Entity\nReplace para #7 with:\nThe entity MAY contain related entities or entity references as inline content. For single-valued navigation properties this replaces the relationship. For collection-valued navigation properties this replaces the contents of the collection for the specified entites. \nmay either add to the relationship (link to 11.4.3.1-see below) or update related entities (link to 11.4.3.2-see below). Combining these two variants for updating a single collection-valued navigation property results in a 400 Bad Request error.\n\n(new section providing a guideline for updating links) 11.4.3.1 Add Links to Related Entities When Updating an Entity\nTo update an entity by adding further links to existing entities, the request includes bind operations on the corresponding navigation property.  However, using such bind operations is deprecated. The preferred method is to update the related entities (link to 11.4.3.2).\n\n\n(new section) 11.4.3.2 Update Related Entities When Updating an Entity\n\nThe request to update an entity MAY contain collection-valued navigation properties with updated representations of the set of entities related according to the relationship represented by the navigation property. This set MAY be a combination of entities as inline content in the request body, which is referred to as \"deep update\", entity references, deleted links and deleted entities.\n\nIf the update operation is triggered by a PUT request, the value of a navigation property represents the full set of related entities. Any entity in the relation that is not included in the request, either as an entity or entity reference, is removed from the relation. Any entity that is included as an entity reference is retained without changes if it was already related or added as a member if it wasn't. Any entity represented inline is updated (link to 11.4.3) if it is already related and upserted otherwise (link to 11.4.4). A PUT request MUST NOT include deleted links and deleted entities.\n\nIf the update operation is triggered by a PATCH request with the \"delta format\" for that nested entity collection,  the value of a navigation property represents changes to the set of related entities. Any entity in the relation that is not included in the request is retained without changes. Any entity that is included as an entity reference is retained without changes if it was already related or added as a member if it wasn't. Any entity represented inline is updated (link to 11.4.3) if it is already related and upserted otherwise (link to 11.4.4). A deleted link is processed as removed reference for that navigation property (link to 11.4.6.2). A deleted entity is processed as deleted link and then deleted (link to 11.4.5). Comment: The collection may contain added links.\nIf the update operation is triggered by a PATCH request without the \"delta format\" for that nested entity collection, we apply PUT semantics for the collection membership, and PATCH semantics for the rest.\n\nAn entity being part of the deep update MUST include its entity-id or its full set of key values for identification.  It is an error to specify an entity reference that does not identify an existing entity. \n\nThe service MUST NOT treat an update request for related entities with an odata.etag annotation as an insert and must use the etag for conditional updates of existing members. Conflicts will be signaled via status code 412 (precondition failed).\n \nUpon failure of the operation, the service MUST NOT modify any of the entities in the request in order to prevent a partial update. \n\n\n(Guideline for linking entities) 11.4.2.1 Link to Related Entities When Creating an Entity\n\t- Replace sentence #2 with \"The preferred method of providing such entity-ids is through entity references; the use of bind operations is deprecated\".\n\n\n \njson-format\n\nIn section 4.5.7 Annotation odata.id\nAdd after para #2: \nThe odata.id annotation MAY appear in deep update requests to identify entities to be updated. \n\n\nIn section 8.4 Deep Inserts\nRemove sentence #2. (\"Deep inserts are not allowed in update operations using PUT or PATCH requests.\")\n\nAdd section 8.5 Deep Update (shift all subsequent sections)\nWhen updating an entity with a PUT request, the request body MAY contain related entities specified using the same representation as for an expanded navigation property.\nWhen updating an entity with a PATCH request, the request body MAY contain changes to related entities specified using the representation as for an expanded navigation property that MAY also comprise deleted links and deleted entities.\n \natom-format\n \nIn section 8.4 Deep Inserts\nRemove sentence #2. (\"Deep inserts are not allowed in update operations using PUT or PATCH requests.\")\n\nAdd section 8.5 Deep Update (shift all subsequent sections)\nWhen updating an entity with a PUT request, the request body MAY contain related entities specified using the same representation as for an expanded navigation property.\nWhen updating an entity with a PATCH request, the request body MAY contain changes to related entities specified using the representation as for an expanded navigation property that MAY also comprise deleted links and deleted entities.\n\n### Proposal\n\n [ODATA-613](https://issues.oasis-open.org/browse/ODATA-613) defines semantics for PATCH to a collection of entities can take a delta payload (assumed delta format if an array).\n\nIn addition:\n1)\tWe deprecate @odata.bind in PATCH, PUT, POST\na.\tClients should instead use @odata.id for insert & link to existing elements\ni.\ti.e., instead of “property@odata.bind”:”...”, use “property”:{“@odata.id”:”url…”}\nii.\tAllow entity references in deep insert to add/update reference to existing\nb.\tTo be OData compliant, services need to support @odata.bind for OData-Version: 4.0\ni.\tOData-Version: 4.01 payloads must not use @odata.bind\nii.\tNOTE: to be compliant with OData, you MUST support 4.0 clients\n\n2)\tIn OData-Version 4.01 payloads, services that support conditional updates MUST pay attention to @odata.etag annotation within payloads [ODATA-666](https://issues.oasis-open.org/browse/ODATA-666)\na.\tIf present, implicit match \nb.\tReturns 412 Precondition failed if no match (same as if-match header)\ni.\tAdd to description in status codes?\nii.\tEtag is ignored in 4.00 payloads\nc.\tAn @odata.etag value of \"*\" means force update (same semantics as if-match)\nd.     If present in the top level resource, it must match both the odata.etag value and any if-match header\n\n3)\tContained items may have their own etags [ODATA-666](https://issues.oasis-open.org/browse/ODATA-666)\na.\tChanging a contained item MAY change the parent etag\n\n\nImported from [ODATA-666](https://issues.oasis-open.org/browse/ODATA-666)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add OData-MetadataETag header",
    "body": "In responses this header is an alternative to the odata.metadataETag instance annotation for JSON that can also be used in responses with 204 No Content or in Atom.\n\nIn requests it expresses the desire to receive requests using the metadata version with this ETag. This is useful for stores that version their EDM schemas.\n\nImported from [ODATA-665](https://issues.oasis-open.org/browse/ODATA-665)",
    "labels": [
      "Protocol",
      "V4.02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Consider supporting parameterless function imports with no parens",
    "body": "Currently we require function imports to have open/close parens, even if they have no parameters.\n\nServices could be more lax in allowing clients to call parameterless function imports with no parens.\n\n### Proposal\n\nFor function imports with no parameters the service may support an alternate syntax of omitting the parens. For maximum interoperability, the service must still support calling function imports with the parens.\n\nImported from [ODATA-664](https://issues.oasis-open.org/browse/ODATA-664)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify construction rules for calling function in $filter",
    "body": "The protocol spec calls out that you can invoke a function in $filter using the namespace- or alias- qualified name, but does not clearly spell out the rules for invoking a bound function from the current resource. \n\nSpecifically, to call bound function in filter do you need to prefix with $it?\ni.e., ~Products?$filter=$it/Model.GetPrice(3) gt 10\nor can I do\ni.e., ~Products?$filter=Model.GetPrice(3) gt 10 ?\n\nIf the latter, then how do I differentiate between a bound function and an unbound function with the same non-binding parameters? \n\n\n### Proposal\n\nThe $it/ path prefix is required for bound functions applied to the current instance\n\nImported from [ODATA-663](https://issues.oasis-open.org/browse/ODATA-663)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow usage of $apply as \"Expand Option\" in $expand",
    "body": "We haven't specified the usage of $apply as \"Expand Option\" in $expand. \nThere are good use cases for $apply as an option of $expand (and it combines very well):\n\n    GET Products?$expand=Sales($apply=aggregate(Amount with sum as Total))\n\nReturns all products, and the Sales navigation property value is a one-element array with the Total\nMeans: per Product in top-level result inline result of \n\n    GET Product(<key>)/Sales?$apply=aggregate(Amount with sum as Total)\n\nThis is equivalent to the clumsier\n\n    GET Products?$apply=groupby((<key properties of Product>,<all non-key structural properties of Product>),aggregate(Sales/(Amount with sum as Total))\n\n\n### Proposal\n\nIntroduce a new sub-chapter \"3.XX $apply as expand option in $expand\"; describe the behavior and add an example(s).\nExtend the sub-chapter \"3.15 Evaluating $apply\".\nExtend the ABNF Rules.\n\n\nImported from [ODATA-662](https://issues.oasis-open.org/browse/ODATA-662)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 15: describe key format for EnumTypeMember in MetadataService",
    "body": "Chapter 15 describes how model elements are identified in the Metadata service, and the description for enumeration type members is missing.\n\n### Proposal\n\nUse the same syntax as for target paths: Schema.EnumType/Member \n\nImported from [ODATA-661](https://issues.oasis-open.org/browse/ODATA-661)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether or not PATCH can be used to update a primitive property using its edit URL",
    "body": "Section 11.4.9.1 only mentions PUT as a method for updating a primitive property using its edit URL.  Sections 11.4.9.3 and 11.4.9.4 specifically mention the rules regarding both PUT and PATCH.\n\nWe should clarify whether or not PATCH is allowed in 11.4.9.1.\n\n### Proposal\n\nWe want to give direction to the client to use PUT for this. Services can support PATCH -- that would be outside of the pattern we are prescribing for updating a primitive property, but there is no reason for us to explicitly prohibit it.\n\nPropose no change.\n\nImported from [ODATA-660](https://issues.oasis-open.org/browse/ODATA-660)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarity needed about if/when Control Information\" must be specified in payload sent from client to server",
    "body": "In regard to section 4.5 \"Control Information\", (apart from section 4.5.1 odata.context) the JSON format spec is written as if it only considers payload sent in responses from server to client.\n\nHowever it is clear that it must in some cases apply to content sent in payload from client to server.\n\nFor example, presumably when an inheritance hierarchy is involved, a POST request needs to set odata.type.\n\nOn the other hand, a client might not know a valid entity-id to put in odata.id for a POST request (in particular where the server does not support canonical URLs).\n\n### Proposal\n\nClarify, for each subsection of 4.5 \"Control Information\", whether each annotation is optional or required (and in which circumstances it is required) for request from client to server.\n\n\nImported from [ODATA-657](https://issues.oasis-open.org/browse/ODATA-657)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Requesting clarity on payload ordering constraints for clients",
    "body": "Section 4.4 Payload Ordering Constraints would appear to apply only to servers/services.\n\nIf there was any intent that it also (optionally) apply to request payload (from client to server), or even if not, we should be clear about this.\n\n\n### Proposal\n\nClarify in Section 4.4 Payload Ordering Constraints that clients may use the odata.streaming=true format parameter to specify that the contents of the payload supplied by the client follow the ordering constraints. In the absence of such a type parameter the service must assume that the properties of json objects are unordered.\n\n\nImported from [ODATA-656](https://issues.oasis-open.org/browse/ODATA-656)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA03",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "OData-EntityId is only required for 204 No Content, but client may need it when server doesn't support canonical URLs",
    "body": "OData protocol section \"8.3.3 Header OData-EntityId\" states:\n\n\"A response to a create operation that returns 204 No Content MUST include an OData-EntityId response header.\"\n\nIf the server doesn't support canonical URLs, the client cannot obtain the entity id of a created entity (when 204 No Content is returned) without requerying the entity.\n\n\n\n### Proposal\n\nClose without action\n\nImported from [ODATA-654](https://issues.oasis-open.org/browse/ODATA-654)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Errors in CSDL \"16.1 Products and Categories Example\" and \"15.4 Properties\"",
    "body": "The example uses Uris of the form:\n\n  http://docs.oasis-open.org/odata/odata/v4.0/cs01/vocabularies/...\n\nbut should use:\n\n  http://docs.oasis-open.org/odata/odata/v4.0/os/vocabularies/...\n\nAlso, the example has:\n\n          <Annotation Term=\"Core.OptimisticConcurrencyControl\">\n\nwhich should be:\n\n          <Annotation Term=\"Core.OptimisticConcurrency\">\n\nExample 75 in 15.4 has\n\n      \"QualifiedName\":\"Core.OptimisticConcurrencyControl\",\n      \"Name\":\"OptimisticConcurrencyControl\",\n\nand should be\n\n      \"QualifiedName\":\"Core.OptimisticConcurrency\",\n      \"Name\":\"OptimisticConcurrency\",\n\n\n### Proposal\n\nFix the Uris and Change OptimisticConcurrencyControl to OptimisticConcurrency\n\nImported from [ODATA-652](https://issues.oasis-open.org/browse/ODATA-652)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Chapter 3: Rephrase \"An entity can be a member of at most one entity set at any given point in time\"",
    "body": "The sentence \"An entity can be a member of at most one entity set at any given point in time\" is causing some confusion. Replace it with a more verbose description of what we want to achieve.\n\nAn incomplete version of this sentence is included in CSDL and should be removed to avoid confusion.\n\n### Proposal\n\nProtocol, chapter 3:\n\n[Keep]   An entity's key uniquely identifies the entity within an entity set. \n[New]    If multiple entity sets use the same entity type, the same combination of key values can appear in more than one entity set and identifies different entities, one per entity set where this key combination appears. Each of these entities has a different entity-id (link to section 4.1).\n[Delete] An entity can be a member of at most one entity set at any given point in time. \n[Keep]   Entity sets provide entry points into the data model. \n\nProtocol, chapter 4.1:\n[Delete] Whereas entities in the Data Model are uniquely identified by their key values within an entity set, entities within a payload are identified by a durable, opaque, globally unique entity-id.\n[New]    Whereas entities within an entity set are uniquely identified by their key values, entities are also uniquely identified by a durable, opaque, globally unique entity-id.\n\nCSDL, chapter 13:\n\n[Remove] Note: although a model may expose multiple entity sets of the same type, an entity can be a member of at most one entity set, see [OData-Protocol].\n\nImported from [ODATA-651](https://issues.oasis-open.org/browse/ODATA-651)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify the use of $format in delta links and next links",
    "body": "The specification clearly forbids clients to compose $format onto a delta or next link, and allows using the Accept header.\n\nIt does not forbid servers to encode $format in a delta or next link, which would make it impossible for the client to overrule this encoded format with an Accept header.\n\nDuring the TC meeting on 04/24/2014, some members suggested concerns of changing the response format when following next links. The server can prevent this format change by encoding the initial format in the next link using $format (regardless of whether the client originally used $format or not).\n\nFormat for a delta response should not depend on the original format.  However, if a client explicitly used $format, they may have done so because they couldn't use the Accept header (for whatever reason), in which case they may not be able to change the Accept header when using a delta link, in which case they would expect the delta link to include $format as well.\n\n### Proposal\n\n- Services MAY use $format in a next link to prevent clients from changing the format between requests\n- Services SHOULD NOT use $format in a delta link\n\nImported from [ODATA-650](https://issues.oasis-open.org/browse/ODATA-650)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define \"Edit URL\" of primitive property",
    "body": "In section 11.4.9.1 Update a Primitive Property, we refer to the \"Edit URL for a primitive property\", but we don't define (at least where it's used) what the Edit URL for a primitive property is (i.e., the edit url for the entity with the property name appended as a segment).\n\n### Proposal\n\nMake sure in 11.4.9.1., and any other locations where we reference the \"Edit URL for xxxx\" that we have defined that url.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52864/odata-meeting-71_on-20140424-minutes.html#odata-647\n\nImported from [ODATA-647](https://issues.oasis-open.org/browse/ODATA-647)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify; returning content from a data modification should be same as GET",
    "body": "In the section on data modification (update/create) we say that the service may return the representation of the entity but we don't say, especially for PATCH, whether this should return just the specified properties or the full entity. We should clarify that services are expected return the full entity (or at least the 'default properties\") that would be returned from GET.\n\n### Proposal\n\nClarify that, when returning content from an insert or update, services should return the full entity (or at least the 'default properties\") that would be returned from GET. Note that this should not affect existing rules around expanded content.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52887/odata-meeting-72_on-20140501-minutes.html#odata-646\n\nImported from [ODATA-646](https://issues.oasis-open.org/browse/ODATA-646)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Default for PUT/PATCH is not to return data",
    "body": "We are clear that, in the absence of a return=representation prefer header, the default for created entities should be to return the created entity. The default for PUT/PATCH has always been no data, but that is harder to find in the current document.\n\n### Proposal\n\nClarify in \"Update an Entity\" that, in the absence of a return=minimal preference, services SHOULD return data.\nAlso rephrase 8.2.8.7 to express that return=representation returns a complete representation of the targeted resource (not necessarily an entity).\n\nImported from [ODATA-645](https://issues.oasis-open.org/browse/ODATA-645)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Example 18 should use \"Orders\" instead of \"Items\"",
    "body": "Example 18 of the JSON document shows a sample payload for a deep insert of Customers with nested Items.\n\nFor the rest of the examples we use a schema where orders are nested within customers; for consistency and to avoid confusion we should show a nested collection of orders rather than \"Items\"\n\n### Proposal\n\nUpdate Example 18 to show nested orders instead of nested \"items\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/52864/odata-meeting-71_on-20140424-minutes.html#odata-644\n\nImported from [ODATA-644](https://issues.oasis-open.org/browse/ODATA-644)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that PUT must persist all \"updatable\" properties",
    "body": "In section 11.4.3, Update an Entity, we are clear that non-updatable properties specified in PUT or PATCH are ignored:\n\"Key and other non-updatable properties, as well as dependent properties that are not tied to key properties of the principal entity, can be omitted from the request. If the request contains a value for one of these properties, the service MUST ignore that value when applying the update.\"\n\nHowever, we also make general statements like: \n\"Collection properties and primitive properties provided in the payload MUST replace the value of the corresponding property in the entity or complex type\"\nand\n\"Services that support PUT MUST replace all values of structural properties with those specified in the request body\"\n\nWe should clarify that these later statements apply to *updatable* structural properties.\n\n### Proposal\n\nClarify that statements around updating properties apply to structural *updatable* structural properties.\n\nImported from [ODATA-643](https://issues.oasis-open.org/browse/ODATA-643)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$select wording clarification; specify, rather than restrict, set of properties",
    "body": "http://docs.oasis-open.org/odata/odata/v4.0/os/part2-url-conventions/odata-v4.0-os-part2-url-conventions.html#_Toc372793861\nspecifies that: \"The $select system query option allows clients to requests a limited set of properties for each entity or complex type.\"\n\nSince, in the absence of a $select, we allow the service to choose a default set of properties to return, $select can be used not only to restrict but also to expand the set of properties to be selected.\n\nSome readers have been concerned that \"limited\" corresponds to the default set, as opposed to the available properties.\n\n\n### Proposal\n\nchange wording to: \"The $select system query option allows clients to request a *specific* set of properties for each entity or complex type.\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/52864/odata-meeting-71_on-20140424-minutes.html#odata-642\n\nImported from [ODATA-642](https://issues.oasis-open.org/browse/ODATA-642)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "MetadataService.edmx: Property IncludeInServiceDocument is missing for entity type EntitySet",
    "body": "This attribute is described in the prose document and edm.xsd, but forgotten in MetadataService.edmx.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52887/odata-meeting-72_on-20140501-minutes.html#odata-641\n\nImported from [ODATA-641](https://issues.oasis-open.org/browse/ODATA-641)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "NavigationPropertyBinding cannot be annotated",
    "body": "NavigationPropertyBinding elements cannot be annotated according to the prose spec and edm.xsd, but the MetadataService.edmx claims they can, which is an error.\n\n### Proposal\n\nRemove property \"Annotations\" from entity type \"NavigationPropertyBinding\" in MetadataService.edmx\n\nImported from [ODATA-640](https://issues.oasis-open.org/browse/ODATA-640)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "MetadataService.edmx: Schema annotations have to be represented inline",
    "body": "Only model elements identifyable with a target path can be represented within the Annotations entity set. Schema elements don't fall into this category because A.B.C could be a schema name as well as the name of element C in schema A.B\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52887/odata-meeting-72_on-20140501-minutes.html#odata-639\n\nImported from [ODATA-639](https://issues.oasis-open.org/browse/ODATA-639)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify Delta responses with Minimal Metadata",
    "body": "Within a delta response, @odata.context is used to convey that a link has been added, or that a link or entity has been deleted, and @odata.id is used to convey id of an added or updated entry.\n\nIn minimal metadata, we say that data that can be computed on the client can be omitted. Clearly the context url is still required for added links, deleted links, and deleted entries, as well as added/updated entities from sets other than indicated by the response context url as that cannot be computed from the payload. the id may be computed from the payload only if the payload contains the id fields, and since a service is allowed to return only changed fields then it must also include the id for added/updated entities, even in minimal metadata. same is true for @odata.deltaLink on the last page of the response for retrieving additional changes.\n\n### Proposal\n\nClarify that @odata.contextUrl for added/deleted links, deleted entities, and entities from sets other than specified in the context url of the feed, as well as @odata.id for added/updated entities and @odata.deltaLink for additional changes must be present in a delta response, even in minimal metadata.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52864/odata-meeting-71_on-20140424-minutes.html#odata-638\n\nImported from [ODATA-638](https://issues.oasis-open.org/browse/ODATA-638)",
    "labels": [
      "Extension for JSON Data",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ATOM and JSON formats do not define representation of operation results",
    "body": "4.0 spec for ATOM and JSON formats doesn't define how values are represented when they are returned from operations (actions or functions).\n\nFor example, the following JSON format sections would appear to be only applicable only to a property within an entity or complex type instance.\n\n7.1 Primitive Value\n7.2 Complex Value\n7.3 Collection of Primitive Values.\n7.4 Collection of Complex Values\n11 Individual Property\n\nIf a value of one of the above types is returned by an action or function, we need to define how it is represented.\n\n\n### Proposal\n\nUse the same representation as for an individual property, section 11.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52864/odata-meeting-71_on-20140424-minutes.html#odata-637\n\n\nImported from [ODATA-637](https://issues.oasis-open.org/browse/ODATA-637)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that complex types and arrays can only be passed to functions through parameter aliases",
    "body": "complex types and arrays can be passed by value to functions as JSON, however the structure of the JSON may contain characters (urls, types prefixed with \"#\", etc.) which are not valid in the path of the URL. Thus, complex types/arrays may only be passed by value as parameters using a parameter alias (whose value is passed as a query option).\n\nThis is supported from the ABNF, but it takes some digging to figure out. It would be good to call this out in the prose.\n\n\n\n### Proposal\n\nExplicitly call out in the discussion of passing complex types/arrays to functions that passing complex types/arrays by value MUST use parameter alias syntax.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-636\n\nImported from [ODATA-636](https://issues.oasis-open.org/browse/ODATA-636)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify if  a PUT request is allowed to change the odata.type of the entity (public comment c201403e00002)",
    "body": "\nWe received the public Comment #20140300002 on 2014-03-27 with title \"Non-updatable properties?\".\n\nText was:\n\"\"\"\nFrom\nhttp://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793719,\nsection 11.4.3 Update An Entity\n\n“Key and other non-updatable properties, as well as dependent properties\nthat are not tied to key properties of the principal entity, can be\nomitted from the request. If the request contains a value for one of\nthese properties, the service MUST ignore that value when applying the\nupdate.”\n\nIs there a definition of what “other non-updatable properties” means\nelsewhere in the spec?  I haven’t had much success finding a reference.\n\nI’m trying to understand this section of the spec to answer a specific\nuse case:\n\nIs a PUT request allowed to change the odata.type of the entity?\n\nClearly this is not allowed by PATCH and MERGE because they operate on\nthe original object, but for PUT I’m not sure. I would like to say no,\nthe entity type should not be altered in any kind of update, but since\nPUT requires complete replacement of the original entity, constructing a\ndifferent type in its place is not beyond the realm of possibility.\n\nAre there OData implementations that allow changing the type of an\nentity in a PUT?\n\nThoughts?\n\"\"\"\n\n\n\n### Proposal\n\nClarify that PUT requests cannot change the type. A PUT request affects all structural properties of the entity, but things like identity, type, and relationships are not affected by the PUT.\n\nThis is supported by the current wording but could be spelled out more clearly:\n\nPUT MUST replace all values of structural properties with those specified in the request body. Missing non-key, updatable structural properties not defined as dependent properties within a referential constraint MUST be set to their default values. Missing dynamic structural properties MUST be removed or set to null.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-635\n\nImported from [ODATA-635](https://issues.oasis-open.org/browse/ODATA-635)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify the behaviour when a non-nullable property with no default value is omitted from a PUT",
    "body": "Section 11.4.3 of the protocol document specifies how an OData server should handle a PUT request.  However, it doesn't specify what the server should do if a non-nullable property with no default value is omitted from the PUT request body.\n\n### Proposal\n\nUpdate section 11.4.3 to specify that the server MUST return a 400 Bad Request when a non-nullable property with no default value is omitted from a PUT request body.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-634\n\nImported from [ODATA-634](https://issues.oasis-open.org/browse/ODATA-634)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rule pct-encoded-unescaped unintentionally omits hex pairs starting with 7",
    "body": "Rule pct-encoded-unescaped is incomplete, the range of hex pairs starting with 7 is missing. \n\nThis is a typo. \n\nThe only forbidden two hex pairs are the percent-encoded double quote %22 and the percent-encoded reverse solidus (backslash) %5C.\n\n### Proposal\n\nChange from\n\npct-encoded-unescaped = \"%\" ( \"0\" / \"1\" /   \"3\" / \"4\" /   \"6\" / \"8\" / \"9\" / A-to-F ) HEXDIG \n                      / \"%\" \"2\" ( \"0\" / \"1\" /   \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\" / A-to-F ) \n                      / \"%\" \"5\" ( DIGIT / \"A\" / \"B\" /   \"D\" / \"E\" / \"F\" )\n\n\nto\n\npct-encoded-unescaped = \"%\" ( \"0\" / \"1\" /   \"3\" / \"4\" /   \"6\" / \"7\" / \"8\" / \"9\" / A-to-F ) HEXDIG \n                      / \"%\" \"2\" ( \"0\" / \"1\" /   \"3\" / \"4\" / \"5\" / \"6\" / \"7\" / \"8\" / \"9\" / A-to-F ) \n                      / \"%\" \"5\" ( DIGIT / \"A\" / \"B\" /   \"D\" / \"E\" / \"F\" )\n\nConsider changing rule name to pct-encoded-no-DQUOTE-REVERSESOLIDUS\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-633\n\nImported from [ODATA-633](https://issues.oasis-open.org/browse/ODATA-633)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "\"Core.OptimisticConcurrencyControl\" should be \"Core.OptimisticConcurrency\"",
    "body": "[Core] refers to the annotation \"Core.OptimisticConcurrencyControl\" which was renamed to \"Core.OptimisticConcurrency\" in [ODATA-531](https://issues.oasis-open.org/browse/ODATA-531).\n\n### Proposal\n\nreplace the reference to \"Core.OptimisticConcurrencyControl\" with \"Core.OptimisticConcurrency\".\n\nClose without action as covered by [ODATA-580](https://issues.oasis-open.org/browse/ODATA-580)\n\nImported from [ODATA-632](https://issues.oasis-open.org/browse/ODATA-632)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow expressing that a term can be applied any collection and is not restricted to entity sets",
    "body": "We have a number of annotations (for example, in the capabilities vocabulary) that target entity sets. Most of these annotations can similarly be applied to containment relationships and singletons. How does the service apply such annotations to containment/singletons?\n\nAppliesTo is only a hint, so the Capability annotations can already applied to non-containment navigation properties that are just collections of entities and not entity sets.\n\nStill open: does AppliesTo=\"EntitySet\" imply that the annotation can target any collection of entities, or do we need an additional AppliesTo value, e.g. \"Collection\"?\n\n### Proposal\n\nAdd AppliesTo value \"Collection\" to clearly indicate that this term can be applied to any collection of entities, not only entity sets.\n\nThe new value is intentionally vague, i.e. not differentiated into EntityCollection, ComplexCollection, PrimitiveCollection because this optional restricition will typically be implied by the term semantics.\n\nImported from [ODATA-631](https://issues.oasis-open.org/browse/ODATA-631)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider making odata the default namespace for annotations",
    "body": "OData control information is represented in a JSON payload using annotations in the odata namespace, such as:\n\"@odata.nextlink\":\"http://...\"\nFor services that want the payload to look as much as possible like handcrafted json, the fact that \"odata\" is explicitly called out in the payload is a distraction.\n\nWe might make it easier for services to ease into OData's JSON format by making odata the default namespace, such that the same annotation could be written equivalently as:\n\"@nextlink\":\"http://...\"\n\n### Proposal\n\nIf the client does not specify odata.maxversion = 4.0, the service may omit the \"odata.\" namespace  for annotations. Clients interpret properties starting with \"@\" that don't contain a dot as being within the odata namespace.\n\ni.e., \"@type\", \"@id\", \"@editLink\", \"@nextLink\", etc.\n\nClients must still be prepared to receive results with the \"odata.\" prefix and must only omit the prefix in request bodies to services supporting OData 4.01 or greater (generally, it should be safe to format a request body the same way it was retrieved in a response)\n\n\nImported from [ODATA-630](https://issues.oasis-open.org/browse/ODATA-630)",
    "labels": [
      "JSON Format",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for UrlRef in attribute notation",
    "body": "The UrlRef expression allows both element and attribute notation. We provide two examples for element notation but none for attribute notation.\n\n### Proposal\n\nAdd example equivalent to the second example in element notation:\n\n<Annotation Term=\"Core.LongDescription\" UrlRef=\"http://host/wiki/HowToUse\" />\n\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-625\n\nImported from [ODATA-625](https://issues.oasis-open.org/browse/ODATA-625)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that (clients and) services may include additional format parameters in Content-Type header.",
    "body": "The json spec defines format parmaters that may be used in a request and response, but isn't clear about custom format parameters.\n\n\n\n### Proposal\n\nClients should be prepared for services to return custom format parameters, and should be able to safely ignore format parameters not specified in OData.\nServices must not include format parameters that a client needs to understand unless the client has done something special in order to request the format parameter.\nServices must return with not acceptable if the request contains an unknown or unsupported format parameter.\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-624](https://issues.oasis-open.org/browse/ODATA-624)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.4.3: be more specific on updating key properties",
    "body": "Paragraph 5 of http://docs.oasis-open.org/odata/odata/v4.0/os/part1-protocol/odata-v4.0-os-part1-protocol.html#_Toc372793719 explicitly allows updating key properties and describes side-effects to dependent entities. Unfortunately it does not mention that \n\nParagraph 6 still starts with \"Key and other non-updatable properties\", implying that key properties are not updatable.\n\n\n\n### Proposal\n\nChange start of paragraph 6 to \"Key properties, non-updatable properties\"\n\nAlternate proposal agreed to in meeting:\n\"Updating a key property that is tied to a dependent entity through a referential constraint on the dependent entity updates the dependent property.\"\nto:\n\"Updating a principle property that is tied to a dependent entity through a referential constraint on the dependent entity updates the dependent property.\"\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-623](https://issues.oasis-open.org/browse/ODATA-623)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow comparison of geo types, binary to null.",
    "body": "We currently state that operators can be used with types other than geo, stream, and binary, as these values are typically not comparable, but we don't say what *can* be used with these types..\n\nIt is valid to compare these values to null. This is handled in database systems, for example, by having \"is null\" and \"is not null\" operators, but since in OData we decided (after long debate) to use \"eq null\" and \"ne null\" to compare to null values (with appropriate null propagation rules). However, the current verbiage could be misinterpreted to mean that the common and useful case of comparing binary, stream and geo values to null is not supported.\n\n### Proposal\n\nExplicitly state that binary, stream and geo values can only be compared to null using \"eq null\" and \"ne null\".\n\nImported from [ODATA-622](https://issues.oasis-open.org/browse/ODATA-622)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify: Specifying an unbound function with overloads in a function import should import all overloads of that function to the entity container",
    "body": "It's not clear from the spec, if a function import refers to a function with multiple overloads, which overloads should be imported into the entity container. The intention (which would reasonable to interpret from the spec) is that all unbound overloads are imported, but spelling that out in the spec makes it clearer for implementers.  \n\n### Proposal\n\nClarify in the spec that all overloads of unbound functions specified in a function import are callable from the entity container.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-621\n\nImported from [ODATA-621](https://issues.oasis-open.org/browse/ODATA-621)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Replace \"scalar type\" with \"primitive type\" and \"scalar property\" with \"structural property\"",
    "body": "We use \"scalar type\" in a few places where we mean \"primitive type\", and \"scalar property\" where we mean \"structural property\". \nBesides using it with two different meanings we never introduce the term \"scalar\".\n\n### Proposal\n\nPart 1, section 11.2: replace \"scalar property\" with \"structural property\"\n\nPart 3, sections 12.1 and 12.2: replace \"scalar\" with \"primitive\"\nPart 3, sections 14.5.11 14.5.13: replace \"scalar\" with \"structural\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-620\n\nImported from [ODATA-620](https://issues.oasis-open.org/browse/ODATA-620)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Attach action and function signatures to terms, i.e. make a term definition an interface definition",
    "body": "This could be done with new Core terms SupportsAction and SupportsFunction whose string value is a qualified action/function name\n\nImported from [ODATA-619](https://issues.oasis-open.org/browse/ODATA-619)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow using term names in positions that allow type names",
    "body": "Terms have a declared type plus additional semantics, so using term names in place of type names seems natural.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-618](https://issues.oasis-open.org/browse/ODATA-618)",
    "labels": [
      "CSDL XML",
      "V4.01_WD01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow eq/ne comparison of instances of same structured (complex or entity) type, allow eq/ne comparison with null for 0..1 nav props",
    "body": "These are natural extensions of the query language\n\n### Proposal\n\ncan compare ordered collections: same members, same position\ncan compare unordered collections: same members, any order. don't expect this to work though...\ncan compare complex types by value (may fail if complex type contains unordered collection)\n-single-valued navigation properties reference the same entities\n-any collections of entities compare as equal\n   -if unordered, reference the same entities in any order\n   -if ordered, reference the same entities in same order\ncan compare two entities (as being the same reference)\n  ex: Person(1)/BestFriend eq Person(2)/WorstEnemy\n  ex: Person(1)/BestFriend eq {\"@odata.id\":\"/People(1)\"}\ncan compare entities to null:\n  ex: Person(1)/BestFriend eq null\n\nImported from [ODATA-617](https://issues.oasis-open.org/browse/ODATA-617)",
    "labels": [
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow POST to collections of complex and primitive types, and DELETE with $filter",
    "body": "This is a natural extension that does not require indexing into collections.\nFiltering on collections of primitive types can be done with the $it literal.\n\n### Proposal\n\n1) POST of a single item to a collection of complex or primitive types adds that item to the collection (as it does today with entity types.).  POST to an ordered collection adds to the end. ?$index can be used to insert other locations in an ordered collection\n2) DELETE to any collection without a $filter clears the collection  [[ODATA-616](https://issues.oasis-open.org/browse/ODATA-616)]\n\nImported from [ODATA-616](https://issues.oasis-open.org/browse/ODATA-616)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow PATCH and DELETE with /$filter=@... on collections to modify or delete all (and only) the matching entities",
    "body": "Another natural extension\n\nPrevious proposal: \n(was 11.4.3) 11.4.3.1 Update a Single Entity\n(add this first sentence to explain the expected request URL) To update a single entity in a collection, the client sends a PATCH or POST request to an entity's edit URL. \n\n11.4.3.2 Updating Multiple Entities\nTo update multiple entities in a collection, the client sends a PATCH request to that collection's URL.\nThe URL may include a $filter query option restricting the entities to be updated. For the entities matching the filter expression or all entities in the collection if no $filter query option was given, the service handles the request as a request to update a single entity (link to 11.4.3.1). \nOn success, the response MUST be a valid success response (link to 9.1).\nOn failure, the service MUST NOT update any of the qualifying entities.\n\n\n11.4.5 Deleting Entities from a Collection\n\n(was 11.4.5) 11.4.5.1 Delete a Single Entity\n\n11.4.5.2 Deleting Multiple Entities\nTo delete multiple entities in a collection, the client sends a DELETE request to that collection's URL.\nThe URL may include a $filter query option restricting the entities to be deleted. For the entities matching the filter expression or all entities in the collection if no $filter query option was given, the service handles the request as a request to delete a single entity (link to 11.4.5.1). \nOn success, the response MUST be 204 No Content (link to 9.1.4) and contain an empty body. .\nOn failure, the service MUST NOT delete any of the qualifying entities.\n\n\n\npart2-url-conventions\n\nIn section \"5.1 System Query Options\", change the sentence \"POST requests to entity sets as well as all PUT and DELETE requests do not allow system query options.\" to \"POST and PUT  requests to entity sets do not allow system query options.\"\n\n\n### Proposal\n\n1)\tDELETE to any collection deletes all elements of the collection; a $filter path segment can be used to delete only elements matching that filter. [[ODATA-616](https://issues.oasis-open.org/browse/ODATA-616)], [[ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)]\n2)\tPUT against a collection of primitive/complex types takes a collection (format is same as for a GET on the collection) in the payload and replaces the entire collection. [[ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)] (all or nothing)\na.\tPUT does not support set operations (so $filter segment doesn't apply).\nb.\tThis is the existing 4.0 behavior\n3)\tPUT is not supported against an entity collection  [[ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)]\n4)\tPATCH to any collection with a payload containing a single instance updates each element in the collection [[ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)]\na.\tA $filter path segment can be used to apply the patch only to those items matching the $filter [[ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)]\n5)\tPATCH to a collection of primitive or complex types with a collection payload is not supported  [[ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)]\n\nNOTE: if we supported a $expand path segment if the future we could support the ability to delete related entities (deep delete)\n\nImported from [ODATA-615](https://issues.oasis-open.org/browse/ODATA-615)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow $expand and $select with modifying requests that return a single instance in combination with return=representation to specify the response shape",
    "body": "This seems to be a natural extension for inserts and (partial) updates.\nAction calls already allow the same system query options as GET requests for the same return type.\n\n### Proposal\n\nApplies only to requests that return a single resource, and only to $select and $expand (and $format)\n1) if $expand/$select are present, implies return=representation\n2) if $expand/$select are present and return=minimal, service MUST include preference-applied if they DON'T return a result\n3) if it returns a result, $expand MUST be applied if specified and MUST include at least the $selected columns\n4) the service MUST NOT fail the request due to the $expand/$select; if the service cannot return a result with the appropriate $expand and $select it MUST return No Content\n\n\nImported from [ODATA-614](https://issues.oasis-open.org/browse/ODATA-614)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow PATCH to entity sets using the delta-response format",
    "body": "This will allow easy synchronization between services with same model\n\nPrevious proposal (for sanity check):\n\nDocument changes:\npart1-protocol\n\nAdd section: 11.4.10 Update an Entity Set\nTo update a collection, the client sends a PATCH request to that collection's URL. The PATCH body MUST contain a valid delta response consisting of appropriate representations for \nIf the target URL for the collection is a navigation link, any added entity is automatically linked to the entity containing the navigation link, and any deleted entity is automatically unlinked.\n\n### Proposal\n\nPATCH to a collection of entities can take a delta payload (interpreted as deltas if body represents a collection of entities) [ODATA-613](https://issues.oasis-open.org/browse/ODATA-613)\na.\tMUST NOT have $filter, $select, $orderby, etc. \n\nFor PATCH, you don't specify a $expand so the extent of that graph is undefined.  Therefore, it is valid to have added/deleted links to anything (at least anything reachable from the target; service probably wouldn't bother validating).  So Clients SHOULD make sure added/deleted links are reachable from target, but services need not validate.\n\nResponse, if requested, should be a delta representation, in the same structure and order as the request payload, representing changes.\n\n\nImported from [ODATA-613](https://issues.oasis-open.org/browse/ODATA-613)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consistently use \"edit link\" and \"edit URL\"",
    "body": "The \"edit link\" is the serialization construct, and it contains as its main part the URL that can be used for editing a resource via PUT and PATCH requests.\n\n### Proposal\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-612](https://issues.oasis-open.org/browse/ODATA-612)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state that the service root URL ends with a forward-slash",
    "body": "This is implicitly defined in the ABNF, and apparently worth of being mentioned explicitly.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-11\n\nImported from [ODATA-611](https://issues.oasis-open.org/browse/ODATA-611)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.4.4: Upsert and server-generated keys",
    "body": "We do not describe the desired behavior for Upsert operations on non-existing resources in case the key is partly or fully generated by the service.\n\nEither explicitly state that the behavior is service-specific, or state the desired generic behavior, e.g. disallow this combination altogether.\n\n### Proposal\n\nDisallow upserts for entity types with server-generated keys.\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-610](https://issues.oasis-open.org/browse/ODATA-610)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Section 11.4.4 Upsert: key values in URL win over key values in request body",
    "body": "For updates this is a consequence of section 11.4.3, and the same rule should apply for inserts.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odataprotocol\n\nImported from [ODATA-609](https://issues.oasis-open.org/browse/ODATA-609)",
    "labels": [
      "Protocol",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state that the path segment /$count can be combined with $search and $filter, and that the calculated count is identical to $count=true",
    "body": "Make explicit that the count calcuated by appending /$count to a collection resource path and the count calculated by applying the $count=true system query option to the same resource path is identical.\n\nConsequently paths ending in /$count also allow $search and $filter, and the resulting number is identical to the number included as @odata.count if the /$count segment is replaced by a $count=true system query option.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-608\n\nImported from [ODATA-608](https://issues.oasis-open.org/browse/ODATA-608)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Section 4.5.4: explicitly state that @odata.count can be applied to expanded to-many navigation properties",
    "body": "We allow $count=true nested after $expand, resulting in @odata.count annotations in the inlined representation of to-many navigation properties. This can be deduced from other specification text but is not explicitly stated in the section on odata.count.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-607\n\nImported from [ODATA-607](https://issues.oasis-open.org/browse/ODATA-607)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify navigation property binding combined with containment",
    "body": "This combination is not explicitly covered in the specification.\n\nThere are two sides to this problem: \n- target entity sets for contained entities\n- contained entity sets as target entity sets\n\nThe first problem can be solved by allowing <NavigationPropertyBinding> elements as children of <NavigationProperty> elements that specify ContainsTarget=\"true\": \n  <NavigationProperty Name=\"Items\" Type=\"Collection(Model.OrderItem)\" ContainsTarget=\"true\">\n    <NavigationPropertyBinding Path=\"Product\" Target=\"Model.Container/Products\"/>\n  </NavigationProperty>\n\nThe second problem is trickier: assume an Order contains Items and Shipments, and an Item refers to a single Shipment of the same Order and vice versa. Using paths that start at the type defining the containment navigation property, the Target would be \"Shipments\" and \"Items\".\n<EntityType Name=\"Order\">\n  <NavigationProperty Name=\"Items\" Type=\"Collection(Model.OrderItem)\" ContainsTarget=\"true\">\n    <NavigationPropertyBinding Path=\"Shipment\" Target=\"Shipments\"/>\n  </NavigationProperty>\n  <NavigationProperty Name=\"Shipments\" Type=\"Collection(Model.Shipment)\" ContainsTarget=\"true\">\n    <NavigationPropertyBinding Path=\"ShippedItems\" Target=\"Items\"/>\n  </NavigationProperty>\n</EntityType>\n\n<EntityType Name=\"OrderItem\">\n  <NavigationProperty Name=\"Shipment\" Type=\"Model.Shipment\" Partner=\"ShippedItems\"/>\n</EntityType>\n\nSlightly more complicated: Region contains SalesPeople and Customers, Customer has SalesRep that is a sales person from the same region. A Target can only be specified if Customer has an upward navigation to the containing Region: Target=\"Region/SalesPeople\".\n\nSo target paths are either relative and start with a sibling of the parent (navigation property within the same type, entity set within the same container) or absolute and start with a qualified schema name.\n\nImported from [ODATA-606](https://issues.oasis-open.org/browse/ODATA-606)",
    "labels": [
      "V4.01_WD01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Annotation target path syntax insufficient to annotate contained entity sets",
    "body": "Section 17.5 does not allow target paths for contained entity sets.\n\n### Proposal\n\nClose without action, topic is addressed in [ODATA-631](https://issues.oasis-open.org/browse/ODATA-631)\n\nImported from [ODATA-605](https://issues.oasis-open.org/browse/ODATA-605)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add type cast segment for complex types in rules for $select and $expand",
    "body": "The rules for select items and and expand items are missing alternatives for casting to complex types.\n\nThis is necessary if these query options are to be applied to resource paths that identify (collections of) complex type instances and the declared complex type has derived types.\n\n### Proposal\n\nReplace\n\n    qualifiedEntityTypeName\n\nwith\n\n    ( qualifiedEntityTypeName / qualifiedComplexTypeName )\n\nin rules selectItem and expandItem\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-604\n\nImported from [ODATA-604](https://issues.oasis-open.org/browse/ODATA-604)",
    "labels": [
      "ABNF",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Primitive type Edm.Stream: use as type of collection, input parameter, return type, or underlying type of type definition",
    "body": "Edm.Stream is listed as a primitive type. Does this allow properties of type Collection(Edm.Stream)?\n\nWhat about actions or functions that use Edm.Stream as an input parameter type or return type?\n\nWhat about its use as an underlying type of a type definition?\n\n### Proposal\n\nEdm.Stream can be used in type definition, return type, binding parameter, but not as non-binding parameter or in a collection.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-603\n\nImported from [ODATA-603](https://issues.oasis-open.org/browse/ODATA-603)",
    "labels": [
      "CSDL XML",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state what's allowed after /$all",
    "body": "Be more specific on what is allowed after /$all, e.g. state that $select and $expand clauses are allowed if a type-cast segment has been appended after $all. This is already allowed and can be deduced from section 4.9.\n\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52637/odata-meeting-69_on-20140327-minutes.html#odata-602\n\nImported from [ODATA-602](https://issues.oasis-open.org/browse/ODATA-602)",
    "labels": [
      "URL Conventions",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Ensure future compatibility by reference to draft-bray-i-json-n (The I-JSON Message Format)",
    "body": "To additionally safe guard against interoperability issues caused by the content updates to the JSON RFC (4627 obsoleted by 7159) lifting some restrictions, we should additionally reference the  internet draft draft-bray-i-json-01 (The I-JSON Message Format) which was added by members of the IETF JSON WG to exactly ensure this.\n\n### Proposal\n\nRefer to I-JSON in section on IEEE754compatible format parameter.\n\n[I-JSON] Tim Bray, Ed., \"The I-JSON Message Format\" draft-bray-i-json-01, 06 January 2014\nURL=http://tools.ietf.org/html/draft-bray-i-json-01\n\nImported from [ODATA-600](https://issues.oasis-open.org/browse/ODATA-600)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Let's update the GeoJSON reference",
    "body": "The GeoJSON community submitted it's standard as an internet draft to IETF. So I suggest we should target with our references this \"living\" document rather than still pointing to the birth place at geojson.org. After all members of this committee kindly asked that community to submit the standard to a standards body ;-)\n\n### Proposal\n\nReplace the existing reference to GeoJSON with the content:\n\n[GeoJSON] Howard Butler, Martin Daly, Alan Doyle, Sean Gillies, Tim Schaub and Stefan Drees, \"The GeoJSON Format\" draft-butler-geojson-02, 15 March 2014\nURL=http://tools.ietf.org/html/draft-butler-geojson-02\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-599\n\nImported from [ODATA-599](https://issues.oasis-open.org/browse/ODATA-599)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Update JSON RFC reference",
    "body": "The JSON RFC 4627 has been obsoleted. Let's update the references. The new RFC has widened a bit it's scope, but takes care to suggest keeping the old constraints allowing only array and object as top level elements for valid JSON text when interoperability is in focus (like is in our use cases).\n\nRFC 7159 became proposed standard only days after our products became standard, so it is not really an erratum, but it might be good style, to place info such as this inside an erratum to have an early indication on the future direction of a 4.1 or 5.0 as service to the users and decision help for international standardization bodies where our OASIS Standard might be submitted to. \n\n### Proposal\n\nUpdate JSON RFC reference from (OLD):\n\n[RFC4627]  Crockford, D., \"The application/json Media Type for\n           JavaScript Object Notation (JSON)\", RFC 4627, July 2006.\n\nto (NEW):\n\n[RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data    \n       Interchange Format\", RFC 7159, March 2014.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-598\n\nImported from [ODATA-598](https://issues.oasis-open.org/browse/ODATA-598)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Seeking clarification of naming for GeographyCollection with GeoJSON",
    "body": "GeoJSON section 2.1.8 states:\n\n  A GeoJSON object with type \"GeometryCollection\" is a geometry object which represents a collection of geometry objects.\n\n  A geometry collection must have a member with the name \"geometries\". The value corresponding to \"geometries\" is an array. Each element in this array is a GeoJSON geometry object.\n  \nCan we assume that for OData, a GeographyCollection contains a member with the name \"geographies\", as opposed to \"geometries\", and that the \"type\" will be \"GeographyCollection\" rather than \"GeometryCollection\"?\n\nOr do we assume that the \"geometry\" naming is used in the GeoJSON format, even for \"geography\" types?\n\n\n### Proposal\n\nI propose we don't introduce new properties/annotations at this point; that a geographyCollection is represented as a geometryCollection with \"geometries\" as the property name. Whether it is to be interpreted as geography or geometry is based on metadata.\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-597\n\n\nImported from [ODATA-597](https://issues.oasis-open.org/browse/ODATA-597)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Discrepancy between ATOM and JSON formats (GML, GeoJson) for Polygon information content",
    "body": "GML seems to require that Polygons specify (usually) an exterior ring, but also permits the specification or zero or more interior rings.\n\nGeoJSON only seems to allow a single set of points (see example in http://geojson.org/geojson-spec.html#id4)\n\nFor OData, one would hope that there is some kind of notion of the information content of Polygon coordinates which is independent of the format (ATOM or JSON) that we use. (Even if this information content is not formally documented, we could imagine that it exists).\n\nUnfortunately, this mismatch in Polygon coordinates between GML and GeoJSON seems hard to fit into a single information model.\n\n\n### Proposal\n\nMinimally, we must clarify to which GML concept (interior or exterior rings) the GeoJSON Polygon refers to. Presumably the exterior.\n\n(Note: this issue points to a larger issue that we have not defined an \"information model\" for Geo-types that is independent of the format.)\n\nImported from [ODATA-594](https://issues.oasis-open.org/browse/ODATA-594)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "JSON example 11: \"type\":\"Point\" with uppercase P according to GeoJSON spec",
    "body": "This is a typo in a non-normative example\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/52767/odata-meeting-70_on-20140403-minutes.html#odata-592\n\nImported from [ODATA-592](https://issues.oasis-open.org/browse/ODATA-592)",
    "labels": [
      "JSON Format",
      "V4.0_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]