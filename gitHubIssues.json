[
  {
    "title": "Authorization vocabulary: discourage use of OAuth 2 implicit grant flow",
    "body": "Security note: OAuth2 implicit grant is considered to be not secure and should not be used by clients, see [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics.html#name-implicit-grant).\n\n### Proposal\n\n[https://github.com/oasis-tcs/odata-vocabularies/pull/238] \n\nImported from [ODATA-1643](https://issues.oasis-open.org/browse/ODATA-1643)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that content-id referencing for newly created entities also works for entities created by an action",
    "body": "Section [11.7.4 Referencing Returned Entities](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ReferencingReturnedEntities) explicitly mentions \"insert requests\".\n\nSection [11.5.5.1 Invoking an Action](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_InvokinganAction) states that\n> Actions that create and return a single entity follow the rules for [entity creation](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CreateanEntity) and return a Location header that contains the edit URL or read URL of the created entity.\n> \n\nClarify that referencing returned entities also works for entities created via an action.\n\nAlso clarify whether that requires a bound action to specify an `EntitySetPath` and an action import to specify an `EntitySet`, or whether it is sufficient that the server knows how to identify the returned entity.\n\n### Proposal\n\nReferencing also works for actions that create an entity.\n\n`EntitySetPath` or `EntitySet` are not necessary, the server has to return a `Location` header and thus has to \"know\" how to identify the returned entity.\n\nOptional: action MAY/SHOULD be annotated as a constructor/factory action, see [ODATA-1214](https://issues.oasis-open.org/browse/ODATA-1214).\n\nImported from [ODATA-1637](https://issues.oasis-open.org/browse/ODATA-1637)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Referencing values from request bodies in batch requests: add examples",
    "body": "Section [11.7.6 Referencing Values from Response Bodies](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ReferencingValuesfromResponseBodies) doesn't have counterparts with examples for\n- Multipart requests - would be Protocol section 11.7.7.4\n- JSON Batch - would be JSON Format between current sections 19.3 and 19.4\n\n### Proposal\n\nAdd examples\n\nImported from [ODATA-1636](https://issues.oasis-open.org/browse/ODATA-1636)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Authorization: use consistent alias in vocabulary definition",
    "body": "The `Authorization` vocabulary uses the file-local alias `Auth`, whereas all the other vocabularies use a non-abbreviated alias.\n\nThis repeatedly leads to confusion around \"official\" vocabulary aliases, which can be avoided by being consistent with the other vocabularies.\n\nImported from [ODATA-1634](https://issues.oasis-open.org/browse/ODATA-1634)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Section 11.5.2 is about \"operations\", not only \"actions\"",
    "body": "Section [11.5.2 Applying an Action to Members of a Collection](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31359007) applies to both actions and functions and Example 87 shows a function.\n\n### Proposal\n\nReplace \"Action\" with \"Operation\"\n\nImported from [ODATA-1632](https://issues.oasis-open.org/browse/ODATA-1632)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Validation.Constraint may also be applied to a navigation property",
    "body": "See summary\n\n### Proposal\n\nSee PR\n\nImported from [ODATA-1631](https://issues.oasis-open.org/browse/ODATA-1631)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Avoid homonym \"target path\"",
    "body": "The CSDL specs use \"target path\" with two rather different meanings:\n1. In [navigation property binding target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_BindingTarget) and in [action import / function import entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ActionImport) it identifies the entity set of related or returned entities.\n1. In [annotation target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Target) it identifies the annotated model element.\n\nThe syntax of the first kind of target path is defined in section [15.4 Target Path.](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_TargetPath)\n\nThe syntax of the second kind of target path is defined in section [14.2.2 Target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Target), and this section is the only place where \"target path\" is used for the second meaning, and only once. \n\n### Proposal\n\nConsistently use\n1. \"target path\" for  [navigation property binding target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_BindingTarget) and[action import / function import entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ActionImport)\n1. \"target expression\" for annotations with external targeting\n\nImported from [ODATA-1629](https://issues.oasis-open.org/browse/ODATA-1629)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL: correct examples for odata.concat to use two parameters",
    "body": "The CSDL specification claims that\n\nbq. the odata.concat client-side function takes two or more expressions as arguments\n\n and all examples for applying function `odata.concat` show three or more arguments.\n\nThe corresponding URL function however is defined with exactly two arguments.\n\n### Proposal\n\nAdjust examples to use nested calls with exactly two arguments per call.\n\nImported from [ODATA-1628](https://issues.oasis-open.org/browse/ODATA-1628)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Avoid \"MAY ... only if\"",
    "body": "Combining the RFC2119 term \"MAY\" with a negation or restrictions runs counter to what MAY wants to express.\n> Clients MAY do A only if B\n> \n\nsounds as if\n- the client may choose not to do A if B (which is not always implied)\n- there is no rule for the client if not B.\n\nInstead, write\n> Clients MUST NOT do A if (not B)\n> \n\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-specs/pull/138\n\nImported from [ODATA-1622](https://issues.oasis-open.org/browse/ODATA-1622)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify context URL in JSON error response",
    "body": "[4.5.1 Control Information: context (odata.context)](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_ControlInformationcontextodatacontex) states that\n> The context control information is not returned if metadata=none is requested. Otherwise *it MUST be the first property of any JSON response*.\n> \n\n\nDoes this also include the [Error Response](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_ErrorResponse) which currently does not mention the `context` control information?\n\n### Proposal\n\nChange text to\n\n> The context control information is not returned if metadata=none is requested. Otherwise it MUST be the first property of any JSON response _that allows this control information_.\n> \n\n\nImported from [ODATA-1620](https://issues.oasis-open.org/browse/ODATA-1620)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consistently use \"parameter\" instead of \"argument\"",
    "body": "Section [5.1.1.5.7 `substring`](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_substring) talks about \"arguments\", all other sections on canonical functions talk about \"parameters\".\n\n### Proposal\n\nUse \"parameters\" also in the section on \"substring\".\n\nImported from [ODATA-1619](https://issues.oasis-open.org/browse/ODATA-1619)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify matchespattern and regular expression flags",
    "body": "Does the URL function `matchespattern` support [regular expression flags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions#advanced_searching_with_flags), and if yes, how?\n\nAdd statement and if yes add an example.\n\n### Proposal\n\nAdd overload with third parameter for providing regular expression flags.\n\nAdd example showing its use.\n\nImported from [ODATA-1618](https://issues.oasis-open.org/browse/ODATA-1618)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Is ODATA-1472 an erratum or a new feature?",
    "body": "[ODATA-1472](https://issues.oasis-open.org/browse/ODATA-1472) was closed as part of V4.01_ERRATA01. But isn't it really a new feature, which\n- belongs to V4.02\n- must be mentioned in \"Changes from Earlier Versions\"\n- should be annotated with a Capabilities annotation?\n\n### Proposal\n\n* mention in \"Changes from Earlier Versions\"\n- no capability needed\n\nImported from [ODATA-1617](https://issues.oasis-open.org/browse/ODATA-1617)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Data Modification Request succeeds, but response body cannot be created",
    "body": "Consider a data modification request that requires a response body (for example, creation with `Prefer: return=representation` or `$expand`). Imagine that the data change is committed to the database, but the subsequent database `SELECT` statement fails for some reason.\n\nHow shall the server respond to indicate that the data are changed on the database, yet there is no response body?\n\n- 204 No Content plus `Location` header after an entity creation\n- 204 No Content without `Preference-Applied: representation` header after an update with `Prefer: return=representation`\n\n### Proposal\n\nOData-Protocol, section 11.4.2:\n\nUpon successful creation of the entity, the service MUST respond with either `201 Created` and a representation of the created entity, or `204 No Content` if the request included a Prefer header with a value of `return=minimal` and did not include the system query options `$select` and `$expand,` _or if a representation of the created entity could not be constructed_. In either case, the response MUST contain a `Location` header that contains the edit URL or read URL of the created entity. \n\n \n\nOData-Protocol, section 11.4.3:\n\nUpon successful completion _of the update,_ the service responds with either 200 OK and a representation of the updated entity, or 204 No Content, _for example, if the request did not specify a Prefer Header with a value of return=representation and did not include the system query options $select and $expand, or if a representation of the updated entity could not be constructed_.\n\nImported from [ODATA-1609](https://issues.oasis-open.org/browse/ODATA-1609)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Latest updates for Aggregation vocabulary use wrong-typed DefaultValue for Core.OptionalParameter",
    "body": "See for example:\n\n```xml\n<Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\" Nullable=\"false\">\n  <Annotation Term=\"Core.OptionalParameter\">\n    <Record>\n      <PropertyValue Property=\"DefaultValue\" Int=\"32767\" />*\n    </Record>\n  </Annotation>\n  <Annotation Term=\"Validation.Minimum\" Int=\"1\" />\n</Parameter>\n```\n\nThe DefaultValue property in Core.OptionalParameterType is defined as a TypeDefinition with UnderlyingType Edm.String.  So using Int=\"...\" is not valid.\n\n### Proposal\n\nUse String=\"...\" in the offending PropertyValue elements.\n\nImported from [ODATA-1607](https://issues.oasis-open.org/browse/ODATA-1607)",
    "labels": [
      "Vocabularies",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ABNF for key values is overly generous",
    "body": "ABNF rule [`keyPropertyValue`](https://github.com/oasis-tcs/odata-abnf/blob/24234aab174f16b73ab963f5b440644faadf06b5/abnf/odata-abnf-construction-rules.txt#L127) is too generous and just references rule `primitiveValue`.\n\nIt should explicitly list primitive values of the types allowed for key properties in  [6.5 Key](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Key)\n\n### Proposal\n\n* Restrict key property values to literals of allowed types\n- Consistently name rules for these types\n  - URL literals with suffix `Literal`\n  - body values with suffix `Value`\n  - no suffix where both representations are identical\n- Split rules for these types where differences exist, especially for representations with PLUS or COLON characters (no percent-encoding in values, allowed percent-encoding in literals)\n- Add test cases for full coverage\n\nImported from [ODATA-1605](https://issues.oasis-open.org/browse/ODATA-1605)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify meaning of trailing spaces in $search query option",
    "body": "An implementation team asks how to treat trailing spaces in a `$search` query option, for example\n```\nGET /Products?$search=blue%20\n```\n\nShould the trailing space be treated as part of the search \"word\", or should it be ignored?\n\n### Proposal\n\nThe ABNF already allows whitespace between `$search=` and the search expression which is not considered part of the search expression.\n\nAlso allow trailing whitespace after the search expression, and mention both leading and trailing whitespace in section [5.1.8.1 Search Expressions](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_SearchExpressions).\n\nImported from [ODATA-1604](https://issues.oasis-open.org/browse/ODATA-1604)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL example 39 applies to Term",
    "body": "https://github.com/oasis-tcs/odata-specs/pull/186\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-specs/pull/186\n\nImported from [ODATA-1602](https://issues.oasis-open.org/browse/ODATA-1602)",
    "labels": [
      "CSDL JSON",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "concat: allow more than two arguments",
    "body": "The URL function [`concat`](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_concat) is currently defined with exactly two arguments.\n\nHowever all its example uses as a client-side function in annotations in the CSDL specs use three or more arguments, which is quite natural.\n\n### Proposal\n\nCorrect examples in CSDL specs via [ODATA-1628](https://issues.oasis-open.org/browse/ODATA-1628) and close this issue and its associated PRs\n- [https://github.com/oasis-tcs/odata-specs/pull/230]\n- [https://github.com/oasis-tcs/odata-abnf/pull/111] \n\nwithout action.\n\nImported from [ODATA-1601](https://issues.oasis-open.org/browse/ODATA-1601)",
    "labels": [
      "URL Conventions",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Functions and Actions as Interfaces",
    "body": "I would like to define an OData function or action outside of a service that serves as an interface. Such a function/action could then be invoked by a special client whenever a service implements it.\n\nThe functions `isancestor` and `isdescendant` defined in the Aggregation vocabulary would have been candidates for such treatment, if we had not assumed they are implemented by _every_ service that uses the `Aggregation.RecursiveHierarchy` annotation.\n\nIf the interface has a parameter or return type of an abstract type like `Edm.EntityType`, its implementations MAY (or MUST) replace this with a concrete entity type.\n\n### Proposal\n\n[https://github.com/oasis-tcs/odata-vocabularies/pull/228]\n\nThe proposed annotation\n```json\n\"ActionA\": [{\n  \"$Kind\": \"Action\",\n  \"@Core.ImplementsSignature\": \"ActionB\"\n}]\n```\nis not superior to currently used annotations like\n```json\n\"EntityType\": {\n  \"$Kind\": \"EntityType\",\n  \"@SAP.ActionB\": \"ActionA\"\n}\n```\nTherefore close this issue without further action.\n\nImported from [ODATA-1600](https://issues.oasis-open.org/browse/ODATA-1600)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Example number 21 is used 3 times in the JSON format document",
    "body": "The label \"21\" is used 3 times in the JSON format document:\n\n[https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_BindOperation]\n\n[https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_CollectionETag]\n\n[https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_StreamProperty]\n\nAlthough not a large issue, it sometimes makes it difficult to refer people to the correct example.\n\nImported from [ODATA-1598](https://issues.oasis-open.org/browse/ODATA-1598)",
    "labels": [
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow Scale=\"floating\" also in 4.0 responses",
    "body": "Section [7.2.4 Scale](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Scale) restricts use of `Scale=\"floating\"` to responses with `OData-Version: 4.01`.\n\nThis seems too hard given that the XML documents use the same XML namespace http://docs.oasis-open.org/odata/ns/edm, which references the combined 4.0 plus 4.01 XML schema.\n\n\n### Proposal\n\nRelax to\n> OData 4.0 responses SHOULD NOT specify the value `floating`.\n> \n\n\nImported from [ODATA-1596](https://issues.oasis-open.org/browse/ODATA-1596)",
    "labels": [
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Replace references to RFC7230, RFC7231, and RFC7232 with RFC9110",
    "body": "[RFC9110](https://datatracker.ietf.org/doc/html/rfc9110) obsoletes [RFC 7230](https://datatracker.ietf.org/doc/html/rfc7230), [RFC 7231](https://datatracker.ietf.org/doc/html/rfc7231), [RFC 7232](https://datatracker.ietf.org/doc/html/rfc7232) (and others we don't reference)\n\n### Proposal\n\nSee description\n\nImported from [ODATA-1595](https://issues.oasis-open.org/browse/ODATA-1595)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "11.4.12 Update a Collection of Entities: add examples",
    "body": "\n\n### Proposal\n\nh2. JSON Format\n\nAdd JSON request and response examples using `Core.ContentID` and `Core.DataModificationException`, also in combination for a failed create.\n\nShow the different error handling for `continue-on-error=true/false`.\n\nShow that `Core.DataModificationException` records can be annotated by adding [`Common.additionalTargets`](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Common.md#additionalTargets) to a `MessageType` record.\nh2. Protocol\n\nMake first occurrence of `continue-on-error` a section link,\n\nImported from [ODATA-1593](https://issues.oasis-open.org/browse/ODATA-1593)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "correct vocabulary URIs in CSDL XML examples",
    "body": "the section 4.2 Include Schema shows examples (example 4) how to include Vocabulary schemas but used non existing URIs like [http://vocabs.odata.org/capabilities/v1]\n\nproposal is to replace them with current URLs like \n[https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml]\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-specs/pull/94\n\nImported from [ODATA-1592](https://issues.oasis-open.org/browse/ODATA-1592)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "OData-Protocol example 64 is syntactically wrong",
    "body": "[OData-Protocol, example 64](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358958) reads:\n```\nGET http://host/service/Suppliers(MainSupplier)/Addresses/0\n```\nBut the `MainSupplier` in parentheses is invalid syntax, and the ABNF does not accept this example:\n```\nOData-Protocol, example 64 fails at 55: http://host/service/Suppliers(MainSupplier)/Addresses/0\nodataUri: http://host/service/Suppliers(MainSupplier)/Addresses/\n.serviceRoot: http://host/service/Suppliers(MainSupplier)/Addresses/\n..host: host\n...reg-name: host\n..segment-nz: service\n..segment-nz: Suppliers(MainSupplier)\n..segment-nz: Addresses\n..segment-nz: 0\n```\n\n### Proposal\n\n```java\nGET http://host/service/MainSupplier/Addresses/0\n```\nhttps://github.com/oasis-tcs/odata-specs/pull/172\n\nImported from [ODATA-1591](https://issues.oasis-open.org/browse/ODATA-1591)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow creating and linking along a nullable single-valued navigation",
    "body": "[ODATA-1141](https://issues.oasis-open.org/browse/ODATA-1141) explicitly forbids creating a to-one related entity for non-containment navigation properties:\n> For a non-containment relationship, PUT or PATCH to a null single-valued navigation property returns an error.\n> \n\nThe only way currently to do this is multi-step:\n1. Create new entity in target set\n1. Bind to newly created entity\n\n### Proposal\n\nRemove restriction on \"containment\" and allow PUT/PATCH if\n- a NavigationPropertyBinding exists for the target navigation property, or\n- the payload includes a context specifying where the new entity is to be created\n\nThis affects the second paragraph of section [11.4.4 Upsert an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpsertanEntity).\n\nCurrent text:\n> Upserts are not supported against media entities, single-valued non-containment navigation properties, or entities whose keys values are generated by the service. Services MUST fail an update request to a URL that would identify such an entity and the entity does not yet exist.\n> \n\nNew text:\n> Upserts to single-valued navigation properties are possible for\n> - containment navigation properties,\n> - non-containment navigation properties with a navigation property binding, or\n> - payloads including a context URL specifying the entity set or contained collection of entities in which the new entity is to be created.\n> \n> Upserts are not supported against media entities or entities whose keys values are generated by the service. Services MUST fail an update request to a URL that would identify such an entity and the entity does not yet exist.\n> \n\n\nImported from [ODATA-1588](https://issues.oasis-open.org/browse/ODATA-1588)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove reference to obsolete GeoJSON document",
    "body": "Section [7.1 Primitive Value](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_PrimitiveValue) references an obsolete version of GeoJSON at [https://geojson.org/geojson-spec.html] that already looks a little \"frayed\".\n\n### Proposal\n\nRemove this informative reference.\n\nShorten the paragraph using this reference to\n> Geography and geometry values are represented as geometry types as defined in [RFC7946]+.+-, with the following modifications:-\n> - <del>Keys SHOULD be ordered with type first, then coordinates, then any other keys</del> - -If the optional CRS object is present, it MUST be of type name, where the value of the name member of the contained properties object is an EPSG SRID legacy identifier, see [GeoJSON-2008].-\n\nNote: [RFC7946](https://datatracker.ietf.org/doc/html/rfc7946#section-4) uses the World Geodetic System 1984 (WGS 84), which is a superset of the EPSG SRID 4326 that the CSDL specs define as the default SRID for `Edm.Geography` types.\n\nImported from [ODATA-1587](https://issues.oasis-open.org/browse/ODATA-1587)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Inconsistency regarding $select=@Namespace.Term",
    "body": "[https://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#_Toc31358942] does not mention the possibility to `$select` an annotation.\n\n[https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#_Toc31361040] allows that:\n\nbq. A path can end with the name of a property or non-entity-valued instance annotation of the identified structured instance,\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-specs/pull/177\n\nImported from [ODATA-1584](https://issues.oasis-open.org/browse/ODATA-1584)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Mention use of ETag with bound function: only process if binding entity matches ETag",
    "body": "Section [11.5.5.1 Invoking an Action](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_InvokinganAction) explicitly mentions how `If-Match` can be used with bound action calls:\n\n> To request processing of the action only if the binding parameter value, an entity or collection of entities, is unmodified, the client includes the If-Match header with the latest known ETag value for the entity or collection of entities. The ETag value for a collection as a whole is transported in the ETag header of a collection response.\n\n\nThe same use case applies to bound functions.\n\n### Proposal\n\nEither also mention this in the corresponding section 11.5.4.1 on bound functions, or pull up the statement to section 11.5.1 Binding an Operation to a Resource.\n\nImported from [ODATA-1582](https://issues.oasis-open.org/browse/ODATA-1582)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify duplicate properties in JSON Batch payload",
    "body": "How should duplicate properties (i.e., id, method, url, headers, dependsOn, atomicityGroup, body, if) in a JSON Batch payload be handled?\n\nMost of these (id, method, url, atomicityGroup, body) should pretty clearly be errors as they are single-valued.  However, [RFC2616 ](https://www.rfc-editor.org/rfc/rfc2616#section-4.2)allows the same header to appear multiple times in a request only if the header value is a coma-separated list of values, and states that the multiple headers is equivalent to a single header with the values appended, in order, separated by comas. So, a service *could* allow the \"header\" property to appear multiple times and append the values. We could do the same thing with dependsOn, and even if.\n\nOr, we could keep it simple and say that a client must not specify any of these properties more than once.\n\n### Proposal\n\nClarify that clients MUST NOT specify any of these properties more than once; services SHOULD reject such a request as a bad request.\n\nSimilarly, clients MUST NOT specify multiple headers with the same (case-insensitive) key; services SHOULD reject such a request as a bad request.\n\nImported from [ODATA-1581](https://issues.oasis-open.org/browse/ODATA-1581)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consistently use \"annotated with the term\" instead of \"annotated with term\"",
    "body": "\n\nImported from [ODATA-1578](https://issues.oasis-open.org/browse/ODATA-1578)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consistently use \"entity-id\" instead of \"entity id\"",
    "body": "\n\n### Proposal\n\nUse dash as this is \"one word\".\n\nCan be changed in Data Aggregation as a non-material change without additional public review\n\nImported from [ODATA-1577](https://issues.oasis-open.org/browse/ODATA-1577)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Data Aggregation",
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consistently use \"instances of structured types\" instead of \"structured instances\"",
    "body": "\n\nImported from [ODATA-1576](https://issues.oasis-open.org/browse/ODATA-1576)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "2023 Virtual Face-to-Face Agenda",
    "body": "Walldorf rooms and times\n|| ||Tue, May 2||Wed, May 3||Thu, May 4||Fri, May 5||\n|*morning*|WDF53 B1.01|WDF53 B1.01| |WDF53 B1.02|\n| |Work time| |Hiking event| |\n|*room switch*|1pm|2pm|3:30pm| |\n|*afternoon*|WDF53 B1.02|WDF53 B1.02|WDF53 B1.02|WDF53 B1.02|\n| |Work time| | | |\n|*4-6pm*|4-4:30 Refine Agenda\n 4-6: Aggregation (Heiko/Gerald)|4-5: 4.01 Triage (Ralf)\n 5-6: Aggregation (Heiko/Gerald)|RSDL Open Items (Mike/Christof)\n RSDL Wrap-up (Mike/Christof)|4-5: RAPID inventory/next steps (Mike)\n 5-6: Aggregation (Heiko/Gerald)|\n|*6-6:15pm*|Break|Break|Break|Break|\n|*6:15-7pm*|RSDL Capabilities (Mike/Christof)|Aggregation (Heiko/Gerald)|RSDL Wrap-up (Mike/Christof)|Aggregation (Heiko/Gerald)|\n|*7-8pm*|4.01 Triage (Ralf)|Aggregation (Heiko/Gerald)|Aggregation (Heiko/Gerald)|Revisit Timeline, Wrap-up|\n\n \n\nImported from [ODATA-1572](https://issues.oasis-open.org/browse/ODATA-1572)",
    "labels": [],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow empty entity containers",
    "body": "CSDL currently requires that\n> \n> h1. 13    [Entity Container](https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html#sec_EntityContainer)\n> \n> Each metadata document used to describe an OData service MUST define exactly one entity container.\n> \n\nand then for CSDL XML only\n> *Element* edm:EntityContainer\n> \n> The edm:EntityContainer MUST contain one or more [edm:EntitySet](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet), [edm:Singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton), [edm:ActionImport](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ActionImport), or [edm:FunctionImport](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_FunctionImport) elements.\n> \n\nThis disallows \"empty\" services without any resources except the service document and the metadata document, or requires such services to not support metadata in CSDL XML\n\nWhile this restriction may make \"business sense\", from a technical and tools perspective it is an unnecessary hurdle, requiring special handling in tools.\n\n### Proposal\n\nRemove restriction from CSDL XML, allow services that only serve a service document (with an empty list of root resources) and a metadata document in XML or JSON.\nAdjust XSD to allow zero elements.\n\nImported from [ODATA-1571](https://issues.oasis-open.org/browse/ODATA-1571)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL XML is defined with reference to XML 1.1 but none of the examples use XML version 1.1 documents",
    "body": "(Refer to https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-prolog-dtd)\n\nCSDL XML Section numbers below are from 4.01 but the issue is present in CSDL 4.0 spec as well.\n\nNow see CSDL XML spec Section 2     XML Representation\n\n> OData CSDL XML is a full representation of the OData Common Schema Definition Language in the Extensible Markup Language (XML) 1.1 (Second Edition) [XML‑1.1]  ...\"\n\nNone of the examples show an XML version 1.1 document (The XML 1.1 spec indicates that without an XML version in the XML declaration, the XML version is 1.0).\n\nExample 2 shows a CSDL example without an XML declaration (so it is XML 1.0, per the XML 1.1 spec).\n\nExample 3 shows a CSDL example with an XML declaration that specifies version=1.0.\n\nNow per section 1.3, all examples in the CSDL XML document are non-normative and informative only.\n\nHowever, none of them show a valid XML 1.1 document.\n\nAccepting that some of the examples could be considered as partial documents (for brevity), it could be accepted that they can omit the XML declaration. But example 2 is the first example and the section title indicates it is the \"CSDL XML Document\", so it should not omit the XML declaration.\n\n### Proposal\n\nConsistently use XML 1.0, change normative reference and check prose texts and examples to not use 1.1 anywhere.\n\nImported from [ODATA-1570](https://issues.oasis-open.org/browse/ODATA-1570)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow CSDL JSON also for OData versions 2.0 and 3.0",
    "body": "As a first step relax the JSON Schema to also allow these two values for the `$Version` field in CSDL JSON files.\n\n### Proposal\n\nClose without further action.\n1. CSDL XML also doesn't cover v1, v2, or v3\n1. CSDL JSON can't represent constructs from earlier versions that were not taken over into v4\n\nImported from [ODATA-1569](https://issues.oasis-open.org/browse/ODATA-1569)",
    "labels": [
      "CSDL JSON",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow handling of in-stream errors on protocol level",
    "body": "[OData-Protocol, section 9.5](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_InStreamErrors) says\n> In the case that the service encounters an error after sending a success status to the client, the service MUST leave the response malformed according to its content-type. Clients MUST treat the entire response as being in error.\n> \n\nBut certain content types, for example `text/plain` in a response of type `Edm.Stream`, cannot be malformed. Suggest to allow abortion of the response on HTTP protocol level.\n\n### Proposal\n\nthe service MUST leave the response malformed according to its content-type _or abort the response by causing an error on transport protocol level_.\n\nImported from [ODATA-1568](https://issues.oasis-open.org/browse/ODATA-1568)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify: Is Open on a derived type required or implied",
    "body": "I have always assumed that any type derived from an open type was, by definition, open.\n\nHowever, I recently read the rule for this in [CSDL-XML 6.3, Open Entity Type](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_OpenEntityType) which states:\n \"An entity type derived from an open entity type MUST indicate that it is also open.\"\n\nWhich *could* be read as requiring that the XML explicitly specifies OpenType=\"true\" in any type derived from an open type.\n\nThe same wording exists in Section 6.9, Open Complex Type, as well as the corresponding sections of the JSON CSDL specification.\n\nWhile it should always be valid to specify OpenType=\"true\", I would think it would be implied, and not required to be explicitly stated, since the base type is open.\n\nIt should be invalid to specify OpenType=\"false\" if the base type is open.\n\n### Proposal\n\nClose with no action.\n\nImported from [ODATA-1566](https://issues.oasis-open.org/browse/ODATA-1566)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Document that Measures terms can also apply to parameters",
    "body": "Currently AppliesTo only lists Property, makes sense to also document Parameter.\n\nImported from [ODATA-1565](https://issues.oasis-open.org/browse/ODATA-1565)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Protocol 11.7.7.1 misleading text on request formats",
    "body": "Section [11.7.7.1 Multipart Batch Request Body](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_MultipartBatchRequestBody) gives three examples for request URL formats that implementations must support:\n> The request URL of individual requests within a batch request or change set can use one of the following three formats:\n> \n\nUnfortunately all three examples use the `GET` method, which can mislead readers to assume that `GET` requests are allowed within a change set, which is not the case according to the preceding section [11.7.2 Request Dependencies](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestDependencies).\n\n### Proposal\n\nUse `POST` or `PATCH` or `DELETE` method in the examples because these can be both within and outside of change sets.\n\nImported from [ODATA-1564](https://issues.oasis-open.org/browse/ODATA-1564)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "URL 4.11, paragraph 2: clarify restriction \"that is part of a Boolean expression\"",
    "body": "Section [4.11 Addressing Derived Types](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AddressingDerivedTypes) states in the second paragraph \n\n> \n> If used in a path expression *that is part of a Boolean expression*, the type cast will evaluate to null. \n> \n\n\nWhy the restriction \"that is part of a Boolean expression\"?\n\n### Proposal\n\nRemove restriction, shorten sentence to\n\n> \n> If used in a path expression, the type cast will evaluate to null. \n> \n\n\nImported from [ODATA-1563](https://issues.oasis-open.org/browse/ODATA-1563)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify uniqueness of bound action and function names",
    "body": "Can an action bound to entity type `A` have the same name as a function bound to entity type `B`?\n\nOr more general: can an action (import) have the same name as a function (import)?\n\nTaking the request method and URL into account, it can be unambiguously decided whether the action or function is called.\n\n### Proposal\n\nAllow this and add to chapter 5 the following rule right after the sentence on non-colliding type names:\n\n\"Services SHOULD NOT have actions and functions with the same name, and MUST NOT have actions and functions with the same name bound to the same type.\"\n\nImported from [ODATA-1562](https://issues.oasis-open.org/browse/ODATA-1562)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify format of AsyncResult response header value",
    "body": "Clarify that the AsyncResult response header contains the three-digit HTTP response code of the asynchronously processed request, for example\n- `AsyncResult:200` for a successfully processed request\n- `AsyncResult:500` for a failed asynchronous request\n\n \n\n### Proposal\n\nAdd text (and example?) to Protocol\n\nAdd rule to ABNF\n\nImported from [ODATA-1561](https://issues.oasis-open.org/browse/ODATA-1561)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify definition of transient",
    "body": "We define transient entities as instances of an entity type that exist within a payload.  However, after query transformations, the resulting payload is not constrained to conform to the entity type definition.  Also, it may be possible to re-derive the transient entity, so the read URL may be appropriate for that purpose.\n\n \n\n### Proposal\n\nh2. 4.3 [Transient Entities](#sec_TransientEntities)\n\nTransient entities are {color:#4c9aff}*derived* *from* {color}instances of an entity type that are “calculated on the fly” and only exist within a single payload. They cannot be -*reread or*- updated and consequently possess neither a stable entity-id nor -*{color:#FF0000}a read UR{color:#de350b}L{color}{color}{color:#de350b} or{color}*- an update URL.  {color:#4c9aff}*A transient entity may have a read URL, which may be used to re-derive the transient entity from the current state of the underlying entity.*{color}\n\nImported from [ODATA-1559](https://issues.oasis-open.org/browse/ODATA-1559)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Collection-valued Aggregation.RecursiveHierarchy/ParentNavigationProperty",
    "body": "The Aggregation vocabulary currently specifies that `RecursiveHierarchy/ParentNavigationProperty` is single-valued, but hierarchies can also be defined with multiple parents of a node.\n\n### Proposal\n\nAllow a collection-valued `RecursiveHierarchy/ParentNavigationProperty` in the [Aggregation vocabulary](https://github.com/oasis-tcs/odata-vocabularies/blob/13de8f242e505761940cff7e2f5c22eb614b7ae5/vocabularies/Org.OData.Aggregation.V1.xml#L208). Nodes can then have null and non-null parents simultaneously, meaning that they occur as a root and as a child.\n\nSee material appended to sections 6.2.2 and 6.3 in [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/70988/odata-data-aggregation-ext-v4.0-csd04.docx].\n\nImported from [ODATA-1557](https://issues.oasis-open.org/browse/ODATA-1557)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Entities with ambiguous property values",
    "body": "The output set of a transformation has a context URL of the form [Collection of Entities](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CollectionofEntities), but it can contain the same entity multiple times, even with conflicting properties:\n```java\nGET /service/Products?$apply=\n  concat(compute(0.1 as Discount),\n         compute(0.2 as Discount))\n```\nThe OData-Aggr specification is not always prepared for such situations.\nh2. groupby\n\nWhat does grouping by such an ambiguous entity mean? How many items does the response to the following request contain?\n```java\nGET /service/Sales?$apply=\n  concat(transformnested(Product,compute(0.1 as Discount)),\n         transformnested(Product,compute(0.2 as Discount)))\n  /groupby((Product/Discount))\n```\nWhat is the `Discount` in the response to the following request?\n```java\nGET /service/Sales?$apply=\n  concat(transformnested(Product,compute(0.1 as Discount)),\n         transformnested(Product,compute(0.2 as Discount)))\n  /groupby((Product))\n  &$expand=Product($select=Discount)\n```\nh2. aggregate\n\nAggregation considers only distinct entities, but which `Discount` is used in the following request?\n```java\nGET /service/Sales?$apply=\n  concat(transformnested(Product,compute(0.1 as Discount)),\n         transformnested(Product,compute(0.2 as Discount)))\n  /aggregate(Product/Discount with max as MaxDiscount)\n```\n\n### Proposal\n\nSee [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/70631/odata-data-aggregation-ext-v4.0-csd04.docx]\n- section 3.1.2\n- section 3.2.1.1, first bullet point in \"Determination of U\"\n- section 3.2.3.1, step 2.\n\n \n\nImported from [ODATA-1556](https://issues.oasis-open.org/browse/ODATA-1556)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Strengthen definitions for $orderby, $top and $skip",
    "body": "h2. Total or partial order?\n\n[OData-Protocol, section 11.2.6.2](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_SystemQueryOptionorderby) speaks of \"the order\" in which items are returned. Must this be a total order, or only a partial order? A partial order would not allow paging with `$top` and `$skip`. But not all services may be able to produce a total order.\n\nThis should be clarified.\n\nh2. Further implications of partial ordering\n\n[OData-Protocol, section 11.2.6.3](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_SystemQueryOptiontop) seems to allow n _arbitrary_ items to be returned:\n> a non-negative integer n that limits the number of items returned from a collection.\n> \n\nThe next sentence sounds as if a number was returned:\n> The service returns the number of available items up to but not greater than the specified value n.\n> \n\n[OData-Protocol, section 11.2.6.4](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_SystemQueryOptionskip) is clearer:\n> excludes the first n items of the queried collection from the result. The service returns items starting at position n+1.\n> \n\nBoth definitions assume that \"the first n items\" always exist. But in general the result set is neither totally ordered (in which case \"the first n\" would be well-defined) nor totally unordered (in which case n arbitrary items could be returned or skipped). After an `$orderby`, the result set may be only partially ordered.\n\nThe definitions of `$top` and `$skip` should make clearer what freedom to choose n items the server has.\n\n### Proposal\n\nAligned with the wording in [OData-Data-Aggregation-Ext-4.0](https://oasis-tcs.github.io/odata-specs/odata-data-aggregation-ext/odata-data-aggregation-ext.html#Transformationtop):\n\n11.2.6.3. Let A be a copy of the result set with a total order that extends any existing order of the result set but is otherwise chosen by the service. The total order MUST be stable across requests.\n\nIf A contains more than n instances, the result of `$top=n` consists of the first n occurrences in A. Otherwise, the output set equals A. The instances in the result are in the same order as they occur in A.\n\n11.2.6.4. Let A be a copy of the result set with a total order that extends any existing order of the result set but is otherwise chosen by the service. The total order MUST be stable across requests.\n\n`$skip=n` excludes from the result set the first n occurrences in A. It keeps all remaining instances in the same order as they occur in A.\n\nSomewhere in 11.2.6. The order of the result MUST be respected during serialization to the response payload.\n\nImported from [ODATA-1555](https://issues.oasis-open.org/browse/ODATA-1555)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify the algorithm for evaluating the compute transformation",
    "body": "It seems warranted that compute expressions can use dynamic properties that were computed by previous compute expressions, as in `compute(A add B as C, C mul 2 as D)`.\n\nAnd the sequence of the compute expressions should not matter, therefore `compute(C mul 2 as D, A add B as C)` should produce the same result. The server must determine an appropriate sequence in which to evaluate the compute expressions, or fail if a cycle is detected.\n\n### Proposal\n\nThe output set is constructed by copying the instances of the input set and adding one dynamic property per compute expression to each instance of the <del>input</del> _output_ set. The name of the added property is the alias following the as keyword. The value of the property is the value of the <del>compute</del> expression evaluated relative to that instance. _Services MAY support expressions that address dynamic properties added by other expressions within the same compute transformation, provided that the service can determine an evaluation sequence._\n\nImported from [ODATA-1554](https://issues.oasis-open.org/browse/ODATA-1554)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify the algorithm for evaluating $compute",
    "body": "It seems warranted that compute expressions can use dynamic properties that were computed by previous compute expressions, as in `$compute=A add B as C, C mul 2 as D`.\n\nAnd the sequence of the compute expressions should not matter, therefore `$compute=C mul 2 as D, A add B as C` should produce the same result. The server must determine an appropriate sequence in which to evaluate the compute expressions, or fail if a cycle is detected.\n\n### Proposal\n\nThe value of $compute is a comma-separated list of compute instructions, each consisting of a common expression followed by the keyword as, followed by the name for the computed dynamic property. This name MUST differ from the names of declared or dynamic properties of the identified resources. _Services MAY support compute instructions that address dynamic properties added by other compute instructions within the same `$compute` system query option, provided that the service can determine an evaluation sequence._\n\nImported from [ODATA-1553](https://issues.oasis-open.org/browse/ODATA-1553)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "edm.xsd permits primitive Type for NavigationProperty",
    "body": "https://github.com/oasis-tcs/odata-csdl-schemas/blob/main/schemas/edm.xsd#L147\n\n <xs:attribute name=\"Type\" type=\"edm:TTypeName\" use=\"required\" />\n\nand then:\n\n<xs:simpleType name=\"TTypeName\">\n    <xs:union memberTypes=\"edm:TPrimitiveType edm:TAbstractType edm:TQualifiedName\">\n\nSchema-assisted editing (e.g. VS Code with \"XML Language Support by Red Hat\") will consider a primitive Type to be valid for a NavigationProperty.\n\n\n### Proposal\n\nRefine the edm.xsd to disallow obvious inappropriate types for NavigationProperty elements, perhaps by the introduction of a \"TNavigationTypeName\".\n\nhttps://github.com/oasis-tcs/odata-csdl-schemas/pull/71\n\nImported from [ODATA-1552](https://issues.oasis-open.org/browse/ODATA-1552)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Recursive complex types must be nullable",
    "body": "We have rules around a partner navigation property in a recursive containment relationship (it must be single valued and nullable) but we don't call out the fact that the child of a single-valued recursive containment must also be nullable (or the recursion would never end). \n\nSimilarly, we say nothing about the child of a recursive complex-typed property. For example, we don't have a rule against the following definition, although the model it describes results in an endless recursion:\n\n \n```java\n<ComplexType Name=\"myType\">\n    <Property Name=\"nested\" Type=\"myType\" Nullable=\"false\">\n</ComplexType> ```\n \n\n### Proposal\n\nClarify that a recursive single-valued navigation and complex typed property must be nullable.  This rule is implied today, so calling it out to make it more apparent should not be a breaking change.\n\nImported from [ODATA-1547](https://issues.oasis-open.org/browse/ODATA-1547)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify /$value segment appended to function returning a primitive value",
    "body": "Protocol and URL Conventions only mention appending the `/$value` segment to primitive properties.\n\nABNF however also allows this segment appended to functions returning a primitive value: https://github.com/oasis-tcs/odata-abnf/blob/27ae38545f44cd0f5373abb7262c6176d4eec144/abnf/odata-abnf-testcases.yaml#L1178-L1180\n\n### Proposal\n\nExplicitly mention this in\n- Protocol section [11.2.4.1 Requesting a Property's Raw Value using $value](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestingaPropertysRawValueusingval) and/or\n- URL Conventions section [4.7 Addressing a Property Value](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AddressingaPropertyValue).\n\nMaybe change text and headlines to \"address a raw primitive value\".\n\nImported from [ODATA-1546](https://issues.oasis-open.org/browse/ODATA-1546)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Conflicting information about presence of read-only properties on update",
    "body": "[OData Version 4.01. Part 1: Protocol/Section 14.3.1/7th Paragraph](https://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_UpdateanEntity) states\n \n_Key and other properties marked as read-only in metadata (including computed properties), […] , can be omitted from the request. If the request contains a value for one of these properties, the service MUST ignore that value when applying the update._ \n\n [OData core vocabulary / UpdateRestrictionsType/ NonUpdatableProperties](https://github.com/oasis-tcs/odata-vocabularies/blob/f6818f02e7cb4eb5a63e96e75ea986104fa4a42d/vocabularies/Org.OData.Core.V1.xml#L384) states\n \n _These structural properties cannot be specified on update_\nThese two statements contradict each other. The vocabulary term description should reflect that what section 14.3.1 describes.\n\n### Proposal\n\nSee https://github.com/oasis-tcs/odata-vocabularies/pull/200\n\nImported from [ODATA-1543](https://issues.oasis-open.org/browse/ODATA-1543)",
    "labels": [
      "Vocabularies",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Forward slashes in /$filter segments",
    "body": "[OData-URL, section 4.12](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AddressingaSubsetofaCollection) says:\nbq. If the filter path segment appears in the resource path and the parentheses contain a filter expression, that expression MUST NOT use forward slashes.\n\nCan an offending forward slash be replaced by `%2f` (the ABNF does not accept this at the moment)? Or must an alias be used to avoid forward slashes in paths? Clarify if necessary.\n\nOn the other hand, the rule is too strict, because forward slashes are not a problem if the `/$filter` segment occurs in a URL query option, as in [this test case](https://github.com/oasis-tcs/odata-abnf/blob/ad7fc9b1f391b84bcccb5fd7080b863c77d516c6/abnf/odata-aggregation-testcases.yaml#L560-L572).\n\n### Proposal\n\nRephrase:\n> If the filter path segment appears in the resource path, the filter expression in parentheses MUST NOT use forward slashes, it must be specified with a parameter alias [link to 5.3] instead.\n> \n\n\n\nImported from [ODATA-1541](https://issues.oasis-open.org/browse/ODATA-1541)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Require decoding of plus as space in query part of URL",
    "body": "The [WhatWG URL](https://url.spec.whatwg.org/) specification defines an API for manipulating URLs that uses `application/x-www-form-urlencoded` for parsing and serializing query options.\n\nThis API encodes space (octet 0x20) as \"\\+\" (octet 0x2B), and consequently decodes \"\\+\" (octet 0x2B) as space (octet 0x20).\n\n This is a follow-up to [ODATA-1539](https://issues.oasis-open.org/browse/ODATA-1539).\n\n### Proposal\n\nLeave it as an option for servers to make moving to V4.02 as easy as possible.\n\nMake it a requirement for conforming clients, and add to section [13.3 Interoperable OData Clients](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_InteroperableODataClients) between current rules 9 and 10:\n\n> \n> 10. MUST encode the plus character (octet 0x2B) as %2B in URLs to avoid servers mis-interpreting the plus character as an encoded space\n> \n\n\nImported from [ODATA-1540](https://issues.oasis-open.org/browse/ODATA-1540)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify decoding of plus character in URLs",
    "body": "OData URL is based on [RFC3986](https://www.rfc-editor.org/rfc/rfc3986.html), which in [Section 2.1 Percent-Encoding](https://www.rfc-editor.org/rfc/rfc3986.html#section-2.1) explicitly defines `%20` as the encoding for space.\n\nUnfortunately RFC3986 is less clear on the encoding of the plus (`+`) character: [Section 2.2 Reserved Characters](https://www.rfc-editor.org/rfc/rfc3986.html#section-2.2) recommends `%2B` as the encoding for plus “unless […] specifically allowed by the URI scheme to represent data in that component”.\n\nAs a consequence, many URL-encoding tools, and the most commonly used browsers (Chrome, Edge, Firefox) do not percent-encode the plus character and retain it as a plus character.\n\nTo make matters really confusing the [WhatWG URL](https://url.spec.whatwg.org/) specification defines an API for manipulating URLs that - depending on how it is used - will encode space as the the plus (`+`) character:\n```js\nvar x = new URL(\"http://foo?bar=a+b c\")\nx.href // --> http://foo/?bar=a+b%20c\n\nvar y = new URL(\"http://foo\")\ny.searchParams.append(\"bar\",\"a+b c\")\ny.href // --> http://foo/?bar=a%2Bb+c\n```\n \nThis raises the question on how an OData service SHOULD / MUST interpret the plus (`+`) character in a URL:\n- does it mean plus,\n- or does it mean space?\n\nNote: the percent-encoded variants are unambiguous:\n- `%20` means space\n- `%2B` means plus\n \n\n \n\n \n\n### Proposal\n\nRephrase second part of [2.1 URL Parsing](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_URLParsing):\n> After applying these steps defined by {color:#00875a}[{color}RFC3986{color:#00875a}]{color} the following steps MUST be performed:\n> - Split undecoded query at \"&\" {color:#00875a}(octet 0x26){color} into query options, and each query option at the first \"=\" {color:#00875a}(octet 0x3D){color} into query option name and query option value\n> - Percent-decode path segments, query option names, and query option values exactly once\n> - Interpret path segments, query option names, and query option values according to OData rules\n> \n> {color:#00875a}Note: neither [RFC3986] nor this specification assign special meaning to \"\\+\" (octet 0x2B). Some implementations decode \"\\+\" (octet 0x2B) as space (octet 0x20), others take it literally. Clients are advised to percent-encode space (octet 0x20) as %20 and \"\\+\" (octet 0x2B) as %2B and avoid the ambiguous \"\\+\" (octet 0x2B) in URLs.{color}\n> \n\n \n\nThis is all we can do in Errata, follow-up action is [ODATA-1540](https://issues.oasis-open.org/browse/ODATA-1540).\n\nImported from [ODATA-1539](https://issues.oasis-open.org/browse/ODATA-1539)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "edm.xml: types TSimpleIdentifier, TNamespaceName, and TQualifiedName too restrictive",
    "body": "The simple types TSimpleIdentifier, TNamespaceName, and TQualifiedName are currently based on `xs:NCName` which adds restricitions beyond what CSDL defines.\n\nBase these simple types on `xs:string` instead, with `minLength=\"1\"`.\n\nAlso check other simple types that are currently based on `xs:token` whether they should better also be based on `xs:string`, and maybe just to be consistent.\n\nImported from [ODATA-1537](https://issues.oasis-open.org/browse/ODATA-1537)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ODATA 4.01. 16.1 Example CSDL has missing alias",
    "body": "Example 89 under  [16.1 Products and Categories Example](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ProductsandCategoriesExample) uses the schema alias \"self\" when referring to \"Supplier\" in the \"MainSupplier\" singleton but the alias is not defined.\n\nImported from [ODATA-1536](https://issues.oasis-open.org/browse/ODATA-1536)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow more methods to qualify start nodes of transformation ancestors and descendants",
    "body": "At present, ancestors and descendants accept a filter expression as parameter to qualify instances of the input set as start nodes for the transformation.\n\nWe found that there are interesting use cases with further methods to identify such start nodes, including a free-text search. Supporting only filter expressions seems too limited and should be generalized.\n\n### Proposal\n\nProposal is to replace the filter expression parameter by a parameter accepting a transformation sequence returning a result that preserves the structure of the input set. This approach covers filter expressions and search via the filter and search transformations and leaves room for further applications.\n\n(detailed text proposal to follow)\n\nImported from [ODATA-1533](https://issues.oasis-open.org/browse/ODATA-1533)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Align usages of recursive hierarchies",
    "body": "The signature and behavior of hierarchy-related transformations descendants and ancestors was changed in [ODATA-1384](https://issues.oasis-open.org/browse/ODATA-1384).\n\nGrouping with rollup of recursive hierarchies makes use of these transformations and hasn't been adapted to these changes yet. Also transformation traverse needs to be updated to consider a separate hierarchy collection specified as parameter. This mainly relates to sections 3.1.3.2.2 and 3.4.3 of the document.\n\n### Proposal\n\nDecisions:\n - Align references to recursive hierarchies in the definition of `traverse` and `groupby` with `rollup`\n - Introduce operator `rolluprecursive` to distinguish it from `rollup` of leveled hierarchies.\n - Remove operator `rollupall`, because not needed; it can be represented as a combination of `concat` with `groupby`/`rollup`\n\nSee links under resolution for details.\n\nImported from [ODATA-1532](https://issues.oasis-open.org/browse/ODATA-1532)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "14.1.2 Applicability: clarify that \"Property\" means \"structural property\" and excludes navigation properties",
    "body": "Section [14.1.2 Applicability](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Applicability) says\n||Symbolic Value||Model Element||\n|Property|Property of a structured type|\n\nIt should instead say \"structural property\" because now it seems to be a superset of structural and navigation properties, which does not make sense.\n\nDefining a term that applies to both structural and navigation properties should be done by listing both: `AppliesTo=\"Property NavigationProperty\"`.\n\nOtherwise we would lose the ability to define terms that only apply to structural properties.\n\n### Proposal\n\nChange text to \"Structural Property\"\n\nImported from [ODATA-1531](https://issues.oasis-open.org/browse/ODATA-1531)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Specify when and how stream valued properties are included",
    "body": "Section 11.4.8 Managing Stream Properties states that \n `The values for stream properties do not usually appear in the entity payload.`\n\nThe standard does not specify when they are included, how the client controls it, and how the stream properties value is represented in the payload if this property is one of many of a structural type.\n\n \n\n### Proposal\n\nProtocol section 11.4.8: add reference to $expand:\n> The values for stream properties do not usually appear in the entity payload *unless explicitly requested with [`$expand`](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_SystemQueryOptionexpand)*.\n> \n\n\nImported from [ODATA-1530](https://issues.oasis-open.org/browse/ODATA-1530)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify context URL for response to $expand=*",
    "body": "What is the correct or preferred context URL for responses to requests with `$expand=*`?\n\n[Protocol 10.10 Expanded Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ExpandedEntity) talks about \"explicitly expanded\", which can be interpreted in two ways for `$expand=*`:\n1. Explicitly list all expanded properties because this is a shortcut for explicitly expanding all navigation properties\n1. Do not list expanded properties because they are not explicitly expanded\n\n### Proposal\n\n#1: explicitly list all expanded navigation properties\n\nImported from [ODATA-1525](https://issues.oasis-open.org/browse/ODATA-1525)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify key-as-segment representation for Duration and EnumValue",
    "body": "Explicitly state in section [4.3.6 Key-as-Segment Convention](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_KeyasSegmentConvention) that duration and enumeration values as key segments are both without prefix and without surrounding single-quotes, for example\n```java\n/TimeThing/P13DT13H13M13.13S\n/EnumThing/blue```\n\n### Proposal\n\nNo quotes, no prefixes allowed or required\n\nImported from [ODATA-1524](https://issues.oasis-open.org/browse/ODATA-1524)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Can Validation.DerivedTypeConstraint specify collection-valued types?",
    "body": "The term [DerivedTypeConstraint](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Validation.V1.xml#L147:~:text=%3CTerm%20Name=%22-,DerivedTypeConstraint,-%22) takes a collection of [QualifiedTypeName](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#QualifiedTypeName)s. Can these also contain collection-valued types, as in\n```xml\n<Annotation Term=\"Validation.DerivedTypeConstraint\">\n <Collection>\n  <String>Edm.PrimitiveType</String>\n  <String>Collection(Edm.PrimitiveType)</String>\n </Collection>\n </Annotation>\n```\n?\n\nIf the declared type is single-valued, derivations cannot be collection-valued.\n\nIf the declared type is `Collection(ns.T1)`, which is correct: `\"@Validation.DerivedTypeConstaint\": [\"ns.T2\"]` or `\"@Validation.DerivedTypeConstaint\": [\"Collection(ns.T2)\"]`?\n\nIf the declared type is `Edm.Untyped`, both single- and collection-valued derived types are possible.\n\n### Proposal\n\nInclude two statements in the term definition:\n\nAllow `Validation.DerivedTypeConstraint` to specify `Collection(...)`, but only if the declared type is `Edm.Untyped`, because that is the only case where the property can be collection-valued or not.\n\nIf the declared type of a property is `Collection(ns.T1)`, then `\"@Validation.DerivedTypeConstaint\": [\"ns.T2\"]` means that  instances of `ns.T2` are allowed in the collection.\n\nPROPOSED WORDING:\nIf the element being annotated is collection-valued, the DerivedTypeConstraint specifies the types allowed for members of the collection; it does not specify the Collection() wrapper.  The QualifiedTypeName may only include the Collection() wrapper if the declared type of the element being annotated is Edm.Untyped. \n\nImported from [ODATA-1523](https://issues.oasis-open.org/browse/ODATA-1523)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Define behavior for partial /$count",
    "body": "We define the $count=true query option as returning an estimate of the number of records matching the request. In OData-1516 we introduced control information that a service could return in order to convey the accuracy of the inline count, and specifically to enabling returning a partial count where counting all of the items was too expensive.\n\n/$count in the resource path is defined to be an exact count. If an implementation can't return an exact count it is required to fail the request. However, in the case that the implementation has reached a limit in counting matching records there is no way for the service to convey to the implementation the partial count reached.\n\nFor backward compatibility I think we need to continue returning an error, and /$count used within an expression definitely must error if an exact count cannot be returned, but it would be nice to have a way to return the fact that an error was being returned because a certain threshold had been reached.\n\nWe could return this information as an annotation within the returned error, or as a header.  Alternatively, we could define a preference header that the client could specify to say that they were willing to accept an incomplete count, and a preference-applied header that the service could return in the response to specify the accuracy of the count.\n\n \n\n \n\nImported from [ODATA-1522](https://issues.oasis-open.org/browse/ODATA-1522)",
    "labels": [],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Case statement ambiguous with timeOfDay values",
    "body": "Our rules for the Case statement use colons to separate the condition from the value-if-true and value-if-false:\n```java\ncaseMethodCallExpr = \"case\" OPEN BWS boolCommonExpr BWS COLON BWS commonExpr BWS \n                        *( COMMA BWS boolCommonExpr BWS COLON BWS commonExpr BWS ) CLOSE\n```\nHowever, timeOfDay also uses colons to separate the parts of a time of day value, including optional seconds:\n```java\ntimeOfDayValueInUrl = hour COLON minute [ COLON second [ \".\" fractionalSeconds ] ]```\nThat means that, for certain time of day values, the case statement could be ambiguous. i.e.;\n\n`case(CreatedTime eq 10:20:15:10:10,15:20)`\n\n`which could legally be parsed any of the following ways:`\n `  if CreatedTime eq 10:20 then 15:10:10 otherwise 15:20`\n `  if CreatedTime eq 10:20:15 then 10:10 otherwise 15:20`\n\n`Note that the user *could* differentiate between these by inserting whitespace before/after the separators separating the case parameters:`\n `  case(CreatedTime eq 10:20 : 15:10:10 : 15:20)`\n `  case(CreatedTime eq 10:20:15 : 10:10 : 15:20)`\n \n\n### Proposal\n\nThe use of the case statement without the optional whitespace and with timeofday values could be ambiguous. Clients should use whitespace or parens to disambiguate. \n\nImported from [ODATA-1521](https://issues.oasis-open.org/browse/ODATA-1521)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Central definition for type-cast and term-cast segments",
    "body": "The terms \"type-cast segment\" and \"term-cast segment\" are defined adhoc in several places throughout the specification. Specify them _once_ in a central place instead.\n\n### Proposal\n\nDefine \"type-cast segment\" in section [4.11 Addressing Derived Types](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AddressingDerivedTypes).\n\nTurn all occurrences of \"type-cast segment\" into hyperlinks to section 4.11 (some already are), and remove all ad-hoc definitions.\n\nImported from [ODATA-1520](https://issues.oasis-open.org/browse/ODATA-1520)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify: Clients should ignore unknown control information in a json response",
    "body": "\n\nImported from [ODATA-1519](https://issues.oasis-open.org/browse/ODATA-1519)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Extend [OData-Protocol, example 18] with properties from derived types",
    "body": "[OData-Protocol, example 18](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CollectionofProjectedEntities) shall be extended with a context URL that contains properties from derived types.\n\n### Proposal\n\nAdd example:\n```java\nhttp://host/service/Customers?$select=Address,Orders,Model.VipCustomer/PreferredContact\nhttp://host/service/$metadata#Customers(Address,Orders,Model.VipCustomer/PreferredContact)\n```\n\nImported from [ODATA-1518](https://issues.oasis-open.org/browse/ODATA-1518)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "[OData-CSDL, example 64] annotating a navigation property or its addressed resource?",
    "body": "[OData-CSDL](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_PathSyntax) contains\n> Example 64: model path addressing an annotation on a navigation property\n> ```java\n> …/Items@Capabilities.InsertRestrictions/Insertable\n> ```\n> \n\nwhich claims to be\n> addressing annotations on the navigation property itself\n> \n\nBut according to the [capabilities vocabulary](https://github.com/oasis-tcs/odata-vocabularies/blob/27967a1cef3e737b8ab3d787581664aa5dcb921b/vocabularies/Org.OData.Capabilities.V1.xml#L600), this annotation applies only to entity sets and collections, not to navigation properties.\n\nHowever, external [annotation targets](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Target) that start with a container make no distinction between a navigation property and the resource addressed by it. Is the distinction between\n```java\n…/Items@Capabilities.InsertRestrictions/Insertable\n```\nand\n```java\n…/Items/@Capabilities.InsertRestrictions/Insertable\n```\nperhaps entirely artificial?\n\n### Proposal\n\nExtend example with a second line:\n> Example 64: model path _segment_ addressing an annotation on a navigation property _vs. term cast addressing an annotation on the resource_ _addressed by the navigation property_\n> ```java\n> …/Items@Core.Description\n> …/Items/@Core.Description\n> ```\n> \n\n\nImported from [ODATA-1517](https://issues.oasis-open.org/browse/ODATA-1517)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow $value as the last path segment of an annotation target - no, annotate the media entity type",
    "body": "The media stream of a media entity can be addressed as a pseudo-property `$value` both in the [path part of the URL](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestingtheMediaStreamofaMediaEnti) and in the [system query option $expand](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_SystemQueryOptionexpand).\n\nWhat's missing is the possibility to [target this pseudo-property with an annotation.](https://docs.oasis-open.org/odata/odata-csdl-json/v4.01/odata-csdl-json-v4.01.html#sec_Target)\n\n### Proposal\n\nAnnotate the media entity type, check all terms that apply to stream properties and add \"EntityType\" to the AppliesTo list\n\nImported from [ODATA-1515](https://issues.oasis-open.org/browse/ODATA-1515)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Dynamic properties are not allowed as function parameters",
    "body": "[OData-URL, section 5.1.1.15](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_PathExpressions) allows as function parameters properties of the entity addressed by the resource path. But this does not work for dynamic properties, because ABNF disallows\n```\n$compute=concat(year(Date),'-05-01') as MayDay\n&$filter=Special.IsSunday(Date=MayDay)\n```\nSee [this failed test case](https://github.com/oasis-tcs/odata-abnf/runs/5127416747?check_suite_focus=true).\n\nImported from [ODATA-1511](https://issues.oasis-open.org/browse/ODATA-1511)",
    "labels": [
      "ABNF"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "$root/EntitySet is not allowed by ABNF",
    "body": "[OData-URL, 5.1.1.14.5](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_root) seems to allows `$root` only in a single-valued expression or within complex or collection literals. The ABNF allows also some collection-valued expressions, but not entity sets.\n\n### Proposal\n\nMerge [PR #64](https://github.com/oasis-tcs/odata-abnf/pull/64).\n Remove second sentence from [OData-URL, section 5.1.1.14.5](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_root) and add another example.\nh5. 5.1.1.14.5 [$root](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_root)\n\nThe `$root` literal can be used in expressions to refer to resources of the same service.\n\nAdditional Example: function call returning the average rating of a given employee by their peers (employees in the same department)\n```java\nhttp://host/service/Employees('A1245')\n/self.AvgRating(RatedBy=@peers)\n?@peers=$root/Employees/$filter(Department eq $it/Department)\n```\n\nImported from [ODATA-1510](https://issues.oasis-open.org/browse/ODATA-1510)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Core.MediaType for media resources",
    "body": "Term `Core.MediaType` allows specifying the media type of a binary or stream data. \n\nThe term cannot currently applied to media resources.\n\n### Proposal\n\nAllow applying the term to media entity types for the corresponding media resource, similar to [ODATA-1471](https://issues.oasis-open.org/browse/ODATA-1471) for `Core.ContentDisposition`.\n\nImported from [ODATA-1509](https://issues.oasis-open.org/browse/ODATA-1509)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Missing annotation namespace in example 8",
    "body": "[OData-JSON, example 8](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_ControlInformationcollectionAnnotati) contains an annotation\n```java\n\"@emailType\":\"Personal\"\n```\nwithout a namespace. Is this example also meant to illustrate the concept of default namespaces, or was it simply forgotten?\n\n### Proposal\n\nReplace `\"@emailType\"` with `\"@OfficeCommunication.emailType\"`.\n\nImported from [ODATA-1508](https://issues.oasis-open.org/browse/ODATA-1508)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Does a filter segment followed by a key predicate make sense?",
    "body": "ABNF rules allow the production\n```java\ncollectionNavNoCastExpr = filterExpr keyPredicate\n```\nwhich enables things like\n```java\nOrder('A')/Items/$filter(Product eq 'Sugar')(ItemNumber=2)\n```\nIs the `$filter` redundant since a key predicate follows anyway? Or does this ensure that item #2 is returned only if its product is sugar?\n\n### Proposal\n\n[PR #62](https://github.com/oasis-tcs/odata-abnf/pull/62)\n\nImported from [ODATA-1507](https://issues.oasis-open.org/browse/ODATA-1507)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Instance annotations of absent complex properties",
    "body": "According to [OData-JSON](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_InstanceAnnotations) section 20, a complex property has its instance annotations embedded into the JSON object:\n```json\n{\n \"ComplexProperty\": {\n  \"@ns.term\": ...\n  \"SubProperty\": ...\n }\n}\n```\nHowever, if the property is null, it looks different:\n```json\n{\n \"ComplexProperty\": null,\n \"ComplexProperty@ns.term\": ...\n}\n```\nHow shall the instance annotation look if the property is absent? So\n```json\n{\n \"ComplexProperty@ns.term\": ...\n}\n```\nor so?\n```json\n{\n \"ComplexProperty\": {\n  \"@ns.term\": ...\n }\n}\n```\nSection 20 does not cover the case \"When annotating a name/value pair for which the value is absent\".\n\n### Proposal\n\nAnnotations are always expressed as name/value pairs. For entity data model constructs represented as JSON objects the annotation name/value pairs are placed within the object; for constructs represented as JSON arrays or primitives, _including null,_ they are placed next to the annotated model construct _and have the name of the annotated property before the `@`. An annotation in the latter format can also take the place of an absent property._\n\nImported from [ODATA-1503](https://issues.oasis-open.org/browse/ODATA-1503)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Annotations targeting contained singletons",
    "body": "The combination `AppliesTo=\"EntitySet Collection\"` occurs very often and the `EntitySet` could even be omitted, because an entity set is also a collection. This combination allows targeting contained entity sets with `Target=\"ns.Schema/EntitySet/collectionValuedNavProp\"`.\n\nHowever, `AppliesTo=\"Singleton\"` does not allow `Target=\"ns.Schema/EntitySet/singleValuedNavProp\"`. In order to treat \"contained singletons\" like named singletons, a new value for applicability is needed:\nh3. 14.1.2 Applicability\n||Symbolic Value||Model Element||\n|Instance|Singleton or complex-valued Property or Navigation Property|\n\n### Proposal\n\nAdd a new value depending on the restrictions we want on the single instance\n1. `Single` Singleton or single-valued Property or Navigation Property\n1. `Object` Singleton or single-valued complex Property or Navigation Property\n1. `Entity` Singleton or single-valued Navigation Property\n\nWe can argue that this is a compatible change as the specification calls out that\n> clients SHOULD be prepared for any term to be applied to any model element and SHOULD be prepared to handle unknown values within the `AppliesTo` attribute\n> \n\nTC agrees to extend `AppliesTo=\"Singleton\"` to mean also single-valued Property or Navigation Property.\n\nImported from [ODATA-1501](https://issues.oasis-open.org/browse/ODATA-1501)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Why is function \"matchesPattern\" written in camelCase?",
    "body": "\n\n### Proposal\n\nWrite it \"matchespattern\" to be consistent with the other functions.\n\nThe function names are now case-insensitive, so it really doesn't matter from a functionality perspective.\n\nImported from [ODATA-1500](https://issues.oasis-open.org/browse/ODATA-1500)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify where collection of primitive type can be used",
    "body": "Section 3.4 Built-In Abstract Types states that\n\n> \n> - Collection(Edm.PrimitiveType)\n>   - cannot be used as the type of a property or term.\n>   - cannot be used as the type of a parameter or the return type of an action or function.\n> \n\n\nWhere can it be actually used?\n\n### Proposal\n\nChange to\n>  * Collection(Edm.PrimitiveType)\n>   - cannot be used.\n\nAfter reopening:\n\nAdd note to [OData-JSON]: A collection of primitive values that occurs in a property of type `Edm.Untyped` is interpreted as a collection of `Edm.Boolean`, `Edm.String` and `Edm.Decimal`, depending on the Javascript type.\n\nClarify that `Validation.DerivedTypeConstraint` can contain only types that would be allowed as type of the constrained member.\n\nImported from [ODATA-1498](https://issues.oasis-open.org/browse/ODATA-1498)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "13.6 Function Import: annotations allowed but not mentioned",
    "body": "Function imports can be annotated, same as action imports, but the corresponding sentence is missing. \n\nThe sentence is there for action imports (section 13.5), and annotations are explicitly allowed in the XML schema.\n\nImported from [ODATA-1497](https://issues.oasis-open.org/browse/ODATA-1497)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "clarify the relationship of the various path expression types",
    "body": "The section [14.4.1 Path Expressions](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_PathExpressions) lists various different path exptessions\n\nThe sections 14.4.1.4 to 6 mention the relationship between the built-in types Edm.PropertyPath, Edm.AnyPropertyPath, or Edm.ModelElementPath but never makes it explicit what the relationship is. \nUnder ModelElementPath is states \n    \"specify the built-in types Edm.ModelElementPath\"\nUnder Navigation Property Path it states \n     \"specify the built-in types Edm.NavigationPropertyPath, Edm.AnyPropertyPath, or Edm.ModelElementPath.\n\nWhich seems to indicate the ModelElementPath is more specific. \nCan this be explained in a more comprehensive way ?\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-specs/pull/228\n\nImported from [ODATA-1496](https://issues.oasis-open.org/browse/ODATA-1496)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove statement about format of media streams",
    "body": "The Protocol spec describes in section [11.4.3 Update an Entity](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358979) how media entities can be updated with OData V4.01. It contains a statement about the format how the media stream should be represented.\n\nStatements about data representation should only be made in the corresponding format specs.\n\n### Proposal\n\nThe JSON format spec includes the same definition in section [JSON Format 10 Media Entity.](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_MediaEntity)\n\n \n\nTherefore, proposal is to simply remove the statement about the format in the fifth paragraph: \"For requests with an OData-Version header with a value of 4.01 or greater, the media stream of a media entity can be updated by specifying the <del>base64url-encoded</del> _format-specific representation_ of the media stream as a virtual property $value.\"\n\nImported from [ODATA-1495](https://issues.oasis-open.org/browse/ODATA-1495)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "edm.xsd doesn't allow Edmx Version=\"4.01\", and there doesn't seem to be a 4.01 version of the xsd",
    "body": "XSD-based validation of a CSDL XML file fails if Edmx Version=\"4.01\".\n\n\n### Proposal\n\nEither we need to have a 4.01 version of the xsd, or the 4.0 version needs to allow Edmx Version=\"4.01\".\n\n\nImported from [ODATA-1494](https://issues.oasis-open.org/browse/ODATA-1494)",
    "labels": [],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "OData-URL 5.1.1.15 does not explain example 106 in 5.1.1.14.4",
    "body": "Example 106 in [OData-URL](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_it)\n```java\nhttp://host/service/Customers?$expand=Orders($filter=$it/Address/City eq ShipTo/City)\n```\nuses the navigation property `ShipTo` of the `Orders` navigation target. According to section 5.1.1.15, however, `ShipTo` should be equivalent to `$it/ShipTo`, a property of the addressed resource `Customers`:\n> Properties and navigation properties of the _entity type of the set of resources that are addressed by the request URL_ can be used as operands or function parameters, as shown in the preceding examples.\n> \n\n\n### Proposal\n\nRephrase section 5.1.1.15:\n> Properties and navigation properties of the _structured type_ _on which a common expression is evaluated_ can be used as operands or function parameters, as shown in the preceding examples.\n> \n\nAdd note to 5.1.1.14.6 that example could use `$this/ShipTo/City`, which would be equivalent and longer.\n\nImported from [ODATA-1493](https://issues.oasis-open.org/browse/ODATA-1493)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Inconsistency in example 16.1, entity type Product",
    "body": "[CSDL Example 16.1](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ProductsandCategoriesExample) has an entity type `Product` which is a media entity (`HasStream=\"true\"`) and a non-nullable navigation property `Category`. \n\nIt would be rather hard to create such an entity because the POST body must be the media resource, and the server would have to guess the Category from that media (a picture or movie).\n\n### Proposal\n\nRemove `HasStream=\"true\"` resp. `$HasStream:true` from the example.\n\nImported from [ODATA-1491](https://issues.oasis-open.org/browse/ODATA-1491)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Point out that additional rules for stream properties were introduced with V4.01",
    "body": "# The current JSON spec for V4.01 describes in section [9 Stream Properties](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457765) that stream properties can be returned expanded in the response and can be represented as native JSON, if they are of media type application/json. These are two statement that are not included in the [corresponding section ](http://docs.oasis-open.org/odata/odata-json-format/v4.0/errata03/os/odata-json-format-v4.0-errata03-os-complete.html#_Toc453766652) in the last Errata 3 of the same JSON spec of V4.0.\n1. The current URL conventions spec for V4.01 describes in section [5.1.3 System Query Option $expand](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361039) in the paragraph starting with \"A path can end with\" as the first point that stream properties can be included. This statement is not included in the [corresponding section](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part2-url-conventions/odata-v4.0-errata03-os-part2-url-conventions-complete.html#_Toc453752359) in the last Errata 3 of the same URL conventions spec of V4.0.\n\n### Proposal\n\nRe 1: Make an explicit note about the rules added with V4.01 in section [9 Stream Properties](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457765)\n\nRe 2: Make an explicit note about the rules added with V4.01 in section [5.1.3 System Query Option $expand](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361039)\n\nImported from [ODATA-1490](https://issues.oasis-open.org/browse/ODATA-1490)",
    "labels": [
      "JSON Format",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Core.ContentDisposition: add Disposition Type",
    "body": "\n\n### Proposal\n\nAdd property `Type` to term `Core.ContentDisposition`.\n\nImported from [ODATA-1489](https://issues.oasis-open.org/browse/ODATA-1489)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Inconsistencies for Annotation between CSDL XML spec and edm.xsd",
    "body": "Sections 12.2 and 12.4 mention that Action and Function MAY contain edm:Annotation elements (no constraints on ordering are stated relative to other child elements), but edm.xsd doesn't permit Annotation to appear within the Action/Function after ReturnType.\n\n13.6 Function Import doesn't mention that FunctionImport MAY contain edm:Annotation elements, but the edm.xsd allows it.\n\n### Proposal\n\nFix edm.xsd so that edm:Annotation may appear after ReturnType.\n\nFix CSDL XML section 13.6 to mention that FunctionImport MAY contain edm:Annotation elements.\n\n\nImported from [ODATA-1488](https://issues.oasis-open.org/browse/ODATA-1488)",
    "labels": [
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "broken link in \"References\" section",
    "body": "The references to IETF RFCs are using http:// which does not seem to be supported\n\nbroken: http://tools.ietf.org/html/rfc6570\nworks: https://tools.ietf.org/html/rfc6570\n\nRFC https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#BMRFC6570\n\n### Proposal\n\nChange all IETF RFC references to the preferred format, see http://docs.oasis-open.org/templates/ietf-rfc-list/ietf-rfc-list.html\n\n\nImported from [ODATA-1487](https://issues.oasis-open.org/browse/ODATA-1487)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Section 4.3: Correct references to ABNF rules",
    "body": "Section 4.3 uses outdated ABNF rule names:\n- `entityColFunctionCall` --> `entityColFunctionImportCall`\n- `entityFunctionCall` --> `entityFunctionImportCall`\n- `actionCall` --> `actionImportCall`\n\nImported from [ODATA-1486](https://issues.oasis-open.org/browse/ODATA-1486)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify canonical URLs for stream properties",
    "body": "Feedback:\n- It would help if JSON Format 4.5.12 would not simply generically refer to _OData Version 4.01 Part 2: URL Conventions_ and explicitly state that the stream property URL conventions are the same as for other properties. I see that [4.7 Addressing a Property Value](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_AddressingaPropertyValue) actually implicitly makes such a statement but a more explicit statement would still help.\n- Since examples speak more than 1000 words I would most appreciate if in [11.2.4 Requesting Individual Properties](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestingIndividualProperties) or in [11.4.8 Managing Stream Properties](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ManagingStreamProperties), an example could be added. In 11.4.8, one could then add one example with the canonical URL and one with a different mediaReadLink.\n\n \n\n### Proposal\n\nJSON Format 4.5.12:\n- First paragraph: explicitly reference URL Conventions [4.14 Addressing the Media Stream of a Media Entity](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AddressingtheMediaStreamofaMediaEnti) and [4.6 Addressing a Property](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AddressingaProperty)\n\nProtocol\n- 11.4.8: add example `GET http://host/service/Products(1)?$select=Thumbnail` with a response (excerpt) cloned from [JSON Format chapter 9 Stream Property](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_StreamProperty)\n- 11.4.8.2: add example `DELETE http://server/uploads/Thumbnail546.jpg` using the response from 11.4.8\n\n\nImported from [ODATA-1485](https://issues.oasis-open.org/browse/ODATA-1485)",
    "labels": [
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify response to batch request that fails before \"OData processing\"",
    "body": "The specification does not spell out that it is allowed for a server to fail before \"OData processing\", and even before digesting a multipart request body.\n\nIn that case the (error) response can have any content type and response shape, including application/json and an OData error response.\n\n### Proposal\n\nChange [Part 1: Protocol, Section 9.4 Error Response Body](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ErrorResponseBody) to:\n> The representation of an error response body is format-specific.\n>  <ins>An OData-specific error response</ins> +(which can be recognized by the presence of the OData-Version header)+-it- consists at least of the following information:\n> \n\n\nImported from [ODATA-1482](https://issues.oasis-open.org/browse/ODATA-1482)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow Edm.Stream for non-binding action and function parameters",
    "body": "The CSDL specifications currently restrict the use of `Edm.Stream` to _binding_ parameters and return types of actions and functions.\n\nEspecially for stream values of media types `application/json` and `text/plain` this is an unnecessary limitation.\n\n### Proposal\n\nCSDL:\n- Allow use of `Edm.Stream` also for _non_-binding parameters of actions and functions.\n\nJSON Format\n- 18 Action Invocation: mention Edm.Stream for values of non-binding parameters, reference chapter 9 for their representation\n- (do not rename chapter 9)\n\nURL Conventions\n- Only allow path expressions that evaluate to Edm.Stream to be passed as non-binding function parameters\n- No literal representation for Edm.Stream values in URLs\n\nImported from [ODATA-1481](https://issues.oasis-open.org/browse/ODATA-1481)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "7.2.3 Precision: clarify absence of $Precision for DateTimeOffset",
    "body": "CSDL XML defines different meaning for the absence of the Precision attribute depending on the type (Decimal versus DateTimeOffset).\n\nCSDL JSON does not define a different meaning for absence of the $Precision member. This is intentional, see [ODATA-1115](https://issues.oasis-open.org/browse/ODATA-1115).\n\n### Proposal\n\nClarify that this is intentional. In CSDL JSON write\n> Absence of `$Precision` means unspecified precision +both for decimal and temporal properties+.\n> \n\nin CSDL XML write:\n> If not specified for a decimal property, the decimal property has <ins>unspecified</ins> precision.\n> \n\n\nImported from [ODATA-1478](https://issues.oasis-open.org/browse/ODATA-1478)",
    "labels": [
      "CSDL JSON",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Aggregation on different levels",
    "body": "Use case: Display top 4 countries by number of sales, with aggregate sales amount and number of account responsibles per country.\n\nThis requires aggregation on two different levels:\n- per distinct account responsible per country\n- per country\n\nThis can be achieved with a `concat` transformation inside `groupby`\n```java\n$apply=groupby((Country),concat(\n  groupby((AccountResponsible))/aggregate($count as number_of_leaves),\n  aggregate(SalesNumber,SalesAmount)\n))\n/orderby(SalesNumber desc)/top(4)\n```\nthat returns two rows per country\n||Country||number_of_leaves||SalesNumber||SalesAmount||\n|DE|2000| | |\n|DE| |500|5000|\n|UK|1500| | |\n|UK| |400|5500|\n\nBut then the subsequent `orderby` cannot sort the countries, because each country occupies two rows. Before the `orderby`, the table would need to be compressed into\n||Country||number_of_leaves||SalesNumber||SalesAmount||\n|DE|2000|500|5000|\n|UK|1500|400|5500|\n\nOne way to achieve this is\n```java\n$apply=groupby((Country),concat(\n  groupby((AccountResponsible))/aggregate($count as number_of_leaves),\n  aggregate(SalesNumber,SalesAmount)\n)/aggregate(\n  number_of_leaves with max as number_of_leaves2,\n  SalesNumber with max as SalesNumber2,\n  SalesAmount with max as SalesAmount2\n))\n/orderby(SalesNumber2 desc)/top(4)\n```\nBut this is cumbersome and requires renaming the properties.\n\nCan [OData-Aggr] offer a more elegant solution?\n\nImported from [ODATA-1477](https://issues.oasis-open.org/browse/ODATA-1477)",
    "labels": [
      "Data Aggregation"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON batch body encoding for \"text\" content types may cause conversion errors or data loss",
    "body": "OData 4.01 JSON Format Section 19.1 Batch Request states:\n\n... \"For media types of top-level type text, for example text/plain, the value of body is a string containing the value of the request body.\"\n\nThis is fine if there is an explicit charset=utf-8 parameter in the Content-Type, otherwise is highly problematic for two reasons:\n\n1. See https://www.w3.org/International/articles/http-charset/index \"It is very important to always label Web documents explicitly. HTTP 1.1 says that the default charset is ISO-8859-1. But there are too many unlabeled documents in other encodings, so browsers use the reader's preferred encoding when there is no explicit charset parameter.\"\n\nWith no explicit charset, we may assume that media/stream content is utf-8 when it isn't, and risk transmitting invalid UTF-8 sequences or failing conversions.\n\n2. If charset is not us-ascii (a strict subset of utf-8) or utf-8, then the agent (client or server) attempting to encode a body as a JSON string may be unable (or even likely) to fail the conversion as it may not have a suitable conversion library for arbitrary charset conversion.\n\nContrast with multipart batches, where media/stream content (within a batch request/response) would be treated as binary with no conversion. If we cannot reliably use JSON batches for arbitrary \"text\" media/stream types without fear of conversion error or lossy conversion, then we will need to use multipart batches for reliable media/stream batch processing.\n\n### Proposal\n\nPossibility: only encode \"text\" content as a JSON string if `charset=utf-8` or `charset=us-ascii` is explicitly present or the defined default of the \"text\" sub-type, which is the case for `text/plain`. Otherwise encode as a string in base64url format.\n\nThis proposal isn't backwards compatible with the current spec in all cases, we need to compile a list of \"text\" sub-types and their defined default charset to see where this might cause problems.\n\nOn the other hand the current spec doesn't give instructions for encoding charsets other than UTF-8 and its true subsets as JSON strings, so a recipient of `text/<something>;charset=iso-8859-16` now does not really know how to decode the stream value.\n\nChange fourth paragraph of [9 Stream Property](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_StreamProperty) to (inserted text in *{color:#00875a}green{color}*)\n> If the actual stream data is included inline, the control information mediaContentType MUST be present to indicate how the included stream property value is represented. Stream property values of media type `application/json` or one of its subtypes, optionally with format parameters, are represented as native JSON. Values of top-level type `text` *{color:#00875a}with an explicit or default `charset` of `utf-8` or `us-ascii`, for example `text/plain`{color}*, are represented as a string, with JSON string escaping rules applied. Included stream data of other media types is represented as a base64url-encoded string value, see [RFC4648], section 5.\n> \n\n\nImported from [ODATA-1476](https://issues.oasis-open.org/browse/ODATA-1476)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "How to search for double quotes",
    "body": "The ABNF rules for `$search` do not allow clear-text or percent-encoded double quotes (`\"`) in search words and search phrases.\n\nAs a consequence it is not possible to search for double quotes.\n\nNote: the prose specification and the ABNF allow to enclose an \"incomplete\" search expression in single quotes, but do not define how services should interpret \"incomplete\" search expressions.\n\n### Proposal\n\nAdd a sentence to OData-URL, section 5.1.8.1:\n> To support type-ahead use cases, incomplete search expressions can be sent as OData string literals enclosed in single-quotes, and single-quotes within the search expression doubled. _Such an expression can also be used to search for double quotes: `?$search='\"'`._\n> \n\n \n\nImported from [ODATA-1475](https://issues.oasis-open.org/browse/ODATA-1475)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add example for timeline entity set requiring an object key definition",
    "body": "\n\n### Proposal\n\nChapter 3: add example for annotation from [https://github.com/oasis-tcs/odata-vocabularies/pull/154]\n\nSection 4.3.2.2: add request example with data before and after the action\n\n \n\nImported from [ODATA-1474](https://issues.oasis-open.org/browse/ODATA-1474)",
    "labels": [
      "Temporal",
      "V4.0_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify: PATCH should allow changing type on nested complex type",
    "body": "We state that PATCH semantics to an entity also applies PATCH semantics to any provided complex-typed properties. However, we don't say whether a PATCH to an entity can change a complex-typed property to a different complex type.\n\nWhile we (explicitly) prohibit changing the type of an instance of an entity type (since an instance of an entity type has identity) it should be possible to change the a complex-typed property to a property of a value of a different type.\n\n### Proposal\n\nA complex-typed property can be set to different type in a PATCH request by specifying a different type in the payload.  Properties shared through inheritance, as well as dynamic properties, are retained (unless overwritten by new values in the payload). Other properties are discarded.\n\nImported from [ODATA-1473](https://issues.oasis-open.org/browse/ODATA-1473)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify: PATCH should allow changing type on nested complex type",
    "body": "We say that a PATCH request to an entity with a complex type in the payload also patches the nested complex type (i.e., it only affects the properties specified in the request).\n\nWe don't say whether or not the PATCH request can change the complex type of the nested property.\n\nWhile changing the type of an entity should not be allowed (and is, in fact, explicitly prohibited) because entities define an *instance*, the type of a complex-typed property should be able to be changed in a PATCH request by specifying a new complex type (i.e., @odata.type) in the payload.\n\n### Proposal\n\nA complex-typed property can be set to different type in a PATCH request by specifying a different type in the update payload.  Properties shared through inheritance, as well as dynamic properties, are retained (unless overwritten by new values in the payload). Other properties of the original type are discarded.\n\nImported from [ODATA-1472](https://issues.oasis-open.org/browse/ODATA-1472)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Core.ContentDisposition for media resources",
    "body": "Term `Core.ContentDisposition` allows specifying a proposed filename when \"downloading\" binary or stream data. The term can currently be applied to terms or properties.\n\n### Proposal\n\nAllow applying the term to media entity types for the corresponding media resource.\n\nImported from [ODATA-1471](https://issues.oasis-open.org/browse/ODATA-1471)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify value of @odata.mediaContentType if stream is null",
    "body": "The control information `mediaContentType` SHOULD match the media type of the binary stream represented by the `mediaReadLink` URL.\n\nWhat if the binary stream is \"null\", meaning there is no stream?\n\n### Proposal\n\nThe presence of `mediaContentType` with value `null` MAY be used to indicate the absence of a binary stream.\n\nImported from [ODATA-1470](https://issues.oasis-open.org/browse/ODATA-1470)",
    "labels": [
      "JSON Format",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify $select behavior for properties of \"null\" instances",
    "body": "Section [5.1.4 System Query Option $select](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_SystemQueryOptionselect) states that\n\n> \n> Each select item in the $select clause indicates that the response MUST include the declared or dynamic properties, actions and functions identified by that select item. \n> \n\n\nand\n\n> If a select item is a path expression requesting a component of a complex property and the complex property is null on an instance, then the component is treated as null as well.\n\n\nThis is misleading because we do _not_ expect the components of a \"null\" instance to be represented as \"null\" values.\n\n\n### Proposal\n\nChange to\n> Each select item in the $select clause indicates that the response MUST include the declared or dynamic properties, actions and functions identified by that select item. If a select item is a path expression requesting a component of <ins>an entity or</ins> complex property and the <ins>entity or</ins> complex property is null on an instance, then +the entity or complex property is included and represented as null+.\n> \n\nThat is pull up the last sentence of the section right after the first sentence in this issue.\n\nImported from [ODATA-1469](https://issues.oasis-open.org/browse/ODATA-1469)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Unified treatment of paths in aggregate, groupby and transformnested",
    "body": "Original description: The  [`groupby`](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016583) specification should also allow instance annotations as grouping properties.\n\nThis idea was rejected by TC 2022-03-10. Still, changes to the specification text are necessary.\n\n### Proposal\n\nIntroduce the following definition in [OData-Aggr, section 2.1]:\n> A _data aggregation path_ consists of one or more segments separated by a forward slash. Segments are names of declared or dynamic structural or navigation properties other than stream properties, or type-cast segments consisting of the (optionally qualified) name of a structured type that is derived from the type identified by the preceding path segment to reach properties declared by the derived type.\n> \n\nRephrase [OData-Aggr, section 3.1] (unchanged parts in {color:#57d9a3}green{color}):\n> {color:#57d9a3}The `aggregate` transformation takes a comma-separated list of one or more _aggregate expressions_ as parameters and returns an output set with a single instance{color} _containing one dynamic property per aggregate expression_ {color:#57d9a3}representing the aggregated value of the input set.{color}\n> \n> In the following, P is a _data aggregation path_ with single- or collection-valued segments. P is evaluated relative to the input set of the `aggregate` transformation, this must be well-defined for each instance in the input set.\n> \n> The allowed types of aggregate expressions are listed below. To compute the value of the dynamic property for a given aggregate expression, the `aggregate` transformation first determines a collection U of instances or primitive values, based on the input set of the `aggregate` transformation and a path P that occurs in the aggregate expression, as explained below. Each type of aggregate expression defines a function f(U) that then yields the dynamic property value.\n> \n> In types 1 and 2, the aggregate expression must be followed by the keyword `with` and an aggregation method g. In types 1, 2 and 3, it must be followed by the keyword `as` and an alias, which is then the name of the dynamic property. In types 1, 2 and 4, the aggregate expression can be followed by a `from` expression.\n> \n> _Types of aggregate expressions:_\n> 1. A path P whose last segment is an aggregatable property.\n>  f(U) = g(U).\n> 1. An aggregatable expression W built from arithmetic operations [OData-URL, section 5.1.1.2], unbound primitive function calls, numeric or duration values, and data aggregation paths with single-valued segments whose last segment is primitive.\n>  f(U) = g(W evaluated relative to each member of U). In this type, P is absent.\n> 1. A path P/`$count` with optional prefix P/ where the last segment of P is collection-valued.\n>  f(U) = cardinality(U). (`$count` behaves like a property having the value 1 followed by `with sum`.)\n> 1. A path P/c consisting of an optional prefix P/ where the last segment of P has a structured type and a custom aggregate c defined on the collection addressed by P.\n>  f(U) = c(U). The name of the dynamic property is the name of the custom aggregate.\n> \n> _Determination of U:_\n> \n> _If P is absent, let U = input set._\n> \n> -If P is present, it must be well-defined for all instances in the input set.-{color:#57d9a3} {color}_Otherwise,_{color:#57d9a3} let Q be the portion of P up to and including the last navigation property, if any, and let R be the remainder, if any, of P that contains no navigation properties, such that P equals the concatenated path Q/R. The aggregate transformation considers each entity reached via the path Q exactly once. To this end{color}\n> - {color:#57d9a3}if Q is non-empty, let E be the set of distinct entities reached via Q starting from the input set{color}\n> - {color:#57d9a3}if Q is empty, let E be the input set (which may contain multiple instances with the same value).{color}\n> \n> {color:#57d9a3}Then, if R is empty, {color}_let U = E_, {color:#57d9a3}otherwise {color}_let U be the collection containing_ {color:#57d9a3}all instances {color}_or primitive values (possibly with repititions)_{color:#57d9a3} addressed via R starting from E.{color}\n>  <del>Any aggregate expression that specifies an aggregation method MUST define an [alias](#sec_Keywordas) for the resulting aggregated value. The resulting instance contains one dynamic property per parameter representing the aggregated value. The properties of P do not appear in the result (see Example 64, with P = Q = Sales and R = empty).</del> \n\nRephrase [OData-Aggr, section 3.10.1]:\n> In its simplest form the first parameter of `groupby` specifies the _grouping properties_, a comma-separated list of one or more _data aggregation paths_ with single-valued segments that is enclosed in parentheses.\n> \n> ...\n> \n> If the <del>property</del> path leads to a single-valued navigation property, this means grouping by the entity-id of the related entities. <del>Other</del> navigation properties specified in grouping properties <del>paths</del> are expanded by default.\n> \n\nRephrase step 4:\n> In each set resulting from the previous step, each entity and complex _property_-type-, including nested complex and navigation properties, are augmented if necessary to include all primitive property values of the corresponding projection. _In case of grouping by entity-id of a related entity, they must include at least the key properties of the related entity (see example 61)._\n> \n\nRephrase [OData-Aggr, section 3.13]:\n> Their first parameter is a _data aggregation path_ with single- or collection-valued non-primitive segments where only the last segment may have an entity type, but it can instead have a complex type. This path is optionally followed by a type-cast segment to -expand-_select_ only related entities of that derived type or one of its sub-types. The sub-path starting with the last segment that is not a type-cast is called the final sub-path in this definition. \n>  This is -a generalization-_an extension_ of the definition in [OData-URL, section 5.1.3] in that it does not require a navigation property -or entity-valued instance annotation-.\n> \n\nRemove mentions of \"entity-valued instance annotation\" from sections 3.13.1 and 3.13.2.\n\nRephrase example 61:\n> Example 61: Grouping by navigation property Customer <del>is treated as groupby((Customer/$ref))</del> ```java\n> GET ~/Sales?$apply=groupby((Customer))\n> ```\n> may result in\n> ```java\n> {\n>   \"@odata.context\": \"$metadata#Sales(Customer)\",\n>   \"value\": [\n>     { \"Customer\": { \"ID\": \"C1\" } },\n>     { \"Customer\": { \"ID\": \"C2\" } },\n>     { \"Customer\": { \"ID\": \"C3\" } }\n>   ]\n> }\n> ```\n> depending on which properties the server includes when expanding `Customer` without `$select` or `$ref`.\n> \n\nAdd new example 63:\n> If both subtypes have a `Rating` property but their common base type does not,\n> ```java\n> GET ~/Products?$apply=groupby((SalesModel.FoodProduct/Rating,\n>     SalesModel.NonFoodProduct/Rating))\n> ```\n> results in\n> ```java\n> {\n>   \"@odata.context\": \"$metadata#Products(\n>     SalesModel.FoodProduct/Rating,\n>     SalesModel.NonFoodProduct/Rating)\",\n>   \"value\": [\n>     {\"@odata.type\": \"#SalesModel.FoodProduct\", \"Rating\": 5},\n>     {\"@odata.type\": \"#SalesModel.FoodProduct\", \"Rating\": null},\n>     {\"@odata.type\": \"#SalesModel.NonFoodProduct\", \"Rating\": \"average\"},\n>     {\"@odata.type\": \"#SalesModel.NonFoodProduct\", \"Rating\": null}\n>   ]\n> }\n> ```\n> Note that the `@odata.type` context information is needed to distinguish the two groups with `\"Rating\": null`.\n> \n\nRemove `with sum` after `$count` in example 67.\n\nMerge ABNF pull request [#75](https://github.com/oasis-tcs/odata-abnf/pull/75) and vocabularies pull request [#186](https://github.com/oasis-tcs/odata-vocabularies/pull/186).\n\nImported from [ODATA-1468](https://issues.oasis-open.org/browse/ODATA-1468)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarification: Delete supported for Nullable single-valued navigation properties",
    "body": "The existing text [OData Version 4.0 Part 1: Protocol (oasis-open.org)](https://nam06.safelinks.protection.outlook.com/?url=http%3A%2F%2Fdocs.oasis-open.org%2Fodata%2Fodata%2Fv4.0%2Fos%2Fpart1-protocol%2Fodata-v4.0-os-part1-protocol.html%23_Toc372793721&data=04%7C01%7Cmikep%40microsoft.com%7Ce612c9c5595f41a75ebc08d95617c237%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C637635482313014844%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C1000&sdata=oe2tLG1qQ3hcJZSSOI5d%2BbwW5vjsJuUo7xJEX%2FdomWQ%3D&reserved=0) says the following:\n\n{color:#0b5690}11.4.5 {color}[Delete an Entity](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_DeleteanEntity)\n\nTo delete an individual entity, the client makes a DELETE request to a URL that identifies the entity. Services MAY restrict deletes only to requests addressing the [edit URL](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#sec_ReadURLsandEditURLs) of the entity.\n\nThe request body SHOULD be empty. *Singleton entities can be deleted if they are nullable. Services supporting this SHOULD advertise it by annotating the singleton with the term Capabilities.DeleteRestrictions (nested property Deletable with value true) defined in* *[[OData-VocCap]](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#VocCapabilities).*\n\n \n\n>>The highlighted text applies to top-level <Singleton> entities, not to single-valued navigation properties. Calling DELETE on the edit URL of a nullable single-valued navigation property sets that property to null.  Subsequent GET requests would return 404.\n\n \n\n### Proposal\n\nUpdate the highlighted text as follows:\n- *Top-level Singleton entities can be deleted if they are nullable. Services supporting this MAY advertise it by annotating the singleton with the term Capabilities.DeleteRestrictions (nested property Deletable with value true) defined in* *[[OData-VocCap]](http://docs.oasis-open.org/odata/odata/v4.01/os/part1-protocol/odata-v4.01-os-part1-protocol.html#VocCapabilities).*\n\nImported from [ODATA-1465](https://issues.oasis-open.org/browse/ODATA-1465)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Redundant section 14.4.4.3 Function odata.matchesPattern",
    "body": "Section [14.4.4.1 Canonical Functions](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_CanonicalFunctions) defines that all URL functions can be used with prefix `odata.`.\n\nWe added section [5.1.1.7.1 matchesPattern](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#sec_matchesPattern) to the URL Conventions, making section [14.4.4.3 Function odata.matchesPattern](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_FunctionodatamatchesPattern) in the CSDL specifications redundant (and slightly confusing).\n\n### Proposal\n\nKeep section, clarify the redundancy, keep the example\n\nImported from [ODATA-1464](https://issues.oasis-open.org/browse/ODATA-1464)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "in operator should allow empty collection literals",
    "body": "Currently, the ABNF requires that a collection literal used in an \"in\" clause requires at least one element:\n\n \n\ninExpr = RWS \"in\" RWS ( listExpr / commonExpr )\n\nlistExpr = OPEN BWS primitiveLiteral BWS *( COMMA BWS primitiveLiteral BWS ) CLOSE\n\n \n\nThere may be scenarios in which the user intends to provide an empty collection (for example, to reflect that there are no items selected in a drop-down list box). This should evaluate to false.\n\nAlso, note that commonExpr may be empty, so it would seem we should have equal expressivity between commonExpr and listExpr\n\n### Proposal\n\nEnable empty collections in a literal expression for an in expression:\n\nlistExpr = OPEN BWS [primitiveLiteral BWS *( COMMA BWS primitiveLiteral BWS )] CLOSE\n\nImported from [ODATA-1462](https://issues.oasis-open.org/browse/ODATA-1462)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Term describing GeoJSON Feature Objects",
    "body": "OData defines primitive types for all GeoJSON [Geometry Objects](https://datatracker.ietf.org/doc/html/rfc7946#section-3.1), but it does not define a counterpart for the GeoJSON [Feature Object](https://datatracker.ietf.org/doc/html/rfc7946#section-3.2).\n\nFrom an OData perspective a Feature Object is just a complex type with properties `type`, `geometry`, `properties`, and optionally `id`.\n\n### Proposal\n\nDefine new term `GeometryFeature`, either in the `Core` vocabulary, or in a new `Geo` vocabulary, with a corresponding structured type.\n\nImported from [ODATA-1461](https://issues.oasis-open.org/browse/ODATA-1461)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Aggregation.ApplySupportedDefaults: use PATCH logic when overriding with ApplySupported",
    "body": "`ApplySupportedDefaults` allows to specify aggregation defaults on the entity container, applying to all entity sets. This default behavior can be overridden on entity-set level via `ApplySupported` whose type inherits from the type of `ApplySupportedDefaults`.\n\nClarify that this \"override\" uses PATCH semantics, i.e. values not specified via `ApplySupported` are \"inherited\" from `ApplySupportedDefaults`.\n\nImported from [ODATA-1460](https://issues.oasis-open.org/browse/ODATA-1460)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify representation of property paths in groupby with leading segments being null",
    "body": "The specification text contains an example for tranformation `outerjoin` whose result is applied to a subsequent `groupby` transformation:\n\nExample 66:\n```java\nGET ~/Customers?$apply=outerjoin(Sales as ProductSales)\n                       /groupby((Country,ProductSales/Product/Name))\n```\nreturning\n```java\n{\n  \"@odata.context\":\"$metadata#Customers(Country,ProductSales(Product(Name)))\",\n  \"value\": [\n     { \"Country\": \"Netherlands\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Paper\"  } } },\n     { \"Country\": \"Netherlands\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Sugar\"  } } },\n     { \"Country\": \"USA\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Coffee\" } } },\n     { \"Country\": \"USA\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Paper\"  } } },\n     { \"Country\": \"USA\",\n      \"ProductSales\": { \"Product\": { \"Name\": \"Sugar\"  } } },\n    { \"Country\": \"France\", \"ProductSales\": null }\n  ]\n}\n```\n—\n\nLooking at the first step, `outerjoin` returns combinations of customer instances and the related sales instances:\n```java\n[\n  { 'ID': 'C1', 'Name': 'Joe', 'Country': 'USA', 'ProductSales': { 'ID': '1', … } },\n  { 'ID': 'C1', 'Name': 'Joe', 'Country': 'USA', 'ProductSales': { 'ID': '2', … } },\n  …\n  { 'ID': 'C4', 'Name': Luc', 'Country': France', 'ProductSales': null }\n]\n```\nThe following `groupby` operates on two grouping properties: `Country` and `ProductSales/Product/Name`.\n\nThe latter property path is not defined for the last instance returned by `outerjoin`. Intuition says its value should be null.\n\nIt should be clarified\n1. that the value for such a property path is clearly defined in some specification, when a leading segment is already null\n1. how the `groupby` result should look like for the last instance returned by `outerjoin`:\n   1. like shown above:\n `'ProductSales': null`\n   1. returning the complete structure of the grouping property:\n \\{{ 'ProductSales': { 'Product': { 'Name': null }\n}}}\n\n \n\n \n\n \n\n### Proposal\n\nRephrase the beginning of section 3.10 as follows (insertions are indented or italicized.)\nh2. 3.10 [Transformation groupby](#sec_Transformationgroupby)\n\nThe `groupby` transformation takes one or two parameters _where the second is a list of set transformations, separated by forward slashes to express that they are consecutively applied._\nh3. 3.10.1 [Simple Grouping](#sec_SimpleGrouping)\n\nIn its simplest form the first parameter of `groupby` specifies the _grouping properties_, a comma-separated list of one or more single-valued property paths that is enclosed in parentheses. A path may consist of a sequence of single-valued navigation and complex properties. The same property path SHOULD NOT appear more than once; redundant property paths MAY be considered valid, but MUST NOT alter the meaning of the request. If the property path leads to a single-valued navigation property, this means grouping by the entity-id of the related entities. Other navigation properties specified in grouping property paths are expanded by default.\n> The output set is constructed in five steps:\n> 1. For each instance in the input set:\n>    1. Create a projection of the instance with all related entities included that are reached via navigation properties that occur in the grouping properties.\n>    1. Remove from the projection all structural and navigation properties that are not traversed by any grouping property.\n> 1. The input set is split into subsets where two instances are in the same subset if their projections are the same with null considered different from absent.\n> 1. The set transformations from the second parameter are applied to each subset, resulting in a new set of potentially different structure and cardinality. If the second parameter is absent, each subset is transformed into a set consisting of a single instance without properties. <del>Transformations may take into account the grouping properties for producing their result, e.g. aggregate removes properties that are used neither for grouping nor for aggregation.</del> 1. In each set resulting from the previous step, each entity and complex type, including nested complex and navigation properties, are augmented if necessary to include all primitive property values of the corresponding projection.\n> 1. The output set is the union of the augmented sets of the previous step.\n <del>If the service is unable to group by same values for any of the specified properties, it MUST reject the request with an error response. It MUST NOT apply any implicit rules to group instances indirectly by another property related to it in some way.</del> \n \n\nImported from [ODATA-1459](https://issues.oasis-open.org/browse/ODATA-1459)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify representation of navigation properties in response that are expanded by $apply",
    "body": "In the context of [ODATA-1449](https://issues.oasis-open.org/browse/ODATA-1449) we clarified that if the paths expanded by transformation e.g. `transformnested` include a navigation property, the resources addressed by that path are included in the output set of the transformation, but that it requires a dedicated `$expand` of that navigation property to include the resources also in the response to the request.\n\nThis is in line with the following para in section 3 System Query Option $apply of the [current WD of the spec:](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68846/odata-data-aggregation-ext-v4.0-wd05.docx): \"This means an output set can contain structural and dynamic properties as well as navigation properties, Navigation properties in the result of $apply can be further expanded using $expand (see [Evaluating $apply](#sec_Evaluatingapply)).\"\n\nHowever, transformation `groupby` behaves differently: Navigation properties part of a grouping property path are returned expanded in the response to the request - see examples in spec text.\n\nThis means the specification has two behaviors when processing paths with navigation properties. It should be clarified if this is intended.\n\nIn this context, the text at the end of section 3.10.2 should be sharpened. It says: \"Grouping properties that specify navigation properties are automatically expanded, and the specified properties of that navigation property correspond to properties specified in a $select expand option on the expanded navigation property. \" - It is unclear if it describes the effect for the output set of the `groupby` transformation or for the response to the request.\n\n### Proposal\n\nTreat the result structures with related entities expanded from all `$apply` transformations in a uniform manner.\n\nThe necessary changes to the specification text and examples are described in this [document](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/69011/[ODATA-1458)(https://issues.oasis-open.org/browse/ODATA-1458)%20-%20Proposal.docx]\n\nImported from [ODATA-1458](https://issues.oasis-open.org/browse/ODATA-1458)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Navigation path from instance to lambda operator",
    "body": "The section on [lambda operators](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_LambdaOperators) states:\n> Other path expressions in the Boolean expression neither prefixed with the lambda variable nor $it are evaluated in the scope of the collection instances at the origin of the navigation path prepended to the lambda operator.\n> \n\nBut the navigation path does not necessarily originate in a collection, it can also be an instance, for example\n```java\nProducts('Sugar')?$compute=Sales/any(p:p/Amount lt MinSalesVolume) as LongTail\n```\n \n\n### Proposal\n\nThe argument of a lambda operator is a case-sensitive lambda variable name followed by a colon (\\:) and a Boolean expression that uses the lambda variable name to refer to properties of _the instance or of_ members of the collection identified by the navigation path.\n\n...\n\nOther path expressions in the Boolean expression neither prefixed with the lambda variable nor $it are evaluated in the scope of the _instance or members of the_ collection <del>instances</del> at the origin of the navigation path prepended to the lambda operator.\n\nImported from [ODATA-1456](https://issues.oasis-open.org/browse/ODATA-1456)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Deprecate media entities in next minor version, and remove them in next major version",
    "body": "Media entities are left-overs from AtomPub, offer no benefit over entities with stream properties, are a constant source of confusion (when to use which), and need a lot of special rules and specification text.\n\nBetter get rid of them altogether.\n\n### Proposal\n\nDeprecate media entities in V4.02\n\nRemove media entities in V5\n\nImported from [ODATA-1455](https://issues.oasis-open.org/browse/ODATA-1455)",
    "labels": [
      "Protocol"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow upserts against media entities",
    "body": "Section 11.4.4 in protocol mentions that upserts are not supported against media entities and, more importantly, that services MUST fail an update request to a URL that would identify such an entity if it does not exist.\nGiven the fact that the service can't be using service-generated keys for these entities and the client apparently already knows how to compose/identify the individual media entities in such collection, why not allow upserts as well?\n\nPS Also noted that in v4.01 we've added \"single-valued non-containment navigation properties\" to the exclusions list as well. Couldn't quickly recall/figure out the issue but shouldn't that only be if there is no navigation property binding?\n\n### Proposal\n\nAllow a service to support upserts against media entities if and only if the media resource is inlined as a `$value` pseudo-property according to [JSON Format, 10. Media Entity](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_MediaEntity).\n\nImported from [ODATA-1454](https://issues.oasis-open.org/browse/ODATA-1454)",
    "labels": [
      "Protocol",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "search('text') instead of search(text)",
    "body": "The current definition of the `search` transformation has no escaping mechanism so that one cannot search for a closing parenthesis, because `search())` gives a syntax error.\n\n### Proposal\n\nAdd a statement to [OData-Aggr, section 3.14]:\n> Closing parentheses in search expressions must be within single or double quotes in order to avoid syntax errors like `search())`.\n> \n\n\nImported from [ODATA-1452](https://issues.oasis-open.org/browse/ODATA-1452)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Rephrase definitions for any, all and aggregate",
    "body": "The current specification of the `aggregate` function ([ODATA-1244](https://issues.oasis-open.org/browse/ODATA-1244)) leaves undefined what the \"input collection\" is in cases like\n```java\n$filter=Sales/any(p:aggregate(p/Amount mul TaxRate with sum) gt 5) \n```\nthat include property paths with and without lambda variable.\n\n### Proposal\n\n* The `aggregate` function is considered a [`collectionPathExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L556-L561) (rather than a `methodCallExpr`) and must be prepended with a navigation path that addresses the input collection (in the sense of [ODATA-1244](https://issues.oasis-open.org/browse/ODATA-1244)). In the argument of the `aggregation` function, common expressions are evaluated according to the rules for [lambda operators](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_LambdaOperators). (The lambda variable evaluates to the current instance within the addressed collection, whereas an unprefixed `Amount` would be evaluated in the context of the `Products` instance currently being filtered.)\n```java\nProducts?$filter=Sales/aggregate(s:s/Amount mul TaxRate with sum) gt 100```\n\n- Instead of a navigation path, the input collection can also be addressed by the keyword `$these`. A new kind of `[{{propertyPathExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L516-L523)}} is introduced in which `$these` addresses the \"current collection\" (defined below), in analogy with the current instance `$this` [OData-URL, section 5.1.1.14.6]. The current collection is also at the origin of the path `$these`, therefore `s/Amount` could be replaced by `Amount` in the following example.\n```java\nSales?$apply=groupby((Product),filter($these/aggregate(s:s/Amount) lt 100))```\n\n- `$these` can be prepended to collection path expressions like `any`, `all` and `aggregate`. (But we allow only `$these/aggregate` for now, so as not to touch the core spec.) See also [ODATA-1456](https://issues.oasis-open.org/browse/ODATA-1456).\n- In a system query option (possibly nested within `$expand` or `$select`), when evaluating the `boolCommonExpr` in a [`filter`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L313) or the `commonExpr` in an [`orderbyItem`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L316) or [`computeItem`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L281), the current collection is the collection being filtered or ordered or augmented.\n```java\nProducts?$select=Sales($filter=$these/aggregate(s:Price with avg) gt $this/Price)\n```\n\n- In an `$apply` transformation, when evaluating the `boolCommonExpr` in a [`filterTrafo`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-aggregation-abnf.txt#L145) or the `commonExpr` in a [`computeExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-aggregation-abnf.txt#L129), the current collection is the input set of the transformation.\n- When evaluating a `commonExpr` in its nearest [`collectionPathExpr`](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L556-L561), the current collection is the collection identified by the navigation path before the `collectionPathExpr`. This allows things like\n```java\nProducts?$filter=Sales/any(p:p/Amount gt $these/aggregate(q:Amount))\n```\n\nSee also [oasis-tcs/odata-abnf#37](https://github.com/oasis-tcs/odata-abnf/pull/37).\n\nThe third paragraph in [OData-Aggr, section 3.24 \"Function aggregate\"] must be rewritten to reflect the rules above. The `$these` keyword and \"current collection\" concept introduced in these rules are not mentioned outside of that section for now. See [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/69074/[ODATA-1451](https://issues.oasis-open.org/browse/ODATA-1451).docx]\n\nImported from [ODATA-1451](https://issues.oasis-open.org/browse/ODATA-1451)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Key with PropertyRef using navigation path incompatible with Protocol 11.4.2 \"Create an Entity\"",
    "body": "Consider this CSDL.\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<edmx:Edmx Version=\"4.01\" xmlns:edmx=\"http://docs.oasis-open.org/odata/ns/edmx\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://docs.oasis-open.org/odata/ns/edmx http://docs.oasis-open.org/odata/odata/v4.0/os/schemas/edmx.xsd http://docs.oasis-open.org/odata/ns/edm http://docs.oasis-open.org/odata/odata/v4.0/os/schemas/edm.xsd\">\n    <edmx:DataServices>\n        <Schema Namespace=\"example\" xmlns=\"http://docs.oasis-open.org/odata/ns/edm\" Alias=\"Self\">\n            <EntityType Name=\"Customer\">\n                <Key>\n                    <PropertyRef Name=\"ID\"/>\n                </Key>\n                <Property Name=\"ID\" Type=\"Edm.Int32\" Nullable=\"false\"/>\n                <NavigationProperty Name=\"Photo\" Type=\"Self.CustomerPhoto\" Partner=\"Customer\">\n                    <OnDelete Action=\"Cascade\"/>\n                </NavigationProperty>\n            </EntityType>\n            <EntityType Name=\"CustomerPhoneNumber\">\n                <Key>\n                    <PropertyRef Name=\"Customer/ID\" Alias=\"CustomerID\"/>\n                </Key>\n                <Property Name=\"PhoneNumber\" Type=\"Edm.String\" Nullable=\"false\"/>\n                <NavigationProperty Name=\"Customer\" Type=\"Self.Customer\" Nullable=\"false\"/>\n            </EntityType>\n            <EntityContainer Name=\"CustomerService\">\n                <EntitySet Name=\"Customers\" EntityType=\"Self.Customer\">\n                    <NavigationPropertyBinding Path=\"Photo\" Target=\"CustomerPhotos\"/>\n                </EntitySet>\n                <EntitySet Name=\"CustomerPhoneNumbers\" EntityType=\"Self.CustomerPhoneNumber\">\n                    <NavigationPropertyBinding Path=\"Customer\" Target=\"Customers\"/>\n                </EntitySet>\n            </EntityContainer>\n        </Schema>\n    </edmx:DataServices>\n</edmx:Edmx>\n```\nIf a client sends this request:\n\n```js\nPOST /CustomerPhoneNumber\n\n{\"Customer\":{\"ID\":123},\"PhoneNumber\":\"+18001234567\"}\n```\n\nthen per Protocol 11.4.2 \"Create an Entity\":\n\n*The entity representation MAY include references to existing entities as well as content for new related entities, but MUST NOT contain content for existing related entities.*\n\n... the above POST request MUST be interpreted as a deep insert. The client cannot portably create a CustomerPhoneNumber (except via a bind operation) as any attempt to specify its key (via the customer it relates to) will be interpreted as a deep insert.\n\nIf we were to relax the language in section 11.4.2 to allow an interpretation of relating a CustomerPhoneNumber to an existing Customer (rather than also creating the Customer by deep insert), then the specification is now ambiguous in regard to the correct interpretation of the above example payload.\n\nSimilar issues apply to 11.4.3.1 \"Update Related Entities When Updating an Entity\"\n\n*If a nested entity has the same id or key fields as an existing entity, the existing entity is updated according to the semantics of the PUT or PATCH request.*\n\nUsing the same payload for updating an existing CustomerPhoneNumber by PUT (in an attempt to link the photo to a different Customer) would be interpreted as a deep update to PUT the newly related customer (clearing its non-key properties, if any).\n\nThe key point of discussing the issue is to work out how to discourage implementers from treating inline relationships (with only the related entity's key) as a substitute for bind operations while at the same time not implementing bind operations the standard way.\n\n### Proposal\n\nExtend examples 76 and 77 in section [11.4.2.1 Link to Related Entities When Creating an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_LinktoRelatedEntitiesWhenCreatinganE) to also show a to-one association:\n\n> \n> _Example 76: using the JSON format, 4.0 clients can create a new manager entity with links to existing employees by applying the `odata.bind` annotation to the `Manager` and `DirectReports` navigation properties_\n> ```json\n> {\n>   \"@odata.type\":\"#Northwind.Manager\",\n>   \"ID\": 1,\n>   \"FirstName\": \"Pat\",\n>   \"LastName\": \"Griswold\",\n>   \"Manager@odata.bind\": \"http://host/service/Employees(0)\",\n>   \"DirectReports@odata.bind\": [\n>     \"http://host/service/Employees(5)\",\n>     \"http://host/service/Employees(6)\"\n>   ]\n> }\n> ```\n> \n> _Example 77: using the JSON format, 4.01 clients can create a new manager entity with links to existing employees by including the entity-ids within the `Manager` and `DirectReports` navigation properties_\n> ```json\n> {\n>   \"@type\":\"#Northwind.Manager\",\n>   \"ID\": 1,\n>   \"FirstName\": \"Pat\",\n>   \"LastName\": \"Griswold\",\n>   \"Manager\": { \"@id\": \"Employees(0)\" },\n>   \"DirectReports\": [\n>     {\"@id\": \"Employees(5)\"},\n>     {\"@id\": \"Employees(6)\"}\n>   ]\n> }\n> ```\n> \n\n\n\nImported from [ODATA-1450](https://issues.oasis-open.org/browse/ODATA-1450)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Split nest into three transformations",
    "body": "The `nest` transformation introduced with [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404) is too overloaded. Suggestion to split this into three transformations:\n- `nest(trans1 as alias1, ....)` as it was before [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404)\n- `transformnested(path, trans)` for one transformation without alias\n- `addnested(path, trans1 as alias1, ...)` for one or more transformations with alias.\n\n### Proposal\n\nhttps://www.oasis-open.org/apps/org/workgroup/odata/download.php/68838/[ODATA-1449](https://issues.oasis-open.org/browse/ODATA-1449).docx, sections 3.12, 3.13 and related examples\n\nAll examples with `transformnested` or `addnested` now have an `$expand` option in order to output the nested navigation property (mostly, `Sales`).\n\nImported from [ODATA-1449](https://issues.oasis-open.org/browse/ODATA-1449)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Re-allow CustomAggregate and ApplySupported targeting EntityType",
    "body": "At SAP, entity types carrying these annotations are not re-used across containers, therefore annotating the types directly is sufficient and simpler.\n\nThe alternatives (targeting EntitySets and Collections) would remain valid.\n\n### Proposal\n\nAddition to the `Core.AppliesViaContainer` tag:\n\nServers that apply the tagged term based solely on the entity type, structural or navigation property, independently of the container MAY additionally annotate the `EntityType`, `Property` or `NavigationProperty` model element in order to facilitate the annotation consumption by OData clients.\n\nSee also [PR #137](https://github.com/oasis-tcs/odata-vocabularies/pull/137).\n\nAfter reopening, see also [PR #153](https://github.com/oasis-tcs/odata-vocabularies/pull/153).\n\nImported from [ODATA-1448](https://issues.oasis-open.org/browse/ODATA-1448)",
    "labels": [
      "Data Aggregation",
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify applicability of terms Core.MediaType and Core.MediaAcceptableMediaType",
    "body": "Type definition [JSON.JSON](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.JSON.V1.xml#L75) from the the JSON vocabulary is annotated with terms [Core.MediaType](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L402) and [Core.AcceptableMediaTypes](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L397) from the Core vocabulary.\n\nIssues:\n1. The list of applicable model elements for both terms lacks TypeDefinition\n1. Along these lines, both terms should also be applicable to parameters and return types of functions and actions\n1. The description of Core.MediaType does not mention stream properties\n\n### Proposal\n\n* Add TypeDefinition to AppliesTo of terms [Core.MediaType](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L402) and [Core.AcceptableMediaTypes](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L397)\n  - Add the semantics of such an application to the description: The annotation of a TypeDefinition propagates to the model elements having this type\n- Add Parameter and ReturnType to AppliesTo of terms [Core.MediaType](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L402) and [Core.AcceptableMediaTypes](https://github.com/oasis-tcs/odata-vocabularies/blob/053724df1ab5d19cc198f2a52cf8a85a2be08d79/vocabularies/Org.OData.Core.V1.xml#L397)\n- Mention stream properties in the description of Core.MediaType\n\nImported from [ODATA-1447](https://issues.oasis-open.org/browse/ODATA-1447)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify usage of Edm.Stream-typed function and action return types",
    "body": "*1. Edm.Stream-typed function parameters in URLs*\n\nToday, the option to pass a value to an Edm.Stream-typed parameter in a request addressing a function import requires to look at different places and combine the individual steps (analogous for function calls):\n- Section on [Addressing Functions](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360941) in the URL conventions spec refers to certain ABNF rules (e.g., `primitiveFunctionImportCall`) that eventually lead to either rule `parameterAlias` or `primitiveLiteral`.\n- Following `parameterAlias`, section [5.3 Parameter Aliases](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#_Toc31361051) in the same spec explains the relation to ABNF rule `aliasAndValue`, which finally gets us to `parameterValue` with `arrayOrObject` as one of the options.\n- Section [5.1.1.14.2 Complex and Collection Literals](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#_Toc31361029) in the same spec defines the use of this ABNF rule `arrayOrObject` for complex and collection literals, but not for JSON documents as values of Edm.Stream-typed properties.\n- So, the only escape is to go the other route and use `commonExpr`, which is the other choice for `arrayOrObject`. This can become a `primitiveValue`, which includes a [comment](https://github.com/oasis-tcs/odata-abnf/blob/513b5bd1319d3093491d76a30ea91ded619b9e5a/abnf/odata-abnf-construction-rules.txt#L930) that strings can be used for JSON documents\n- So, finally we have found a rule to pass such a stream value\n\nIt should be discussed if the consumption of this feature could be simplified by making it more explicit in the URL conventions spec.\n\n \n\n*2. Edm.Stream-typed action parameters in request body and function and action* *return types* *in response body*\n\nSection [9        Stream Property](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457765) in the JSON Format spec defines the representation of stream _properties_ of media type JSON. It should be clarified that these rules are also applicable to function and action parameters as well as return types.\n\n \n\n \n\n \n\n### Proposal\n\nAdd to Protocol:\n- Return type Edm.Stream has same behavior as Stream properties: return content-type and raw octet-stream according to content-type, allow content negotiation via Accept.\n\n \n\nImported from [ODATA-1446](https://issues.oasis-open.org/browse/ODATA-1446)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow applying JSON.Schema to any model element that can be typed with Edm.Stream",
    "body": "The term JSON.Schema can be applied to model elements of type Edm.Stream that can contain \"raw\" JSON.\n\nThe current restriction to \"Property\" is an accident, it can also be applied to terms, type definitions, parameters, and return types.\n\nImported from [ODATA-1445](https://issues.oasis-open.org/browse/ODATA-1445)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "groupby algorithm does not cover \"select distinct\" case",
    "body": "The four-step algorithm given at the beginning of the groupby transformation does not describe what happens for `Products?$apply=groupby((Category))`. According to a later remark, this is supposed to select only the distinct `Categories`. But, after step 1, I have two subsets\n||ID||Category||Name||Color||TaxRate||\n|P1|PG1|Sugar|White|0.06|\n|P2|PG1|Coffee|Brown|0.06|\n\nand\n||ID||Category||Name||Color||TaxRate||\n|P3|PG2|Paper|White|0.14|\n|P4|PG2|Pencil|Black|0.14|\n\nStep 2 cannot be carried out due to lack of a second parameter. Step 3 has no effect. Step 4 concatenates these two subsets again, so that the overall effect is of `groupby((Category),identity)`.\n\nTo keep the case without second parameter within the four-step framework, step 2 must essentially produce an instance without properties, leading to subsets\n||ID||Category||Name||Color||TaxRate||\n| | | | | |\nand\n||ID||Category||Name||Color||TaxRate||\n| | | | | |\n\nwhich step 3 would then change to\n||ID||Category||Name||Color||TaxRate||\n| |PG1| | | |\nand\n||ID||Category||Name||Color||TaxRate||\n| |PG2| | | |\n\n### Proposal\n\nAdd a _sentence_ to step 2 of the four-step algorithm:\n\nApplies set transformations to each subset according to the second parameter, resulting in a new set of potentially different structure and cardinality. _If the second parameter is absent, transforms each subset into a set consisting of a single instance without properties,_\n\nRephrase the later remark about \"select distinct\":\n\n_If_ the second parameter <del>can be</del> _is_ omitted, _steps 2 and 3 produce one instance containing only the grouping properties per_ <del>to request</del> distinct value combination of the grouping properties.\n\nImported from [ODATA-1444](https://issues.oasis-open.org/browse/ODATA-1444)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Aggregation vocabulary: Create container-level term for ApplySupported defaults",
    "body": "Currently, term ApplySupported can also be applied to entity containers, which the semantics that its settings propagate to all sets in the container except for those with their own annotation.\n\nA similar topic is discussed in [ODATA-1412](https://issues.oasis-open.org/browse/ODATA-1412), where the approach is to introduce a dedicated term for specifying set capabilities at container-level that describes only the common capabilities and does not reference individual properties of the sets.\n\nThe ways to describe core and aggregation capabilities at container level should be aligned.\n\n### Proposal\n\n* Create new term at container with all settings from existing terms that do not reference individual properties:\n- Refactor the existing complex types used by the existing terms to be derived from base types used for the properties of the new container-level term.\n- naming pattern for container-level types: <name>Base instead of proposed Common<name>Type\n\nImported from [ODATA-1443](https://issues.oasis-open.org/browse/ODATA-1443)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Update Aggregation ABNF with changes from previous issues",
    "body": "ABNF of Data Aggregation does not reflect current list of transformations defined in the specification.\n\nLikewise, test cases need to be updated.\n\nImported from [ODATA-1442](https://issues.oasis-open.org/browse/ODATA-1442)",
    "labels": [
      "ABNF",
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Aggregation.CustomAggregate applies to ComplexType still needed?",
    "body": "[https://github.com/oasis-tcs/odata-vocabularies/blob/58a00289375e83f577661c18d2025dbb45e58e35/vocabularies/Org.OData.Aggregation.V1.xml#L167-L168]\n\nAggregation.CustomAggregate has AppliesTo=\"ComplexType\", however, this contradicts what is stipulated by the Core.AppliesViaContainer tag.\n\n### Proposal\n\n[PR #124](https://github.com/oasis-tcs/odata-vocabularies/pull/124): Remove AppliesTo=\"ComplexType\"\n\nImported from [ODATA-1440](https://issues.oasis-open.org/browse/ODATA-1440)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve descriptions of property restrictions in term Aggregation.ApplySupported",
    "body": "[ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382) changed applicability of term `ApplySupported` from schema level to instances. Two new properties `GroupableProperties` and `AggregatableProperties` were added to its structure, and as a consequence, the property `PropertyRetrictions` and the terms `Groupable` and `Aggregatable` were deprecated.\n\nProblem is that the descriptions of these new properties `GroupableProperties` and `AggregatableProperties` still refer to the deprecated `PropertyRetrictions`. This causes confusion how to interpret their meaning in case an annotation omits the deprecated property.\n\n### Proposal\n\nMake the descriptions of these two properties independent from `PropertyRestrictions`.\n\nNew descriptions:\n- A non-empty `GroupableProperties` indicates that only the listed properties of the annotated target are supported by the groupby transformation\n- A non-empty `AggregatableProperties` indicates that only the listed properties of the annotated target can be used in the aggregate transformation together with the optionally specified restrictions on supported aggregation methods.\n\nReflect this change in the specification and in the vocabulary.\n\nImported from [ODATA-1439](https://issues.oasis-open.org/browse/ODATA-1439)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "11.4.9.4 Update a Collection Property: reference section 11.4.11 Positional Inserts",
    "body": "Section 11.4.9.4 [Update a Collection Property](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_UpdateaCollectionProperty) also describes inserting into a collection. The current description partially overlaps with the content of section 11.4.11 [Positional Inserts](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_PositionalInserts) and does not reference this section.\n\n \n\n### Proposal\n\nAdd a reference and align the text.\n> A successful POST request to the edit URL of a collection property adds an item to the collection. The body of the request MUST be a single item to be added to the collection. If the collection is ordered, the item is added to the end of the collection, and <ins>if the collection supports [positional insert](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_PositionalInserts)</ins> $index MAY be used to specify +the insert position+-a zero-based ordinal position to insert the new value, with a negative value indicating an ordinal position from the end of the collection-.\n> \n\nExplicitly mention that the success response for return=representation is the after-image of the collection, same as for a GET request to the collection property.\n> Upon successful completion the service responds with either [200 OK](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ResponseCode200OK) <ins>and a representation of the updated collection,</ins> or [204 No Content](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_ResponseCode204NoContent). The client may request that the response SHOULD include a body by specifying a [Prefer header](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_Preferencereturnrepresentationandret) with a value of [return=representation](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_Preferencereturnrepresentationandret).\n> \n\n \n\nImported from [ODATA-1437](https://issues.oasis-open.org/browse/ODATA-1437)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "List of recommended navigation property bindings is incomplete.",
    "body": "Section 13.4 Navigation Property Binding  \nlists the cases when a navigation property binding should be provided:\n\n\n _An [entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet) or a [singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton) SHOULD contain a navigation property binding for each [navigation property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_NavigationProperty) of its entity type, including navigation properties defined on complex typed properties._\n\nIt does not state that a navigation property binding should also be provided for navigation properties reached through a chain of type casts, complex properties, or containment navigation properties.\n\nSection 13.4.1 does explain what are legal Paths but the section 13.4 seems to limit the need to declare the binding it to navigation properties of only the type of the entity set or singleton. \n\n### Proposal\n\nChange \n\n_An [entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet) or a [singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton) SHOULD contain a navigation property binding for each [navigation property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_NavigationProperty) of its entity type, including navigation properties defined on complex typed properties._\n\nto\n\n_An [entity set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_EntitySet) or a [singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Singleton) SHOULD contain a navigation property binding for each non-containment navigation property that can be reached from the entity type through a sequence of type casts, complex properties, or containment navigation properties._\n\nImported from [ODATA-1434](https://issues.oasis-open.org/browse/ODATA-1434)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify applicability of lambda operators to complex-typed collections",
    "body": "The URL Conventions spec describes in [5.1.1.13 Lambda Operators](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361024) that lambda operators are applicable to  instances of a collection addressed by a navigation path.\n\nI couldn't find a definition of navigation path in any of the specification documents. If my assumption that it is a property path ending in a navigation property is correct, then the description is too restrictive, because lambda operators are actually intended to be applied to all sorts of collections: entity-, complex- and primitive collections.\n\n### Proposal\n\n1. occurrence:\n\nBoth must be prepended with a path expression that identifies a collection.\n\n2. occurrence: identified by the path expression\n\n3. occurrence: ...origin of the path expression...\n\n \n\nImported from [ODATA-1433](https://issues.oasis-open.org/browse/ODATA-1433)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify wording in Section 7.2, Type Facets",
    "body": "Section 7.2, Type Facets, describes the use of applying facets to types when used in property definitions. Unfortunately, the same section is used to describe the application of facets, for example, in a Term definition.  When referenced from a term definition, the usage of the word \"property\" is confusing.\n\n### Proposal\n\nFix ambiguity in wording in Section 7.2, Type Facets, to clarify that it applies to the usage of the type regardless of whether it is part of a property definition, term definition, parameter/return type definition, type definition, etc.\n\nImported from [ODATA-1432](https://issues.oasis-open.org/browse/ODATA-1432)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Standard vocabulary does not always specify Nullable for collection typed properties",
    "body": "[Section 7.2]([OData Common Schema Definition Language (CSDL) XML Representation Version 4.01 (oasis-open.org)|https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Nullable)] states\n\n_In OData 4.01 responses a collection-valued property MUST specify a value for the Nullable attribute._\n \nSome standard annotations don't follow the specification.\n\n\n \n```java\nvocabularies\\Org.OData.Capabilities.V1.xml:    452:         <Property Name=\"FilterExpressionRestrictions\" Type=\"Collection(Capabilities.FilterExpressionRestrictionType)\"    453:     977:       <Term Name=\"CustomHeaders\" Type=\"Collection(Capabilities.CustomParameter)\" AppliesTo=\"EntityContainer\">    978:         <Annotation Term=\"Core.Description\" String=\"Custom headers that are supported/required for the annotated resource\" />       984:    1005:       <Term Name=\"CustomQueryOptions\" Type=\"Collection(Capabilities.CustomParameter)\" AppliesTo=\"EntityContainer\">   1006:         <Annotation Term=\"Core.Description\" String=\"Custom query options that are supported/required for the annotated resource\" />      1014:  \n vocabularies\\Org.OData.Validation.V1.xml:   152:       <Term Name=\"AllowedTerms\" Type=\"Collection(Core.QualifiedTermName)\" AppliesTo=\"Term Property\">   153:         <Annotation Term=\"Core.Description\" String=\"Annotate a term of type Edm.AnnotationPath, or a property of type Edm.AnnotationPath that is used within a structured term, to restrict the terms that can be targeted by the path.\" /> \n   158:       <Term Name=\"ApplicableTerms\" Type=\"Collection(Core.QualifiedTermName)\">   159: ```\n\nImported from [ODATA-1431](https://issues.oasis-open.org/browse/ODATA-1431)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify handling of null values for complex-typed properties",
    "body": "The JSON Format specification describes in section [7.1 Primitive Value](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457753) how a null value is represented for a property of primitive type. However, an analogous description is not provided in section [7.2 Complex Value](http://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#_Toc38457754). \n\nThe case of complex-typed properties having null values is intended as the URL Conventions specification describes in  [5.1.1.1.1 Equals](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360958) how the eq-operator works for such properties to test against the null value.\n\nHence it seems to be a gap that section 7.2 of the JSON Format document does not explicitly mention null values.\n\n### Proposal\n\nAdd the sentence from section 7.1 in the JSON Format document also to section 7.2: \"Null values are represented as the JSON literal null.\"\n\nImported from [ODATA-1430](https://issues.oasis-open.org/browse/ODATA-1430)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify applicability of $expand options",
    "body": "In the protocol specification, section [11.2.5.2.1 Expand Options](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358944) lists applicable system query options without considering whether a single-valued or a collection-valued navigation property is expanded. In section [11.2.5.2.1.1     Expand Option $levels](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358945)  the statement that \"same expand options are applied at each level of the hierarchy\" is obviously not completely true. It has to be \"all but $levels\".\n\nThe URL conventions specification is not in sync: Section [5.1.3 System Query Option $expand](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31361039), in the text after example 115, lists only a subset of the allowed system query options.\n\n### Proposal\n\nProtocol spec:\n- Add to section [11.2.5.2.1 Expand Options](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358944): Allowed system query options are $select, $expand, and $compute, as well as $filter, $orderby, $skip, $top, $count, $search, and $levels for collection-valued navigation properties.\n- Rephrase section [11.2.5.2.1.1     Expand Option $levels](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358945): \"All provided expand options except $levels are applied ...\"\n\n \n\nURL conventions spec:\n Allowed system query options are $select, $expand, and $compute, as well as $filter, $orderby, $skip, $top, $count, $search, and $levels for collection-valued navigation properties.\n\nImported from [ODATA-1429](https://issues.oasis-open.org/browse/ODATA-1429)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Definition of service-specific client-side functions",
    "body": "According to [OData-CSDL, section 14.4.4](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ApplyClientSideFunction) services can define client-side functions outside the `odata` namespace.\n- Can they be defined like server-side functions, through `edm:Function`? (I think yes, because the client should be able to delegate their execution to the server.)\n- Does `edm:Function` need an attribute `ClientSide=\"true\"`? (I think yes, if this means: can _only_ be executed by the client.)\n- Or perhaps a new core annotation (no need to wait for the next CSDL version):\n```xml\n<Term Name=\"ClientSideOnly\" AppliesTo=\"Function\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"true\">\n <Annotation Term=\"Core.Description\" String=\"Client-side function as in [OData-CSDL, section 14.4.4](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_ApplyClientSideFunction) that cannot be executed by the server\"/>\n <Annotation Term=\"Core.LongDescription\" String=\"A function without this tag can also occur as a client-side function in an apply expression for an annotation. The client can then delegate the execution to the server by `$compute`-ing the function.\"/>\n</Term>\n```\nBut such a tag is dangerous, since clients that do not understand might wrongly invoke the function on the server.\n\nA function without this tag can occur in an annotation that is contributed by a proxy between OData client and server. Continuing the example from [ODATA-1420](https://issues.oasis-open.org/browse/ODATA-1420), assume the proxy contributes the following annotation:\n```xml\n<Schema Namespace=\"SalesOrderServer\">\n <EntityType Name=\"SalesOrderItem\">\n  <Property Name=\"Pieces\" Type=\"Edm.Int\"/>\n  <Property Name=\"Price\" Type=\"Edm.Decimal\"/>\n  <Annotation Term=\"PAngV.PriceSection2\">\n   <Apply Function=\"SalesOrderServer.PricePerPiece\">\n    <Path>Price</Path>\n    <Path>Pieces</Path>\n   </Apply>\n  </Annotation>\n </EntityType>\n</Schema>```\nThe proxy would then convert the request\n```java\nGET ~/SalesOrderItems?$select=ItemNo,@PAngV.PriceSection2\n```\ninto\n```java\nGET ~/SalesOrderItems?$select=ItemNo\n&$compute=SalesOrderServer.PricePerPiece(Price=Price,Pieces=Pieces) as PriceSection2\n```\nforward the converted request to the SalesOrderServer and rename JSON property `PriceSection2` to `@PAngV.PriceSection2` in the response, effectively handling the instance annotation `@PAngV.PriceSection2` like an additional property.\n\nThis examples assumes that the `SalesOrderServer.PricePerPiece` function is implemented on the server. If the server declared that function ClientSideOnly, or if the function was contributed by the proxy instead, then the proxy would send the following metadata to the client:\n```xml\n<Schema Namespace=\"SalesOrderServer\"> <!-- namespace of server -->\n <EntityType Name=\"SalesOrderItem\">\n  <Property Name=\"Pieces\" Type=\"Edm.Int\"/>\n  <Property Name=\"Price\" Type=\"Edm.Decimal\"/>\n  <Annotation Term=\"PAngV.PriceSection2\">\n   <Apply Function=\"PAngV.PricePerPiece\">\n    <Path>Price</Path>\n    <Path>Pieces</Path>\n   </Apply>\n  </Annotation>\n </EntityType>\n</Schema>\n<Schema Namespace=\"PAngV\"> <!-- namespace of proxy -->\n <Function Name=\"PricePerPiece\">\n  <Annotation Term=\"Core.ClientSideOnly\" Bool=\"false\"/>\n  ...\n </Function>\n</Schema>\n```\nand the proxy would request\n```java\nGET ~/SalesOrderItems?$select=ItemNo,Price,Pieces\n```\nfrom the server and perform the computation of `@PAngV.PriceSection2` itself.\n\nImported from [ODATA-1428](https://issues.oasis-open.org/browse/ODATA-1428)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify treatment of duplicates in OData-Aggr example 7",
    "body": "Example 7 in the [`aggregate ... as` specification](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016569) leaves unclear whether entities that are reachable via more than one instance path are considered once during aggregation or as often as they are reachable.\n\nDoes\n```java\nGET CainAndAbel?$apply=aggregate(Parents($count as c))\n```\ncount Adam and Eve once or twice ([https://www.bibleserver.com/KJV/Genesis4])? Is the result\n```java\n\"Parents\": [{\"c\": 2}]\n```\nor 4?\n\n### Proposal\n\nModify the relevant part of the specification as follows (deletions are striked out, insertions are in italics or indented). To be discussed whether the fifth alternative (the {color:#57d9a3}green{color} text) can be abolished and remove example 7. TC agrees to abolish it on 2021-06-10.\n\nThe aggregate transformation takes a comma-separated list of one or more aggregate expressions as parameters and returns a result set with a single instance, representing the aggregated value for <del>all instances in</del> the input set.\n> In the following, P is a path made up of navigation properties, complex properties, and complex collection properties.\n> \n\nAn aggregate expression may be:\n- an aggregatable expression on the input set with a specified aggregation method,\n- an aggregatable property that can be reached via a path _P_ <del>consisting of a sequence of navigation properties, complex properties and complex collection properties,</del> with a specified aggregation method,\n- a custom aggregate that can be reached via a path _P_ <del>consisting of a sequence of navigation properties, complex properties and complex collection properties,</del> - any of the above, followed by a from expression,\n- <del>any of the above, enclosed in parentheses and prefixed with a navigation path to related entities, which serve as input set for the enclosed aggregate expression,</del> - $count, which is a shortcut for the expression 1 with sum\n\n> If P is present, it must be well-defined for all instances in the input set. Let Q be the portion of P up to and including the last navigation property, if any, and let R be the remainder, if any, of P that contains no navigation properties, such that P equals the concatenated path Q/R. The aggregate transformation considers each entity reached via the path Q exactly once. To this end\n> - if Q is non-empty, let E be the set of distinct entities reached via Q starting from the input set\n> - if Q is empty, let E be the input set (which may contain multiple instances with the same value).\n> \n> Then, if R is empty, the aggregated value is computed for all instances in E, otherwise the aggregated value is computed for all instances addressed via R starting from E.\n> \n> If no paths are present, the aggregated value is computed for all instances in the input set.\n> \n\nAny aggregate expression that specifies an aggregation method MUST define an alias for the resulting aggregated value. The resulting instance contains one dynamic property per parameter representing the aggregated value <del>across all instances within the input set-. -If paths are present, the corresponding navigation properties are implicitly expanded to make the properties part of the result representation.</del> > The properties of P do not appear in the result (cf. example 59, with P = Q = Sales and R = empty).\n> \n\n\nImported from [ODATA-1427](https://issues.oasis-open.org/browse/ODATA-1427)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow marking properties as required on insert or update",
    "body": "Some APIs need to tell clients that certain properties must be provided in create or update requests.\n\n### Proposal\n\nAdd property `RequiredProperties` to insert- and update-restrictions\n\nImported from [ODATA-1425](https://issues.oasis-open.org/browse/ODATA-1425)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Check uniform handling of entities reached via navigation in responses",
    "body": "When a transformation adds entities reached via navigation to its result, the request must specifically ask to expand them in order to have them appear in the response.\n\nExample from [ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409) that triggered the discussion: The join transformation in\n\n`GET ~/Products?$apply=join(Sales as Sale`) creates a `Sale` dynamic property with Sales instances as values which are entities. Another `$expand=Sale` is required to include these entities in the response.\n\nCross-check this with other cases such that all behave in the same way:\n- transformation `nest` that can be used to add related entities to the input set\n- transformation `groupby` applied to single-valued navigation properties (see [ODATA-971](https://issues.oasis-open.org/browse/ODATA-971))\n- transformation `aggregate` on related entities (see [ODATA-945](https://issues.oasis-open.org/browse/ODATA-945))\n\n### Proposal\n\n1. Rephrase wording in section 3 to have clear definitions referenced throughout the text:\n\n- input set  for the input of a transformation\n- output set for the result of a transformation\n- the final result of the $apply option is the output set of the last transformation\n\n2. Add general remark for the whole $apply section 3: Navigation properties in the final result set are carried over to the final result of the $apply option. Navigation properties in this final result can be further expanded using $expand. \n\n3. Section 3.1 and 3.12: Accompany \"mental bridge\" by more normative text. \n\nThe necessary text changes are provided in this [file](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68407/[ODATA-1423)(https://issues.oasis-open.org/browse/ODATA-1423).docx], marked with the ID of this issue as comments.\n\n\nImported from [ODATA-1423](https://issues.oasis-open.org/browse/ODATA-1423)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify $select behavior for stream properties",
    "body": "The $select behavior for stream properties is not explicitly stated.\n\nClarify whether property access to stream properties (e.g. `GET Entity(123)/Thumbnail`) is expected to be implemented by services.\n\n\n### Proposal\n\nJSON Format:\n- Stream properties requested with $select or included in the default selection are represented by their control information `odata.media*`.\n- Stream properties requested with $expand or implicitly expanded are represented as a property with its value.\n\nProtocol:\n- Services SHOULD support direct property access to a stream property's canonical URL (e.g. `GET Entity(123)/Thumbnail`). The response MAY be a redirect to the media read link of the stream property if the media read link is different from the canonical URL.\n- Note: if neither canonical URL nor media read link can be used and the stream value can only be accessed via $expand, the modeler should have used an Edm.Binary property instead.\n\nImported from [ODATA-1422](https://issues.oasis-open.org/browse/ODATA-1422)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add UpdateRestrictions property to specify update type",
    "body": "Clients can determine updatability by looking at the \"UpdateRestrictions\" capability annotation.  however, this annotation does not distinguish between PATCH and PUT.\n\n\n\n### Proposal\n\nAdd a new property to UpdateRestrictionsType to specify whether the service supports PATCH or PUT.  If not specified, PATCH Should be supported and PUT May be supported.\n\n```xml\n<Property Name=\"UpdateMethod\" Type=\"Capabilities.HttpMethod\" Nullable=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Supported HTTP Methods (PUT or PATCH) for updating an entity.  If null, PATCH SHOULD be supported and PUT MAY be supported.\" />\n</Property>\n\n<EnumType Name=\"HttpMethod\" IsFlags=\"true\">\n  <Member Name=\"GET\" Value = \"1\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP GET Method\" />\n  </Member>\n  <Member Name=\"PATCH\" Value = \"2\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP PATCH Method\" />\n  </Member>\n  <Member Name=\"PUT\" Value = \"4\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP PUT Method\" />\n  </Member>\n  <Member Name=\"POST\" Value = \"8\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP POST Method\" />\n  </Member>\n  <Member Name=\"DELETE\" Value = \"16\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP DELETE Method\" />\n  </Member>\n  <Member Name=\"OPTIONS\" Value = \"32\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP OPTIONS Method\" />\n  </Member>\n  <Member Name=\"HEAD\" Value = \"64\">\n    <Annotation Term=\"Core.Description\" String=\"The HTTP OPTIONS Method\" />\n  </Member>\n</EnumType>\n```\n\nImported from [ODATA-1421](https://issues.oasis-open.org/browse/ODATA-1421)",
    "labels": [
      "Vocabularies",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Path evaluation for annotations targeting annotations",
    "body": "[OData-CSDL, section \"Path evaluation\"](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_PathEvaluation) does not specify rules for annotations that target another annotation.\n\nImagine an annotation term `PAngV.PriceSection2` whose value is an amount.\n```xml\n<EntityType Name=\"SalesOrderItem\">\n <Property Name=\"Pieces\" Type=\"Edm.Int\"/>\n <Property Name=\"Price\" Type=\"Edm.Decimal\"/>\n <Annotation Term=\"PAngV.PriceSection2\">\n  <DivBy>\n   <Path>Price</Path>\n   <Path>Pieces</Path>\n  </DivBy>\n  <Annotation Term=\"Measures.ISOCurrency\">\n   <Path>Price/@Measures.ISOCurrency</Path>\n  </Annotation>\n </Annotation>\n</EntityType>\n```\nThis entity type computes the `PAngV.PriceSection2` as an annotation and wants to annotate this annotation with the corresponding currency. I would expect the evaluation of the path `Price/@Measures.ISOCurrency` to follow the rules for \"annotations embedded within a structural or navigation property of an entity type or complex type\", because the \"outer\" annotation has a primitive type and can thus be treated like a structural property.\n\nThis should be clarified in the specification.\n\n### Proposal\n\nh3. 14.4.1.2 Path Evaluation\n\nAnnotations MAY be embedded within their target, or specified separately, e.g. as part of a different schema, and specify a path to their target model element. The latter situation is referred to as _targeting_ in the remainder of this section.\n\nIf the value of an annotation is expressed dynamically with a path expression, the path evaluation rules for this expression depend on the _host of the annotation_ (roughly, the innermost model element other than an annotation) and its _hosting kind_ (roughly, embedded vs. targeting).\n- The host of an annotation embedded within or targeting another annotation or a collection, record or property value of another annotation is the host of that other annotation.\n- The host of an annotation embedded within or targeting another kind of model element is that model element.\n- The hosting kind of an annotation with external targeting whose target path starts with an entity container is \"container\".\n- The hosting kind of an annotation with external targeting whose target path starts with another kind of schema child is \"targeting\".\n- The hosting kind of an annotation embedded within another annotation or a collection, record or property value of another annotation is the hosting kind of that other annotation.\n- The hosting kind of an annotation embedded within another kind of model element is \"embedded\".\n\n||Host of annotation||Hosting kind||Path evaluation starts at||Remark||\n|Entity Container|container or embedded|the entity container|An empty path resolves to the entity container, and non-empty paths MUST start with a segment identifying a container child (entity set, function import, action import, or singleton). The subsequent segments follow the rules for path expressions targeting the corresponding child element.|\n|Entity Set or Singleton|container or embedded|the entity set or singleton|An empty path resolves to the entity set or singleton, and non-empty paths MUST follow the rules for annotations targeting the declared entity type of the entity set or singleton.|\n|Entity Type or Complex Type|embedded or targeting|the type|An empty path resolves to the type, and the first segment of a non-empty path MUST be a structural or navigation property of the type, a [type cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TypeCast), or a [term cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TermCast).|\n|Structural or navigation property|container|the declared type of the property|An empty path resolves to the declared type of the property, and non-empty paths MUST follow the rules for annotations targeting the declared type of the property. If the type is primitive, the first segment of a non-empty path MUST be a term cast or type cast.|\n|Structural or navigation property of an entity type or complex type|embedded|the directly enclosing type|This allows e.g. specifying the value of an annotation on one property to be calculated from values of other properties of the same type. An empty path resolves to the enclosing type, and non-empty paths MUST follow the rules for annotations targeting the directly enclosing type.|\n|Structural or navigation property of an entity type or complex type|targeting|the _outermost_ entity type or complex type named in the target|An empty path resolves to the outermost type, and the first segment of a non-empty path MUST be a structural or navigation property of the outermost type, a [type cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TypeCast), or a [term cast](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#ref_TermCast).|\n|Action, action import, function, function import, parameter, or return type|any|the action or function|The first segment of the path MUST be a parameter name or $ReturnType.|\n|Any other kind of model element|embedded|n/a|Path evaluation is not possible.|\n\nImported from [ODATA-1420](https://issues.oasis-open.org/browse/ODATA-1420)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Temporal",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Use of Core.ContentID by clients if service does not reference Core vocabulary",
    "body": "Section [11.4.2.2 Create Related Entities When Creating an Entity](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_CreateRelatedEntitiesWhenCreatinganE) states\n\n> \n> Clients MAY associate an id with individual nested entities in the request by using the Core.ContentID term defined in [OData-VocCore]. \n> \n\n\n1. Are clients allowed or even required to use an alias defined in the service's `$metadata`?\n1. Are clients allowed to use this annotation if the service does not reference the Core vocabulary? Should they then use the fully qualified term name `Org.OData.Core.V1.ContentID`? Or are services required to reference the Core vocabulary when they advertise this feature via `Capabilities.DeepInsertSupport`?\n\nNote-to-self: if we had placed the term `ContentID` in the Capabilities vocabulary, the problem wouldn't exist.\n\n### Proposal\n\nServices advertising \n```java\n@Capabilities.DeepInsertSupport:{ContentIDSupported:true}```\nMUST reference the Core vocabulary in their $metadata.\n\nClients MUST use either the namespace of the Core vocabulary or the alias defined by the service's reference as the qualifier of `ContentID`.\n\nImported from [ODATA-1419](https://issues.oasis-open.org/browse/ODATA-1419)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Capabilities.UpdateRestrictions lacks a NonUpdatableProperties",
    "body": "Term Capabilities.UpdateRestrictions allows to restrict updatability for entities as a whole and in addition to specify [NonUpdatableNavigationProperties](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Capabilities.V1.xml#L720). But it does not allow to specify NonUpdatableProperties.\n\nThis prevents use cases with such constraints where only a subset of an entity type's properties may be updated. Moreover, it doesn't match the expressiveness of Capabilities.InsertRestrictions allowing to specify NonInsertableProperties.\n\n \n\n### Proposal\n\nExtend term type Capabilities.[UpdateRestrictionsType](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Capabilities.V1.md#UpdateRestrictionsType) with property NonUpdatableProperties of type [PropertyPath]\n\nImported from [ODATA-1418](https://issues.oasis-open.org/browse/ODATA-1418)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Inconsistencies in OData-CSDL section 14.2.2",
    "body": "[14.2.2 Target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#_Toc31805592) contains the following variant for a target path:\n> qualified name of an entity container followed by a segment containing a singleton or entity set name and zero or more property, navigation property, or type-cast segments\n> \n\nThe necessary forward slashes are not mentioned.\n\n\n### Proposal\n\nh3. 14.2.2 Target\n\nThe target of an annotation is the model element the term is applied to.\n\nThe target of an annotation MAY be specified indirectly by “nesting” the annotation within the model element. Whether and how this is possible is described per model element in this specification.\n\nThe target of an annotation MAY also be specified directly; this allows defining an annotation in a different schema than the targeted model element.\n\nThis external targeting is only possible for model elements that are uniquely identified within their parent, and all their ancestor elements are uniquely identified within their parent. These are the direct children of a schema with a unique name (i.e. except actions and functions whose overloads to not possess a natural identifier), and all direct children of an entity container.\n||Model element||Can be targeted with path expression (see also section 14.4.1.1)||Example (from ex. 42)||\n|[Action](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Action) overload|qualified name of action followed by parentheses containing the binding parameter type of a bound action overload to identify that bound overload, or by empty parentheses to identify the unbound overload| |\n|all overloads of an [Action](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Action)|qualified name of action| |\n|[Action Import](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ActionImport)|qualified name of entity container followed by a segment containing the action import name| |\n|[Annotation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Annotation) on a model element|path expression identifying the model element followed by a segment containing an at (@) prepended to the qualified name of a term, optionally suffixed with a hash (#) and the qualifier of an annotation| |\n|[Complex Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ComplexType)|qualified name of complex type| |\n|[Entity Container](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EntityContainer)|qualified name of entity container| |\n|[Entity Set](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EntitySet)|qualified name of entity container followed by a segment containing the entity set name| |\n|[Entity Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EntityType)|qualified name of entity type| |\n|[Enumeration Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EnumerationType)|qualified name of enumeration type| |\n|[Enumeration Type Member](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_EnumerationTypeMember)|qualified name of enumeration type followed by a segment containing the name of a child element| |\n|[Function](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Function) overload|qualified name of function followed by parentheses containing the comma-separated list of the parameter types of a bound or unbound function overload in the order of their definition in the function overload| |\n|all overloads of a [Function](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Function)|qualified name of function| |\n|[Function Import](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_FunctionImport)|qualified name of entity container followed by a segment containing the function import name| |\n|[Navigation Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_NavigationProperty) via container|qualified name of entity container followed by a segment containing a singleton or entity set name and zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Navigation Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_NavigationProperty) via structured type|qualified name of structured type followed by zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Parameter](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Parameter)|qualified name of entity container followed by a segment containing an action or function import name followed by a segment containing a parameter name| |\n|[Parameter](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Parameter)|qualified name of action or function optionally followed by a parenthesized expression as in the first row followed by a segment containing the name of a child element| |\n|[Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_StructuralProperty) via container|qualified name of entity container followed by a segment containing a singleton or entity set name and zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Property](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_StructuralProperty) via structured type|qualified name of structured type followed by zero or more segments containing the name of a structural or navigation property, or a type-cast {color:#de350b}or term-cast{color}| |\n|[Return Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ReturnType)|qualified name of entity container followed by a segment containing an action or function import name followed by a segment containing `$ReturnType`| |\n|[Return Type](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_ReturnType)|qualified name of action or function optionally followed by a parenthesized expression as in the first row followed by a segment containing `$ReturnType`| |\n|[Singleton](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_Singleton)|qualified name of entity container followed by a segment containing a singleton name| |\n|[Type Definition](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_TypeDefinition)|qualified name of type definition| |\n\nAll [qualified names](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cos01/odata-csdl-xml-v4.01-cos01.html#sec_QualifiedName) used in a target path MUST be in scope.\n\nExternal targeting of structural and navigation properties is possible \"via container\", i.e., for properties of singletons or entities in a particular entity set {color:#de350b}or in annotations thereof{color}. These annotations targeted via container override annotations on the structural or navigation properties targeted via the declaring structured type.\n\nImported from [ODATA-1417](https://issues.oasis-open.org/browse/ODATA-1417)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Dynamic capabilities for containment cases",
    "body": "Capabilities are annotated on entity sets, and for \"nested\" / contained entities they are expressed via Capabilities.NavigationRestrictions.\n\nThis works fine for static capabilities (can't ever update, can't ever delete), but does not allow expressing dynamic capabilities via boolean properties on the nested entities.\n\nExample:\n- `Orders` have (contained) `items`\n- Each `Item` has a property `isUpdatable`\n\nThe corresponding navigation restriction is (rather bulky):\n\n```xml\n<Annotations Target=\"MyService.EntityContainer/Orders\">\n  <Annotation Term=\"Capabilities.NavigationRestrictions\">\n    <Record Type=\"Capabilities.NavigationRestrictionsType\">\n      <PropertyValue Property=\"RestrictedProperties\">\n        <Collection>\n          <Record Type=\"Capabilities.NavigationPropertyRestriction\">\n            <PropertyValue Property=\"NavigationProperty\" NavigationPropertyPath=\"items\"/>\n            <PropertyValue Property=\"UpdateRestrictions\">\n              <Record Type=\"Capabilities.UpdateRestrictionsType\">\n                <PropertyValue Property=\"Updatable\" Path=\"isUpdatable\"/>\n              </Record>\n            </PropertyValue>\n          </Record>\n        </Collection>\n      </PropertyValue>\n    </Record>\n  </Annotation>\n</Annotations>\n```\n\nUnfortunately the above annotation is also wrong, because [14.4.1.2 Path Evaluation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_PathEvaluation) states\n\n> For annotations embedded within or targeting an entity set or a singleton, the path is evaluated starting at the entity set or singleton, i.e. an empty path resolves to the entity set or singleton, and non-empty paths MUST follow the rules for annotations targeting the declared entity type of the entity set or singleton.\n> \n\n\nThis means that the annotation would have to use `Path=\"items/isUpdatable\"` which is a collection of Boolean values and thus not type-compatible with the `Updatable` property, and the connection to the concrete item that is to be updated is lost.\n\n\n### Proposal\n\nAllow annotating capabilities at entity types, so paths can be expressed per the `Item` instance:\n\n```xml\n<Annotations Target=\"MyService.Item\">\n  <Annotation Term=\"Capabilities.UpdateRestrictions\">\n    <Record Type=\"Capabilities.UpdateRestrictionsType\">\n      <PropertyValue Property=\"Updatable\" Path=\"isUpdatable\"/>\n    </Record>\n  </Annotation>\n</Annotations>\n```\n\nExtend `AppliesTo` list to include `EntityType`, and add to description that this \"escape hatch\" should only be used for dynamic capabilities depending on a property of a related type.\n\n*New proposal after [ODATA-1420](https://issues.oasis-open.org/browse/ODATA-1420) has been resolved:* See PR #149.\n\nImported from [ODATA-1416](https://issues.oasis-open.org/browse/ODATA-1416)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify application of term Aggregation.ApplySupported on entity containers",
    "body": "Term `ApplySupported` is applicable to entity sets, complex types and entity containers. However, the definition does not describe the semantics when applied to a container.\n\n### Proposal\n\nAdd to description:\n\nAn annotation of this term to an entity container propagates to all sets in the container except for those with their own annotation.\n\n \n\nImported from [ODATA-1414](https://issues.oasis-open.org/browse/ODATA-1414)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarification of response to a request against a delta link",
    "body": "The current text mentions that a delta response spread across multiple pages must be ordered to guarantee consistent application on the receiving side (section [11.3.2 Using Delta Links](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358967), fourth para).\n\n\n For single-page delta responses no statement is made about ordering and the fact that a single entity may be included multiple times in the response, as added, updated, and deleted entity.\n\n### Proposal\n\nRephrase 11.3.2 \"The results of a request against the delta link may span *one or more pages and* ...\"\n\n \n\nImported from [ODATA-1413](https://issues.oasis-open.org/browse/ODATA-1413)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "$expand: Discrepancy in argument descriptions",
    "body": "The documents refer to different values for `$expand`: property names or paths ending in a navigation property. This needs to be aligned:\n- Protocol spec: [11.2.5.2 System Query Option $expand](http://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html): “The value of the $expand query option is a comma-separated list of navigation +*property names*+, stream property names, or $value indicating the stream content of a media-entity.”\n- URL spec: [5.1.3 System Query Option $expand](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html): “An expand item is either a +*path*+ or … A +*path*+ can end with … +*a navigation property*+ to expand the related entity or entities”\n\n### Proposal\n\nAdapt text in Protocol to match text in URL Conventions\n\nImported from [ODATA-1411](https://issues.oasis-open.org/browse/ODATA-1411)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "$expand: clarify that property *paths* must not appear twice",
    "body": "Current text on $expand in https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_SystemQueryOptionexpand says that\n\n> A property MUST NOT appear in more than one expand item.\n\n\nThis is misleading if e.g. a complex type is used multiple times.\n\nThe option `$expand=billToAddress/country,shipToAddress/country` should be valid even though the `country` navigation property of the `Address` complex type appears twice, but within different property paths.\n\n### Proposal\n\nChange text to \n\n> A {color:green}path{color} MUST NOT appear in more than one expand item.\n\n\nImported from [ODATA-1410](https://issues.oasis-open.org/browse/ODATA-1410)",
    "labels": [
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add support for joining entities with instances of their related collections ",
    "body": "Such a feature would allow handling property paths with one or more collection-valued segments in it, i.e. collection-valued navigation or complex properties.\n\nThere are use cases in data aggregation that require to deal with such paths, e.g. to group by properties that can only be reached via a path involving a collection-valued navigation property like this:\n\n`GET ~/Products?$apply=groupby((Name,Sales/Customer/ID), aggregate(TaxRate with average as AverageTaxRate))`\n\n \n\n[ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206) declared support for such paths with collection-valued properties in groupby, however it lacks a description how to process them and furthermore [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404) withdraws this statement by restricting grouping properties to be reached via single-valued navigation and complex properties.\n\n### Proposal\n\nTo support such use cases, this gap could be closed by a new transformation `join` that allows decomposing the collections on the property path and hereby combining entities with instances of their related collections.\n\nThe proposal is described in section 3.21 and examples 57 and 58 in this file: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68332/[ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409)-2.docx](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68332/[ODATA-1409)(https://issues.oasis-open.org/browse/ODATA-1409)-2.docx]\n\nImported from [ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify behavior of aggregate on property paths with collection-valued properties",
    "body": "Example 53 illustrates a use case for such property paths:\n `GET ~/Products?$apply=`\n `groupby((Name),`\n `         ``aggregate(Sales/Amount with sum as Total))`\n\n[ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206) clarified that the aggregate transformation supports collection-valued navigation/complex properties in property paths.\n\nWhat is still missing for a complete definition is a description of the service behavior for the aggregate transformation applied on paths containing segments with collection-valued properties.\n\n### Proposal\n\nIn section 3.1, extend the third paragraph (insertions surrounded by *):\n If paths are present, the corresponding navigation properties are implicitly expanded to make the properties part of the result representation. \\*For every collection-valued navigation or complex property in the path, the aggregate transformation considers the concatenated list of all instances identified by that property for the remainder of the path.\\*\n\nImported from [ODATA-1406](https://issues.oasis-open.org/browse/ODATA-1406)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "groupby specification does not explain example 54",
    "body": "The specification of `groupby` in section 3.10 of the [Data Aggregation extension V4.0 CS02](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016582) cannot be used to explain the steps that must be carried out to compute an aggregation like in example 54 in [section 7.2](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016610).\n\n### Proposal\n\n* Fuse definitions of transformations `expand` and `nest` (replace section 3.12, delete section 3.18).\n  - Allow paths without a navigation property at the end\n  - Remove sentence about multi-level expansion\n- Move example 30 (nested `expand`) to section 7.2\n- Replace example 54 with two examples, one with `nest` (not `nestproperty`), another with `join` (transformation join is discussed in [ODATA-1409](https://issues.oasis-open.org/browse/ODATA-1409))\n- Revert [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206), only single-valued property paths are allowed in `groupby`\n\nDetails are described in [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68283/[ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404).docx]\n\nImported from [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Annotation of implicit entity sets",
    "body": "[NavigationPropertyBindings](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/os/odata-csdl-xml-v4.01-os.html#sec_NavigationPropertyBinding) are used to assign an entity set to a Path ending in a non-containment navigation property. The assigned entity set can then be the target for annotations like Aggregation.CustomAggregate (see https://issues.oasis-open.org/browse/[ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382)).\n\nPaths ending in a containment navigation property, which implicitly define an entity set, are treated totally different, however. In order to define a custom aggregate on this implicit entity set, the annotation Capabilities.NavigationRestrictions with type Aggregation.NavigationPropertyAggregationCapabilities/CustomAggregates must be used.\n\nAn easier alternative would be to use external targeting with a path that ends in a containment navigation property:\n \n```xml\n<Annotations Target=\"namespace.ContainerName/me/Mails\">\n <Annotation Term=\"Aggregation.CustomAggregate\" Qualifier=\"JunkRating\" String=\"Edm.Int32\"/>\n</Annotations>\n```\n\n\n\n### Proposal\n\nMake use of existing specification text in section [14.2.2 Target](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_Target).\n\nFor vocabulary terms `Aggregation.CustomAggregate` and `Aggregation.ApplySupported`, add `AppliesTo=\"Collection\"` and tag these terms with a new annotation in the `Core` vocabulary:\n```xml\n<Term Name=\"AppliesViaContainer\" Type=\"Core.Tag\" DefaultValue=\"true\" Nullable=\"false\" AppliesTo=\"Term\">\n <Annotation Term=\"Core.Description\" String=\"The target path of an annotation with this term must start with an entity container or the annotation must be embedded within an entity container, entity set or singleton\"/>\n</Term>\n```\nDeprecate terms `Groupable`, `Aggregatable`, complex type `NavigationPropertyAggregationCapabilities`.\n\nFor compatibility reasons, do not use this technique for annotations in the `Capabilities` vocabulary.\n\nImported from [ODATA-1403](https://issues.oasis-open.org/browse/ODATA-1403)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Correct Nullable attributes in Aggregation vocabulary terms",
    "body": "The structures of several terms lack the intended Nulable=\"false\" setting\n\nImported from [ODATA-1402](https://issues.oasis-open.org/browse/ODATA-1402)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add term Measures.UNECEUnit",
    "body": "Add new term to Measures vocabulary that allows pointing from a measured quantity to its UN/ECE unit code.\n\n \n\n \n\nImported from [ODATA-1401](https://issues.oasis-open.org/browse/ODATA-1401)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that Validation.DerivedTypeConstraint can be used to restrict Edm.Untyped",
    "body": "Type Edm.Untyped is [\"conceptually an abstract base type for any OData type\"]([https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#sec_BuiltInAbstractTypes).]\n\nThis seems to imply that term [Validation.DerivedTypeConstraint](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Validation.V1.md#DerivedTypeConstraint) can be used to restrict this to a list of concrete(r) types.\n\n### Proposal\n\nSee pull request in Resolution\n\nImported from [ODATA-1400](https://issues.oasis-open.org/browse/ODATA-1400)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Close gap in definition of term JSON.Schema ",
    "body": "[ODATA-1323](https://issues.oasis-open.org/browse/ODATA-1323) clarified how term JSON.Schema shall be annotated. It says: \n\n\"\n\n [Use] a constant string expression for Edm.Stream with media types application/json or text/*\n\n[...]\n\nFor stream values the annotation (property) MUST be annotated with term `Core.MediaType` and the media type of the stream as its value.\n\n\"\n\nThe latter statement is not yet reflected in the term definition of [JSON.Schema](https://github.com/oasis-tcs/odata-vocabularies/blob/61542d91d01a8bade005317d922270011a89a0a1/vocabularies/Org.OData.JSON.V1.xml#L67)\n\n \n\n### Proposal\n\nExtend term JSON.Schema with annotation\n`<Annotation Term=\"Core.MediaType\" String=\"application/json\" />`\n\nImported from [ODATA-1399](https://issues.oasis-open.org/browse/ODATA-1399)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve text and examples for JSON and multipart batch",
    "body": "\n\n### Proposal\n\nFeedback from Martin Zurmuehl:\n\n1. [https://docs.oasis-open.org/odata/odata-json-format/v4.01/cos01/odata-json-format-v4.01-cos01.html#sec_BatchResponse]\n\nExample 50 only shows the body, the other response elements are missing, example 51 is more complete, as is the corresponding example 104 here: [https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_MultipartBatchResponse]).\n\nExtend it to \n```java\nHTTP/1.1 200 Ok\nOData-Version: 4.01\nContent-Length: ####\nContent-Type: application/json\n\n...here goes the current example...```\n \n\n2. The normative text doesn't state which HTTP response code to send for synchronous batch responses; for async responses (19.6.) it is explicitly stated. Part 1: Protocol states this explicitly in [https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_BatchRequestHeaders.](https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_BatchRequestHeaders)\n\nHowever this is (mis)placed under „Batch Request Headers“: move it up to 11.7 Batch Request because it is valid for all response formats.\n\n3. The statement „but the processing is yet to be completed“ suggests that processing is not finished when sending 200 OK. We should remove this and explicitly state that the request can also be streamed.\n\nText for 2. and 3. in 11.7 Batch Request\n> If the set of request headers of a batch request are valid the service MUST return a [200 OK](https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_ResponseCode200OK) HTTP response code to indicate that the batch request was accepted for processing-, but the processing is yet to be completed-. The individual requests within the body of the batch request may <ins>be processed as soon as they are received+-may subsequently fail or be malformed; however-, this enables +clients to stream batch requests, and</ins> batch implementations to stream the results. \n> \n> If the service receives a batch request with an invalid set of headers it MUST return a [4xx response code](https://docs.oasis-open.org/odata/odata/v4.01/cs02/part1-protocol/odata-v4.01-cs02-part1-protocol.html#sec_ClientErrorResponses) and perform no further processing of the batch request.\n> \n\n \n\n \n\nImported from [ODATA-1398](https://issues.oasis-open.org/browse/ODATA-1398)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Examples 86 and 87 apply an entity type as term",
    "body": "Example 86 shows an annotation and uses an entity type as term:\n\n{{{color:#000000}<Annotation Term=\"org.example.person.Employee\">{color}}}\n\n`...`\n\nThis is in conflict with [14.2 Annotation](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#_Toc38530405) where the Term attribute is defined as a reference to a Term definition.\n\n### Proposal\n\nExtend the example to\n```xml\n<Annotations Target=\"org.example.Person\">\n  <Annotation Term=\"org.example.hcm.Employee\">\n    ...\n</Annotations>\n```\nExplain that the term `org.example.hcm.Employee` is of structured type. Introduce notion of an entity-valued annotation.\n\nThis may be less confusing because we use `org.example.hcm` as a term namespace in Example 5.\n\nGo all the way and give the definition of term `org.example.hcm.Employee` and its type in an additional code block within this example, maybe a subset of https://schema.org/Person.\n\nAlign the two example representations: the JSON representation has the `@type` control information, but the XML representation lacks the `Type` attribute.\n\nExplain that this annotation can be used in term-cast expressions in requests and give examples.\n\nImported from [ODATA-1397](https://issues.oasis-open.org/browse/ODATA-1397)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Rules \"ordinalIndex\" and \"complexColPath\" are too restrictive: negative indexes and index with type-cast",
    "body": "4.01 added the ability to index into ordered collections from the end, using negative values for index segments, see [11.2.6.8 Requesting an Individual Member of an Ordered Collection.](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestinganIndividualMemberofanOrde)\n\nThe specification does not explicitly forbid this indexing after a type-cast segment, but it is not allowed by rule `complexColPath`. This seems to be an accident as it is also not mentioned in [ODATA-820](https://issues.oasis-open.org/browse/ODATA-820).\n\nTrivial: some optional path segments have empty alternatives, making them \"doubly optional\". This complicates automatic processing of the ABNF and is bad style.\n\n### Proposal\n\nAllow negative values for index segments in paths.\n\nAllow index segments after type-cast segments.\n\nRephrase optional path segments to not be empty.\n\nImported from [ODATA-1396](https://issues.oasis-open.org/browse/ODATA-1396)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify impact of applying expand to subsequent transformations ",
    "body": "Property paths used in a `$apply` transformation by default may refer to any instances that can be directly or indirectly reached via navigation properties. They are all part of the input set of the transformation.\n\nA preceding `expand` transformation limits the input set to those navigation paths constructed from the navigation property given as first argument to `expand`, possibly nested several times, reaching target instances that match the given filter expression.\n\nFrom the current text this limitation does not become clear.\n\nFurthermore, `groupby` may follow an expand transformation. The definition of `groupby` currently refers to an “initial” set, and it should be clarified that this is actually the input set, e.g. the result of the preceding `expand`.\n\n### Proposal\n\nCorrect [3.10 Transformation groupby](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016582), point 1: Replace “Splits the initial set...” with “Splits the input set ...”\n\nThe remaining parts of the reported issue have been addressed and resolved with [ODATA-1404](https://issues.oasis-open.org/browse/ODATA-1404), which introduces transformation `nest`\n\nImported from [ODATA-1395](https://issues.oasis-open.org/browse/ODATA-1395)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Rule \"index\" is too restrictive, needs to allow negative integers with 4.01",
    "body": "4.01 added the ability to index into ordered collections from the end, using negative values for the `$index` system query option, see [11.2.6.8 Requesting an Individual Member of an Ordered Collection](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_RequestinganIndividualMemberofanOrde)\n\n### Proposal\n\nAllow negative values for `$index`\n\nImported from [ODATA-1393](https://issues.oasis-open.org/browse/ODATA-1393)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Point out aggregation of amounts in different currencies",
    "body": "\n\n### Proposal\n\n- remove currency from data model\n\n- rewrite all examples\n\n- section 6.2.4: until now we have ignored the reality of several currencies. Now we introduce currency to the model ...\n\n \n\nImported from [ODATA-1392](https://issues.oasis-open.org/browse/ODATA-1392)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Enable usage of $this and $root in filter transformation",
    "body": "Literals $root and $this have been introduced in the URL Conventions spec for use with the $filter option. Their usage is likewise interesting for similar cases related to the filter transformation and therefore should be enabled there.\n\n### Proposal\n\nAlready allowed by $filter expressions\n\n \n\nAdd examples to ABNF test cases to ilustrate their usage\n\nImported from [ODATA-1391](https://issues.oasis-open.org/browse/ODATA-1391)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clean up annotation term RecursiveHierarchy",
    "body": "Term definition is not concise as it includes properties that are typical attributes of a recursive hierarchy but not required to create the recursive hierarchy: `ChildrenNavigationProperty`, `DistanceFromRootProperty`, `IsLeafProperty`\n\nThis raises the bar to adopt this capability. \n\n \n\n### Proposal\n\nLimit term `RecursiveHierarchy` to those properties that are essential for creating it: `NodeProperty`, `ParentNavigationProperty`.\n\nServices may choose to use dedicated annotations for further hierarchy attributes.\n\n \n\nReflect this change in the specification and in the vocabulary.\n\nImported from [ODATA-1390](https://issues.oasis-open.org/browse/ODATA-1390)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Difference between Asynchronous and Repeatable Requests",
    "body": "The term \"[Asynchronous Requests](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#sec_AsynchronousRequests)\" invites comparison to the term \"Asynchronous SOAP communication\". The latter involves \"reliable messaging\", which is not implied by the former.\n\nHowever, readers of the OData specification who are acquainted with SOAP may not be aware of this difference.\n\n### Proposal\n\nClarify in the spec that Asynchronous OData Requests do not imply reliable messaging. Refer to the [Repeatable Requests](https://blogs.sap.com/2020/07/27/repeatable-requests-for-rest-apis/) specification for the latter.\n\nImported from [ODATA-1387](https://issues.oasis-open.org/browse/ODATA-1387)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add TypecastSegmentSupported to ReadRestrictions",
    "body": "Currently we can tell whether a cast segment is supported for insert/update/delete operations through the TypecastSegmentSupported boolean property on the respective types.  However, there is no way to tell whether the service supports appending the cast segment to a read request for a particular segment.\n\n### Proposal\n\nAdd TypecastSegmentSupported to ReadRestrictions. Default, if not specified, should be supported.\n\nAlso,in DeleteRestrictions fix FilterSegmentSupported and TypeCastSegmentSupported descriptions which both reference PATCH/Update.\n\n\nImported from [ODATA-1385](https://issues.oasis-open.org/browse/ODATA-1385)",
    "labels": [
      "Vocabularies",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify usage of annotation qualifiers as references to hierarchies",
    "body": "Section [6.3.2 Recursive Hierarchy](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016605) specifies that \"The value of the Qualifier attribute can be used to reference the hierarchy in Hierarchy Filter Functions.\"\n\nHierarchy filter functions make use of this concept, they accept a qualifier as first parameter.\n\nAll examples in the document apply this approach with top-level entities, i.e. part of the collection addressed by the resource path. E.g.:\n `GET ~/SalesOrganizations?`$filter=$it/Aggregation.isdescendant(}}\n \\`      Hierarchy='SalesOrgHierarchy',Node='EMEA')`\n\nUsing this approach also for hierarchies on entity collections _related_ to the top-level entities would require identifying the node set on which the function operates, which is not possible (example: `GET ~/Sales?`\n `$filter=$it/SalesOrganization/Aggregation.isdescendant(`\n `     Hierarchy='SalesOrganization/SalesOrgHierarchy',Node='EMEA')` leaves the set of sales orgs to consider as hierarchy unspecified )\n\nTherefore it needs to be clarified if/that these functions with the references to hierarchies always operate on top-level entities given by the resource path.\n\nThis issue is also relevant for [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218), which introduces transformations for hierarchy processing that also expect such a qualifier as call argument.\n\n \n\n### Proposal\n\n*Regarding hierarchy predicate functions:*\n\nThe node set on which these functions operate should be explicitly specified with an additional argument addressing the entity set containing the hierarchy nodes. This will then also cover the interesting use case to use the functions for related hierarchies. For example,\n```java\nGET ~/Sales?\n $filter=$it/SalesOrganization/Aggregation.isdescendant(\n      Nodes='SalesOrganizations',Hierarchy='SalesOrgHierarchy',Node='EMEA')\n```\nreturns those sales entities whose sales organization is a descendant of EMEA.\n\nNecessary changes:\n1. Extend functions in the Aggregation vocabulary: Add `Nodes` as new first parameter to `isroot`, `isdescendant`, `isancestor`, `issibling`, `isleaf`.\n  - The `Nodes` parameter takes the name of an entity set exposed by the service.\n  - The `Hierarchy` parameter receives the qualifier of a `RecursiveHierarchy` annotation attached to the entity type of the set whose name is specified in `Nodes`.\n1. Adjust examples 42-46 to reflect point 1.\n1. Add the example above to illustrate application of a predicate function on a related hierarchy.\n\n*Regarding transformations for recursive hierarchy processing originally introduced with [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218):*\n\n[Proposal ](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/69651/[ODATA-1384)(https://issues.oasis-open.org/browse/ODATA-1384).docx] to extend definitions of transformations `ancestors` and `descendants` to receive a recursive hierarchy via parameters that may differ from the input set.\n\nProposal to rewrite section about hierarchical functions:\nh4. 6.5.2.1 Hierarchy Functions\n\nFor testing the position of a given entity in a recursive hierarchy, the Aggregation vocabulary defines functions. These have\n- a parameter pair `HierarchyNodes`, `HierarchyQualifier` where `HierarchyNodes` is a collection and `HierarchyQualifier` is the qualifier of a `RecursiveHierarchy` annotation on its entity type. The node values in this collection define the recursive hierarchy\n- a parameter `Node` that contains the node value of entity to be tested. Note that the test result depends only on this node value, not on any other property of the given entity\n- additional parameters, depending on the type of test (see below)\n- a boolean return value for the outcome of the test.\n\nThe following functions are defined:\n- `isroot` tests if the given entity is a root of the hierarchy,\n- `isdescendant` tests if the given entity is a descendant of an ancestor node (whose node value is given in a parameter `Ancestor`) with a maximum distance `MaxDistance`, or equals the ancestor if `IncludeSelf` is true,\n- `isancestor` tests if the given entity is an ancestor of a descendant node (whose node value is given in a parameter `Descendant`) with a maximum distance `MaxDistance`, or equals the descendant if `IncludeSelf` is true,\n- `issibling` tests if the given entity and another entity (whose node value is given in parameter `Other`) have the same parent node or both are roots, but are not the same,\n- `isleaf` tests if the given entity is without descendants.\n\nImported from [ODATA-1384](https://issues.oasis-open.org/browse/ODATA-1384)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Complete the cardinalities in data model",
    "body": "The diagram does not include the target cardinalities for the navigation between entity types.\n\n### Proposal\n\n* All \"Sales\" navigation properties have a 0..* target cardinality\n- \"Category/Products\" has a 0..* target cardinality\n- \"SalesOrganization/Superordinate\" has a 0..1 target cardinality\n- All others have a 1 target cardinality\n\n[Revised models in UML](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/67762/[ODATA-1383)(https://issues.oasis-open.org/browse/ODATA-1383)%20Example%20Model%20in%20UML.vsdx]\n\nAdjust the text in the document:\n- Replace \"Sales\" entity type with \"Sale\" (singular)\n- In section [2.3 Example Data](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016565) extend the description \"The following *entity sets and* sample data will be used to...\"\n\nImported from [ODATA-1383](https://issues.oasis-open.org/browse/ODATA-1383)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add EntitySet to the list of possible target for terms ApplySupported, CustomAggregate",
    "body": "The current definitions of terms `ApplySupported` and `CustomAggregate` do not include `EntitySet`, but only `EntityType` (amongst others). This prevents services to provide different apply capabilities and different custom aggregates for two entity sets of the same type.\n\n### Proposal\n\n1.\n\nReplace `EntityType` with `EntitySet` to the list of model elements applicable for these two terms.\n\nRemove EntityType from related terms CustomAggregate, ApplySupported, Aggregatable, Groupable.\n\n2.\n\nExtend complex type `NavigationPropertyRestriction` in the `Capabilities` vocabulary to describe the different aggregation support and restrictions between different navigation path, including collections that can only be reached from containment navigation properties. Add this type definition to the `Aggregation` vocabulary.\n\nImported from [ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "New term Core.ContentDisposition",
    "body": "Allow defining the values of the [`Content-Disposition`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition) header for binary and stream properties:\n\n\n```json\n\"attachment\": {\n  \"$Type\": \"Edm.Stream\",\n  \"@Core.ContentDisposition\": { \n    \"Filename\": { \"$Path\": \"attachmentFilename\" } \n  }\n},\n\"attachmentFileName\": {\n  \"@Core.Description\": \"This string property contains proposed download filename for `attachment`\"\n}\n```\n\nThis means that \n```\nGET /foo/1/attachment\n```\nreturns the header\n```\nContent-Disposition: attachment; filename=\"<content of attachmentFilename property>\"\n```\n\n### Proposal\n\nhttps://github.com/oasis-tcs/odata-vocabularies/pull/87/files\n\nImported from [ODATA-1381](https://issues.oasis-open.org/browse/ODATA-1381)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "11.4.1.2 Handling of DateTimeOffset Values: replace \"i.e. UTC\" with \"for example UTC\"",
    "body": "See summary\n\nImported from [ODATA-1380](https://issues.oasis-open.org/browse/ODATA-1380)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify use of $root with function imports",
    "body": "Section [5.1.1.14.5 $root](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_root) says:\n  \n> The $root literal can be used in expressions to refer to resources of the same service.\n> \n\nHowever the [ABNF](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L501) currently limits this to singletons, entities within an entity set, and everything reachable from there, including bound functions:\n> `rootExpr = '$root/' ( entitySetName keyPredicate / singletonEntity ) [ singleNavigationExpr ]`\n> \n\nAre function imports intentionally omitted?\n\n### Proposal\n\nExtend ABNF to include function imports\n\nImported from [ODATA-1378](https://issues.oasis-open.org/browse/ODATA-1378)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "$all not available for rolling up named hierarchies",
    "body": "`$all` is defined in [3.10.2 Grouping with rollup and $all](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016584). For unnamed leveled hierarchies it may be used to introduce a virtual root level that allows to aggregate over all specified hierarchy levels. In other words, this feature offers a “grand total” for unnamed leveled hierarchies.\n\nThe feature is equally interesting for named hierarchies, where the hierarchy is specified by the qualifier of a LeveledHierarchy annotation. However, in this case, `$all` cannot be expressed and thus no “grand total” can be requested from a named hierarchy.\n\nThe same limitation applies to `groupby((rollup(HierQual)),...)`, if `HierQual` refers to a qualifier of an annotation with term `RecursiveHierarchy`, which is discussed in [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218).\n\n \n\nSimply allowing `$all` also for named hierarchies does not work as the following example shows:\n\nRollup with named leveled hierarchy:\n `GET Sales?$apply=groupby(rollup(Product/ProductHierarchy), T)`\n is equivalent to unnamed leveled hierarchy\n `GET Sales?$apply=groupby(rollup(Product/Name,Product/Category/Name), T)`\n\nAdditionally rolling up the root levels:\n- For unnamed leveled hierarchy\n `GET Sales?$apply=groupby(rollup($all,Product/Name,Product/Category/Name), T)`\n- For named hierarchy this does not work, because the qualifier may clash with property name, e.g.\n `GET Sales?$apply=groupby(rollup($all,Product/ProductHierarchy), T)`\n\n### Proposal\n\n1.\n\nIntroduce a further grouping operator `rollupall` that combines `rollup`/`$all` and replaces `$all`:\n- Rollup an unnamed leveled hierarchy incl. root level\n `GET Sales?$apply=groupby(rollupall(Product/Name,Product/Category/Name), T)`\n- Rollup an named leveled hierarchy incl. root level\n `GET Sales?$apply=groupby(rollupall(Product/ProductHierarchy), T)`\n- <del>Rollup a named recursive hierarchy incl. root nodes</del> // not needed. For details see this comment: <del>https://issues.oasis-open.org/browse/[ODATA-1377](https://issues.oasis-open.org/browse/ODATA-1377)?focusedCommentId=79188&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-79188</del>  -`GET SalesOrganizations?$apply=groupby(rollupall(SalesOrgHierarchy), T)`-\n\n2.\n\nUpdate handling for leveled hierarchies. In [3.10.2  Grouping with rollup and $all](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016584):\n- Replace the mentions of `$all` with `rollupall`\n- Replace processing rule for groupby((rollup($all,  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image028.png|width=16,height=21! )),  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! ) with: groupby((rollupall(p1)),,  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! ) is equivalent to concat(groupby((  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image021.png|width=13,height=21! ),  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! ),  !http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02_files/image025.png|width=11,height=21! )\n <del>3.</del>  // not needed. For details see this comment: https://issues.oasis-open.org/browse/[ODATA-1377](https://issues.oasis-open.org/browse/ODATA-1377)?focusedCommentId=79188&page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-79188\n <del>Update handling for recursive hierarchies. [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218) specifies groupby(rollup(...),...) for recursive hierarchies. In the [proposed extension](https://1drv.ms/w/s!AlFcFKQNWuoXimvZ8LDIG-AdfOvQ?e=Sg7sxN), add these processing rules for the given input set:</del> - <del>The result of `groupby((rollupall(RHQ),R),T)` is defined as</del>  -{\\{ concat (groupby((R),T),groupby((rollup(RHQ), R), T))}}-\n- <del>The result of `groupby((rollupall(RHQ)),T)` is defined as</del>  -{\\{ concat (T,groupby((rollup(RHQ)), T))}}-\n\n4.\n\nServices announce support for rollup via annotation of term `ApplySupported` with property `Rollup` of type `RollupType`.\n\nProposal is to keep this and treat `rollup`/`rollupall` as a single capability and to express this in the documentation of the `RollupType` enumeration:\n\n`SingleHierarchy` - Only one rollup or rollupall operator per groupby\n `MultipleHierarchies` - Full support for rollup and rollupall\n\nImported from [ODATA-1377](https://issues.oasis-open.org/browse/ODATA-1377)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify terminology where unbound functions can be invoked",
    "body": "Section [12.5 Bound or Unbound Action or Function Overloads](https://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/odata-csdl-xml-v4.01.html#_Toc38530387) in the CSDL spec states that “Unbound functions are invoked as static functions within a filter or orderby expression,...”\n\nIf confused with $filter/$orderby system query options one could draw wrong implications, e.g. functions cannot be invoked within a key predicate from parameter alias assignment.\n\n### Proposal\n\nSuch expressions are referred to as common expressions in the URL spec. Rephrase the above to “as static functions within a common expression, cf. [OData-URL], section 5.1.1”\n\nLikewise, proposal includes a change to section [4.5.2 Addressing Functions](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part2-url-conventions.html#_Toc31360941) in the URL spec. In the fourth point, replace references to filter and orderby grammar rules by a reference to common expressions ([OData-URL], section 5.1.1).\n\nImported from [ODATA-1376](https://issues.oasis-open.org/browse/ODATA-1376)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify location of custom aggregates in $apply results",
    "body": "This problem occurs twice:\n\n1.\n\nThe current text in [7.3 Custom Aggregates](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016611) states that the dynamic property with the result of a custom aggregate “MUST always be in the same set as the original property.”\n\nExample 61 following this statement puts the result of the custom aggregate Forecast into the nested Sales structure although the request uses a path expression:\n\n`GET ~/Products?$apply=groupby((Name), ... Sales/Forecast))`\n\n2.\n\nThe same statement appears in section [7.4 Aliasing](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016612). Here, it is not wrong, but may draw wrong conclusions , if it is applied to a variation of the request in example 64:\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/Amount with sum as Total))`\n\nThen, `Total` MUST be placed at the top result level.\n\n \n\nFurthermore, we should clarify this semantics in the sentence from [3.1.1 Keyword as](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016569): \"The introduced dynamic property is added to the type containing the original expression _or custom aggregate_. \"\n\n### Proposal\n\nad 1.\n\nTo comply with what we have decided in [ODATA-945](https://issues.oasis-open.org/browse/ODATA-945) (see [red-lined document](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/67246/[ODATA-945)(https://issues.oasis-open.org/browse/ODATA-945)%20-%20Proposal%20for%20Spec%20Update.docx]), the Forecast dynamic property must be placed at the top level of the result entities. Correct the response in example 61.\n\nad 2.\n\nRemove \"The introduced dynamic properties MUST always be in the same set as the original property.\".\n\nTo illustrate the rules, replace the request in example 64 with a variation of it:\n\n`GET ~/Products?$apply=groupby((Name),`\n `                   aggregate(Sales/Amount with sum as Total,`\n `                             Sales(Amount with average as AvgAmt)))`\n\nAccordingly, move `Total` to the top-level entities in the result.\n\n \n\nFurthermore, the sentence in [3.1.1 Keyword as](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016569) should read: \"The introduced dynamic property is added to the context where the aggregate expression is applied to\". This covers custom aggregates, which are also aggregate expressions.\n\nImported from [ODATA-1375](https://issues.oasis-open.org/browse/ODATA-1375)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify service-defined bound functions used as $apply transformations",
    "body": "The current text in [3        System Query Option $apply](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016567) makes an incomplete statement about the return type of such a function in a sequence of $apply transformations: “If it returns an entity set, further transformations can follow the bound function.” This leaves room to use also functions that return a value of a complex or primitive type, which does not fit to the general principle of “set in/set out” for all transformations and the result of $apply being a collection of instances.\n\n### Proposal\n\nRephrase the definition of such functions:\n\nCurrent: \nService-defined bound functions that take an entity set as their binding parameter MAY be used as set transformations within $apply if the type of the ...\n\nNew: \nService-defined bound functions that take a collection of instances of a structured type as their binding parameter and return a collection of instances of a structured type MAY be used as set transformations within $apply if the type of the ...\n\n\nImported from [ODATA-1374](https://issues.oasis-open.org/browse/ODATA-1374)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Examples 60, 61: Missing aggregation method for $count on related entities",
    "body": "The examples make use of `$count` applied to a path expression in an aggregate expression without specifying an aggregation method, e.g. `aggregate(Sales/$count as SalesCount)`\n\nThis syntax construct and its semantics has been introduced in the Core specification, section [11.2.6.1 System Query Option $filter](https://docs.oasis-open.org/odata/odata/v4.01/odata-v4.01-part1-protocol.html#_Toc31358948) and must not be confused with the virtual property `$count` defined in the Data Aggregation extension specification, section [3.1.5 Virtual Property $count](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016573). It represents a common expression that, if used in the `aggregate` transformation, must be complemented with an aggregation method.\n\n### Proposal\n\n*Ex 60: Replace*\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count as SalesCount))`\n\nwith\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count with sum as SalesCount))`\n\n*Ex 61: Replace*\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count as SalesCount,``Sales(Amount with sum as TotalAmount)))`\n\nwith\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count with sum as SalesCount,``Sales(Amount with sum as TotalAmount)))`\n\nImported from [ODATA-1373](https://issues.oasis-open.org/browse/ODATA-1373)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify term \"filter function\"",
    "body": "Term \"filter function\" suggests function isdefined and the predicate functions for hierarchies are only valid within $filter. Actually, as Boolean method call expression/Boolean functions they can be used in more cases.\n\n### Proposal\n\nName them \"functions\".\n\nImported from [ODATA-1372](https://issues.oasis-open.org/browse/ODATA-1372)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve structure of CSDL clause 4",
    "body": "The subclause levels of this section suggest that Included Schema and Included Annotations are independent declarations from the $Reference declaration.  However, they should be documented as parts of the $Reference declaration.\n\nRelated to this, 4.1 Reference asserts that it is used to bring in part of the referenced document.  However, both $Include and $IncludedAnnotations is documented as optional.  Either $Reference can bring in all of a referenced document, or at least one of $Include or $IncludedAnnotations must be specified.\n\nNote that edmx.xsd does not resolve this issue since it also allows the possibility that neither Include or IncludeAnnotations is specified.  \n\nA trivial issue is that both 'include' and 'included' are used to refer to the same functionality in this section.\n\n### Proposal\n\nReword section 4.3 along similar lines as 4.2:\n\"In addition to including whole schemas with all model constructs defined within that schema, _a reference may include_ annotations.\"\n\nMake both references to *references* be links to section 4.1.\n\nImported from [ODATA-1371](https://issues.oasis-open.org/browse/ODATA-1371)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Example 30: Wrong context",
    "body": "The request addresses the Categories set, so the context URL must refer to this set and not to the Customers set.\n\n### Proposal\n\nsee description\n\nImported from [ODATA-1369](https://issues.oasis-open.org/browse/ODATA-1369)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify Term applicability",
    "body": "The following text may be misconstrued to be a require that limits the term to the listed model elements.\nh3. [14.1.2 Applicability](#sec_Applicability)\n\nThe applicability of a term MAY be restricted to a list of model elements. If no list is supplied, the term is not intended to be restricted in its application. The list of model elements MAY be extended in future versions of the vocabulary.\n\n \n\n### Proposal\n\nChange the text as follows:\nh3. [14.1.2 Applicability](#sec_Applicability)\n\nApplicability specifies a list of model elements to which the term MAY be applied.  If no list is supplied, the term MAY be applied to any model element. The list of model elements MAY be extended in future versions of the vocabulary.\n\nImported from [ODATA-1368](https://issues.oasis-open.org/browse/ODATA-1368)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve the layout of vocabularies markdown to indicate that shown annotations are not exhaustive",
    "body": "Markdown tables in the vocabularies markdown files are typically not showing all the possible annotations. When they are shown because they are notable, the table gives the impression that they are the only allowed annotations, which is not the case.\n\n \n\n \n\n### Proposal\n\nSuggestion is to split the table in two: one for regular properties, one for annotation properties. The table header for the second should indicate that these are not the only allowed annotations.\n\n \n\ne.g.\n\nFrom:\n\n!image-2020-05-14-09-33-15-133.png|width=618,height=132!\n\n \n\nTo:\n\n!image-2020-05-14-09-32-41-327.png|width=649,height=213!\n\nImported from [ODATA-1367](https://issues.oasis-open.org/browse/ODATA-1367)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove redundant text to improve readability",
    "body": "In the CSDL documents, the struck-through words below are redundant.\n\n*$EntityContainer*\n\nThe value of $EntityContainer -{color:#de350b}is value{color}- is the namespace-qualified name of the entity container of that service. This is the only place where a model element MUST be referenced with its namespace-qualified name and use of the alias-qualified name is not allowed.\n\n### Proposal\n\nRemove the redundant words.\n\nImported from [ODATA-1366](https://issues.oasis-open.org/browse/ODATA-1366)",
    "labels": [
      "CSDL JSON",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Enhance Validation.AllowedValue to have optional symbolic name",
    "body": "In some cases EnumType is undesirable because adding a member constitutes a backwards-incompatible change.\n\nIf Validation.AllowedValue had an optional Name property (Type=\"Edm.String\" Nullable=\"true\") then Validation.AllowedValues inside a TypeDefinition could be used to define \"better enums\" (including String-valued enums) that would allow graceful evolution of services without backwards-incompatible changes.\n\n            <TypeDefinition Name=\"Colour\" UnderlyingType=\"Edm.Int32\">\n                <Annotation Term=\"Validation.AllowedValues\">\n                    <Collection>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Red\"/>\n                            <PropertyValue Property=\"Value\" Int=\"1\"/>\n                        </Record>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Blue\"/>\n                            <PropertyValue Property=\"Value\" Int=\"2\"/>\n                        </Record>\n                    </Collection>\n                </Annotation>\n            </TypeDefinition>\n\nor using String:\n\n            <TypeDefinition Name=\"Colour\" UnderlyingType=\"Edm.String\">\n                <Annotation Term=\"Validation.AllowedValues\">\n                    <Collection>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Red\"/>\n                            <PropertyValue Property=\"Value\" String=\"ff0000\"/>\n                        </Record>\n                        <Record>\n                            <PropertyValue Property=\"Name\" String=\"Blue\"/>\n                            <PropertyValue Property=\"Value\" String=\"0000ff\"/>\n                        </Record>\n                    </Collection>\n                </Annotation>\n            </TypeDefinition>\n\n\nTBD (possibly should be spun off to another JIRA issue): how to mark an AllowedValues to indicate that it provides the equivalent of a Flags-style EnumType.\n\n\n### Proposal\n\nDefine a new SymbolicName annotation that can be applied to the AllowedValues annotation (or other places) of type SimpleIdentifier (a new TypeDef with underlying type of string).\n\nAdd SymblicName to the list of ApplicableTerms for AllowedValues.\n\nImported from [ODATA-1365](https://issues.oasis-open.org/browse/ODATA-1365)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Missing comma in JSON metadata example",
    "body": "In 16.1 Products and Categories Example, there’s a “,” missing after “$Nullable”: true for the \"Country\" navigation property on \"Address\":\n\n\n\"Country\": {\n        \"$Kind\": \"NavigationProperty\",\n        \"$Nullable\": true\n        \"$Type\": \"self.Country\",\n        \"$ReferentialConstraint\": {\n          \"CountryName\": \"Name\"\n        }\n      }\n\n\n\n### Proposal\n\nAdd the missing comma.\n\nImported from [ODATA-1363](https://issues.oasis-open.org/browse/ODATA-1363)",
    "labels": [
      "CSDL JSON",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ABNF: preference omit-values missing",
    "body": "The preference `omit-values` is missing from the ABNF\n\nImported from [ODATA-1362](https://issues.oasis-open.org/browse/ODATA-1362)",
    "labels": [
      "ABNF",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL TimeOfDay literals inconsistent with XSD",
    "body": "CSDL XML 4.01 sectin 14.3.12 Time of Day\n\nThe edm:TimeOfDay expression evaluates to a primitive time value. A time-of-day expression MUST be assigned a value conforming to the rule timeOfDayValue in [OData‑ABNF].\n\nABNF shows:\n\ntimeOfDayValue      = hour \":\"   minute [ \":\"   second [ \".\" fractionalSeconds ] ]\n\n(so the second can be omitted)\n\nBut in http://docs.oasis-open.org/odata/odata/v4.0/os/schemas/edm.xsd\n\n<xs:simpleType name=\"time\">\n  <xs:restriction base=\"xs:time\">\n    <xs:pattern value=\"([01][0-9]](2[0-3)):[0-5][0-9]:[0-5][0-9](\\.[0-9]{1,12})?\"/>\n  </xs:restriction>\n</xs:simpleType>\n\ndoesn't allow the seconds portion to be omitted, so is inconsistent with the ABNF timeOfDay references by CSDL spec.\n\n### Proposal\n\nFix the edm:time definition in the xsd\n\n\nImported from [ODATA-1361](https://issues.oasis-open.org/browse/ODATA-1361)",
    "labels": [
      "CSDL XML",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that clients have to do content-ID replacing to interpret Location headers in batch results",
    "body": "A server is allowed to return a URI in the Location header that is relative to the request URL.  In a batch request, a request URL can contain a content-ID reference, like $1/Orders to create an order to a not yet created customer.  The server can return a Location header of ../Orders(2020) in the response.  For the client to be able to determine the correct location of the new Order it MUST perform the content-ID replacement in the request URL (because $1 is not necessarily a single path segment).\n\nWe should clarify this by explicitly stating that these steps are required by clients under these circumstances.\n\n### Proposal\n\nAdd a sentence to JSON Format, section 19.2 (and the corresponding section on Multipart Batch in Protocol):\n> If the `Location` header in the response contains a relative URL, clients MUST be able to resolve it relative to the request's URL even if that contains such a reference.\n> \n\n\nImported from [ODATA-1360](https://issues.oasis-open.org/browse/ODATA-1360)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "19.4, second paragraph, first sentence: missing \"in\"",
    "body": "\n\n### Proposal\n\n> The service MAY process the individual requests and atomicity groups within a batch request, or individual requests within an atomicity group, {color:#00875a}*in*{color} any order that is compatible\n> \n\n\nImported from [ODATA-1359](https://issues.oasis-open.org/browse/ODATA-1359)",
    "labels": [
      "JSON Format",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add descriptions to system query option restrictions in Capability vocabulary",
    "body": "There are cases when a custom description for system query options can help service consumers to better understand the supported functionality. For example, they could be used to explain special constraints stemming from the service model that cannot be expressed otherwise.\n\n### Proposal\n\nAllow application of term Core.Description to:\n - BatchSupportType\n - FilterRestrictionsType\n - SortRestrictionsType\n - ExpandRestrictionsType\n - SearchRestrictionsType\n\nAllow application of term Core.LongDescription to:\n - BatchSupportType\n\nDocument this via Validation.ApplicableTerms.\n\nRationale:\n - BatchSupportType describes an operation and thus has both a Description and a LongDescription, similar to InsertRestrictionsType, UpdateRestrictionsType, DeleteRestrictionsType, and ReadRestrictionsBase.\n - The other four types describe query options, similar to type CustomParameter, which also only has a Description, no LongDescription\n\nImported from [ODATA-1357](https://issues.oasis-open.org/browse/ODATA-1357)",
    "labels": [
      "Vocabularies",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "13.2, paragraph 5: typo \"indicatet\" instead of \"indicated\"",
    "body": "See summary\n\nImported from [ODATA-1356](https://issues.oasis-open.org/browse/ODATA-1356)",
    "labels": [
      "CSDL XML",
      "V4.01_COS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Generalize Validation.Minimum and Validation.Maximum to Edm.PrimitiveType",
    "body": "Currently Validation.Minimum and Validation.Maximum are of type Edm.Decimal.\n\nIn principle these terms can apply to any totally ordered primitive type, e.g. Edm.Duration.\n\n### Proposal\n\nChange type of term from Edm.Decimal to Edm.PrimitiveType (and remove the Scale facet).\n\nImported from [ODATA-1355](https://issues.oasis-open.org/browse/ODATA-1355)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarity for \"@odata.type\" in request payloads",
    "body": "We ran into an interoperability issue where servers don't accept \"@odata.type\" in request payload (this is for a case where there is no inheritance in model).\n\nClient is sending \"@odata.type\" because previously we encountered servers that required \"@odata.type\".\n\nNow we were hoping to argue that servers not accepting \"@odata.type\" in request payload were non-compliant with the spec, however...\n\nThe “minimal” and “full” metadata are defined in subsections of OData 4.01 JSON section 3.1 Controlling the Amount of Control Information in *Responses*.\n\nNowhere do we appear to define the amount of control information in *requests*.\n\nAlthough we could take it as an unstated assumption that \"@odata.type\" MAY appear even where it isn’t required to appear, it would be best if we have a separate section describing what control information MAY (and MUST, in the case of entity inheritance) appear in request payloads.\n\n\n\n\nImported from [ODATA-1353](https://issues.oasis-open.org/browse/ODATA-1353)",
    "labels": [
      "JSON Format",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify format for $value",
    "body": "Section 11.2.4.1 says that the format is text/plain but does not specify the exact format for the primitive types.  We should clarify that the format is xxxValue from OData-ABNF.\n\n### Proposal\n\nChange the sentence:\n\nThe default format for single primitive values except Edm.Binary and the Edm.Geo types is text/plain.\n\nto (roughly)\n\nThe default format for single primitive values except Edm.Binary and the Edm.Geo types is text/plain and follows the rules xxxValue defined in [ODATA-ABNF].\n\nImported from [ODATA-1352](https://issues.oasis-open.org/browse/ODATA-1352)",
    "labels": [
      "Protocol"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify IEEE754Compatible applies to request payloads as well",
    "body": "Section 3.2 in the JSON format does not make it clear that IEEE 754 Compatibility applies to both response and requests.  Reword the section to make it more clear by stating explicitly which component (client and/or service) can add the IEEE754Compatible format parameter to the Accept and Content-Type headers.\n\n### Proposal\n\nChange:\n\"OData JSON payloads that format Edm.Int64 and Edm.Decimal values as strings MUST specify this format parameter in the media type returned in the Content-Type header.\"\nto:\n\"OData JSON request and response payloads that format Edm.Int64 and Edm.Decimal values as strings MUST specify this format parameter in the media type returned in the Content-Type header.\"\n\n(or other clarifications as editor deems appropriate)\n\nImported from [ODATA-1351](https://issues.oasis-open.org/browse/ODATA-1351)",
    "labels": [
      "JSON Format",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Calculate Custom Aggregates from Aggregated Instances",
    "body": "A CustomAggregate annotation defines a dynamic property that can be used in the aggregate transformation. The current document states in [6.2.3 Custom Aggregates](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016600), second paragraph: “When applied to a structured type, the annotation specifies custom aggregates that are available for collections of _instances of that structured type_.”\n\nThis also means that a custom aggregate cannot be applied to an intermediate, already aggregated result produced by $apply transformations. Such a result consists of aggregated instances that are based on the structure of the instances from which they have been calculated ([4        Representation of Aggregated Instances](http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016593)) and some properties from the originating type have been aggregated away.\n\nThis limits the applicability of custom aggregates and prevents requests for use cases like this example: For a custom aggregate “Amount”, determine the total amount for countries with a sales amount greater than X:\n\n`GET ~/Sales?$apply=groupby((Country),aggregate(Amount))/filter(Amount gt X)/aggregate(Amount)`\n\nThis can be a valid request under the assumption that `Amount` can be calculated for a set of aggregated instances each having a value for the `Amount` property.\n\n### Proposal\n\nInterpretation of this statement is too strict; it is actually intended to allow custom aggregates on intermediate results.\n\nState more precisely that custom aggregates are also available for aggregated instances created from the defining structure:\n\n“When applied to a structured type, the annotation specifies custom aggregates that are available for collections of instances of that structured type _or of aggregated instances resulting from these instances_.”\n\nImported from [ODATA-1349](https://issues.oasis-open.org/browse/ODATA-1349)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL MaxLength is ill-defined",
    "body": "7.2.2 MaxLength\n\n  \"A positive integer value specifying the maximum length of a binary, stream or string value. For binary or stream values this is the octet length of the binary data, for string values it is the character length.\"\n\nWhat does character mean here? (Unicode specs don't define character in any normative text).\n\n3.3 Primitive Types\n\n\"Edm.String Sequence of UTF-8 characters\"\n\nIf we combine 7.2.2 and 3.3, we might reasonably infer that MaxLength is the maximum valid length of a String value in UTF-8 encoding.\n\nIs this what the spec intended, in which case 7.2.2 should be clarified, or was it intended that 7.2.2 refer to UTF-16 code points or Unicode code points?\n\nSee also: https://unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries\n\nWhy does any of this matter? Consider a client, that wants to create an offline cache of data from a server (in a database, where columns need a specified maximum length). Or consider some other intermediary, which wants to allocate space for a buffer (e.g. malloc MaxLength+1 for a buffer to hold a Property value in a C program). It is important for such apps to be able to determine how much space to set aside to avoid accidental truncation of values. \n\nAdditionally, any client or other agent wishing to do validation of a Property value according to MaxLength, it makes huge difference whether this is done by UTF-8, UTF-16 or Unicode code points.\n\n\n### Proposal\n\nSection 3.3: replace \"UTF-8 characters\" with \"Unicode code points\" in table line for Edm.String.\n\nSection 7.2.2: replace \"character length\" with \"number of Unicode code points\".\n\nSections 7.2.5, 15.1 and 15.2: replace all (four) occurrences of \"Unicode character\" with \"Unicode code point\".\n\n \n\nImported from [ODATA-1348](https://issues.oasis-open.org/browse/ODATA-1348)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add an example showing a delta link and nested next link in the same response payload",
    "body": "Add an example showing a delta link and nested next link in the same response payload.\n\n### Proposal\n\n```json\n{\n  \"@context\": \"http://host/service/$metadata#Customers/$entity/$delta\",\n  ...\n  \"Orders@count\": 42,\n  \"Orders\": [ ... ],\n  \"Orders@nextLink\": \"...\",\n  ...\n  \"@deltaLink\": \"Customers?$deltatoken=...\",\n}\n```\n \n\nImported from [ODATA-1347](https://issues.oasis-open.org/browse/ODATA-1347)",
    "labels": [
      "JSON Format",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify handling of delta with $expand",
    "body": "Section [11.3.1 Delta Links](https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html#sec_DeltaLinks) describes handling of delta queries in combination with $expand, the relevant text is attached below. The highlighted sentence seems contradictory and should be clarified. It demands that the delta response must include changes to the expanded entities also for navigation properties expanded with $ref, whereas the following paragraph states that a delta query with a $ref expansion will ignore changes to changes to related entities.\n\n\"If the defining query includes expanded relationships, the delta link MUST return changes, additions, or deletions to the expanded entities, as well as added or deleted links to expanded entities or nested collections representing current membership. *This is independent of whether related entity themselves or only references to related entities were requested.* \n\nNavigation properties specified in the [$select](https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html#sec_SystemQueryOptionselect) list of a defining query are not used to define the scope or contents of the items being tracked. Clients can specify /$ref in [$expand](https://docs.oasis-open.org/odata/odata/v4.01/csprd06/part1-protocol/odata-v4.01-csprd06-part1-protocol.html#sec_SystemQueryOptionexpand) in order to specify interest in the set of related entities without interest in changes to the content of those related entities.“\n\n### Proposal\n\nchange the wording of the first cited paragraph to:\n\nIf the defining query includes expanded relationships, the delta link MUST return changes, additions, or deletions to the expanded entities, as well as added or deleted links to expanded entities or nested collections representing current membership. If the defining query includes expanded references, then the delta link MUST return changes to the membership in the set of expanded references.\n\nImported from [ODATA-1346](https://issues.oasis-open.org/browse/ODATA-1346)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Issues with ContextUrl",
    "body": "There are some issues and ambiguities in how we represent the request in the ContextUrl.\n\n1) From 10.9, \"If the context URL includes only expanded navigation properties (i.e., only navigation properties suffixed with parentheses), then all structural properties are implicitly selected (same as if there were no properties listed in the select-list).\"\n As a result, there is no way to say that a result contains only the expanded content and no selected properties.  This is not a huge issue, as our syntax today doesn't allow requesting only expanded properties, but it seems like it should.\n\n2) In 4.01 we say that, for expanded navigation properties with no expand options, the context URL contains the name of the navigation property suffixed with empty parens, and that this *MAY* be omitted in 4.0.  However, the 4.0 grammar prohibits the use of empty parens.\n\n\n### Proposal\n\nChange current text: \n\"For a 4.0 response, the expanded navigation property suffixed with parentheses MAY be omitted from the select-list if it does not contain a nested $select or $expand, but MUST still be present, without a suffix, if it is explicitly selected.\"\nto:\n\"For a 4.0 response, the expanded navigation property suffixed with parentheses is omitted from the select-list if it does not contain a nested $select or $expand, but MUST still be present, without a suffix, if it is explicitly selected.\"\n\n\nImported from [ODATA-1345](https://issues.oasis-open.org/browse/ODATA-1345)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove leftover wording regarding $expand within $select",
    "body": "Sections 10.7 and 10.8 describe the ContextURL for projected (collections of) entities.\n\nBoth sections include the wording \"... expands nested within $select are represented the same as expands outside of $select.\"\n\nThis is leftover wording from when we supported nesting $expand within $select. However, we removed such capability with [ODATA-1328](https://issues.oasis-open.org/browse/ODATA-1328), partially to avoid such ambiguity.\n\n### Proposal\n\nRemove old wording to avoid confusion. Since the described scenario can never happen, removing the sentence is a non-material, editorial change that helps avoid confusion, and can be addressed in an errata.\n\nImported from [ODATA-1344](https://issues.oasis-open.org/browse/ODATA-1344)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Multipart Batch Request Body example is missing required CRLF before first occurrence of boundary",
    "body": "In protocol spec v4.01, section 11.7.7.1 Multipart Batch Request Body example...\n\nAfter:\n\nContent-Length: ###\n\nthere is a single blank line (which is required to terminate the HTTP headers).\n\nNow RFC2046 states:\n\n   \"The boundary delimiter MUST occur at the beginning of a line, i.e.,\n   following a CRLF, and the initial CRLF is considered to be attached\n   to the boundary delimiter line rather than part of the preceding\n   part.  \"\n\nSo after the Content-Length: ### in the example should appear two blank lines (i.e. two CRLF pairs). The second CRLF pair will be the beginning of the first boundary occurrence.\n\nSimilarly after:\n\nContent-Type: multipart/mixed; boundary=changeset_77162fcd-b8da-41ac-a9f8-9357efbbd\n\nthere should be another blank line (CRLF pair), since one is required to end the headers and one is required to begin the boundary.\n\nand we must interpret that the CRLF pair after each of the two <JSON representation of XXX> occurrences in the example actually belongs to the boundary, not the JSON encoding.\n\nAlthough the examples are non-normative, they of course still need to be corrected.\n\nThe example shows two adjacent lines:\n\n--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd--\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\n\nwhich also should have a blank line between them.\n\nSimilar issues of missing CRLF pairs are apparent in all of the other batch request/response examples.\n\nAnd even missing in the multipart/alternative example in RFC2046 (see page 26 in https://tools.ietf.org/html/rfc2046).\n\nGiven that these examples appear in similar form in OData 4.0 spec as well as OData 4.01, there appears to be considerable scope for interoperability issues if existing 4.0 agents (which may be coded in accordance with the examples) are fixed in accordance with the RFC2046 prose.\n\nExamples in OData 2.0 spec are also missing a few CRLF pairs.\n\n\n### Proposal\n\nExample 103\n- Add additional empty line after GET header block, before delimiter line\n- Add closing delimiter line\n\nImported from [ODATA-1343](https://issues.oasis-open.org/browse/ODATA-1343)",
    "labels": [
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Core.Ordered: mention \"Term\" in AppliesTo",
    "body": "Collection-valued terms may assign meaning to the order of items in the annotation value, e.g. a \"DefaultSortOrder\" term may describe the default sort order of a collection if no $orderby is specified. \n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1342](https://issues.oasis-open.org/browse/ODATA-1342)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that nested next links can appear on the same page as a delta link",
    "body": "In the protocol document we specify that a delta link can only appear on the last page of a result set indicating that a top level next link and delta link cannot be returned on the same page.  However, we don't say anything about nested next links.\n\nWe should clarify that nested next links are allowed on all pages but a delta link should only be returned for the top level query.\n\n### Proposal\n\nClarify that each page of results within a response can have either a nextlink or a deltalink but not both. Probably best to avoid the use of the word \"page\" as it is ambiguous. Maybe something like \"The delta payload, and each nested collection within the delta payload, may be paged. The delta link appears on the last page of each collection in place of the nextlink.\"\n\nAlso clarify that following nested next links within a delta payload typically doesn't result in a delta at the end-the delta is tracked by the top level response. Clients MAY request the delta link when requesting the nested content and, since it's a preference, the service MAY ignore it.\n\nThis should be a non-normative clarification.\n\nImported from [ODATA-1341](https://issues.oasis-open.org/browse/ODATA-1341)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_OS"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Make examples 8 (entity type) and 86 (record expression) consistent",
    "body": "Example 86 for record expressions wants to point out that there's no representation difference between structural properties and navigation properties. It does this so successfully that only the specification authors can tell which of the four properties are structural, and which are navigation :-)\n\nWe should give readers a hint.\n\n### Proposal\n\nExample 8: \n- Add navigation property \"CostCenter\"\n\nExample 86:\n- Reference example 8 in the example headline\n- Rename property \"GivenName\" to \"FirstName\" (FirstName is used in other examples)\n- Rename property \"SurName\" to \"LastName\" (LastName is used in another example)\n\nNote: this is a non-material change that only affects non-normative examples.\n\nImported from [ODATA-1339](https://issues.oasis-open.org/browse/ODATA-1339)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Additional representation of entity references using (alternate) key properties",
    "body": "Entity references are currently represented as a JSON object containing an `@id` member, e.g.\n```java\n{\n  \"@context\": \"https://foo/bar/$metadata#$ref\",\n  \"@id\": \"Orders(10643)\"\n}\n```\nAn easier-to-create and also easier-to-digest representation would be to include instead all properties from either the primary key or one of the [declared alternate keys](https://docs.oasis-open.org/odata/odata/v4.01/os/part2-url-conventions/odata-v4.01-os-part2-url-conventions.html#sec_AlternateKeys)):\n```java\n{\n  \"@context\": \"https://foo/bar/$metadata#Orders(quux)/$entity\",\n  \"quux\": 10643\n}\n```\nThis is similar to the V4.01 format for [deleted entities](https://docs.oasis-open.org/odata/odata-json-format/v4.01/odata-json-format-v4.01.html#sec_DeletedEntity) in delta payloads. If properties other than the key properties are supplied, these are ignored - a reference is _not_ an implicit update.\n\n### Proposal\n\nAllow entity references to contain all key fields instead of `@id`.\n\nImported from [ODATA-1338](https://issues.oasis-open.org/browse/ODATA-1338)",
    "labels": [
      "JSON Format"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify use of @Core.ContentId in delta update",
    "body": "We added the @Core.ContentId annotation in order to enable annotating instances in an insert request to be correlated with results in the returned response.  We specifically call out its use in deep insert and deep update requests in [Protocol], but omit mentioning it in bulk (delta) update requests. \n\nIt's use in these cases is implied through deep insert and deep update, and from the description of the annotation, but we should add the same text to the delta update section.\n\n### Proposal\n\nAdd the same text to \"Update a Collection\", where we describe delta updates, as we currently have in sections describing deep insert and deep update.\n\nNote that the DeepInsert and DeepUpdate capabilities that describe support for ContentId should be relevant within a delta update request.\n\nProposed wording:\nClients MAY associate an id with individual nested entities in the request by using the Core.ContentID term defined in [OData-VocCore]. Services that respond with 200 OK SHOULD annotate the entities in the response using the same Core.ContentID value as specified in the request. \n\nServices SHOULD advertise support for updating a collection using a delta payload using the DeltaUpdateSupported property of the Capabilities.UpdateRestrictions vocabulary term, and SHOULD advertise support for returning the Core.ContentID in the response to a delta update through the Capabilities.DeepUpdateSupport term, both defined in [OData-VocCap]. \n\nImported from [ODATA-1337](https://issues.oasis-open.org/browse/ODATA-1337)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ABNF Does not allow selecting instance annotations",
    "body": "In the URL conventions document in section 5.1.4 it mentions in the text that $select can be used to select instance annotations.  However, the ABNF does not appear to allow this.\n\nAlso, the bulleted list in section 5.1.4 is missing mention of instance annotations.  The first bullet point should be updated to include instance annotations.\n\nImported from [ODATA-1335](https://issues.oasis-open.org/browse/ODATA-1335)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Mismatch in ModificationException term naming",
    "body": "In our last F2F we added a new term for annotating failed data modifications within a bulk (i.e., delta) payload. We went back and forth on the naming, and ended up with different names between the vocabulary and the protocol document.\n\nThe protocol document, in section 11.4.12, Update a Collection of Entities, refers to the \"Core.DataModificationException\".  However, the Core vocabulary defines \"ModificationException\" along with \"ModificationExceptionType\" and \"ModificationOperationKind\".\n\n### Proposal\n\na. Update the protocol document to refer to \"Core.ModificationException\", or\nb. Update the Core.Vocabulary to prefix \"Data\" to \"ModificationException\", \"ModificationExceptionType\", and \"ModificationOperationKind\"\n\nI kinda prefer the prefixed name (b), although it is slightly longer. However, the vocabulary changes are \"live\" where-as the protocol document has not yet been finalized, so b) would technically be a breaking change to anyone using the new vocabulary term, although it could be argued that it's unlikely that people are already using that term.\n\nImported from [ODATA-1334](https://issues.oasis-open.org/browse/ODATA-1334)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support augmenting entities with aggregated values from related entities",
    "body": "For a collection of entities having navigation paths to related entities, adding an aggregated value from the related entities to each entity in the collection today requires a first argument to groupby listing all properties. For example, to retrieve all products together with their total sales amount:\n\n`GET ~/Products?$apply=groupby((<key property>,<all other properties of type Product...>),aggregate(Sales/Amount with sum as TotalAmount))`\n\nreturns all entities from the Products entity collection whose structure now also includes a dynamic property TotalAmount. If the underlying type comprises many properties, this approach becomes rather clumsy.\n\nOptions to describe this request in a leaner way could be:\n A) Do the aggregation inside an expand transformation with a nested compute argument that operates on the entities of the navigation target. The determined result is then added to the result as expanded navigation property:\n `GET ~/Products?$apply=expand(Sales,compute(aggregate(Amount with sum) as TotalAmount))&$select=*,Sales/TotalAmount`\n\nreturns\n```java\n{  \n  \"@odata.context\": \"$metadata#Products\",  \n  \"value\": [\n    { \"ID\": ..., \"Name\": ...\", ...\n      \"Sales\": [{ \"TotalAmount\": ... }] },\n    ...\n  ]\n}\n```\n(this option requires an extension of expand to allow applying `compute` to related entities)\n\nB) Allow $it as first argument to groupby meaning that each entity of the input set becomes a separate subset on its own:\n `GET ~/Products?$appy=groupby($it,aggregate(Sales/Amount with sum as TotalAmount))`\n\nreturns\n```java\n{  \n  \"@odata.context\": \"$metadata#Products\",  \n  \"value\": [\n    { \"ID\": ..., \"Name\": ...\", ...\n      \"TotalAmount\": ... },\n    ...\n  ]\n}\n```\n\nImported from [ODATA-1332](https://issues.oasis-open.org/browse/ODATA-1332)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Override entity set when extending an entity container (public comment)",
    "body": "See [https://groups.google.com/forum/?utm_medium=email&utm_source=footer#!msg/odata-discussion/5g3mk2A7yG8/tluOLeO2AgAJ]\n \nWhat is the expected behavior when an Entity Container extends another Entity Container and there is an Entity Set with the same name in both? \nThe spec says: \"All children of the “base” entity container are added to the “extending” entity container.\" and \"An entity set is identified by its name, a simple identifier that MUST be unique within its entity container.\"\n \nDoes that mean this case is invalid?\n \nIIUC, 4.01 adds covariance, i.e., the ability for Structural Types to redeclare Properties defined in the base Structural Type with a subtype. It would be nice if the same were possible for Entity Containers, i.e., if an Entity Container that extends another Entity Container could redeclare Entity Sets with a subtype\n\n### Proposal\n\nSupport covariance in extending an entity container.  Existing entity sets/singletons can be redefined using types derived from the type defined in the extended entity container.\n\nImported from [ODATA-1331](https://issues.oasis-open.org/browse/ODATA-1331)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON Batch: explicitly state that continue-on-error=true is the default",
    "body": "In [19.4 Processing a Batch Request](https://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd05/odata-json-format-v4.01-csprd05.html#sec_ProcessingaBatchRequest) we state that\n> Clients [...] MAY specify the preference `continue-on-error=false`\n> \n\nThis sort of implies that the default is `true`. Better to explicitly say so.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1330](https://issues.oasis-open.org/browse/ODATA-1330)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON Batch: explicitly state that continue-on-error=true is the default",
    "body": "In [19.4 Processing a Batch Request](https://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd05/odata-json-format-v4.01-csprd05.html#sec_ProcessingaBatchRequest) we state that clients can specify the preference `continue-on-error=false`. This sort of implies that `true` is the default, but it doesn't explicitly say so.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1329](https://issues.oasis-open.org/browse/ODATA-1329)",
    "labels": [
      "JSON Format",
      "V4.01_CS02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Simplify query rules by removing $expand select option",
    "body": "In OData-1105 we added support for simplifying the syntax for selecting multiple fields from a complex type by introducing $select options, consistent with nested expand options. This also allowed us to specify other select options for collections, such as top, skip, count, and filter. \n\nUnfortunately, we also introduced $expand as a nested select option. Providing the ability to expand inside a select provides multiple ways to express the same thing in the same request, requiring rules to validate the combination of nested expands and regular expands that add complexity to the system with no added benefit.\n\n### Proposal\n\nRemove $expand from the set of allowable $select options.\n\nImported from [ODATA-1328](https://issues.oasis-open.org/browse/ODATA-1328)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Extend applicability of Core.MediaType and Core.AcceptableMediaTypes to non-stream (string/binary) properties and terms",
    "body": "We have some cases where the value of a String-typed Term may be expected to contain JSON, XML or SQL (i.e. the annotation values have a constrained media type).\n\nIt would be helpful if we could change the description of Core.MediaType and Core.AcceptableMediaTypes to state that it is also applicable to regular (non-stream) properties of type Edm.Binary or Edm.String, as well as changing the AppliesTo so those terms can be applicable to Term elements of type Edm.Binary or Edm.String.\n\n### Proposal\n\nChange the description of Core.MediaType and Core.AcceptableMediaTypes to state that it is also applicable to regular (non-stream) properties of type Edm.Binary or Edm.String, and change the AppliesTo so those terms can be applicable to Term elements of type Edm.Binary or Edm.String.\n\nImported from [ODATA-1327](https://issues.oasis-open.org/browse/ODATA-1327)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Enhance syntax of term Validation.OpenPropertyTypeConstraint",
    "body": "Term [Validation.OpenPropertyTypeConstraint](https://github.com/oasis-tcs/odata-vocabularies/blob/master/vocabularies/Org.OData.Validation.V1.md#OpenPropertyTypeConstraint) is of type `Collection(Core.QualifiedTypeName)`.\n\nThis is too restrictive, I'd also be able to specify that a dynamic property of an open type can be collection-valued.\n\n### Proposal\n\nAlso allow strings with `Collection(...)` as values of this term, where `...` is the qualified name of a type is scope.\n\nNote: this \"rhymes\" with the syntax of the `Type` attribute of CSDL XML, less so with the syntax of CSDL JSON.\n\nNote: resolved with [ODATA-1523](https://issues.oasis-open.org/browse/ODATA-1523)\n\nImported from [ODATA-1326](https://issues.oasis-open.org/browse/ODATA-1326)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Explicitly state server behaviour when a client uses $select/$expand for an update response",
    "body": "Clients need a guaranteed way to get certain information in the response to PATCH/PUT such as an updated ETag.  Clarify that if the client specifies a $select and/or $expand for the response of a PATCH/PUT request, that the server MUST respond with a a response body including the ETag.\n\n### Proposal\n\nClarify that if the client specifies a $select and/or $expand for the response of a PATCH/PUT request, that the server MUST respond with a a response body. If the service uses ETags for optimistic concurrency, the entities in the response MUST include ETags.\n\nImported from [ODATA-1325](https://issues.oasis-open.org/browse/ODATA-1325)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Incorrect text about mediaEditLink control information",
    "body": "In section 4.5.12 in JSON format doc, the text says that the mediaEditLink control information needs to be included if it differs from the id.  It should be if it differs from the conventional URL of the media stream.\n\n### Proposal\n\nReword to say that the mediaEditLink control information needs to be included if it differs from the conventional URL of the media stream.\n\nImported from [ODATA-1324](https://issues.oasis-open.org/browse/ODATA-1324)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify representation of GEO literals and streams in annotations (XML, JSON)",
    "body": "Section 14.3 Constant Expression defines representations for primitive constant values in annotations, with two exceptions:\n- Edm.Stream\n- Edm.Geo*\n\nWe currently have no concrete use cases for either, but it's a gap.\n\n\n### Proposal\n\nIn CSDL JSON a constant annotation (property) value is the type-specific JSON representation of that value, see [OData-JSON].\n - For Edm.Geo* this is the GeoJSON value\n - For properties of type Edm.Stream this is\n -- native JSON for streams of media type application/json or one of its subtypes, optionally with format parameters\n -- a string containing the plain text for streams of media types text/*\n -- a string containing the base64url-encoded value for all other media types (same as Edm.Binary)\n\nIn CSDL XML a constant annotation (property) value is represented according to the appropriate alternative in the `primitiveValue` rule defined in [OData‑ABNF], using element or attribute notation:\n - a constant string expression for Edm.Geo* whose value is the appropriate `full_Xxx_Literal` for Edm.Geo*, e.g. `fullPointLiteral` for Edm.GeometryPoint and Edm.GeographyPoint\n - a constant string expression for Edm.Stream with media types application/json or text/*\n - a constant binary expression for Edm.Stream for all other media types\n\nFor stream values the annotation (property) MUST be annotated with term `Core.MediaType` and the media type of the stream as its value.\n\nServices SHOULD only return these annotation values in CSDL documents with Version 4.02 or later.\n\nClients SHOULD already ignore unknown annotations. This now extends to annotations containing literal Edm.Stream and Edm.Geo* values.\n\nImported from [ODATA-1323](https://issues.oasis-open.org/browse/ODATA-1323)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add odata. prefix to omit-values preference",
    "body": "In the last TC call it was decided that we should register the \"odata.\" prefixed versions of the OData preferences with IANA.  The omit-values preference is new to OData 4.01 and therefore never had an \"odata.\" prefixed version of the preference.  Should an the preference name \"odata.omit-values\" be added as an alternate name for the preference? \n\n### Proposal\n\nAdd \"odata.omit-values\" as an alternate name for the omit-values preference\n\nImported from [ODATA-1322](https://issues.oasis-open.org/browse/ODATA-1322)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Prefer:respond-async on individual requests within a batch request",
    "body": "Part 1: Protocol states in [8.2.8.8 Preference `respond-async`](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_Preferencerespondasync) that\n> \n> The respond-async preference MAY be used for batch requests, but the service MUST ignore the respond-async preference for individual requests within a batch request.\n> \n\n\nHowever, JSON Format states in [19.6 Asynchronous Batch Requests](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_AsynchronousBatchRequests) that\n> \n> In addition to the above interaction pattern individual requests within a batch MAY be executed asynchronously if they specify the respond-async preference and if the service responds with a JSON batch response.\n> \n\n\nApparently the restriction in Part 1: Protocol only applies to multi-part batch requests or responses.\n\n### Proposal\n\nIn Protocol: preference respond-async, remove references to use for single requests within a batch; clarify that use on a batch applies to the entire batch:\n\"The respond-async preference MAY be used for batch requests, in which case it applies to the batch request as a whole and not to individual requests within the batch.\"\n\nIn description of multipart batch, prohibit use of respond-async for individual requests within a batch\n\nIn JSON Format, allow use of respond-async for individual requests as long as they are not within an atomicity group. If a request depends on a request that is executed asynchronously, then it SHOULD fail with 424 failed dependency.\n\nImported from [ODATA-1321](https://issues.oasis-open.org/browse/ODATA-1321)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "edm.xsd: attribute edm:Annotations/@Target does not cover all allowed targets",
    "body": "The pattern for simple type TTarget does not cover all allowed target path expressions with segment /$ReturnType to address the return type of an action/function overload.\n\nIt also allows one parentheses too many after the overload signature.\n\n### Proposal\n\nSee summary and resolution\n\nImported from [ODATA-1320](https://issues.oasis-open.org/browse/ODATA-1320)",
    "labels": [
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify format parameter IEEE754Compatible with requests",
    "body": "Section 3.3 states that *payloads* that format Edm.Int64 and Edm.Decimal values as strings MUST specify the IEEE754Compatible=true format parameter, however section 4.1 only mentions responses.\n\n### Proposal\n\nChange fourth paragraph of [4.1 Header Content-Type](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_HeaderContentType) to (new text in green)\n> R{color:#14892c}equests and r{color}esponses MUST include the IEEE754Compatible parameter if Edm.Int64 and Edm.Decimal numbers are represented as strings.\n> \n\n\nNote: this is a non-material change as section 3.3 already required this for all payloads, which includes request payloads.\n\nImported from [ODATA-1319](https://issues.oasis-open.org/browse/ODATA-1319)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Should support multiple permissions for read/write",
    "body": "Authentication schemes define scopes that govern the permissions that an authenticated client has when accessing the service. \n\nA service may support multiple different schemes for authentication. \n\nThis is well supported today in our authentication vocabulary.\n\nHowever, access to an individual resource today is specified through a PermissionType, which specifies a set of scopes from a single authentication scheme. If the service supports multiple authentication schemes, then any of the supported authentication schemes may control access to the resource.\n\nWhere controlling access to a resource, the capabilities vocabulary should specify a collection of PermissionTypes (required scopes from a particular authentication scheme) that can be used to access a resource.\n\n### Proposal\n\nChange the \"Permission\" property to \"Permissions\", and \"PermissionType\" to \"Collection(PermissionType)\", where used in the capabilities vocabulary.\n\nImported from [ODATA-1316](https://issues.oasis-open.org/browse/ODATA-1316)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Introduce CollectionAnnotation control information for JSON",
    "body": "We don't have a way to annotate members of a primitive collection in JSON.\n\n### Proposal\n\nAdd a new JSON control information item, \"collectionAnnotations\".\n Value is a complex type containing an integer \"index\" property and any annotations associated with the indexed item.\n\nusage:\n\nmyList@odata.collectionAnnotations : [\n {\n \"index\": 2,\n \"@Core.ValueException\" :\n\n{ \"value\", \"9223372036854775807\"}\n\n\"@custom.ProvidedBy\" : \"Bill\"\n },\n\n{ \"index\": 5, \"@custom.NotAuthorized\" : true }\n\n],\n myList : [\n 3,\n 9223372036854776000,\n 47,\n 0,\n null,\n 12\n ]\n  \n\nImported from [ODATA-1315](https://issues.oasis-open.org/browse/ODATA-1315)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "odata.mediaContentType control information for embedded stream properties",
    "body": "JSON Batch represents JSON message bodies as \"inlined JSON\" and textual media types as JSON strings (with JSON string quoting/escaping), everything else is base64url-encoded and then packed into a JSON string.\n\nThe rules for expanded/inlined stream properties are slightly different, which is inconsistent.\n\n### Proposal\n\nSame rules for JSON Batch message bodies and inlined/expanded streams:\n- Streams of media type application/json and subtypes are represented as \"inlined JSON\".\n- Streams of media type text/* are represented as JSON strings (quoted/escaped accordingly.\n- Streams of all other content types are base64url-encoded and represented as JSON strings. \n\nControl information mediaContentType MUST be present for inlined streams.\n\nImported from [ODATA-1314](https://issues.oasis-open.org/browse/ODATA-1314)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Simplify $batch atomicity group processing",
    "body": "Current specification requires all but the failing request in an atomicity group to return a 424 failed dependency status code. This impedes stream processing of $batch requests with large atomicity groups.\n\n### Proposal\n\nAllow request in an atomicity group to report the actual status of executing that request while continuing to allow requests to return a 424 failed dependency which would then typically be used for those requests that haven't been attempted due to a failed request.\n\nImported from [ODATA-1313](https://issues.oasis-open.org/browse/ODATA-1313)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add $compute to supported $select query options",
    "body": "4.01 adds support for $select options such as nested $select and $expand and, for collection-valued properties, $top, $skip, $orderby, and $count.\n\nAs pre ABNF and URL Conventions, we also allow $compute as a $select option, that is missing from the section on $select in the Protocol document, which states:\n\n{color:#000000}\"...Allowed system query options are {color}[$select](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionselect){color:#000000} and {color}{color:#000000}$expand{color}{color:#000000}, plus {color}[$filter](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionfilter){color:#000000}, {color}[$search](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionsearch){color:#000000}, {color}[$count](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptioncount){color:#000000}, {color}[$orderby](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionorderby){color:#000000}, {color}[$skip](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionskip){color:#000000}, and {color}[$top](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptiontop){color:#000000} for collection-valued properties.\"{color}**++\n\n### Proposal\n\nSupport $compute as a select option for collection/complex type valued structural properties.\n\nImported from [ODATA-1312](https://issues.oasis-open.org/browse/ODATA-1312)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Edm.AnyPropertyPath: no corresponding path expression",
    "body": "[ODATA-516](https://issues.oasis-open.org/browse/ODATA-516) introduced Edm.AnyPropertyPath and Edm.AnyPath (later renamed to Edm.ModelElementPath).\n\nWhile we added a dynamic annotation expression for ModelElementPath, we did not add one for Edm.AnyPropertyPath.\n\n### Proposal\n\nRemove type Edm.AnyPropertyPath.\n\nVocabulary designers can use Edm.ModelElementPath instead, and can annotate the term or term property with Validation.DerivedTypeConstraint to restrict it to just Edm.PropertyPath and Edm.NavigationPropertyPath.\n\nImported from [ODATA-1311](https://issues.oasis-open.org/browse/ODATA-1311)",
    "labels": [
      "CSDL JSON",
      "Data Aggregation",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "\"Long\" numbers in response payloads without IEEE754Compatible=true",
    "body": "Section [3.2 Controlling the Representation of Numbers](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_ControllingtheRepresentationofNumber) currently states:\n> \n> If not specified, or specified as `IEEE754Compatible=false`, all numbers MUST be serialized as JSON numbers.\n\n\n\n\n### Proposal\n\nKeep the rules for requesting and sending representations of numbers.\n\nAllow services to represent \"overly long\" numbers in responses without format parameter `IEEE754Compatible=true` as an instance annotation on the numeric property with term `Core.ValueException` containing the exact value as a string. The service MAY also include the numeric property with a rounded/inexact value as a JSON number.\n\nThis is not supported in request payloads, clients can use format parameter `IEEE754Compatible=true` and pass all Int64 and Decimal values as strings.\n\nImported from [ODATA-1310](https://issues.oasis-open.org/browse/ODATA-1310)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON Batch: clarify \"Textual media types\" and their string representation",
    "body": "Question from implementation team:\n> \"Textual media types\" are represented as a string: what exactly are \"textual media types\"?\n\n\n\n### Proposal\n\n\"Textual media types\" are all and only the media types `text/*`, i.e. top-level type `text`.\n\nSame rule for inlined stream properties: `application/json` and `text/*` are represented \"naturally\", everything else is base64url-encoded, see [ODATA-1314](https://issues.oasis-open.org/browse/ODATA-1314).\n\nImported from [ODATA-1309](https://issues.oasis-open.org/browse/ODATA-1309)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Errors in Example 34: products with aggregated sales",
    "body": "Example 34 in “3.17 Evaluating $apply as an Expand Option” ([http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016591](https://nam06.safelinks.protection.outlook.com/?url=http%3A%2F%2Fdocs.oasis-open.org%2Fodata%2Fodata-data-aggregation-ext%2Fv4.0%2Fcs02%2Fodata-data-aggregation-ext-v4.0-cs02.html%23_Toc435016591&data=04%7C01%7Cmikep%40microsoft.com%7C69c4d0d17ebe430ca45d08d6e9dfa7ff%7C72f988bf86f141af91ab2d7cd011db47%7C1%7C0%7C636953544148230845%7CUnknown%7CTWFpbGZsb3d8eyJWIjoiMC4wLjAwMDAiLCJQIjoiV2luMzIiLCJBTiI6Ik1haWwiLCJXVCI6Mn0%3D%7C-1&sdata=SelBZPN1ChRzKcLeJWO4aaap5ZizR3iCopsZmtFXM%2Bo%3D&reserved=0)) says  that for following query:\n\nGET Products?$expand=Sales($apply=aggregate(Amount with sum as Total))\n\n @odata.context in result should look like:\n\n\"@odata.context\":\"$metadata#Poducts(Salees(Amount)\",\n\n There appear to be a few errors with the context:\n- Typos in Products and Sales\n- Amount instead of Total that is part of output\n- Missing closing parens\n\n I believe the context should be:\n\n\"@odata.context\":\"$metadata#Products(Sales(Total))\",\n\n### Proposal\n\nUpdate the context in the example as described.\n\nImported from [ODATA-1307](https://issues.oasis-open.org/browse/ODATA-1307)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Align conformance clauses with normative text",
    "body": "The prose text contains MUST requirements for features that are called out as being optional for certain conformance levels, e.g. section 11.1.2 [Metadata Document Request](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_MetadataDocumentRequest) says that\n> OData services MUST expose a metadata document [...]\n> \n\nwhereas 13.1.1 [OData 4.0 Minimal Conformance Level](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_OData40MinimalConformanceLevel) says\n> \n> 13.  SHOULD publish metadata [...]\n> \n\n\n### Proposal\n\nChange first sentence of fourth paragraph to \n> OData services +can+-MUST- expose a metadata document that describes the data model exposed by the service.\n> \n\n\nImported from [ODATA-1306](https://issues.oasis-open.org/browse/ODATA-1306)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify ranges of minute, hour, and second functions",
    "body": "The headlines of the examples for the hour, minute, and second function may suggest that the result ranges of these functions start with 1.\n\n### Proposal\n\nExplicitly state the result ranges 0..23 for hour, 0..59 for minute, and 0..60 for second - to allow for leap seconds.\n\nAdapt the example headlines to be less misleading.\n\nImported from [ODATA-1305](https://issues.oasis-open.org/browse/ODATA-1305)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve descriptions on Capabilities.NavigationRestrictionsType",
    "body": "\n\n### Proposal\n\nFor Navigability on the entityset/singleton, change description to: \n\"Default navigability for all navigation properties on the annotated target. Individual navigation properties can override this value via RestrictedProperties.\"\n\nFor Navigability on individual navigation property, change description to:\n\"Supported navigability of this navigation property\"\n\nImported from [ODATA-1304](https://issues.oasis-open.org/browse/ODATA-1304)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify whether schemas traversed in path expressions must be in scope",
    "body": "Assume service A references service B, which in turn references service C.\n\nIf I annotate an entity type in service A with a path expression using cross-service navigation to services B and C, do I need to reference/include the corresponding schemas of B an C, or is it sufficient to only reference/include the schema of service A containing the targeted entity type?\n\nExample\n```xml\n<Annotations Target=\"SchemaServiceA.SomeEntityType\">\n  <Annotation Term=\"SomeVocab.SomeTerm\" Path=\"NavPropToServiceB/NavPropToServiceC/ServiceCProperty\"/>\n</Annotations>\n```\n \n\n### Proposal\n\nIt is sufficient to reference service B from service A.\n\nA client/validator needs to read the metadata of service B anyway to find out whether the referenced entity type from service B has a navigation property NavPropToServiceC. Then it can use the references within service B's metadata to figure out where NavPropToServiceC points to, and if necessary follow a reference from service B to service C for the next step of validation.\n\nThis is true for all path traversal (i.e., in URL) and is in contrast to directly referencing a type defined in service C's schema from service A (which requires a direct reference to service c's schema) \n\nImported from [ODATA-1303](https://issues.oasis-open.org/browse/ODATA-1303)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support PUT to replace a collection of entities",
    "body": "In 4.01 we added support for doing a deep update by doing a PUT against an entity with an inline set of objects; the semantics are that, at the end of the operation, the entity contains exactly the entities specified in the payload; any entities not specified are removed (and, for containment or if an integrity constraint exists, deleted).  This is the same semantics as doing a PUT with a nested collection of primitive or complex types.\n\nWe do not, however, currently support the same semantics against the path that specifies the same collection.  That is, a PUT to customers(1) that contains nested orders replaces the orders for customer 1, but a PUT to customers(1)/orders is not currently specified if orders is a collection of entities (though it is if orders is a collection of complex types). \n\n### Proposal\n\nSupport PUT to a resource path that identifies a collection of entities with the same replace semantics as if the collection were a collection of primitive or complex types, or a collection of entities in a deep update.\n\nImported from [ODATA-1302](https://issues.oasis-open.org/browse/ODATA-1302)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Can nullable singletons be deleted or created?",
    "body": "[ODATA-1183](https://issues.oasis-open.org/browse/ODATA-1183) introduced nullable singletons:\n- Can they be created if they are currently null?\n- Can they be deleted if they are currently not null?\n\nProtocol section 11.4.5 Delete an Entity currently states that singletons cannot be deleted.\n\n### Proposal\n\nNullable singleton should have identical semantics to a nullable single-value contained navigation property.\n\nIf a singleton is null, a service may support upserting it via PATCH or PUT, and can announce  this with annotation `Capabilities.UpdateRestrictions/Upsertable:true`, see [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005).\n\nIf a singleton is nullable, a service may support deleting it via DELETE. By default nullable singletons are deletable, and the service can announce that it is _not_ deletable with annotation `Capabilities.DeleteRestrictions/Deletable:false`, see [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005). (Note: the default for this annotation is `Deletable:true` because it also applies to entity sets and has been around for some time.)\n\nImported from [ODATA-1301](https://issues.oasis-open.org/browse/ODATA-1301)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Capabilities: clarify CountRestrictions and ExpandRestrictions",
    "body": "The complex type `NavigationPropertyRestriction` has properties for all capability annotations that can be directly applied to an entity set or singleton and allows applying the same restrictions to a (containment) navigation property.\n\nWith two exceptions: currently there are no properties `CountRestrictions` and `ExpandRestrictions` corresponding to the identically named terms. Instead these terms have lists of NonXxxableProperties.\n\nDo we want to keep this difference in style, or do we want to harmonize that with `NavigationRestrictions/RestrictedProperties`?\n\n### Proposal\n\n`ExpandRestrictionsType`:\n- Add property `NonExpandableStreamProperties` of type `Collection(Edm.PropertyPath)`\n\n`CountRestrictionsType`:\n- Applies also to `Singleton`\n- Adjust descriptions accordingly\n\nImported from [ODATA-1300](https://issues.oasis-open.org/browse/ODATA-1300)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Continue-on-Error for Collection requests",
    "body": "In a GET against a collection of entities, it is possible that an entity returns an error, for example if a connection to the provider of the entity is lost.\n\nThe proposal is to allow a Continue-On-Error preference or a $Continue-On-Error query option for a GET against a collection.\n\nIn the event of an error returned by an entity being retrieved, the effect of Continue-On-Error,  would be to stop the current page, returning both the entities up to the error and an Error result for the element that returned the error and, if there are additional elements following, a nextLink for use in retrieving the remaining entities in the collection.\n\nNote for discussion, the first result could be split, first returning entities up to but not including the failed entity, with a nextLink to retrieve the error result for the failing entity, And finally more entities, if the last returned a nextLink. \n\n \n\n \n\n### Proposal\n\nChanges:\n 1. Define Core.ExceptionType\n\n  -optional info property of type MessageType\n\n2. (re) Define Core.ValueExceptionType : ExceptionType\n\n  -optional value property of type string\n\n3. Define Core.ResourceException:ExceptionType to mark a resource or collection within a success payload as in error.\n       -optional retryLink\n\n4. Define Core.ModificationException of type DataModificationException : ExceptionType\n      -failedOperation (insert, update, upsert, delete, invoke, addlink, removelink)\n      -optional responseCode (i.e., 424 for failed dependency)\n\nClarifications:\n\n1. (non-key) Properties within tombstones in update payloads are effectively ignored\n\nScenarios:\n 1. Error retrieving a value within a structured resource (does not require continueonerror)\n a) Annotate property with the new Core.ValueException\n  \n 2. Error retrieving a resource within a collection (any collection, with continueonerror)\n a) Annotate resource within collection with Core.NestedItemException\n  \n 3. Error retrieving part of a collection (with continueonerror)\n a) Return a NextLink\n  \n 4. Error retrieving entire collection within a resource (with continueonerror)\n a) Annotate collection property with Core.NestedItemException\n\n5. Applying a delta update\n a) Return=representation response is a Delta response that is 1:1 with delta request\n b) Entities within the response have current persisted values\n c) Don’t support $select, $filter, $expand, $orderby, $search, $count, etc…\n d) If continue-on-error\n i) Failed deletes are returned as entities/entity references, annotated with DataModificationException (operation=delete or unlink)\n ii) Failed inserts are returned as tombstones with DataModificationException (operation=insert)\n iii) Failed updates may be annotated with DataModificationException (operation=update)\n iv) Failed addedlinks returned as deletedlink with DataModificationException (operation=link)\n v) Failed deletedlinks returned as addedlink with DataModificationException (operation=unlink)\n e) If the delta update contains a nested full representation, the response contains the full nested representation of the after-image.\n\ng) If the update of a nested resource fails, the update to the parent (and siblings) may fail\n i) Operation is the operation attempted at the resource that is annotated (i.e., update)\n ii) May return 424 Failed Dependency as status for related resources\n i) Unlike batch, if it is not annotated with failed, it is success\n h) If return=minimal + ContinueOnError, service MUST return at least the things in error\n i) perhaps as a flattened delta payload\n  \n 6. Applying a deep update/insert\n a) Don't support continue-on-error for deep inserts/updates\n b) Deep updates can support delta collections and inline full representations. Deep inserts are not extended to support updating - the client can do a delta update against the collection with the single entity to be inserted, including nested information to be updated.\n\nc) Response is the same shape as the deep update/insert in the request\n d) Entities within the response have current persisted values\n  \n 7. Applying a set-based update\n a) Response (if specified by return=representation) is the delta response showing current values (after-image) of the set of things identified by the input collection (i.e., after any filter segment). Note that specifying return=representation may remove any implementation optimizations around doing the set operation.\n b) Note: may be deep update (including nested collection/delta collection, in which case above rules apply)\n c) Don’t specify support for query options\n d) If continue-on-error\n i) Failed updates may be annotated with DataModificationException (operation=update)\n ii) If return=minimal + continue on error, MUST return at least the things in error (perhaps flattened)\n  \n 8. Applying a set-based delete\n a) Response (if specified by return=representation) is the delta response showing tombstones for the set of things identified by the input collection (i.e., after any filter segment). Note that specifying return=representation may remove any implementation optimizations around doing the set operation.\n b) Don't specify support for query options\n c) If continue-on-error\n i) Failed deletes returned as entity/entity reference with DataModificationException (operation=delete)\n ii) If return=minimal + continue on error, MUST return at least failures\n\n9. Applying a set-based action invocation\na) Clarify that (if specified by return=representation) the result of a set-based action invocation is a collection of the individual action responses as if they had been invoked separately (including any value wrapper for collections or primitives).\nc) Support for query options is not specified, but apply to each individual action response\nd) If continue-on-error\ni) Response objects returned from failed invocations may be annotated with DataModificationException (operation=invoke)\nii) If return=minimal + continue on error, MUST return at least the things in error\n\nImported from [ODATA-1299](https://issues.oasis-open.org/browse/ODATA-1299)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify creation choreography for media entities, recommend stream properties",
    "body": "Media entities are a somewhat obscure heirloom from AtomPub, and the \"atomic pair\" nature of a media resource and its media entity is not clearly explained and not very intuitive.\n\nFor example implementations differ in how they treat the `content-type:application/json`  in POST requests to a media entity set:\n - some implementations create a media _entity_ using the POST body and do not create a media resource\n - some implementations create a JSON media resource using the POST body, plus a media entity pointing to that JSON media resource\n\nWe should give guidance on when to use media entities and when to use \"normal\" entities with stream properties.\n\n### Proposal\n\nAdd\n- as a second paragraph to Protocol, section 11.2.3 Requesting the Media Stream of a Media Entity using $value, and\n- after the second sentence to first paragraph of CSDL JSON/XML, section 6.4 Media Entity Type\n\nthe following guidance\n> Use a media entity if the out-of-band stream is the main topic of interest and the media entity is just structured additional information attached to the stream. Use a normal entity with one or more stream properties if the structured data of the entity is the main topic of interest and the stream data is just additional non-structured information attached to the structured data.\n> \n\nAdd *{color:#14892c}green text{color}* to first paragraph of Protocol, section 11.4.7.1 Create a Media Entity\n> A POST request to a media entity's entity set creates a new media entity. The request body MUST contain the media value (for example, the photograph) whose media type MUST be specified in a Content-Type header. *{color:#14892c}The request body is always interpreted as the media value, even if it has the media type of an OData format supported by the service, such as `application/json`. It is not possible to set the structural properties of the media entity when creating the media entity.{color}*\n> \n\n\nImported from [ODATA-1298](https://issues.oasis-open.org/browse/ODATA-1298)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON Batch: clarify values of body property, context URL, batch in batch, continue-on-error",
    "body": "Clarify:\n1. Can the `body` property in request/response object have the value `null`? If yes, does this mean \"empty body\" or \"no body\"? See also next question.\n1. Can responses with `status:204` have a `body`?\n1. \"Textual media types\" are represented as a string: what exactly are \"textual media types\"?\n1. [RFC 7230](https://tools.ietf.org/html/rfc7230) distinguishes between \"message body\" and \"payload body\": which one is `body`, i.e. can a `Transfer-Encoding` (gzip, chunked, ...) be applied?\n1. What is the context URL of a JSON batch request or JSON batch response?\n1. Can a request object within a JSON batch request be itself a (JSON) batch request?\n1. Why do we allow the preference `continue-on-error=false` at all? The client can specify explicit dependencies with `dependsOn` if it wants certain dependency chains to stop at first error. \n\n### Proposal\n\nFrom 2019-6-6 discussion:\n\nResponses for all except #3 seem straightforward. We'll open a separate issue for #3. The rest are as proposed:\n1. Yes, `\"body\":null` and omitting the `body` property both mean \"no body\"\n1. Yes, `\"body\":null`\n\n3. issue [ODATA-1309](https://issues.oasis-open.org/browse/ODATA-1309) created to track this issue.\n\n4. body content can be compressed/chunked if correctly reflected in `Transfer-Encoding` header\n 5. explicitly mention that these don't have a context URL\n 6. Part 1: Protocol clearly defines which requests can be inside a batch request, and batch is not listed:\n> Batch requests allow grouping multiple individual requests into a single HTTP request payload. An individual request in the context of a batch request is a [Metadata Request](#sec_MetadataRequests), [Data Request](#sec_RequestingData), [Data Modification Request](#sec_DataModification), [Action invocation](#sec_InvokinganAction) request, or [Function invocation](#sec_InvokingaFunction) request.\n> \n\n7. If processing stops on error the batch response can be incomplete, whereas with `dependsOn` the batch response would contain a response for each individual request which has status:412 if the request has been skipped due to a failed dependency\n\nImported from [ODATA-1297](https://issues.oasis-open.org/browse/ODATA-1297)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow all non-whitespace characters in a search word, and allow unbalanced quotes and parentheses",
    "body": "The ABNF rule for [searchWord](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L356) is overly restrictive, allowing only Unicode letters, numbers, and some punctuation characters. Character sequences with other characters need to be enclosed in double-quotes to pass the ABNF, i.e. be formulated as a searchPhrase.\n\nHowever double-quoted \"phrases\" typically have special meaning for search engines, e.g. use exact, non-fuzzy match, meaning that `$search=word` and `$search=\"word\"` have different results.\n\nAlso when used for type-ahead the search expression will typically be incomplete while the user is typing, and the user's expectation is to already see matching proposals while typing. All these search requests should give a search result and none of them should lead to an error:\n```java\n$search=\"\n$search=\"b\n$search=\"bl\n$search=\"blu\n$search=\"blue\n$search=\"blue%20\n$search=\"blue%20p\n$search=\"blue%20pi\n$search=\"blue%20pil\n$search=\"blue%20pill\n$search=\"blue%20pill\"\n```\n Same for unbalanced parentheses.\n\n \n\n### Proposal\n\nClients can send unbalanced expressions in $search to simplify type-ahead use cases if these unbalanced expressions are sent as OData string literals, i.e. enclosed in single quotes, and single quotes within the string need to be doubled to escape them.\n\nServices can announce this feature via term property Capabilities.SearchRestrictions/AllowUnbalancedExpressions (boolean, default false).\n\nImported from [ODATA-1296](https://issues.oasis-open.org/browse/ODATA-1296)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify whether new annotation target syntax requires Version=4.01",
    "body": "With [ODATA-1178](https://issues.oasis-open.org/browse/ODATA-1178) we added the possibility to target individual action/function overloads by appending their signature to the action/function name.\n\nClarify whether this already requires to use Version=4.01, or whether this is just \"string content\" for the Target attribute and can be used with Version=4.0\n\n### Proposal\n\nDo not require Version=4.01 or OData-Version:4.01 for these new targets.\n\nRationale: we already require in [CSDL Version 4.0 Errata 03](http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part3-csdl/odata-v4.0-errata03-os-part3-csdl-complete.html#_Toc453752619) that (minus the blue text)\n> {color:#59afe1}*Unknown or invalid annotations should never result in an error, as long as the payload remains well-formed.* {color}Clients SHOULD ignore *{color:#59afe1}invalid or{color}* unknown terms and *{color:#14892c}silently treat unexpected or invalid values{color}* (including invalid type, invalid literal expression, {color:#59afe1}*invalid targets,*{color} etc.) as an unknown value for the term.\n> \n\nSo worst case clients the annotation on the overload.\n\nAdd the blue text to make this unambiguously clear.\n\nImported from [ODATA-1295](https://issues.oasis-open.org/browse/ODATA-1295)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Explicitly state what is returned on create and update",
    "body": "Section 11.4.2 Create an Entity does not explicitly state what is returned in a 201 response.\n\nSection 11.4.3 Update an Entity does not explicitly state what is returned in a 200 response.\n\n### Proposal\n\nChange text in 11.4.2 to (new text in green)\n> {color:#333333}Upon successful completion the service MUST respond with either [201 Created](#sec_ResponseCode201Created) {color}{color:#14892c}and a representation of the created entity{color}{color:#333333}, or [204 No Content](#sec_ResponseCode204NoContent) if the request included a [Prefer header](#sec_Preferencereturnrepresentationandret) with a value of [return=minimal](#sec_Preferencereturnrepresentationandret).{color}\n> \n\n{color:#333333}Change text in 11.4.3 to (new text in green){color}\n> Upon successful completion the service responds with either [200 OK](#sec_ResponseCode200OK) {color:#14892c}and a representation of the updated entity,{color} or [204 No Content](#sec_ResponseCode204NoContent).\n> \n\n\nImported from [ODATA-1294](https://issues.oasis-open.org/browse/ODATA-1294)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL 7.2.1 Nullable: improve wording",
    "body": "The current text in section 7.2.1 Nullable is\n> \n> 7.2.1 Nullable\n> A Boolean value specifying whether a value is required for the property.\n> \n\n\nThis is misleading and suggests that the property can be omitted. Actually it only means that the property can be null.\n\n### Proposal\n\nChange text to \n> \n> 7.2.1 Nullable\n> A Boolean value specifying whether the property can have the value `null`.\n> \n\n\nImported from [ODATA-1292](https://issues.oasis-open.org/browse/ODATA-1292)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ETags for Collections",
    "body": "With [ODATA-981](https://issues.oasis-open.org/browse/ODATA-981) we clarified that collections can also have ETags and clients must specify `if-match` when posting to the collection.\n\nWhat's missing is\n- an annotation in $metadata to tell clients up-front which collections, especially collection-valued navigation properties, use optimistic concurrency control\n- a way to transport ETags for collection-valued navigation properties in responses to the \"container\" entity\n\n\n### Proposal\n\nh1. JSON Format\n\nTransport the ETag for a collection-valued navigation property in its containing entity as control information on the navigation property:\n```java\n{\n  \"@context\": \"http://host/service/$metadata#Orders/$entity\",\n  \"@id\": \"Orders(1234)\",\n  \"@etag\": \"W/\\\"MjAxMy0wNS0yN1QxMTo1OFo=\\\"\",\n  \"ID\": 1234,\n  \"Items@etag\": \"W/\\\"MjAxOS0wMy0xMlQxMDoyMlo=\\\"\"\n}\n```\nNote: the collection ETag for a navigation property may or may not be identical to the ETag of the container entity, the example shows a different ETag for the Orders collection.\n\nServices MAY include these, just as they MAY include the entity @etag control information. Up to the server when to do it. based e.g. on computational complexity.\nh1. Annotate Navigation Properties\n\nExtend type `Capabilities.NavigationPropertyRestriction` with property `OptimisticConcurrencyControl` of type `Edm.Boolean`, default value `false`.\n\nNote: this differs from the existing term `Core.OptimisticConcurrency` which is a collection of property paths, using an empty collection for \"tagging\" without revealing which properties influence the calculated ETag.\nh1. Protocol\n\nAdd `POST` to the list of methods in sections 8.2.4 Header If-Match and 8.2.5 Header If-None-Match.\n\nMention collection ETags in section 11.4.1.1 Use of ETags for Avoiding Update Conflicts.\n\nImported from [ODATA-1291](https://issues.oasis-open.org/browse/ODATA-1291)",
    "labels": [
      "JSON Format",
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Can an etag value of \"*\" be used in If-Match to force update?",
    "body": "There was a question in [ODATA-1168](https://issues.oasis-open.org/browse/ODATA-1168) that got missed in its resolution, which was whether or not clients could specify If-Match:* could be used by the client to force an update.\n\nThis issue is to address that question.\n\n### Proposal\n\nClients can attempt to disable optimistic control on updating by specifying If-Match:*. Services MAY reject such requests.\n\nImported from [ODATA-1290](https://issues.oasis-open.org/browse/ODATA-1290)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Capabilities: use Edm.Boolean instead of Core.Tag as a type for properties",
    "body": "\n\n### Proposal\n\nSee summary: only use Core.Tag for tagging terms with default value \"true\":\n\nReplace existing use of Core.Tag in properties (i.e., in SelectSupportType) with Edm.Boolean.\n\n \n\nImported from [ODATA-1289](https://issues.oasis-open.org/browse/ODATA-1289)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Precisely specify the format of the Error Response",
    "body": "The current specification text does not explicitly specify that `message` and `target` are strings, and whether they can be `null`.\n\n### Proposal\n\n Updated proposal from 2019-3-7:\n - We need to specify the format-independent minimal content of an error response body in Protocol\n - code: non-empty string, not null\n -  code: not language-dependent\n -  message: language-dependent, non-empty, not null, human-readable\n -  target: string, can be null, can be omitted, can be empty\n - details: collection of structured instances with code, message, target, same rules as above\n - innererror: optional, structured instance, anything goes\n - Make comment about security concerns \"global\" to error response, not only specific to innererror\n\n \n\nChange paragraphs 3 to 5 in chapter 21 Error Response:\n> The value for the code name/value pair is a language-independent string. Its value is a service-defined error code. This code serves as a sub-status for the HTTP error code specified in the response.\n> \n> The value for the message name/value pair -MUST be-+is a string containing+ a human-readable, language-dependent representation of the error. The Content-Language header MUST contain the language code from *[[RFC5646]](#rfc5646)* corresponding to the language in which the value for message is written.\n> \n> The value for the target name/value pair is <ins>a string containing</ins> the target of the particular error (for example, the name of the property in error).\n>  <ins>Neither `code` nor `message` can have the value `null`.</ins> \n\n \n\n \n\n \n\nImported from [ODATA-1288](https://issues.oasis-open.org/browse/ODATA-1288)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Annotate a property as \"cannot be specified on insert, can be updated later\"",
    "body": "Business documents can contain fields that cannot be filled out when creating the document and can only be updated after successfully creating the business document.\n\nOne example is \"physical inventory\":\n- A physical inventory document is created as a plan for performing a physical inventory, listing the materials to be inventoried. \n- The stocks are counted for the materials to be inventoried.\n- The count results are entered in the physical inventory document. The document is now \"counted\".\n- If the count revealed differences between book and reality, the warehouse manager checks the reason for the difference and enters it in the document.\n- The difference can then be posted by the manager.\n\n\nTo accurately reflect this in the service metadata, the \"count\" and the “difference reason” properties need to be annotated as \"do not provide on insert, only provide on update\".\n\n### Proposal\n\nAdd a new property `NonInsertableProperties` to term `InsertRestrictions` that is a collection of property paths, similar to the existing `NonInsertableNavigationProperties`.\n\nNote: we do not need this yet for update as this is covered by term `Core.Immutable` on the property level.\n\nImported from [ODATA-1287](https://issues.oasis-open.org/browse/ODATA-1287)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "What is the meaning of year 0, and negative years",
    "body": "In dateValue and other places ABNF allows year zero (or negative).\n\nNow with OData V4 there is no specific reference to XML Schema Part 2 DataTypes (Second Edition) although OData 3 spec did have a reference to that document for dateTimeOffsetLiteral, so perhaps there is an unwritten understanding that OData lexical representations match those defined in XML Schema Part 2 Datatypes (Second Edition).\n\nIn any case, see [https://www.w3.org/TR/xmlschema-2/#year-zero]\n\nKey questions: (see the linked XML Schema section)\n\n(1) Is year 0 valid in OData Date/DateTimeXXX values (including Edm.String with Core.DateTime annotation in 4.01)? If so, what does it mean? (e.g. 1 BCE)\n\n(2) What is the interpretation of negative years in OData Date/DateTimeXXX values? Is year -1 equivalent to 1 BCE, or to 2 BCE?\n\n \n\n### Proposal\n\nYear 0 is equivalent to 1 BCE, and year -1 is equivalent to 2 BCE.\n\nSupport for negative years and years with more than four significant digits is not mandatory, e.g. SQL only supports years 0001 to 9999.\n\nImported from [ODATA-1286](https://issues.oasis-open.org/browse/ODATA-1286)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add ReadByKeyRestrictions similar to ReadRestrictions",
    "body": "With [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099) we added the term `ReadRestrictions` with a property `Readable`.\n\nFor entity sets we have two independent read operations that need to be distinguished:\n- Read list of entities\n- Read single entity by key\n\n### Proposal\n\nAdd property `ReadByKeyRestrictions` to `ReadRestrictionsType` with a complex type that has the same properties as `ReadRestrictionsType` except `ReadByKeyRestrictions`. If a property of `ReadByKeyRestrictions` is not specified, the corresponding property value of `ReadRestrictions` applies.\n\nAdd property `ReadRestrictions` of type `ReadRestrictionsType` to complex type `NavigationPropertyRestriction`.\n\nImported from [ODATA-1285](https://issues.oasis-open.org/browse/ODATA-1285)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow referencing properties of \"outer\" entity in expressions nested within $expand",
    "body": "Expressions in query options nested within $expand already can reference the instance identified by the resource path via the symbolic literal $it. \nWhat's missing is in case of multiple nesting levels of $expand to reference the \"next outer\" instance.\n\nArtificial example: expand all Bars that have the same Baz as the current instance of Foo\n```\nGET Foo?$expand=Bar($filter=Baz eq $it/Baz)\n```\n\nWhat if I want to do this one level down: expand all Bazes that have the same Qux as the current expanded Bar's Qux\n```\nGET Foo?$expand=Bar($expand=Baz($filter=Qux eq $outer/Qux))\n```\n\nNote: $up is basically the `..` operator in Unix file systems.\n\nLess artificial example: a service with temporal entity sets for Employee, WorkAssignment, and Department. I want to request employees and their work assignments over a period of time to see all changes in data, and want to expand the department with the snapshot state at the beginning of each work assignment because changes to the department are not of interest:\n\n```\nGET Employees?$from=2010-01-01&$to=2019-02-28&$expand=WorkAssignments($expand=Department($at=$outer/@Temporal.From))\n```\n\n\n### Proposal\n\nParameter aliases can be defined within $expand, and as they are evaluated upon assignment $this can be assigned to a \"parameter\" alias to solve the problem at hand:\n```java\nGET Foo?$expand=Bar(@b=$this;$expand=Baz($filter=Qux eq @b/Qux))\n```\n\nAdd an example in Protocol 11.2.6.1.3 Parameter Aliases\n\nChange \"literals\" to \"values\" in last paragraph of 11.2.6.1.3 \n \n\nImported from [ODATA-1284](https://issues.oasis-open.org/browse/ODATA-1284)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "$search: ABNF comment is more restrictive than prose text",
    "body": "[ABNF line 347](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L347) states\n```java\n; The words AND, OR, and NOT are not a valid searchWord.\n```\nThis is more restrictive than the corresponding prose text (bold parts for later reference below):\n> The search expression can contain any number of terms, phrases, or group expressions, along with the case-sensitive keywords NOT, AND, and OR, evaluated in that order.\n> \n> Expressions *prefaced with NOT* evaluate to true if the expression is not matched, otherwise false.\n> \n> Two expressions not enclosed in quotes and separated by a space are equivalent to the same two expressions *separated by the AND* keyword. Such expressions evaluate to true if both of the expressions evaluate to true, otherwise false.\n> \n> Expressions *separated by an OR* evaluate to true if either of the expressions evaluate to true, otherwise false.\n> \n\n \nThe prose text would allow using the words AND and OR as the first search word in an expression because the operators *separate* search expressions, and NOT as the only search word because the operator *prefaces* an expression.\n \n\n### Proposal\n\nAdapt ABNF comment accordingly to allow\n  \n```java\n$search=AND\n$search=OR\n$search=OR ELSE\n$search=NOT```\nNote: it would be sufficient to allow AND, OR, and NOT as search words if they appear alone. Use case triggering this issue is type-ahead: a user slowly typing NOTE into a search field can trigger bad requests if the UI fires `$search=NO`, `$search=NOT`, `$search=NOTE` while the user is typing.\n\n \n\nImported from [ODATA-1283](https://issues.oasis-open.org/browse/ODATA-1283)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "How to set the mediaReadLink and mediaEditLink of a stream property",
    "body": "Stream properties allow the actual media to reside \"somewhere else\", redirecting clients to that location when directly addressing the stream property, and by including mediaReadLink and mediaEditLink in responses so clients can avoid the redirect from the canonical URL and directly access the media at its \"non-canonical\" location.\n\nHow can clients specify a \"non-canonical\" location when creating an entity with stream properties?\n\nHow can clients update the location of an existing stream property?\n\n### Proposal\n\nChange last paragraph of JSON Format section \"4.5.12 Control Information: media* (odata.media*)\" from\n> The `media*` control information is ignored in request payloads and not written in responses if metadata=none is requested.\n> \n\nto\n> The `media*` control information is not written in responses if metadata=none is requested.\n> \n> If a stream property is provided inline in a request, the `mediaContentType` control information may be specified.\n> \n> If a stream property is annotated with `Capabilities.MediaLocationUpdateSupported` and a value of `true`, clients MAY specify the `mediaEditLink` and/or `mediaReadLink` control information for that stream property in data modification requests to the structured type instance containing the stream property.\n> \n> In all other cases `media*` control information is ignored in request payloads.\n> \n\nAdd paragraph to Part 1: Protocol, section \"11.4.8.1 Update Stream Values\":\n> Services MAY support changing the association between a stream property and a media stream by specifying the edit URL or read URL of the stream property in data modification requests to the structured type instance containing the stream property. Services SHOULD advertise this by annotating the stream property with the term `Capabilities.MediaLocationUpdateSupported` defined in [OData-VocCap].\n> \n\n\nImported from [ODATA-1282](https://issues.oasis-open.org/browse/ODATA-1282)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify: interpretation of omitted optional function parameters",
    "body": "With https://issues.oasis-open.org/browse/[ODATA-1066](https://issues.oasis-open.org/browse/ODATA-1066) we added the possibility to mark parameters as optional.\n\nWe also added text to Part 1: Protocol describing how function overload resolution works in combination with optional parameters.\n\nTwo aspects of optional parameters just came up during implementation that I can’t find in the document or the issue:\n1. Are services free to interpret the absence of a parameter as best suits the purpose of the function?\n1. Can actions also have optional parameters?\n\n### Proposal\n\n# Omitting an optional function parameter means that the parameter has the default value specified in the annotation Core.OptionalParameter. \n1. If no explicit DefaultValue is specified, the service is free on how to interpret this. Call this out in term definition.\n1. Nullable non-binding action parameters can already be omitted from the request body, and omitting them means that they have the value null. \n1. Allow annotating action parameters with Core.OptionalParameter. This allows to omit them, whether they are nullable or not.\n1. Omitted action parameter with a DefaultValue means that default value\n1. Omitted action parameter without DefaultValue can be freely interpreted by the service\n\nA nullable non-binding action parameter is equivalent to being annotated with optionalParameter = true and a default value as null.\n\nImported from [ODATA-1281](https://issues.oasis-open.org/browse/ODATA-1281)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify insert entity defined only by key properties of related entities",
    "body": "Clarify how to specify key properties that are defined as properties of referenced entities.\n\n### Proposal\n\nThe key of an entity may include all key properties of a directly related entity if the relationship is single-valued and not nullable. In this case PropertyRefs for all key properties of the related entity have to be specified with an alias. Order need not be the same as in the referenced entity type. This makes the navigation property immutable.\n\nSpecify the related entity as an entity reference, i.e. in JSON Format as a JSON object just containing the `@odata.id`:\n```javascript\n{\n  \"RelatedThing\": {\n    \"@id\": \"Thing(10835)\"\n  },\n  \"NonKeyPropertyToInsert\": \"Inserted Value\",\n  ...\n}\n```\nAdd the corresponding CSDL snippet for clarity.\n\nImported from [ODATA-1280](https://issues.oasis-open.org/browse/ODATA-1280)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Data Aggregation: Clarify need for @odata.id in nested response structures",
    "body": "This issue is to clarify, if nested entities included in the response to an aggregation request need to be equipped with an @odata.id control information.\n\nConsider example 24 from the Data Aggregation specification:\n\n`GET ~/Sales?$apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum as Total))`\n\nresults in\n```java\n{\n  \"@odata.context\": \"$metadata#Sales(Customer(Country),Product(Name),Total)\",\n  \"value\": [\n    { \"@odata.id\": null,\n      \"Customer\": { \"Country\" : \"Netherlands\" },\n      \"Product\": { \"Name\": \"Paper\" },\n      \"Total\": 3 },\n   [...]\n \n```\nTop-level entities do have an @odata.id, but nested projections of related entities currently not. Is this according to rules defined in the format specs to be considered as a gap that needs to be discussed for the Data Aggregation spec?\n\nThe JSON specification describes in section 8.3 for expanded navigation properties that the content is to be rendered according to the entity representation. Two cases exist: 1) If the nested entity is a projection of a \"real\" entity, this could imply mentioning its @odata.id in the response. 2) If the nested entity is a result of an aggregation and therefore transient, section 4.5.8 of the JSON spec states: \"If the entity is transient (i.e. cannot be read or updated), the id annotation MUST appear and have the null value.\"\n\n### Proposal\n\nExamples in the document should comply with the rules stated in the JSON format specification. Since the current examples throughout the document that return transient aggregated entities based on 4.0, all examples having responses with nested projections of related entities should have included an \"@odata.id\":null annotation.\n\n \n\nProposal is to make a blanket statement for V4.01 that clients must be prepared to receive entities having neither @odata.id nor key fields and, in the absence of any additional information, must treat such entities as transient.\n\nWe will update the examples in the aggregation specification to be 4.01 and thus all @odata.id:null (as well as other 4.01 simplifications).\n\nMention in Aggregation that all examples are based on OData V4.01, and call out what would be different across examples for V4.0.\n\nImported from [ODATA-1279](https://issues.oasis-open.org/browse/ODATA-1279)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Deleted Entity: @odata.removed possible in addition to @removed?",
    "body": "Section 15.3 Deleted Entity talks about \"Annotation `removed`\":\n- Is this an annotation or control information?\n- Can it be alternatively be used as `\"@odata.removed\": \\{...`}?\n\nGeneral: clean up use of \"annotation\" and \"control information\".\n\n### Proposal\n\nIs control information and can be used with prefix odata.\n\nAdd subsection of 4.5 for it\n\nClean up use of \"annotation\" versus \"control information\" across the document\n\nImported from [ODATA-1278](https://issues.oasis-open.org/browse/ODATA-1278)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "null and empty paths in Annotation Path, Property Path, Navigation Property Path",
    "body": "The path syntax in annotations defines the empty path to mean \"the annotated model element\".\n\nThe sections on AnnotationPath, NavigationPropertyPath, and PropertyPath define a restriction on the last path element.\n\nThis can be mis-interpreted as \"such a path must not be empty, and must not be null\".\n\n### Proposal\n\nChange text for restriction in section 14.4.1.3 Annotation Path to\n\n> A non-null path MUST resolve to an annotation.\n\n\nChange text for restriction in section 14.4.1.5 Navigation Property Path to\n\n> A non-null path MUST resolve to a model element whose type is an abstract or concrete entity type, or a collection of abstract or concrete entity types, e.g. a navigation property.\n\n\nChange text for restriction in section 14.4.1.6 Property Path to\n\n> A non-null path MUST resolve to a model element whose type is an abstract or concrete primitive or complex type, or a collection of abstract or concrete primitive or complex types, e.g. a structural property.\n\n\nImported from [ODATA-1277](https://issues.oasis-open.org/browse/ODATA-1277)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Explicitly allow the minus sign / dash in a search term",
    "body": "The ABNF rule for [searchWord ](https://github.com/oasis-tcs/odata-abnf/blob/master/abnf/odata-abnf-construction-rules.txt#L349) is overly restrictive.\n\nIt should also include the minus sign / dash \n\n### Proposal\n\nChange from\n> \n> `searchWord = 1*( ALPHA / DIGIT / COMMA / \".\" / pct-encoded )`\n> \n\nto\n> \n> `searchWord = 1*( ALPHA / DIGIT / COMMA / \".\" / \"-\" / pct-encoded )`\n\n\nImported from [ODATA-1276](https://issues.oasis-open.org/browse/ODATA-1276)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Describe structure of \"JSON properties\"",
    "body": "\"JSON properties\" are stream properties whose value is of media type `application/json` or one of its subtypes. They were introduced with [ODATA-1177](https://issues.oasis-open.org/browse/ODATA-1177).\n\nAs outlined in [OData Extension for JSON Data](https://www.oasis-open.org/committees/download.php/46559/OData%20Extension%20for%20JSON%20Data%20v1.0.doc) we need query capabilities on these properties.\n\nRequirements:\n1. Specify a JSON Schema that describes/restricts the JSON stream values (this issue)\n1. Address parts of the JSON stream values in common expressions, e.g. in `$filter`, `$compute`, `$orderby` ([ODATA-1336](https://issues.oasis-open.org/browse/ODATA-1336))\n\n \n\n### Proposal\n\nCreate a type definition `JSON.JSON` in the JSON vocabulary, similar to `Core.LocalDateTime`:\n- type `Edm.Stream`\n- annotated with `Core.AcceptableMediaTypes`, listing `application/json`\n\nCreate a new JSON vocabulary containing terms and functions specific to JSON stream properties.\n\nTerm `JSON.Schema` of type `JSON.JSON` containing a JSON Schema describing/restricting the values of a JSON stream property.\n\nThe annotation value is represented according to [ODATA-1323](https://issues.oasis-open.org/browse/ODATA-1323)\n - in XML metadata as a string\n - in JSON metadata as native JSON\nThe annotation needs to be annotated with `Core.MediaType` and a value of `application/json`.\n\n\nImported from [ODATA-1275](https://issues.oasis-open.org/browse/ODATA-1275)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that a server MUST respond with content-id annotations and MUST include nested entity IDs",
    "body": "Currently in section 11.4.2.2 in the part 1 protocol document it says that the server SHOULD annotate entities in the response with the same content-id used in the request.  This SHOULD needs to be a MUST if the server supports content-ids in deep insert/deep update requests.\n\n \n\nWe also need to clarify that the response must include the entity ID for all entities returned in the response for a create or update if conventional entity IDs are not used.\n\n### Proposal\n\nNew wording for 11.4.2.2: Clients MAY associate an id with individual nested entities in the request by using the Core.ContentID term defined in [OData-VocCore]. Services that respond with 201 Created SHOULD annotate the entities in the response using the same Core.ContentID value as specified in the request. Services SHOULD advertise support for deep inserts through the Capabilities.DeepInsertSupport term, defined in [OData-VocCap]; services that advertise support through Capabilities.DeepInsertSupport MUST return the Core.ContentID for the inserted or updated entities.\n \nClarify that the response must include the entity ID (or all key properties if conventional IDs are used) for all entities returned in the response for a create or update.\n\nImported from [ODATA-1274](https://issues.oasis-open.org/browse/ODATA-1274)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Define mapping of permission scopes to resources",
    "body": "Our Authorizations vocabulary describes multiple different authentication flows and the scopes that can be requested for each flow.\n\nWhat is missing is a way of documenting which resources/properties are available given a particular scope.\n\nThis would allow documentation to be generated that tells the client/app which scopes they need to request in order to access certain resources.\n\nOData-884 and OData-1145 attempt to align with OpenAPI by describing operations supported, and necessary headers, parameters, and permissions required to invoke those operations.  However, we have moved away from OData-884, which uses a more operation-centric approach, to something that aligns with our capabilities.  In doing so, we need a way to specify what permissions are required to access a particular resource (or properties within a resource).\n\nImported from [ODATA-1273](https://issues.oasis-open.org/browse/ODATA-1273)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Highlight implications of derived complex types to their annotations",
    "body": "[Section 9.1](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#_Toc505863922) in the CSDL specification defines derived complex types. The rules how this impacts the annotations of these types are not so easy to grasp, because they are described in another [section 14.2](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#_Toc505863954).\n\n### Proposal\n\nAdd to section 9.1: The rules for annotations of derived complex types are described in section 14.2\n\nImported from [ODATA-1272](https://issues.oasis-open.org/browse/ODATA-1272)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Define a validation term for terms applicable in a given context",
    "body": "Terms are sometimes intended to be used only in certain contexts. Consider, for example, terms Minimum and Maximum from the Validation vocabulary. As stated in [ODATA-856](https://issues.oasis-open.org/browse/ODATA-856), they can optionally be augmented with an annotation of the Exclusive term.\n\nThe Validation vocabulary documents this dependency in the description of term Exclusive. The descriptions of terms Minimum and Maximum, however, contain no related \"forward reference\" to Exclusive. Or to any other annotation, possibly from another vocabulary, that hypothetically could be applied in their context. This leads to the situation that the interface established by a term may or may not be fully described, and clients effectively do not know, which other terms may be applied in a context to add further aspects to the annotated target. In the given example, one has to read through the entire vocabulary to find out that Exclusive plays a role.\n\nWhile this can be mitigated by improving the documentation, the problem becomes more relevant, if annotations are not hand-crafted, but created by modeling tools. Such tools want to guide users and prevent misuse by reducing the overall set of annotations to those applicable in a given context. This requires a machine-readable format for expressing these dependencies. Such a formal description also reduces astonishment on client side, since it can prepare logic for all described combinations of term applications (as opposed to gradually learn the full complexity from different metadata documents)\n\nThe list of applicable terms is open, since there are terms that may be used in any context, e.g. Core.Example. This feature enhances the existing term syntax of AppliesTo=\"Annotation\" with optional information, which other annotations accept this term, described in the definitions of these other terms.\n\n### Proposal\n\nAdd new term ApplicableTerms to the Validation vocabulary that can be used to hint at a list of additional annotations applicable in the context of the target annotated with this ApplicableTerms:\n```xml\n  <Term Name=\"ApplicableTerms\" Type=\"Collection(Core.QualifiedTermName)\">\n    <Annotation Term=\"Core.Description\" String=\"Names of specific terms that are applicable and may be applied in the current context. This annotation does not restrict the use of other terms.\" />\n  </Term>\n```\n \n\n*Example 1: Express the applicability of term Exclusive in the context of terms Minimum and* *Maximum:*\n\nApplied:\n```xml\n<Annotations Target=\"SomeType/SomeSensorProperty\">\n    <Annotation Term=\"Validation.Maximum\" Decimal=\"1.34529\">\n      <Annotation Term=\"Validation.Exclusive\" />\n    </Annotation>\n  </Annotations>\n```\n Enhanced Terms: \n```xml\n  <Term Name=\"Minimum\" Type=\"Edm.Decimal\" Scale=\"variable\" AppliesTo=\"Property Parameter Term\">\n    <Annotation Term=\"Core.Description\" String=\"Minimum value that a property, parameter, or term can have.\" />\n    <Annotation Term=\"ApplicableTerms\">\n      <Collection>\n        <String>Validation.Exclusive</String>\n      </Collection>\n    </Annotation>\n  </Term>\n```\n \n```xml\n  <Term Name=\"Maximum\" Type=\"Edm.Decimal\" Scale=\"variable\" AppliesTo=\"Property Parameter Term\">\n    <Annotation Term=\"Core.Description\" String=\"Maximum value that a property, parameter, or term can have.\" />\n    <Annotation Term=\"ApplicableTerms\">\n      <Collection>\n        <String>Validation.Exclusive</String>\n      </Collection>\n    </Annotation>\n  </Term>\n```\n \n\n *Example 2: Individual term properties can be enhanced with further annotations*\n\nIndividual parts of a term such as a individual property or a complex type can be annotated to accept further annotations. Consider a term T with a structure having two properties, one of which may be further annotated with a certain aspect.\n```xml\n<Term Name=\"HasAspect\" Type=\"Core.Tag\" />\n  <Term Name=\"T\" Type=\"TType\" />\n  <ComplexType Name=\"TType\">\n    <Property Name=\"P1\" Type=\"Edm.String\" />\n    <Property Name=\"P2\" Type=\"Edm.String\">\n      <Annotation Term=\"ApplicableTerms\">\n        <Collection>\n          <String>HasAspect</String>\n        </Collection>\n      </Annotation>\n    </Property>\n  </ComplexType>\n```\n *Applied:*\n```xml\n  <Annotations Target=\"SomeType/SomeProperty\">\n    <Annotation Term=\"T\">\n      <Record>\n        <PropertyValue Property=\"P1\" String=\"...\" />\n        <PropertyValue Property=\"P2\" String=\"...\">\n          <Annotation Term=\"HasAspect\" />\n        </PropertyValue>\n      </Record>\n    </Annotation>\n  </Annotations>\n```\n \n\n*Open*: Which other term relations do exist and should be described?\n\nImported from [ODATA-1271](https://issues.oasis-open.org/browse/ODATA-1271)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "14.4.11: rephrase prose text for dynamic expression Null",
    "body": "Rephrase prose text to avoid the word \"untyped\" and thus confusion with the new type `Edm.Untyped`.\n\n### Proposal\n\nChange text from\n> The null expression returns an untyped null value. \n> \n\nto\n> The null expression indicates the absence of a value.\n> \n\n \n\nImported from [ODATA-1270](https://issues.oasis-open.org/browse/ODATA-1270)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add QueryRestrictions to the Capabilities Vocabulary",
    "body": "We have cases where we want to have an entity set which is only accessible by navigation from another entity but it is not a containment relationship.  We currently have InsertRestrictions and UpdateRestrictions in the capabilities vocabulary but no corresponding QueryRestrictions.  We should add QueryRestrictions to the capabilities vocabulary.\n\n### Proposal\n\nHere is an initial version which we can add too/adjust:\n\n<Term Name=\"QueryRestrictions\" Type=\"Capabilities.QueryRestrictionsType\" AppliesTo=\"EntitySet\">\n\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on queries\" />\n\n</Term>\n\n<ComplexType Name=\"QueryRestrictionsType\">\n\n    <Property Name=\"DirectlyAccessible\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"true\">\n\n        <Annotation Term=\"Core.Description\" String=\"Whether entities in this entity set can be accessed directly or must be accessed through a navigation property.\" />\n\n    </Property>\n\n</ComplexType>\n\nImported from [ODATA-1269](https://issues.oasis-open.org/browse/ODATA-1269)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify meaning of Nullable for collection-valued structural properties",
    "body": "Similar to parameters and return types (see [ODATA-1210](https://issues.oasis-open.org/browse/ODATA-1210)) clarify that Nullable \n\n### Proposal\n\n$Nullable\n\nThe value of $Nullable is one of the Boolean literals true or false. Absence of the member means false.\n\nFor single-valued properties the value true means that the property allows the null value.\n\nFor collection-valued properties the property value will always be a collection that MAY be empty. In this case $Nullable applies to items of the collection and specifies whether the collection MAY contain null values.\n\nImported from [ODATA-1268](https://issues.oasis-open.org/browse/ODATA-1268)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "URL Conventions example in 5.1.1.5.1 has \"bad\" whitespace",
    "body": "[http://host/service/Customers?$filter=concat(concat(City],', '), Country) eq 'Berlin, Germany'\n\nThe space before Country is not permitted by the ABNF construction rules.\n\n(Or else, my interpretation of \"BWS\" is wrong)\n\n### Proposal\n\n Use the same interpretation as RFC7230 for BWS and state this in ABNF Construction Rules:\n> The BWS rule is used where the grammar allows optional whitespace\n> only for historical reasons. A sender MUST NOT generate BWS in\n> messages. A recipient MUST parse for such bad whitespace and remove\n> it before interpreting the protocol element.\n> \n\nRepair examples in URL Conventions.\n\n \n\nImported from [ODATA-1267](https://issues.oasis-open.org/browse/ODATA-1267)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Geo literals with three dimensions",
    "body": "Geo literals in WKT (well-known text) representation as defined by the OpenGIS Simple Feature Access [http://www.opengeospatial.org/standards/sfa] require two dimensions (longitute, latitude) and allow two optional dimensions\n- Three-Dimension (x,y, z)\n- Two-Dimension Measured (x, y, m) with m being a linear referencing measure\n- Three-Dimension Measured (x, y, z, m)\n\n### Proposal\n\nGeoJSON only supports Three-Dimension with a third coordinate representing an altitude or elevation.\n\nGeoJSON notation in principle allows the two \"Measured\" variants, but RFC7946 strongly discourages its use.\n\nTo not be overly restrictive we should extend the ABNF for Geo types and also allow two optional coordinates:\n\n```\npositionLiteral = doubleValue SP doubleValue [ SP doubleValue ] [ SP doubleValue ] ; longitude, latitude, altitude/elevation (optional), linear referencing measure (optional)\n```\n\nImported from [ODATA-1266](https://issues.oasis-open.org/browse/ODATA-1266)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify property paths used in a lambda predicate expression",
    "body": "# In section 5.1.1.12, para #3, the next to last word must be “navigation path” instead of “resource path”\n1. It should be explicitly noted that the meaning of a property path that does not start with either $it or a lambda variable is undefined within a lambda predicate expression\n\n### Proposal\n\n1.\n\nRevised description for section 5.1.1.12 [Lambda Operators](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_LambdaOperators) (changes enclosed with *)\n\nOData defines two operators that evaluate a Boolean expression on a collection. Both must be prepended with a navigation path that identifies a collection.\n\n4.01 Services MUST support case-insensitive lambda operator names. Clients that want to work with 4.0 services MUST use lower case lambda operator names.\n\nThe argument of a lambda operator is a case-sensitive lambda variable name followed by a colon ( : ) and a Boolean expression that uses the lambda variable name to refer to properties of members of the collection identified by the *navigation path*.\n\nIf the name chosen for the lambda variable matches a property name of the current resource referenced by the resource path, the lambda variable takes precedence. Clients can prefix properties of the current resource referenced by the resource path with [$it](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_it).\n\n*Other path expressions in the Boolean expression neither prefixed with the lambda variable nor $it are evaluated in the scope of the collection instances at the origin of the navigation path prepended to the lambda operator.*\n\n2.\n\nTo illustrate evaluation of Boolean expressions not starting with a lambda variable or $it, add two examples to section 5.1.1.12.1 and 5.1.1.12.2:\n\nExample 92’: all employees having an order with a deviating shipping address\n\n`[http://host/service/Employees?$filter=Orders/any(o:o/ShipAddress](http://host/service/Employee?$filter=Orders/any(o:o/ShipAddress) ne Address)`\n\nThe `Address` path expression included in the predicate expression of the `any` lambda operator is evaluated in the scope of the Employee collection, because they are the origins of the `Orders` collection path prepended to the `any` operator.\n\n \n\nExample 93’:  all categories along with their products used in some order with a deviating unit price\n\n`[http://host/service/Categories?$expand=Products($filter=OrderItems/any(od:od/UnitPrice] ne UnitPrice)`\n\n`UnitPrice` is a path expression included in the predicate expression of the `any` lambda operator that gets evaluated in the scope of expanded product instances, because these are the origins of the `OrderItems` collection path prepended to the `any` operator.\n\nImported from [ODATA-1265](https://issues.oasis-open.org/browse/ODATA-1265)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CRUDQ descriptions on entity sets",
    "body": "In public comment https://lists.oasis-open.org/archives/odata-comment/201510/msg00005.html the question was asked on how to provide descriptions specific to one of the standard operations on an entity set: \n- Create new\n- Query list\n- Read single\n- Update existing\n- Delete existing\n\nThis could be leveraged when generating OpenAPI descriptions for OData services, where each entity set results in up to two path items (for the list, for key access) with up to five operations.\n\n### Proposal\n\nAdd new properties to the `Capabilities` terms `InsertRestrictions`, `UpdateRestrictions`, `DeleteRestrictions`, `ReadRestrictions`, and `ReadByKeyRestrictions`:\n- `Description` of type string\n- `LongDescription` of type string\n\nNote: this automatically extends `NavigationPropertyRestriction` with descriptions for Insert, Update, and Delete.\n\n \n\nImported from [ODATA-1264](https://issues.oasis-open.org/browse/ODATA-1264)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Requirement for 204 (No Content) with 11.4.3 \"Update an Entity\" is not backwards compatible",
    "body": "We recently updated section 11.4.3 “Update an Entity” and added: On success the service MUST respond with 204 No Content, or with 200 OK if the request included a return Prefer header with a value of return=representation.\n\nUnfortunately that is not backwards-compatible with OData 4.0. Since the 4.0 spec says nothing at all about what the server will do when the client indicates no preference, a 4.0 server can be spec-compliant if it returns 200 with content (even without seeing a preference). The addition of that text will have the effect of retrospectively making some 4.0 services non-compliant. Also it sets a precedent that the server MUST respect preferences (at least return=representation for PATCH/PUT). Previously (AFAIK) servers could ignore preferences (although it could be argued that sections 11.4.2 and 11.4.7.1 already set such a precedent for POST responses).\n\nBetter would be if 4.01 required a 4.01 response to have status 200 (with content) for PATCH/PUT, unless the client specifies “Prefer: return=minimal” and the server chooses to respect the preference (and for 4.0 responses, no requirement one way or the other since that is the way the 4.0 spec has it). For consistency, sections sections 11.4.2 and 11.4.7.1 should be reworded so as not to force the respecting of preference return=minimal.\n\nThe requirement (by default) for content in a PATCH/PUT response is more important than it was for 4.0, since with “deep update” clients may need the ability to obtain keys. Not having any way for a client to be _sure_ of getting 200 (with content) in a PATCH/PUT response is problematic (it was not that bad with 2.0 - 4.0, since an extra query could always be sent to get the latest state, and there were no \"new keys\" available).\n\n\n### Proposal\n\nChange text for Update an Entity (and for Update a Primitive/Complex/Collection Property) to \n\n> Upon successful completion the service responds with either 200 OK or 204 No Content. The client may request that the response SHOULD include a body by specifying a prefer header with a value of return=representation.\n\n\nCorresponding text for Create an Entity is\n\n> Upon successful completion the service MUST respond with either 201 Created, or 204 No Content if the request included a Prefer header with a value of return=minimal.\n\n\nCorresponding text for Create a Media Entity is\n\n> Upon successful completion the service responds with either 201 Created, or 204 No Content if the request included a Prefer header with a value of return=minimal.\n\n\nImported from [ODATA-1263](https://issues.oasis-open.org/browse/ODATA-1263)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify read-write access via URLs differing from the canonical/read/edit URL",
    "body": "Section [11.2.2 Requesting Individual Entities](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingIndividualEntities) states:\n\n> \n> To retrieve an individual entity, the client makes a GET request to the read URL of an entity.\n> \n\n\nThis seems to suggest that read access is only possible via the readLink (and in subsequent paragraphs: the editLink or the canonical URL), and not for example via a navigation URL such as `Employees(123)/Manager`.\n\nSection 11.4.3 Update an Entity does not state at all which kinds of URLs can be used with PATCH or PUT.\n\nSection 11.4.4 Upsert an Entity allows any valid URL that identifies a single entity.\n\nSection 11.4.5 Delete an Entity only allows the edit URL.\n\nThis is inconsistent and confusing.\n\n### Proposal\n\n||Section||Current Text||New Text||\n|[11.2.2 Requesting Individual Entities](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingIndividualEntities) |To retrieve an individual entity, the client makes a GET request to the read URL of an entity.|To retrieve an individual entity, the client makes a GET request to {color:#14892c}a URL that identifies the entity, e.g. its{color} read URL.|\n|[11.4.3 Update an Entity](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_UpdateanEntity)| (no statement)|To update an individual entity, the client makes a PATCH or PUT request to a URL that identifies the entity. Services MAY restrict updates only to requests addressing the edit URL of the entity.|\n|[11.4.4 Upsert an Entity](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_UpsertanEntity)|An upsert occurs when the client sends an update request to a valid URL that identifies a single entity that does not exist.|An upsert occurs when the client sends an update request to a valid URL that identifies a single entity that does not {color:#14892c}yet{color} exist.|\n|[11.4.5 Delete an Entity](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_DeleteanEntity)|A successful DELETE request to an entity's edit URL deletes the entity.|To delete an individual entity, the client makes a DELETE request to a URL that identifies the entity. Services MAY restrict deletes only to requests addressing the edit URL of the entity.|\n\nImported from [ODATA-1260](https://issues.oasis-open.org/browse/ODATA-1260)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify @type (@odata.type) and metadata=full",
    "body": "Section [3.1.2 metadata=full (odata.metadata=full)](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_metadatafullodatametadatafull) states\n- [type](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_ControlInformationtypeodatatype): the type of the containing object or targeted property if the type of the object or targeted property cannot be heuristically determined\n\nIf \"heuristically determined\" for metadata=full means: only look at the data values, not at $metadata, the only objects whose type can be heuristically determined are GeoJSON values.\n\nAll structured type instances need $metadata knowledge.\n\n### Proposal\n\nReference \"heurstically determined\" in odata.type section:\n> type: the type of the containing object or targeted property if the type of the object or targeted property cannot be heuristically determined *from the data value, see section \"Control Information: type (odata.type)\"*.\n> \n\n(added text in bold).\n\nImported from [ODATA-1259](https://issues.oasis-open.org/browse/ODATA-1259)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Should we allow arrays of primitive in term definitions?",
    "body": "When we introduced the Edm.Primitive type, we explicitly disallowed defining properties of type Collection(Edm.Primitive) because we had no way to annotate individual primitive values within a JSON array.\n\nWe did not define the same restriction for term definitions; as a result, it's possible to define a term as a Collection(Edm.Primitive).  This hasn't been a problem for terms applied in XML CSDL because the XML CSDL has a way to specify the type of a primitive value within a Collection. However, with [ODATA-1221](https://issues.oasis-open.org/browse/ODATA-1221) we now use the same primitive representation in JSON CSDL as in JSON data payloads, which means we no longer have a way to annotate individual primitive values within a collection in JSON CSDL.\n\nNote that we also have the issue with instance annotations -- we cannot apply a term in an instance annotation that is defined as a collection of Edm.Primitive without relying on hueristics for determining between string, bool, or double.\n\nIt seems that failing to restrict term definitions was an oversight, and our intention was likely to restrict any uses of collection(edm.primitive) in our data (and metadata) model.\n\n### Proposal\n\nClarify that Collection(Edm.Primitive) cannot be used in properties, term definitions, parameters, or type definitions.\n\nImported from [ODATA-1258](https://issues.oasis-open.org/browse/ODATA-1258)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Do URLs within a Batch Request need to be URL Encoded?",
    "body": "I couldn't find anywhere in the docs where we say definitively whether a URL within a JSON payload needs to be URL Encoded.\n\nSame question for multipart/mixed, although the answers could differ?\n\n### Proposal\n\nURLs must be fully percent encoded in the request, including in a multipart batch request\n\nURLs represented as string within a JSON payload, including JSON batch, must follow standard OData encoding rules, which do not require that{color:#000000} colons in the query string be percent encoded.{color}\n\nImported from [ODATA-1257](https://issues.oasis-open.org/browse/ODATA-1257)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Harmonize usage of custom aggregates with structured aggregatable properties",
    "body": "Section 3.1 introduces custom aggregates as one of several options for aggregate expressions. This, however, is currently limited to custom aggregates defined for the type of the input set, because no path prefix is allowed.\n\nOn the other hand, for structured properties that are aggregatable, [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206) requested to describe the possibility to reference aggregatable properties in related sets by mentioning the navigation paths as prefix.\n\n \n\n### Proposal\n\nProposal is to handle this symmetric for custom aggregates and allow path prefixes as described in [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206):\n\nAn aggregate expression may be:\n\n...\n- a custom aggregate \"that can be reached via a path consisting of a sequence of navigation properties, complex properties and complex collection properties\"\n\nImported from [ODATA-1256](https://issues.oasis-open.org/browse/ODATA-1256)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Correct usage of $count",
    "body": "Section 3.1 introduces $count as one of several options for aggregate expressions.\n\nExample 57 applies $count relative to a collection-valued navigation property, which is a different use case that is backed by the commonExpr ABNF rule to address the count of a collection (see URL spec, section 4.8). Since section 3.1 requires commonExpr to be augmented with an aggregation method, such a method must be added to the request in the example.\n\nThe current aggregation ABNF contains a rule for $count with a path prefix, which needs to be cleaned up accordingly.\n\n### Proposal\n\nUpdate request in example 57:\n\n`GET ~/Products?$apply=groupby((Name),aggregate(Sales/$count *with sum* as SalesCount))`\n\nRewrite section on aggregate, last item in list on \"virtual property $count\": replace it with \"$count, which is a shortcut for 1 with sum\"\n\nImported from [ODATA-1255](https://issues.oasis-open.org/browse/ODATA-1255)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Can the default set of properties change over time?",
    "body": "Absent a $select, services are allowed to return a service-specific default set of properties.\n\nCan that service-specific default set of properties change over time?\n\nAdding new properties should be allowed, but what about removing properties from the default list.  Unless we explicitly call out that services can remove properties from the default set, we could break apps that were expecting the same set of properties on each request.\n\nHowever, if an app is expecting certain properties then they should be using $select to ensure they get those properties.\n\n\n### Proposal\n\nAbsent $select, the service is allowed to change the default set of properties returned. This includes returning new properties by default and omitting properties previously returned by default.\n \nClients that rely on specific properties in the response MUST use $select, with the required properties or with \"*\", to ensure that properties are not omitted from the response.\n\nImported from [ODATA-1254](https://issues.oasis-open.org/browse/ODATA-1254)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Abstract type definition Core.Number as a super-type of all numeric types",
    "body": "CSDL has the abstract built-in type Edm.Primitive but no (less abstract) sub-type for numeric values.\n\n### Proposal\n\nAdd type definition `Core.Number` with underlying type `Edm.PrimitiveType` annotated with Validation.DerivedTypeConstraint listing all numeric types (depends on [ODATA-1252](https://issues.oasis-open.org/browse/ODATA-1252)), see [https://github.com/oasis-tcs/odata-vocabularies/pull/224.](https://github.com/oasis-tcs/odata-vocabularies/pull/224)\n\nAlternative: `Types.Number` in new vocabulary, see [https://github.com/oasis-tcs/odata-vocabularies/pull/225.](https://github.com/oasis-tcs/odata-vocabularies/pull/225)\n\nA new Types vocabulary could also solve\n- [ODATA-220](https://issues.oasis-open.org/browse/ODATA-220)\n- [ODATA-287](https://issues.oasis-open.org/browse/ODATA-287)\n\nAlternatively we could add these types to the Core vocabulary, similar to\n- [Core.LocalDateTime](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#LocalDateTime)\n\n \n\n[https://github.com/oasis-tcs/odata-vocabularies/pull/224]\n or [https://github.com/oasis-tcs/odata-vocabularies/pull/225]\n\nImported from [ODATA-1253](https://issues.oasis-open.org/browse/ODATA-1253)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "TypeDefinition should allow Edm.Primitive as underlying type",
    "body": "In [ODATA-1034](https://issues.oasis-open.org/browse/ODATA-1034) we added a DerivedTypeConstraint for the purpose of constraining a typedefinition that specified Edm.Primitive to be one of a subset of primitive types (i.e., a string or integer).\n\nWhile we originally defined this annotation term as being applied to a TypeDefinition, we missed the fact that TypeDefinition was originally defined with an UnderlyingType that precluded Edm.PrimitiveType.\n\nDefining a type definition with an underlying type of Edm.PrimitiveType requires that we also define semantics around what facets can be applied.  For example, can MaxLength, Precision, or Scale be applied, and what is the meaning of these facets for instances for which those facets don't apply.\n\nThe same semantics need to be defined for a property of type Edm.PrimitiveType.\n\n### Proposal\n\nAllow Edm.PrimitiveType as an underlying type for TypeDefinition for 4.01 and greater schemas only.\nType-specific facets applied to Edm.PrimitiveType (in property or type definition) should be ignored by the client.\n\nImported from [ODATA-1252](https://issues.oasis-open.org/browse/ODATA-1252)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Should annotated null/default values be omitted/restored?",
    "body": "In [ODATA-818](https://issues.oasis-open.org/browse/ODATA-818) we added the ability to omit null or default values based on a preference request header. If this preference was specified in the preference-applied response header, the client could assume that any missing properties had the null/default value.\n\nWe had to call out certain cases in which nulls/defaults could not be omitted, such as delta and request payloads.\n\nWe did not specify, though, if a property has annotations, but default/null value, whether it could be omitted.  Indeed, in many cases the annotation may be describing *why* the property was value was omitted, and restoring it to a null/default may violate the intention of annotating the value as being missing.\n\n\n### Proposal\n\nProperties that are annotated must not be omitted due to omit-values if they would otherwise be written.\n\n\nImported from [ODATA-1251](https://issues.oasis-open.org/browse/ODATA-1251)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "GeoJSON, SRID, and LineString",
    "body": "Two issues with the JSON Format specification and GeoJSON:\n\n1) The JSON Format specification states\n> Geography and geometry values are represented as geometry types as defined in *[[RFC7946](https://tools.ietf.org/html/rfc7946)]*, with the following modifications:\n> - Keys SHOULD be ordered with type first, then coordinates, then any other keys\n> - The coordinates member of a LineString can have zero or more positions\n> - If the optional CRS object is present, it MUST be of type name, where the value of the name member of the contained properties object is an EPSG SRID legacy identifier.\n\n\nThe CRS object is not defined in RFC7946, it was defined in the now obsolete predecessor [GeoJSON-2008](http://geojson.org/geojson-spec.html), and RFC7946 has explicitly removed the concept of \"coordinate reference systems\" (CRS) and restricts GeoJSON to World Geodetic System 1984 (WGS 84), which (fortunately) is the default for the SRID facet in OData (EPSG 4326).\n \n2) RFC7946 and GeoJSON-2008 require a LineString to have at least two positions: why do we additionally allow zero or one position? And what does that mean?\n\n### Proposal\n\n1) Add GeoJSON-2008 as a non-normative reference and point to it (especially to [http://geojson.org/geojson-spec.html#named-crs]) in the bullet point mentioning the CRS object. Discourage use of CRS object as it is not part of the final GeoJSON specification.\n\n(Note: we already reference RFC 7946 as a _normative_ reference, which in turn references GeoJSON-2008, but without a hyperlink. So whole point of the non-normative reference is providing the link).\n\n2) Remove extension to zero/one position for LineString by removing the second bullet point in the current text (see Description).\n\nImported from [ODATA-1250](https://issues.oasis-open.org/browse/ODATA-1250)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "edm.xsd: ActionImport and IncludeInServiceDocument",
    "body": "The edm.xsd erroneously allows specifying the IncludeInServiceDocument attribute for the edm:ActionImport\n\n### Proposal\n\nedm.xsd: restrict IncludeInServiceDocument to edm:FunctionImport as defined in the prose specification\n\nImported from [ODATA-1249](https://issues.oasis-open.org/browse/ODATA-1249)",
    "labels": [
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "csdl.schema.json: add descriptions to all schema elements",
    "body": "\n\n### Proposal\n\nSee summary.\n\nThis only affects csdl.schema.json, not the specification document.\n\nImported from [ODATA-1248](https://issues.oasis-open.org/browse/ODATA-1248)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "DerivedTypeConstraint should apply to entityset, singleton, navigation properties, parameters, and action/function returns",
    "body": "[ODATA-1232](https://issues.oasis-open.org/browse/ODATA-1232) proposed supporting \"union types\" by restricting the set of types derived from a common type.  In processing [ODATA-1232](https://issues.oasis-open.org/browse/ODATA-1232), we discovered that we already had an annotation term, DerivedTypeConstraint, for restricting the set of derived types.\n\nThe DerivedTypeConstraint annotation term was originally added in [ODATA-1034](https://issues.oasis-open.org/browse/ODATA-1034) to restrict the set of primitive types supported for a property or type definition. While it makes sense to use the same term for other constraints on derived type, we neglected to add those other targeted elements to the AppliesTo list.\n\n### Proposal\n\n Add the following items to the \"AppliesTo\" attribute of the DerivedTypeConstraint annotation term:\n\nEntitySet, Singleton, NavigationProperty, Parameter, ReturnType\n\nImported from [ODATA-1247](https://issues.oasis-open.org/browse/ODATA-1247)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Extract expression syntax into own sub-section next to $filter",
    "body": "Currently the common expression syntax is defined in subsections to $filter.\n\nCommon expressions are also used by $compute and $orderby, so it would help extracting them into an own subsection next to the system query options.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1245](https://issues.oasis-open.org/browse/ODATA-1245)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add a function to determine aggregated values within common expressions",
    "body": "Currently, there is no possibility to combine values of a single entity with an aggregated value determined from the input set in a single calculation. Expressions passed to the compute transformation always operate on properties of the individual entities in the input set. This prevents use cases like calculating the ratio of an entity's property value to an aggregated value from the input set. Examples for ratio calculations can be found in [ODATA-947](https://issues.oasis-open.org/browse/ODATA-947)\n\n### Proposal\n\n1.\n\nAdd a new section before 3.16 Evaluating $apply to define a function aggregate that has a single parameter accepting an aggregate-function expression and returns the aggregated value of type Edm.PrimitiveType as the result from applying the aggregate expression on an input collection provided by the context.\n\nAn aggregate-function expression offers the same capabilities as an aggregate expression defined for the aggregate transformation except that it does not support aggregation on related entities, and it never includes an alias for introducing a dynamic property containing the aggregated value.\n\nThe function can be applied in any expression derived from the commonExpr rule (see **[OData-ABNF]). Within $apply, the function is applied as part of an argument expression to a transformation, and the input set of that transformation is the input collection for the function. Outside of $apply, the function may be applied in requests querying collections in an argument expression for a system query option and a lambda operator. Inside a system query option, the collection on which it operates is used as input collection for the function. This is also valid for nested query options used as arguments, like $filter in $expand. Inside a lambda predicate expression the input collection for the aggregate function depends on the path expression used in the aggregateFunctionExpr (see ABNF below): For a path expression starting with the lambda variable the input collection is given by the target of the navigation path prepended to the lambda operator; for a path expression starting with $it the collection addressed by the resource path is the input collection; for other path expressions the input collection is given by the collection of instances at the origin of the navigation path prepended to the lambda operator.\n\n \n\n2.\n In the Data Aggregation’s ABNF, define the rule for computeAggregateMethodCallExpr as\n{noformat}\naggregateMethodCallExpr = 'aggregate' OPEN BWS aggregateFunctionExpr BWS CLOSE \n\naggregateFunctionExpr   = '$count'\n                        / commonExpr aggregateWith [ aggregateFrom ]\n                        / / [ inscopeVariableExpr \"/\" ] pathPrefix primitiveProperty aggregateWith [ aggregateFrom ]\n                        / / [ inscopeVariableExpr \"/\" ] pathPrefix customAggregate [ aggregateFrom ]\n{noformat}\nAdd the aggregateMethodCallExpr rule to the set of rules recognized by methodCallExpr within a commonExpr:\n{noformat}\nmethodCallExpr =/ aggregateMethodCallExpr\n{noformat}\n\nImported from [ODATA-1244](https://issues.oasis-open.org/browse/ODATA-1244)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify whether $orderby and string comparison with ge, gt, le, lt is language-specific",
    "body": "Alphabetical order of modified letters (â, ö, ñ, ...) is language-specific, see e.g.  [https://en.wikipedia.org/wiki/Alphabetical_order#Language-specific_conventions]\n\nCurrently it is neither specified how this must be implemented, nor is it explicitly left to the specific service.\n\nAlso alphabetical order typically places the uppercase variant of a letter next to its lowercase variant, i.e. A, a, AA, Aa, aa, AAA, AAa, ...\n\n### Proposal\n\nServices SHOULD compare and sort language-dependent properties according to the content-language of the response.\n\nImported from [ODATA-1243](https://issues.oasis-open.org/browse/ODATA-1243)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that resolved relative URIs in batch responses cannot contain content-ID references",
    "body": "With [ODATA-1234](https://issues.oasis-open.org/browse/ODATA-1234) we allow services to return URLs relative to the request URL in headers.  We need to clarify that in a batch response, the service is responsible for producing URLs that don't contain content-id references.\n\n### Proposal\n\nClarify that if the service returns URLs relative to the request URL in a response the service is responsible for ensuring the resolved URLs do not contain a content-ID reference.\n\nImported from [ODATA-1242](https://issues.oasis-open.org/browse/ODATA-1242)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support common expressions as values in URL-JSON",
    "body": "The `in` operator allows comparing a property to a list of values, e.g.\n```java\n$filter=Name in ('Milk', 'Cheese')```\nFor multi-part keys it would be helpful to allow comparison of a tuple of properties to a list of value tuples:\n```java\n$filter=(Firstname,Lastname) in (('John', 'Doe'),('Jane','Smith'))```\n Note that this is natively supported by some databases:\n- [https://docs.oracle.com/cd/B19306_01/server.102/b14200/conditions013.htm]\n- [https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html#function_in] \n\n### Proposal\n\nAllow using common expressions as \"values\" in URL-JSON. This will allow to construct an array from properties as the left operand of  the `in` operator:\n```java\n$filter=[FirstName,LastName] in ([\"John\",\"Doe\"],[\"Jane\",\"Smith\"])```\nNote: a list of arrays is already allowed as the right operand.\n\nImported from [ODATA-1241](https://issues.oasis-open.org/browse/ODATA-1241)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Chapter 2: wrong description of how to split URLs into syntax components",
    "body": "The text currently says\n- Split undecoded URL into components scheme, hier-part, query, and fragment at first \":\", then first \"?\", and then first \"#\"\n\nThe query part is optional, and the fragment may contain the question mark character, so the description is incorrect. \n\nDon't try to capture the RFC3986 ABNF into concise and correct text.\n\n### Proposal\n\n1) Put parsing rules in a 2.1 subsection, and OData ANBF in a 2.2 subsection.\n2) In Parsing rules, shorten text of first step to:\n- Split undecoded URL into components scheme, hier-part, query, and fragment \n\nImported from [ODATA-1240](https://issues.oasis-open.org/browse/ODATA-1240)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarifications for select-list in ContextUrl",
    "body": "The use of select-list is defined in prose in the Protocol document:\n\n{panel:title=10.8 Projected Entity}\nContext URL templates:\n```\n  {context-url}#{entity-set}{/type-name}{select-list}/$entity\n  {context-url}#{singleton}{select-list}\n  {context-url}#{type-name}{select-list}\n```\nIf a single entity contains a subset of properties, the parenthesized comma-separated list of the selected defined or dynamic properties, navigation properties, functions, and actions is appended to the entity-set after an optional type-cast segment and prior to appending /$entity. If the response is not bound to a single entity set, the select-list is instead appended to the {type-name} of the returned entity. \nThe shortcut * represents the list of all structural properties. Properties defined on types derived from the type of the entity set (or type specified in the type-cast segment if specified) are prefixed with the qualified name of the derived type as defined in [OData-ABNF]. *Note that expanded properties are implicitly selected*.\nOData 4.01 responses MAY use the shortcut pattern namespace.* to represent the list of all bound actions or functions available for entities in the collection, see system query option $select.\n{panel}\n\nWe go on to say:\n\n{panel:title=10.9 Collection of Expanded Entities}\nContext URL template:\n```\n  {context-url}#{entity-set}{/type-name}{select-list}\n  {context-url}#Collection({type-name}){select-list}\n``` \nFor a 4.01 response, if a navigation property is explicitly expanded, then in addition to any non-suffixed names of any selected properties, navigation properties, functions or actions, the comma-separated list of properties MUST include the name of the expanded property, suffixed with the parenthesized comma-separated list of any properties of the expanded navigation property that are selected or expanded. If the expanded navigation property does not contain a nested $select or $expand, then the expanded property is suffixed with empty parentheses. If the expansion is recursive for nested children, a plus sign is infixed between the navigation property name and the opening parenthesis. \nFor a 4.0 response, the expanded navigation property suffixed with parentheses MAY be omitted from the select-list if it does not contain a nested $select or $expand, but MUST still be present, without a suffix, if it is explicitly selected. \n{panel}\n\nQuestions:\n\n1) We should clarify that, if the contextUrl includes only expanded navigation properties (i.e., only navigation properties suffixed with parens), then implicitly the default set of properties is selected.  This is never spelled out, but is implied by our example 22:\n\n{panel:title=Example 22: resource URL and corresponding context URL}\nhttp://host/service/Employees(1)/Sales.Manager?\n                   $expand=DirectReports($select=FirstName,LastName;$levels=4)\nhttp://host/service/$metadata\n       #Employees/Sales.Manager(DirectReports+(FirstName,LastName))/$entity\n{panel}\n\nNote that, in this example, there is no $select applied to the top level entity (Employees(1)) implying that the default set of properties should be returned for the sales manager, which appears to be implied by the contextUrl only including the expanded properties.\n\n2) What do we mean by \"Note that expanded properties are implicitly selected.\"?  Does this mean that expanded properties are implicitly in the response, or does it mean that expanded properties also have their navigation link included?  In 4.01 we say that, in the contextUrl, the expanded navigation property must appear with open/close parens *in addition to* any selected or expanded navigation properties.  i.e., if it both selected and expanded, then it appears twice; once with, and once without, the parens.  If we read the first statement as \"also have their navigation link included\" then it seems unnecessary to represent the expanded navigation property in the contextUrl without the parens.\n\n3) Now that we have introduced select options, how do we represent select options within the contextUrl.  We already have a syntax for nested select, using path syntax:\n\n```\nselect         = ( \"$select\" / \"select\" ) EQ selectItem *( COMMA selectItem )\nselectItem     = STAR\n               / allOperationsInSchema \n               / [ ( qualifiedEntityTypeName / qualifiedComplexTypeName ) \"/\" ] \n                 ( selectProperty\n                 / qualifiedActionName  \n                 / qualifiedFunctionName  \n                 )\nselectProperty = primitiveProperty  \n               / primitiveColProperty [ OPEN selectOptionPC *( SEMI selectOptionPC ) CLOSE ]\n               / navigationProperty\n               / selectPath [ OPEN selectOption *( SEMI selectOption ) CLOSE\n                            / \"/\" selectProperty \n                            ]\n```\n\nThis is somewhat more verbose, but it would be breaking (and somewhat ambiguous between dynamic properties with select options and expanded dynamic nav props) to change it to use the parens syntax. But, what about nested expands within $select? \n\n4) We say that explicitly selected functions are also represented in the contextUrl. Should these be represented with, or without, parens?  \n\nLooking again at our ABNF, we see that qualifiedFunctionName is defined generally as:\n\n```\nqualifiedFunctionName = namespace \".\" function [ OPEN parameterNames CLOSE ]\n```\n\nwhich implies that you could include or omit the parens (we should pick one).\nIf we don't include the parens, then we can't differentiate between overloads.\nIf we do include the parens, then how can we differentiate between dynamic functions and dynamic expanded navigation properties?\n\n5) We say that the contextUrl for a collection of references (i.e., Customers/$ref) is #Collection($ref), and the contextUrl for a single reference (i.e., Orders(1)/Customer/$ref) is #$ref, but we don't say how an expanded reference (i.e., Customers?$expand=Orders/$ref) is represented in the contextUrl.  Note that defining new syntax for this (for example, Customers(Orders/$ref)) would be a breaking change.  Also, it's not really necessary to know about the $ref in order to interpret the results, understand metadata, or materialize missing information in a JSON minimal metadata format.  So there may be no need to represent it at all. \n\n\n### Proposal\n\nMake sure the following are clear in the documentation:\n1) If the contextUrl includes only expanded navigation properties (i.e., only navigation properties suffixed with parens), then all structural properties are implicitly selected (same as if there were no properties listed in the select-list)\n2)  In section 10.8, Projected Entity, change:\n\"Note that expanded properties are implicitly selected.\" to \"Note that expanded properties are automatically included in the response.\"\n3) Regardless of how contained structural properties are represented in the request URL (as paths or as select options) they are represented in the contextUrl using path syntax, as defined in 4.0. Similarly, expands nested within $select are represented the same as expands outside of $select.\n4) Operations in the ContextUrl should always be represented using the full namespace- or alias- qualified name, so if it has a dot it is an operation. Functions suffixed with parens represent a specific overload, while functions without parens represent all overloads of the function.\n5) Navigation properties with expanded references are not represented in the ContextUrl.  i.e., the contextUrl for Customers?$expand=Orders/$ref would just be $metadata#Customers.\n\nImported from [ODATA-1238](https://issues.oasis-open.org/browse/ODATA-1238)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "How to specify static result entity set for bound actions/functions?",
    "body": "Bound actions/functions that return a single entity or a collection of entities can specify the entity set of the returned entities relative to the binding parameter via the EntitySetPath attribute.\n\nHow to specify that the returned entities always belong to a statically known entity set that cannot be reached via navigation from the binding parameter type?\n\n### Proposal\n\nNo action.\n\nWe intentionally constructed bound functions/actions this way to make the function/action definition independent of the schema that defines the binding target.\n\nAlso we intentionally don't have references from Schema children to an Entity Container.\n\nModel designers are encouraged to add navigation paths that allow them specifying an EntitySetPath.\n\nImported from [ODATA-1237](https://issues.oasis-open.org/browse/ODATA-1237)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "What should be returned for inserted non-entity value?",
    "body": "In [ODATA-616](https://issues.oasis-open.org/browse/ODATA-616) we introduced the ability to post to a collection of non-entity types.  The new wording appears in [Section 11.4.9.4, Update a Collection Property, of Protocol](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#_Toc505771257):\n\n{panel}\nA successful POST request to the edit URL of a collection property adds an item to the collection. The body of the request MUST be a single item to be added to the collection. If the collection is ordered, the item is added to the end of the collection, and $index MAY be used to specify a zero-based ordinal position to insert the new value, with a negative value indicating an ordinal position from the end of the collection.\n{panel}\n\nAnd later, we say:\n{panel}\n    On success, the response MUST be a valid update response.\n{panel}\n\nHowever, we don't say *what* response code, or body, to return for this case.\n\nFor a created entity, we would typically return 201 Created and the newly created resource in the body, unless the return=minimal preference was applied, in which case we would return 204.  But 201 Created requires a Location header (and, in OData, an Entity-id header). So, if we return 201, what would we return for the location (and entity-id) headers?\n\nDoes it matter whether the collection is ordered (in which case we have a location for the added resource)?\n\nOr, perhaps we always return 204, no content (and no body)?\n\nOr do we view this as an update and return 200, along with the newly inserted value? Or 200 with the full collection? Or 200 with the entity containing (at least?) the populated collection?\n\n### Proposal\n\n1) We shouldn't have different behavior for ordered versus non-ordered collections.\n2) Inserting into a non-entity collection (in general) isn't creating a resource, so 201 is not appropriate, which resolves the issue of the location and entity-id headers.\n3) By default, we should return 204, no content (and no body)\n4) If we support the return=representation header, we should return the updated collection.\n\nImported from [ODATA-1236](https://issues.oasis-open.org/browse/ODATA-1236)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow relative URLs in headers",
    "body": "We currently mention the use of relative URLs in request and response payloads but do not mention anything about allows relative URLs in headers.  HTTP allows relative URLs in headers (for example, see [https://tools.ietf.org/html/rfc7231#section-7.1.2] ) so the OData standard should mention it as well.\n\n### Proposal\n\nAllow URLs relative to the request URL in headers.\n\nPoint this out in Part 1: Protocol, section 4.1\n\nImported from [ODATA-1234](https://issues.oasis-open.org/browse/ODATA-1234)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support Union types",
    "body": "Type inheritance implies polymorphism implies that a property may be any of type derived from the declared type. In some cases, a property may be able to be one of a discrete set of types.\n\nFor example, in the Schema.org schemas, many of the references can point to either a person or an organization.  Person and Organization may derive from a common type, but other types derived from that common base type are not allowed.\n\nThere are several possible approaches for representing such unions:\n1) Allow defining a discrete set of types for a property, that may or may not have a common base type, rather than a single type.\n2) Define a \"union\" type structure that is an open complex type with properties for each \"type\"\n3) Define an annotation that allows you to restrict the set of derived types of a property. The types must derive from the declared type of the property, which could be an abstract type (i.e., Edm.EntityType). \n\n\n### Proposal\n\nDerivedTypeConstraint already exists, just need to extend its use and clarify:\n\nProposal:\n\n1) Add \"EntitySet, Singleton, NavigationProperty, Function, Action, and Parameter to AppliesTo.\n\n2) Clarify in the description that types derived from allowed types are also allowed\n\nImported from [ODATA-1232](https://issues.oasis-open.org/browse/ODATA-1232)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove $Kind for entity container children",
    "body": "There is some redundancy for entity container chilldren, and inconsistency in not including $iscollection for an entityset.\n\n### Proposal\n\nRemove $Kind for entity container children.\n\nAction imports are identified by having a $Action member.\n\nFunction imports are identified by having a $Function member.\n\nEntity sets are identified by having a $Type member and a $Collection:true member.\n\nSingletons are identified by having a $Type member and no $Collection member (preferred) or a $Collection:false member (not recommended, omit instead).\n\nImported from [ODATA-1231](https://issues.oasis-open.org/browse/ODATA-1231)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "/$filter(...) segments in paths and expressions",
    "body": "\n\n### Proposal\n\nAdd /$filter(...) segment that can be used in commonExpr after a collection-valued property\n\nChange syntax of /$filter path segment to also use parentheses instead of an = sign\n\nThis introduces Nav/$filter(...)/$count as an alternative to Nav/$count($filter=...)\n\nSupport expression or parameter within parens.\n\n \n\nImported from [ODATA-1230](https://issues.oasis-open.org/browse/ODATA-1230)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Introduce LocalDateTime TypeDef to apply to string datatype",
    "body": "One of our first actions as a Technical Committee was to remove the Edm.DateTime datatype in favor of Edm.DateTimeOffset. See [ODATA-11](https://issues.oasis-open.org/browse/ODATA-11).\n\nWhile there were good reasons for doing this, it has been a singularly unpopular decision, especially for services integrating with legacy systems that don't carry timezone information.\n\nIt would be a breaking change to add a new datatype in 4.x, would add complexity by expanding the set of data types (especially when all date/time values are serialized as string in JSON) and would encourage a particular anti-pattern (DateTime values without timezone).\n\nStill, we should listen to the continual feedback (for example, see [https://github.com/OData/WebApi/issues/136]) and provide a means of representing such values.\n\nToday, the fallback is to represent such values as strings, but the semantics of what the string represents, including use within a URL and client representation in a strongly typed language, are lost.\n\nA reasonable compromise would be to add a core vocabulary term that could be used to annotate a string as representing a \"LocalTime\" value. The format of the string would have to comply with the Date and Time portions of the existing Edm.DateTimeOffset data type. We could require services that use this annotation to support implicit conversions of such properties (and correctly formatted string literals?) to DateTimeOffset with UTC.\n\n### Proposal\n\n1) Introduce a new Core type annotation:\n```xml\n<TypeDefinition Name=\"LocalDateTime\" UnderlyingType=\"Edm.String\">\n  <Annotation Term=\"Description\" String=\"A string representing a Local DateTime value with no offset.\"/>\n   <Annotation Term=\"Validation.Pattern\" String=\"^[0-9]{4}-(0[1-9]](1[0-2))-(0[1-9]]([12)[0-9]](3[01))T([01][0-9]](2[0-3)):[0-5][0-9](:[0-5][0-9](\\\\.[0-9]+)?)?$\"/>\n</TypeDefinition>\n```\n2) Define the cast function to Edm.DateTimeOffset to allow a string representation of a datetime value with no offset; the result is the specified value as UTC.\n\nImported from [ODATA-1229](https://issues.oasis-open.org/browse/ODATA-1229)",
    "labels": [
      "URL Conventions",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support non-batch mechanism for long URLs",
    "body": "From the early days of OData we have had issues with requests exceeding the maximum URL length for servers.\n\nThe typical response has been to use $batch, which passes the request in the body.  However, using $batch is a bit overkill for this common scenario, and has several drawbacks:\n1) using $batch is non-intuitive and introduces extra complexity and concepts for executing a single request\n2) the /$batch request and response must both be wrapped, with things like headers, request verbs, and response codes hidden within the payload.\n3) the /$batch endpoint is at the root, which means that the request is not routed according the URL but the request body must be parsed in order to determine routing\n\nInstead of relying on batch, we can define a /$query segment that can be applied to a resource path.  Clients POST to the URL, providing the query string in the body. Any query options specified in the URL are combined with the query options specified in the body.\n\nThe format of the querystring in the body is an interesting discussion.  One option is to provide it as a simple string, which would be the most consistent with the existing query string.  Alternatively, we could provide a JSON payload of name/value pairs for each query string option. The two are not mutually exclusive; the client could indicate through the content-type header which format they are using (applicaiton/text versus application/xml).\n\nWe could also explore other structured representations of certain query options. For example, we could provide an AST representation of the $filter query option that could be simpler and more efficient to build and parse than serializing as a string. \n\nThe drawback to defining multiple formats is that services either need to support both, or clients need to check which format(s) are supported by the service.\n\n\n### Proposal\n\nDefine a /$query segment that can be appended to a resource. Clients make POST requests to this endpoint, with no query options specified, and a content-type of text/plain. The body of the request is a string following the syntax rules of the query portion of the URL, using the same percent-encoding rules.\n\nOpen a new issue to track defining an application/json representation of the payload that could include structured representations of things like $filter, $expand, $select, etc.\n\nImported from [ODATA-1228](https://issues.oasis-open.org/browse/ODATA-1228)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve description of filter expression restrictions",
    "body": "Filter expression restrictions define an allowed subset of filter expressions for a single property. We did not explicitly state that it is allowed to combine valid (restricted) expressions for different properties by \"and\".\n\n### Proposal\n\nChange description (green text is new)\n> These properties only allow a subset of filter expressions. {color:#008000}A valid filter expression for a single property can be enclosed in parentheses and combined by `and` with valid expressions for other filterable properties{color}.\n> \n\n\nImported from [ODATA-1227](https://issues.oasis-open.org/browse/ODATA-1227)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Ambiguity with Capabilities.ChangeTracking annotation",
    "body": "Suppose I have an entity type with 2 structural properties (A, B) and 2 navigation properties (C, D).\n\n \n\nThen I use :\n\n \n\n<Annotation Term=”Capabilities.ChangeTracking”>\n\n  <Record>\n\n    <PropertyValue Property=”FilterableProperties”/>\n\n      <Collection>\n\n        <PropertyPath>A</PropertyPath>\n\n      </Collection>\n\n    </Record>\n\n</Annotation>\n\n \n\nNow it is clear that A is filterable and B is not. But how is the client to interpret ExpandableProperties not being specified (defaults to an empty Collection(NavigationPropertyPath))?\n\n \n1. The server omitted these properties from the annotation because they (C, D) are *all* expandable.\n1. The server omitted these properties from the annotation because they (C, D) are *not* expandable.\n\n \n\nThe interpretation of an empty collection here is ambiguous.\n\n### Proposal\n\nRemove EntityContainer from the AppliesTo list. Part 1: Protocol only mentions this term for annotating entity sets.\n\nAdd a LongDescription to FilterableProperties and ExpandableProperties:\n> If no properties are specified or Filterable/ExpandableProperties is omitted, clients cannot assume support for filtering on/expanding any properties.\n> \n\n\nImported from [ODATA-1226](https://issues.oasis-open.org/browse/ODATA-1226)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Correct example 68",
    "body": "The result of example 68 does not match the description of the model function applied in the request. The function is supposed to return an extra entity with a single property holding the aggregated value of all entities not considered.\n\nIn the shown response, these entities contain also a property Product/Name = \"\\*\\*Other\\*\\*\", which is unexpected.\n\n### Proposal\n\nReplace with this response:\n{noformat}\n{\n  \"@odata.context\": \"$metadata#Sales(Customer(Country),Product(Name),Total)\",\n  \"value\": [\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"Netherlands\" },\n      \"Product\": { \"Name\": \"Paper\" }, \"Total\": 3 },\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"Netherlands\" },\n      \"Total\":  2 },\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"USA\" },\n      \"Product\": { \"Name\": \"Coffee\" }, \"Total\": 12 },\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"USA\" },\n      \"Total\": 5 }\n  ]\n}\n\n{noformat}\n\nImported from [ODATA-1225](https://issues.oasis-open.org/browse/ODATA-1225)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Make [OData-]EntityId header optional if the same as Location header",
    "body": "On create and upsert request returning 204 No Content we currently MUST return an [OData-]EntityId header which, if following convention, always has the same value as the, always required, Location header.\n\n### Proposal\n\nMake the [OData-]EntityId header optional if it has the same value then the Location header.\n\nImported from [ODATA-1224](https://issues.oasis-open.org/browse/ODATA-1224)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add OData- prefix back to EntityId header",
    "body": "The following is feedback received from the IANA OData Header registration.  The summary of the feed back is that the EntityId and Isolation header names may be too generic\n\n \n\nSee also [https://protect-us.mimecast.com/s/6cHPCQWX4XfkDzX5iPE-q-?domain=mnot.net]\n\n \n\nFrom: *Ted Hardie* <[ted.ietf@gmail.com](mailto:ted.ietf@gmail.com)>\n Date: Wed, Aug 29, 2018 at 2:58 PM\n Subject: Re: [Ietf-message-headers] Registration request for EntityId, Isolation, OData-MaxVersion, and OData-Version\n To: Chet Ensign <[chet.ensign@oasis-open.org](mailto:chet.ensign@oasis-open.org)>\n Cc: [ietf-message-headers@ietf.org](mailto:ietf-message-headers@ietf.org), \"Mark Biamonte (Progress)\" <[Mark.Biamonte@progress.com](mailto:Mark.Biamonte@progress.com)>\n\nHi Chet,\n\n \n\nI'm a little confused on one point.  The Isolation header states that it was called OData-Isolation in version 4.0, but the linked ABNF document says:\n\n \n\nisolation  = [ \"OData-\" ] \"Isolation\" \":\" OWS \"snapshot\"\n\nThat seems to indicate that both ODate-Isolation and Isolation are expected to be valid for this token.  The ABNF for EntityID is similar:\n\n \n\nentityid   = [ \"OData-\" ] \"EntityID\" \":\" OWS IRI-in-header\n\n \n\nCan you clarify the intent here?  Are both expressions of this token expected to continue?\n\n \n\nIn general, \"Isolation\" seems to be a very general concept, and the reservation of it, unadorned, for a single token use (\"snapshot\") is somewhat surprising compared to the more-obviously scoped OData-isolation.  EntityID seems similar board in possible usage outside the OData specification. \n\n \n\nregards,\n\n \n\nTed Hardie\n\n \n\nHi Mark,\n\n \n\nOn Thu, Aug 30, 2018 at 6:49 PM, Mark Biamonte <[Mark.Biamonte@progress.com](mailto:Mark.Biamonte@progress.com)> wrote:\n\nHi Ted,\n\n \n\nI am a member of the OData Technical Committee (TC).  Chet submitted the request for OASIS on behalf of the OData TC.  You are correct, in OData 4.0 the Headers were titled OData-Isolation and OData-EntityID.  In the latest OData 4.01 spec the header name was changed to just Isolation and EntityID.  The OData- prefixed versions are still supported for backwards compatibility. \n\n \n\n[TH] Okay; I was probing to find out if this superseded the previous header, but it sounds like you expect both to be used at least during the compatibility period.\n\n \n\nThis change was made based on feedback for users and implementors of the OData standard.  I gather your preference would be that we use the OData-prefixed version for the registrations.  If so I will need to discuss that with the TC and get back to you.\n\n \n\n \n\n[TH] While that would be my personal preference, it is simply that:  my opinion as an individual.  I'm primarily concerned that other, unregistered or pre-registration uses of these more general concepts may occur.  While recording them in the registry will help avoid collisions, there is always some risk and the more general the term, the higher the risk.\n\n \n\nregards,\n\n \n\nTed Hardie\n\n> On 1 Sep 2018, at 2:54 am, Ted Hardie <[ted.ietf@gmail.com](mailto:ted.ietf@gmail.com)> wrote:\n > \n >> This change was made based on feedback for users and implementors of the OData standard. I gather your preference would be that we use the OData-prefixed version for the registrations. If so I will need to discuss that with the TC and get back to you.\n > \n > \n > While that would be my personal preference, it is simply that: my opinion as an individual. I'm primarily concerned that other, unregistered or pre-registration uses of these more general concepts may occur. While recording them in the registry will help avoid collisions, there is always some risk and the more general the term, the higher the risk.\n >\n\nSpeaking personally, I'd second that concern. It's least confusing when headers that are specific to an application (in this case, OData) include that application's name in their field name.\n\nCheers,\n\n–\n Mark Nottingham [https://www.mnot.net/](https://protect-us.mimecast.com/s/6cHPCQWX4XfkDzX5iPE-q-?domain=mnot.net)\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1223](https://issues.oasis-open.org/browse/ODATA-1223)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Validation: add terms MinItems and MaxItems",
    "body": "Add terms MinItems and MaxItems that apply to anything collection-valued and allows specifying the expected minimum and maximum number of items in the collection.\n\nSimilar to minimum and maximum this is along the lines of JSON Schema minItems and maxItems, see [https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.4.3]\n\nImported from [ODATA-1222](https://issues.oasis-open.org/browse/ODATA-1222)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Apply, as much as possible, our JSON Format to our annotations as well",
    "body": "In [ODATA-1170](https://issues.oasis-open.org/browse/ODATA-1170) we added the ability to add the type to a term of an enum type.\n\nThe solution chosen was to annotate the predefined, one and only, $EnumMember property, which, by itself, does not add anything other then telling the consumer that he/she is dealing with the name of a member of an enum type, still requiring the $metadata document to find out what the actual enum type is.\n\nThat raises the question why one needs that object wrapper to begin with and why we, like with regular enum typed structured properties, don't simply use the same format and return the enum members name as a string value of that term. \n\nAnd if we do so for enum types why wouldn't we do that for all primitive types for which we introduced a similar wrapper object with one predefined $-property?\n\n \n\nSide question: Does our XML to JSON CSDL conversion correctly convert our annotations to begin with? I'd be tempted to say that enum properties IN complex types used in terms should use the standard JSON format and not the object wrapper with the $EnumMember property either not?\n\n### Proposal\n\nUse same representation for constant expressions as for primitive values in JSON format, i.e. no object wrapper such as\n```java\n\"@some.binary.term\":{\"$Binary\":\"...\" }\n```\nInstead use the plain value: \n```java\n\"@some.binary.term\":\"...\"\n```\nThis puts some burden on clients to \"know\" or look up the term definition to determine the actual type of a JSON string value, but that has to be done for JSON data responses anyway.\n\nNote that no way to distinguish between strings and data exception, datetime, guid values in a collection of Edm.PrimitiveType. In such a case, generic libraries should treat as string and clients must use out of band knowledge to interpret it as some other value.\n\nSame argument applies to model element path expressions: here the client knows from the term definition that the value is a model element path or one of its concreter sub-types, so the value can simply be a string containing the path without object wrapper:\n```\n\"NonExpandableProperties\":[\"Customer\",\"Country\"]\n```\nInstance path expressions still need the object wrapper to distinguish them from actual string values:\n```\n\"@Core.Description\":{\"$Path\",\"CompanyName\"}\n```\n \n\nImported from [ODATA-1221](https://issues.oasis-open.org/browse/ODATA-1221)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Instance annotations section only refers to the XML CSDL, not JSON CSDL",
    "body": "In our OData JSON format specification, chapter 20 Instance Annotations, we, only, refer to the XML CSDL. I think what we really are trying to say is that the annotations have to be defined in CSDL, irrespective of the format, and should find a way to express that here. \n\n### Proposal\n\nAdd/correct wording to express that annotations have to be defined in CSDL, irrespective of the format used.\n\nImported from [ODATA-1220](https://issues.oasis-open.org/browse/ODATA-1220)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Be more explicit about the purpose of $DefaultValue in a Term definition",
    "body": "It appears to be unclear what the purpose is of having a $DefaultValue for a term definition in our JSON CSDL as, as stated in the specification as is, in our JSON CSDL a value MUST always be specified anyway. And while a $DefaultValue might be obvious for some terms, most notably boolean typed terms (read: tags) where the values is typically true, and there maybe a value for some enum and numerically based terms, this is less so the case for any of the other types.\n\nThe reference to it being for documentation purposes raised different questions.\n\nOn the other hand, if a term is of a structured type, default values of the individual structural properties are indeed implied in absence of the property, which is not the case for terms not being applied to any model element it could have been applied to, which further would speak to not having a $DefaultValue in terms potentially causing confusion.\n\nOur XML CSDL however didn't require the value to be there, merely 'tagging' a model element with the annotation term would suffice, implying the DefaultValue specified in the XML CSDL. Therefore, arguably, the only remaining 'function' of this $DefaultValue is to allow for full fidelity round-tripping between our XML and JSON versions of the CSDL.\n\n### Proposal\n\nAt a minimum I think we should be extremely clear in our JSON CSDL specification that this full fidelity between multiple formats of our CSDL is the sole purpose of this $DefaultValue to exists and to not confuse it with $DefaultValue of properties that, when omitted, are presumed to be applied.\n\nImported from [ODATA-1219](https://issues.oasis-open.org/browse/ODATA-1219)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Enhance hierarchy processing",
    "body": "Working with hierarchies often involves functionality to select sub-hierarchies, to retrieve hierarchy nodes in a specified tree order, and to aggregate bottom-up along the hierarchy paths.\n\n### Proposal\n\nOverview and examples: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/65934/Enhanced%20support%20for%20hierarchy%20use%20cases%20-%20Examples.pptx]\n\nContext, use cases and proposals for new transformations: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68535/Enhanced%20support%20for%20hierarchy%20use%20cases%20V1.6.4.1.docx](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68535/Enhanced%20support%20for%20hierarchy%20use%20cases%20V1.6.4.1.docx) (covers all feedback items from the review discussion)\n\n \n\nImported from [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clients should read symbolic values in CSDL case-insensitive",
    "body": "We currently define special symbolic values in CSDL for things like \"variable\" or \"floating\" scale, or \"max\" MaxLength.\n\nSome services return these using different casing than defined in the spec.  \n\n### Proposal\n\nServices SHOULD use lower case for symbolic values \"variable\" and \"floating\" for Scale, and \"max\" for MaxLength, as specified in the specification; clients SHOULD handle these symbolic values in a case-insensitive manner in order to be more robust.\n\nImported from [ODATA-1217](https://issues.oasis-open.org/browse/ODATA-1217)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Terms for POST/PATCH/PUT with system query options to shape response",
    "body": "Services need a way to advertise whether they support response-shaping system query options for certain operations.\n\n### Proposal\n\nRevised proposal from 2018-11-8. \n\nAdd ModificationQueryOptionsType\nAdd  ModificationQueryOptions as a top-level annotation term.\nAdd QueryOptions property to InsertRestrictions \nAdd QueryOptions property to UpdateRestrictions\n\nImported from [ODATA-1216](https://issues.oasis-open.org/browse/ODATA-1216)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify datatype of virtual property $count",
    "body": "In the Data Aggregation extension, the virtual property $count has type Edm.Decimal (http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016573). In contrast the JSON Format specification states that the result of the system query option has type Edm.Int64 (http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html#_Toc372793054).\n\nSince aggregation rather reduces the number of entities in a result collection, question is whether there is some unmentioned reason for this discrepancy.\n\n### Proposal\n\nIf no argument speaks for keeping Edm.Decimal, the proposal is to align both features by assigning Edm.Int64 also to the virutal property $count.\n\nImported from [ODATA-1215](https://issues.oasis-open.org/browse/ODATA-1215)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Address use of 201 Created for Create Link Requests",
    "body": "Section 9.1.2 Response Code 201 Created says that a 201 can be returned for a “Create Link” request which references section 11.4.6.  But all of section 11.4.6 says that successful responses MUST be 204.\n\n### Proposal\n\nRemove \"Create Link\" from section 9.1.2 meaning that only 204 No Content is a valid response status code.\n\nImported from [ODATA-1213](https://issues.oasis-open.org/browse/ODATA-1213)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Validation term for allowed terms in Annotation Paths ",
    "body": "Annotation paths allow referencing annotations.\n\nOften the referenced annotation has to have one of certain \"allowed\" terms that can be interpreted in that context.\n\nCurrently these \"allowed terms\" cannot be expressed in the term or property definition.\n\n### Proposal\n\nMention term Validation.AllowedTerms in CSDL sections 14.4.1.3 Annotation Path.\n\nAdd to Validation vocabulary:\n\n```xml\n<Term Name=\"AllowedTerms\" Type=\"Collection(Core.QualifiedTermName)\" AppliesTo=\"Term Property\">\n  <Annotation Term=\"Core.Description\"\n    String=\"Annotate a property or term of type AnnotationPath to restrict the terms that can be targeted by the path.\" />\n  <Annotation Term=\"Core.LongDescription\"\n    String=\"Annotation path expressions assigned to the annotated term or property are intended to resolve to annotations with one of the listed terms. For forward compatibility, clients should be prepared for the annotation to reference terms besides those listed.\" />\n  <Annotation Term=\"Core.RequiresType\" String=\"Edm.AnnotationPath\" />\n</Term>\n```\n\nAdd to Core vocabulary:\n```xml\n<TypeDefinition Name=\"QualifiedTermName\" UnderlyingType=\"Edm.String\">\n  <Annotation Term=\"Core.Description\" String=\"The qualified name of a term in scope.\" />\n</TypeDefinition>\n```\n\nImported from [ODATA-1212](https://issues.oasis-open.org/browse/ODATA-1212)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "4.2 and 5.1: Explicitly state that an alias MUST NOT be identical to any other alias or namespace in the same document.",
    "body": "This was decided in [ODATA-681](https://issues.oasis-open.org/browse/ODATA-681) but apparently didn't make it into the documents\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1211](https://issues.oasis-open.org/browse/ODATA-1211)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "CSDL ReturnType element needs to specify rules for Nullable and Collection with entity types",
    "body": "It is reasonable to assume:\n- A collection of entities never contains null because the “null entity” has no meaning.\n- A function returning a single entity would have to return 204 No Content to signal “no entity returned”, similar to following a single-valued navigation property with nothing associated at that point in time.\n\nTherefore:\n- A function returning entities behaves like a navigation property.\n- A function returning structured or primitive instances behaves like a structural property.\n\nIn regard to CSDL XML/JSON 4.01, we should specify:\n\nNullable should never be specified for a Collection(SomeEntityType), and it must always be considered to be false by default. This would bring consistency with navigation properties.\n\nGoing one step further, we should probably apply this reasoning to Parameter elements, i.e. a parameter of type Collection(SomeEntityType) should also never have an explicit Nullable facet.\n\nImported from [ODATA-1210](https://issues.oasis-open.org/browse/ODATA-1210)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Term for original OData version of (auto-)converted $metadata",
    "body": "We have several cases of generic clients that can interact with V2 and V4 services and internally only use V4 syntax and semantics. One aspect of this is that the client converts the V2 $metadata into V4 $metadata and needs to \"remember\" whether the original protocol version - and the one to use for URL generation and payload serialization is something else than V4.\n\n### Proposal\n\nAdd term Core.OriginalProtocolVersion with allowed values \"2.0\". \"3.0\", and \"4.0\".\n\nImported from [ODATA-1209](https://issues.oasis-open.org/browse/ODATA-1209)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Specify the finest possible granularity for Duration",
    "body": "Edm.Duration allows to expressing via the Precision facet which number of decimal places can be stored/sent.\n\nWe have applications which don't even support second granularity for durations and only can store durations in days, hours, or minutes (all three variants exist).\n\n\n\n### Proposal\n\nAdd a Measures term DurationGranularity with allowed values \"days\", \"hours\", and \"minutes\". Absence of the annotation means \"seconds with sub-seconds according to Precision\". \n\nImported from [ODATA-1208](https://issues.oasis-open.org/browse/ODATA-1208)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify need for @odata.id in nested response structures",
    "body": "This issue is to clarify, if nested entities included in the response to an aggregation request need to be equipped with an @odata.id control information.\n\nConsider example 24 from the Data Aggregation specification:\n\n`GET ~/Sales?$apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum as Total))`\n\nresults in\n```java\n{\n  \"@odata.context\": \"$metadata#Sales(Customer(Country),Product(Name),Total)\",\n  \"value\": [\n    { \"@odata.id\": null,\n      \"Customer\": { \"Country\" : \"Netherlands\" },\n      \"Product\": { \"Name\": \"Paper\" },\n      \"Total\": 3 },\n   [...]\n \n```\nTop-level entities do have an @odata.id, but nested projections of related entities currently not. Is this according to rules defined in the format specs to be considered as a gap that needs to be discussed for the Data Aggregation spec?\n\nThe JSON specification describes in section 8.3 for expanded navigation properties that the content is to be rendered according to the entity representation. Two cases exist: 1) If the nested entity is a projection of a \"real\" entity, this could imply mentioning its @odata.id in the response. 2) If the nested entity is a result of an aggregation and therefore transient, section 4.5.8 of the JSON spec states: \"If the entity is transient (i.e. cannot be read or updated), the id annotation MUST appear and have the null value.\"\n\n### Proposal\n\nExamples in the document should comply with the rules stated in the JSON format specification. Since the current examples throughout the document that return transient aggregated entities based on 4.0, all examples having responses with nested projections of related entities should have included an \"@odata.id\":null annotation.\n\n \n\nProposal is to make a blanket statement for V4.01 that clients must be prepared to receive entities having neither @odata.id nor key fields and, in the absence of any additional information, must treat such entities as transient.\n\nWe will update the examples in the aggregation specification to be 4.01 and thus all @odata.id:null (as well as other 4.01 simplifications).\n\nMention in Aggregation that all examples are based on OData V4.01, and call out what would be different across examples for V4.0.\n\nImported from [ODATA-1207](https://issues.oasis-open.org/browse/ODATA-1207)",
    "labels": [
      "Data Aggregation",
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Explicitly note support for collection-valued navigation/complex properties in property paths in aggregate/groupby",
    "body": "It is intended to support aggregation of property values reached via paths that may involve _collection-valued_ navigation properties (see example 53). Likewise, it is intended to support grouping by properties reached via paths that may involve _collection-valued_ navigation properties (see example 54).\n\nSo far, these possibilities are mentioned only by examples, but should be described explicitly in the prose text.\n\n### Proposal\n\n*Add to section 3.1 Transformation aggregate* (insertions surrounded by *):\n An aggregate expression may be\n - an expression valid in a $filter system query option on the input set that results in a simple value, e.g. the path to an aggregatable property, with a specified aggregation method,\n - \\* an aggregatable property, with a specified aggregation method, that can be reached via a path consisting of a sequence of navigation properties, complex properties and complex collection properties. \\*\n [...]\n\n*Update of section 3.10.1 Simple Grouping* (insertions surrounded by *):\n In its simplest form the first parameter of groupby specifies the grouping properties, a comma-separated list of one or more single-valued property paths (paths ending in a single-valued primitive, complex, or navigation property) that is enclosed in parentheses. * A path may consist of a sequence of navigation properties, complex properties and complex collection properties.*\n\nImported from [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Examples 53, 54, and 59 are not compliant with Data Aggregation ABNF",
    "body": "Section 3.1 Transformation aggregate defines:\n\nAn aggregate expression may be: \n• an expression valid in a $filter system query option on the input set that results in a simple value, e.g. the path to an aggregatable property, with a specified aggregation method,\n\nThe above-mentioned examples refer to property paths with collection-valued navigation properties, which cannot be created from a CommonExpression that is referenced in rule aggregateExpr of the current ABNF for Data Aggregation.\n\n \n\n### Proposal\n\n \n\nExtend ABNF rule (insertion surrounded with *):\n```java\naggregateExpr   = customAggregate [ customFrom asAlias ]\n                / commonExpr aggregateWith [ aggregateFrom ] asAlias\n-                / pathPrefix primitiveProperty aggregateWith [ aggregateFrom ] asAlias *\n                / pathPrefix '$count' asAlias \n                / pathPrefix customAggregate\n                / pathPrefix pathSegment OPEN aggregateExpr CLOSE```\n \n\n \n\nImported from [ODATA-1205](https://issues.oasis-open.org/browse/ODATA-1205)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow numeric indexes in Path constructs within annotations",
    "body": "With [ODATA-1061](https://issues.oasis-open.org/browse/ODATA-1061) we allowed key segments in parenthesis syntax after path segments that identify a collection of entities.\n\nA logical extension is allowing numeric indexes to reference entities or complex type instances within a collection:\n\n```xml\n<Annotation Term=\"Some.Term\" Path=\"ComplexCollection/0/SomeProperty\" />\n```\n\nThis would address the first item in the collection. If the item is structured, additional path segments can follow after the index segment.\n\n### Proposal\n\nPath expressions allow index segments after path segments that identify an ordered collection of primitive or complex types. The index is zero-based and MUST be an integer literal. Negative integers count from the end of the collection, with -1 representing the last item in the collection.\n\nThis key syntax can only be used in Path expressions as only these refer to instance values.\n\nIt cannot be used in expressions for model references, i.e. PropertyPath, NavigationPropertyPath, AnnotationPath, and their abstract supertypes AnyPropertyPath and AnyPath.\n\n \n\nImported from [ODATA-1203](https://issues.oasis-open.org/browse/ODATA-1203)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Deep update with nested delta items should allow Core.ContentID",
    "body": "The spec only mentions using Core.ContentID with deep insert.\n\nBut deep update may create additional entities and clients may need/wish to be able to correlate keys in the return representation with entities from the request payload.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1202](https://issues.oasis-open.org/browse/ODATA-1202)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Improve the syntax of aggregation exceptions with \"from\"",
    "body": "Current syntax:\n\n \n```java\naggregateExpression    (1)\n  as alias             (3)\n  from groupableProperty_1 with aggregationMethod_1 [ with aggregationMethod_1 ] (2) \n  ... \n  from groupableProperty_n with aggregationMethod_n [ with aggregationMethod_n ] \n```\nIt first takes (1) the standard aggregate expression followed by (3) the alias for the final aggregated value followed by (2) \"from\" clauses for exceptions. Since there is a certain processing order defined, which is 1, 2, 3, the syntax would express the intention more clearly, if it would be (1) (2) (3)\n\n \n\n### Proposal\n\nChange the current syntax in section 3.1.4 to\n```java\naggregateExpression\n  from groupableProperty_1 with aggregationMethod_1 [ with aggregationMethod_1 ]\n  ...\n  from groupableProperty_n with aggregationMethod_n [ with aggregationMethod_n ]\n  as alias\n```\n\nImported from [ODATA-1201](https://issues.oasis-open.org/browse/ODATA-1201)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support sample values for types, parameters, request/response bodies",
    "body": "[ODATA-884](https://issues.oasis-open.org/browse/ODATA-884) currently specifies a \"CustomParameterExampleValue\" for providing a sample value for a custom parameter within an HttpRequest annotation.\n\nMore generally, OpenAPI supports defining one or more sample values for each parameter and each (valid media type allowed for a) request or response payload ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#example-object]), as well as a single example for each schema object ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#schema-object]).\n\nOpenAPI also supports the example value either being an (inline or referenced) Value, or an ExternalValue, where ExternalValue is an external reference to the literal value in a native (i.e., non-OpenAPI) format. This is done partially to support non-JSON media type values, but can also be useful for referencing external samples. We could support this by defining a base \"Value\" type and inherited \"InlineValue\" or \"ExternalValue\" types.\n\nWe could support this by allowing a new \"ExampleValue\" annotation on a type, parameter, or for a request or response body within an HttpRequest.\n```xml\n<Term Name=\"Example\" Type=\"Core.ExampleValue\" AppliesTo=\"EntityType ComplexType Parameter\"/>\n\n<ComplexType Name=\"ExampleValue\" Abstract=\"true\">\n <Property Name=\"Description\" Type=\"Edm.String\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Description of the example value\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"PrimitiveExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"Value\" Type=\"Edm.PrimitiveType\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Example value for the custom parameter\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"ComplexExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"Value\" Type=\"Edm.ComplexType\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Example value for the custom parameter\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"EntityExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"Value\" Type=\"Edm.EntityType\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Example value for the custom parameter\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"ExternalExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"ExternalValue\" Type=\"Edm.String\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Url reference to the value in its literal format\" />\n </Property>\n</ComplexType>\n```\nAnd, within HttpResponse:\n <Property Name=\"Example\" Type=\"Core.ExampleValue\"/>\n\n1) OpenAPI supports the Description as CommonMark syntax ([http://spec.commonmark.org/]) for rich text representation. We could support this as well.\n 2) OpenAPI also includes a short \"Summary\"\n 3) OpenAPI supports multiple examples for request/response bodies and parameters, but not for schema objects (i.e., types). It's unclear how you would relate individual request examples with individual response examples.\n\nImported from [ODATA-1200](https://issues.oasis-open.org/browse/ODATA-1200)",
    "labels": [
      "Vocabularies",
      "CN02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add property SystemQueryOptions to call out supported system query options per request method",
    "body": "In V4.01 we added the possibility to shape the response to POST, PATCH, and PUT requests with system query options.\n\nSupport for this needs to be expressed in some way, see [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005).\n\nEasiest way would be to add a property SystemQueryOptions next to CustomQueryOptions.\nType could be a collection of strings naming the query option, or a complex type of Boolean flags telling which of the system query options is supported.\n\nDrawback is of course that this needs to be annotated for each entity set, whereas a \"traditional\" XxxSupport annotation can be attached to the entity container if the underlying engine supports this across all entity sets.\n\nSecond drawback is the overlap with the existing XxxRestrictions/Xxxable flags.\n\n\n\nImported from [ODATA-1199](https://issues.oasis-open.org/browse/ODATA-1199)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ETag handling deviations from RFC7232 are avoidable if we consider two kinds of ETag (ETag in response header and ETag in response payload)",
    "body": "ETags in response headers should be limited to use for cache validation\n\nETags in response payload (instance annotations) should be limited to use for optimistic concurrency\n\nConflating the two kinds of ETag leads us to difficulties\n\n*In Section 8.2.4 Header If-Match:*\n\n> Services sending ETag headers with weak ETags that only depend on the representation-independent entity state MUST use the weak comparison function because it is sufficient to prevent accidental overwrites. This is a deviation from [RFC7232].\n\nDifficulty: deviation from RFC7232. If we instead required that instance annotation etags be strong etags, and that If-Match only be used (for optimistic concurrency control) with strong etags, we would be compliant with both the draft and final RFC7232 specs. How could it be a strong etag if it depends on the representation-independent entity state? It could be so if we imagine that the representation-independent entity state has some kind of canonical form (which we never actually include in any request/response payload) and that the strong etag is a tag (e.g. version/hash) of that state.\n\n*In Section 8.2.5 Header If-None-Match*\n\n> “As defined in [RFC7232], a client MAY include an If-None-Match header in a request to GET, PUT, PATCH or DELETE. The value of the If-None-Match request header MUST be an ETag value previously retrieved for the resource, or “*”.\n\nDifficulty: apart from when “*” is used (to ensure non-existence of the resource), then the method should be GET and the purpose should be for cache validation. As such, it would seem to be important to use an ETag that came from a response header, not from response payload (in instance annotations).\n\n*In Section 8.3.3 Header ETag*\n\n> A response MAY include an ETag header, see [RFC7232]. Services MUST include this header if they require an ETag to be specified when modifying the resource.\n\nDifficulty: clients may wish to be able to do cache validation as well as optimistic concurrency. Requiring the ETag response header to be specified when modifying the resource doesn’t allow for the possibility that the client wants to use the ETag response header (which might be a content hash) for cache validation (e.g. GET using If-None-Match) and that the client wants to use an ETag from response payload (which might be a version number) for optimistic concurrency (e.g. PATCH using If-Match).\n\n*In Section 11.5.4.1 Invoking an Action*\n\n> To request processing of the action only if the binding parameter value, an entity or collection of entities, is unmodified, the client includes the If-Match header with the latest known ETag value for the entity or collection of entities. The ETag value for a collection as a whole is transported in the ETag header of a collection response.\n\nDifficulty: any ETag response header for a collection as a whole is likely to be only feasibly implemented as a hash of response payload. (At least any such ETag intended for use in cache validation would be such). Then suggesting that it be suitable for If-Match with an action invocation for some kind of optimistic concurrency control is probably not realistically implementable (suppose the collection response was for a subset of properties and the action request is to update some properties that weren’t included in the collection).\n\n### Proposal\n\nNew proposal based on discussion with Matt: *close without action*.\n\nRationale: [https://tools.ietf.org/html/rfc7232#section-3.1] states:\n> An origin server MUST use the strong comparison function when \n> comparing entity-tags for If-Match ([Section 2.3.2](https://tools.ietf.org/html/rfc7232#section-2.3.2)), since the client\n> intends this precondition to prevent the method from being applied if\n> there have been any changes to the _representation data_.\n> \n\nThis is geared towards web servers managing static resources, and is perfectly valid in that context.\n\nThis statement however is not true for (business) applications which track changes to the _underlying data independent from its wire-representation in different formats_. These applications want to prevent accidental changes to the _underlying data_, and for this an ETag only needs to change if the _underlying data_ changes, meaning that different representations of the same underlying data can share the same ETag.\n\nFrom the perspective of RFC7232 these representation-independent \"sufficiently varying\" ETags are weak ETags, which is why we deviate from RFC7232 in this aspect. \nh2. Notes from F2F discussion on 2018-09-28\n- Servers SHOULD use strong Etags for OData entities == \"internal\" Etag transported in @etag\n- Clients SHOULD use @etag for If-Match\n- Servers MUST accept both @etag and the header-etag for If-Match\n- in single-entity responses servers SHOULD send @etag also in etag header\n- If the serializer (especially for JSON) can produce byte-for-byte identical representations of the same underlying data\n- Or if we ignore \"byte-for-byte identical\" and deem \"JSON-equivalent\" sufficient\n\n- Multi-entity response == Collection or Expand\n- Multi-entity response typically does not have etag header\n- MAY have weak etag if caching needs to be supported\n- MAY have strong etag for if-match\n- Collection-response MAY have @etag for if-Match which MAY differ from the header-etag for caching\n- Note: currently no @etag defined for collections in wrapper object, and Hubert uses/needs this\n\nImported from [ODATA-1198](https://issues.oasis-open.org/browse/ODATA-1198)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Chapter 21 Error Response: replace misleading \"code\" values with FOO or BAR",
    "body": "Some readers are misinterpreting the code value \"501\" in the example error response as a MUST for services to echo the HTTP status code, contrary to what the normative spec text says.\n\n### Proposal\n\nUse \"err123\" and \"fourtytwo\" to indicate that this is not the HTTP status code, that it just is a string, \n\nImported from [ODATA-1197](https://issues.oasis-open.org/browse/ODATA-1197)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify update of media streams",
    "body": "Section 8.2.8.7 explicitly forbids return=representation for updating stream property values but allows it for updating media entity streams.\n\nAlso the text does not explicitly state that 204 No Content is the only response for updating stream property values, and that it is the default response for updating media entity streams.\n\n\n### Proposal\n\nAllow preference return=representation for all requests and make clear that the default is \"204 No Content\" for updating both kinds of streams.\n\nImported from [ODATA-1196](https://issues.oasis-open.org/browse/ODATA-1196)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "11.2.6.6: value of $search is search expression, not boolean expression",
    "body": "Section [11.2.6.6 System Query Option $search](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionsearch), last sentence incorrectly says that \n\n??The value of the $search option is a Boolean expression??\n\nIt should say \"search expression\"\n\n### Proposal\n\nRephrase last sentence to\n\n??The value of the `$search` option is a search expression as defined by rule `searchExpr` in *[OData-ABNF]*??\n\nImported from [ODATA-1195](https://issues.oasis-open.org/browse/ODATA-1195)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add term Core.Example to allow including annotation examples in term definitions",
    "body": "While discussing [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099) the idea came up to allow including annotation examples into the term definition, especially useful for structured terms.\n\nSee [https://www.oasis-open.org/committees/download.php/61713/odata-meeting-190_on-20171005-minutes.html#6.2.1,] META 2.\n\nAs [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099) is not yet resolved, the term Core.Example is pulled out into this separate issue.\n\n### Proposal\n\nAdd new term\n\n```xml\n<Term Name=\"Example\" Type=\"Core.ExampleType\">\n  <Annotation Term=\"Core.Description\" String=\"A container for annotation examples\" />\n  <Annotation Term=\"Core.Example\">\n    <Record>\n      <Annotation Term=\"Core.Description\"\n        String=\"Note that the value of Core.Example is a record/object containing the annotation examples\" />\n    </Record>\n  </Annotation>\n</Term>\n<ComplexType Name=\"ExampleType\">\n  <Annotation Term=\"Core.Description\" String=\"This type intentionally doesn't have properties, so it can only contain annotation examples\" />\n</ComplexType>\n```\n\nImported from [ODATA-1194](https://issues.oasis-open.org/browse/ODATA-1194)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Automated vocabulary checks indicate some potential issues",
    "body": "See automated analysis output:\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:82 Property Warning: Unspecified Nullable facet defaults to true for property 'Rollup'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Rollup\" DefaultValue=\"MultipleHierarchies\" Type=\"Aggregation.RollupType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:85 Property Warning: Unspecified Nullable facet defaults to true for property 'PropertyRestrictions'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"PropertyRestrictions\" DefaultValue=\"false\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:164 Parameter Warning: Unspecified Nullable facet defaults to true for parameter 'MaxDistance'. An explicit Nullable='true' facet is recommended when null parameter values should be permitted.\n<Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:174 Parameter Warning: Unspecified Nullable facet defaults to true for parameter 'MaxDistance'. An explicit Nullable='true' facet is recommended when null parameter values should be permitted.\n<Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:76 Property Warning: Unspecified Nullable facet defaults to true for property 'RequiredScopes'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"RequiredScopes\" Type=\"Collection(Edm.String)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:113 Property Warning: Unspecified Nullable facet defaults to true for property 'Scopes'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Scopes\" Type=\"Collection(Auth.AuthorizationScope)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:90 Property Warning: Unspecified Nullable facet defaults to true for property 'Description'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Description\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:107 Property Warning: Unspecified Nullable facet defaults to true for property 'BearerFormat'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"BearerFormat\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:116 Property Warning: Unspecified Nullable facet defaults to true for property 'RefreshUrl'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"RefreshUrl\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:158 Property Warning: Unspecified Nullable facet defaults to true for property 'Description'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Description\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:198 Property Warning: Unspecified Nullable facet defaults to true for property 'Supported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:215 Property Warning: Unspecified Nullable facet defaults to true for property 'Countable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Countable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:246 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterFunctions'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:259 Property Warning: Unspecified Nullable facet defaults to true for property 'TopSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"TopSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:262 Property Warning: Unspecified Nullable facet defaults to true for property 'SkipSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SkipSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:265 Property Warning: Unspecified Nullable facet defaults to true for property 'IndexableByKey'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"IndexableByKey\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:314 Property Warning: Unspecified Nullable facet defaults to true for property 'Supported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:317 Property Warning: Unspecified Nullable facet defaults to true for property 'ContinueOnErrorSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ContinueOnErrorSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:320 Property Warning: Unspecified Nullable facet defaults to true for property 'ReferencesInRequestBodiesSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ReferencesInRequestBodiesSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:323 Property Warning: Unspecified Nullable facet defaults to true for property 'ReferencesAcrossChangeSetsSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ReferencesAcrossChangeSetsSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:326 Property Warning: Unspecified Nullable facet defaults to true for property 'EtagReferencesSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"EtagReferencesSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:339 Property Warning: Unspecified Nullable facet defaults to true for property 'Filterable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Filterable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:342 Property Warning: Unspecified Nullable facet defaults to true for property 'RequiresFilter'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"RequiresFilter\" Type=\"Edm.Boolean\" DefaultValue=\"false\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:355 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:408 Property Warning: Unspecified Nullable facet defaults to true for property 'Sortable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Sortable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:426 Property Warning: Unspecified Nullable facet defaults to true for property 'Expandable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Expandable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:432 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:442 Property Warning: Unspecified Nullable facet defaults to true for property 'Searchable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Searchable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:445 Property Warning: Unspecified Nullable facet defaults to true for property 'UnsupportedExpressions'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"UnsupportedExpressions\" Type=\"Capabilities.SearchExpressions\" DefaultValue=\"none\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:481 Property Warning: Unspecified Nullable facet defaults to true for property 'Insertable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Insertable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:487 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:498 Property Warning: Unspecified Nullable facet defaults to true for property 'Supported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:501 Property Warning: Unspecified Nullable facet defaults to true for property 'ContentIDSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ContentIDSupported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:511 Property Warning: Unspecified Nullable facet defaults to true for property 'Updatable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Updatable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:517 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:527 Property Warning: Unspecified Nullable facet defaults to true for property 'Deletable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Deletable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:533 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:546 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterFunctions'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:559 Property Warning: Unspecified Nullable facet defaults to true for property 'TopSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"TopSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:562 Property Warning: Unspecified Nullable facet defaults to true for property 'SkipSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SkipSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:565 Property Warning: Unspecified Nullable facet defaults to true for property 'Insertable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Insertable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:568 Property Warning: Unspecified Nullable facet defaults to true for property 'Updatable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Updatable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:571 Property Warning: Unspecified Nullable facet defaults to true for property 'Deletable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Deletable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:182 Property Warning: Unspecified Nullable facet defaults to true for property 'Id'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Id\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:185 Property Warning: Unspecified Nullable facet defaults to true for property 'UrlTemplate'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"UrlTemplate\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:232 Property Warning: Unspecified Nullable facet defaults to true for property 'Navigability'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Navigability\" Type=\"Capabilities.NavigationType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:240 Property Warning: Unspecified Nullable facet defaults to true for property 'NavigationProperty'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"NavigationProperty\" Type=\"Edm.NavigationPropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:243 Property Warning: Unspecified Nullable facet defaults to true for property 'Navigability'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Navigability\" Type=\"Capabilities.NavigationType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:250 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterRestrictions\" Type=\"Capabilities.FilterRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:253 Property Warning: Unspecified Nullable facet defaults to true for property 'SearchRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:256 Property Warning: Unspecified Nullable facet defaults to true for property 'SortRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SortRestrictions\" Type=\"Capabilities.SortRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:268 Property Warning: Unspecified Nullable facet defaults to true for property 'InsertRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"InsertRestrictions\" Type=\"Capabilities.InsertRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:271 Property Warning: Unspecified Nullable facet defaults to true for property 'DeepInsertSupport'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"DeepInsertSupport\" Type=\"Capabilities.DeepInsertSupportType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:275 Property Warning: Unspecified Nullable facet defaults to true for property 'UpdateRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"UpdateRestrictions\" Type=\"Capabilities.UpdateRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:278 Property Warning: Unspecified Nullable facet defaults to true for property 'DeleteRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"DeleteRestrictions\" Type=\"Capabilities.DeleteRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:361 Property Warning: Unspecified Nullable facet defaults to true for property 'Property'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Property\" Type=\"Edm.PropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:364 Property Warning: Unspecified Nullable facet defaults to true for property 'AllowedExpressions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"AllowedExpressions\" Type=\"Capabilities.FilterExpressionType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:543 Property Warning: Unspecified Nullable facet defaults to true for property 'CollectionProperty'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"CollectionProperty\" Type=\"Edm.PropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:550 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterRestrictions\" Type=\"Capabilities.FilterRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:553 Property Warning: Unspecified Nullable facet defaults to true for property 'SearchRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:556 Property Warning: Unspecified Nullable facet defaults to true for property 'SortRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SortRestrictions\" Type=\"Capabilities.SortRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:86 Property Warning: Unspecified Nullable facet defaults to true for property 'Version'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Version\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:89 Property Warning: Unspecified Nullable facet defaults to true for property 'Kind'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Kind\" Type=\"Core.RevisionKind\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:92 Property Warning: Unspecified Nullable facet defaults to true for property 'Description'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Description\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:344 Property Warning: Unspecified Nullable facet defaults to true for property 'Name'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Type=\"Edm.PropertyPath\" Name=\"Name\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:348 Property Warning: Unspecified Nullable facet defaults to true for property 'Alias'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Type=\"Edm.String\" Name=\"Alias\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:371 Property Warning: Unspecified Nullable facet defaults to true for property 'DefaultValue'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"DefaultValue\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml:92 Property Warning: Unspecified Nullable facet defaults to true for property 'Value'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Value\" Type=\"Edm.PrimitiveType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml:128 Property Warning: Unspecified Nullable facet defaults to true for property 'path'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"path\" Type=\"Edm.NavigationPropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml:131 Property Warning: Unspecified Nullable facet defaults to true for property 'target'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"target\" Type=\"Edm.NavigationPropertyPath\">...\n\n### Proposal\n\nCheck all the above, determine correct facet(s), and apply appropriate facets explicitly to all standard vocabularies.\n\n \n\nImported from [ODATA-1193](https://issues.oasis-open.org/browse/ODATA-1193)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Capabilities vocabulary: invalid DefaultValue for KeyAsSegmentSupported",
    "body": "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:470 Term Error: Cannot parse default value 'True' of type 'Org.OData.Core.V1.Tag'.\n<Term Name=\"KeyAsSegmentSupported\" Type=\"Core.Tag\" DefaultValue=\"True\" AppliesTo=\"EntityContainer\">...\n\n \n\n### Proposal\n\nChange default value from 'True' to 'true'.\n\n \n\nImported from [ODATA-1192](https://issues.oasis-open.org/browse/ODATA-1192)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Make sure that all model elements are annotatable",
    "body": "Annotations were initially designed as a way that we could extend metadata without introducing breaking changes. However, there are cases where model elements are not annotatable, which limits our ability to extend those elements.\n\nFor example, OData-1187 proposes extending navigation property bindings to specify that a particular path is recursive. We'd like to do this as an annotation, to avoid introducing an incompatability with 4.0, but NavigationPropertyBinding elements are (currently) not annotatable.\n\nWe should go through our model elements to identify those that are not currently annotatable, and see if we can come up with a way to make everything annotatable.\n\nHubert had some thoughts about making it easier to annotate model elements in our JSON format.\n\n### Proposal\n\nClose without action, see comment on the small number of non-annotatable model elements and the rationale for that\n\nImported from [ODATA-1191](https://issues.oasis-open.org/browse/ODATA-1191)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add matchesPattern as a $filter function",
    "body": "\n\n### Proposal\n\nAdd matchesPattern as a $filter function:\n\n \n\nEdm.Boolean matchesPattern(Edm.String,Edm.String)\n\n \n\nThe matchesPattern function returns true if the second parameter string value evaluates to a [*[ECMAScript]*](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#ECMAScript) (JavaScript) regular expression and the result of the first argument string matches that regular expression, using syntax and semantics of [*[ECMAScript]*](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#ECMAScript) regular expressions, otherwise it returns false.\n\nImported from [ODATA-1190](https://issues.oasis-open.org/browse/ODATA-1190)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Conformance: Nullable for collections",
    "body": "Chapter 17 Conformance states:\n\n12.  SHOULD specify the [Nullable](http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/cs01/odata-csdl-json-v4.01-cs01.html#sec_Nullable) facet for collections\n\nThis makes sense in CSDL XML where Nullable defaults to true and collections weren't considered initially.\n\nIn CSDL JSON $Nullable defaults to false for single- and collection-valued properties, so no need to state \n\n### Proposal\n\nRemove conformance statements in CSDL JSON, keep it only in CSDL XML\n\n12.  SHOULD specify the [Nullable](http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/cs01/odata-csdl-json-v4.01-cs01.html#sec_Nullable) facet for collections\n\n14.  MUST specify the [Nullable](http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/cs01/odata-csdl-json-v4.01-cs01.html#sec_Nullable) facet for collections\n\n \n\n \n\nImported from [ODATA-1189](https://issues.oasis-open.org/browse/ODATA-1189)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow using instance annotations in $select and $expand",
    "body": "We already allow using instance annotations in $filter, $orderby, and $compute:\n```\nGET Stuff?$filter=@Core.Messages/any(m:m/severity eq 'error')\n```\n\nThis indirectly allows using instance annotations in $select and $expand:\n```\nGET Stuff?$compute=@Core.Messages as _at_Core_dot_Messages\n         &$select=*,_at_Core_dot_Messages($top=5)\n```\n\nWhich is kind of ugly and loses the canonical name of the instance annotation\n\n\n\n### Proposal\n\nAllow using instance annotations of type (collection of) primitive or complex in $select and instance annotations of type (collection of) entity in $expand.\n\nExample\n```java\nGET Stuff?$select=@Core.Messages($top=5)\n```\nServices can signal this capability to clients with the tagging term `Capabilities.AnnotationValuesInQuerySupported`.\n```xml\n<Term Name=\"AnnotationValuesInQuerySupported\" Type=\"Core.Tag\" DefaultValue=\"True\"\n      Nullable=\"false\" AppliesTo=\"EntityContainer\">\n    <Annotation Term=\"Core.Description\" \n                String=\"Supports annotation values within system query options\" />\n</Term>\n```\n\nAnnotations in $select must be included in response and take precedence over preference header; if $select says to include, and preference says omit, it's still included. preference header can add additional annotations to what is specified in $select.\n\nIn the presence of both include-annotations preference and annotations selected in $select, then preference-applied, if present, reflects the set of annotations added by the preference-applied (not by $select). In the absence of the include-annotations preference header, there should not be an include-annotations in the preference applied.\n\nExplicitly selected (expanded) annotations must appear in the contextUrl as other properties. It is possible to select only annotations, in which case only those selected (expanded) navigations appear in the result. Note that annotations specified in include-annotations do not appear in the context Url, and do not affect the selected/expanded properties.\n\nIt is not valid to $select an entity-valued annotation (because we do not currently define a canonical navigation url for an entity-valued annotation). entity-valued annotations can be included using $expand.\n\nIf the annotation isn't applied to the instance, a null value is returned (same as for dynamic properties).\n\nNote that selecting control information (@odata.type, @odata.navigationLink, etc.) is not allowed.\n\nImported from [ODATA-1188](https://issues.oasis-open.org/browse/ODATA-1188)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "No way to bind nav prop on recursively nested (contained or complex) type",
    "body": "While we are able to bind nav props on nested complex or contained types at an arbitrary level by specifying the path, it's not possible to recursively bind nested nav props.\n Consider the following complex type, containing a navigation property to Country, used within a Customer:\n```xml\n<ComplexType Name=\"Address\">\n  <Property Name=\"PreviousAddress\" Type=\"self.Address\" Nullable=\"true\"/>\n  <NavigationProperty Name=\"Country\" Type=\"self.Country\"/>\n</ComplexType>```\nWe can bind the Country nav on the Address of a Customer:\n```xml\n<EntitySet Name=\"Customers\" EntityType=\"self.Customer\">\n  <NavigationPropertyBinding Path=\"Address/Country\" Target=\"Countries\" />\n</EntitySet>\n```\nWe could also bind the Country on the previous address property of the address of a customer:\n```xml\n<EntitySet Name=\"Customers\" EntityType=\"self.Customer\">\n  <NavigationPropertyBinding Path=\"Address/Country\" Target=\"Countries\" />\n  <NavigationPropertyBinding Path=\"Address/PreviousAddress/Country\" Target=\"Countries\" />\n</EntitySet>\n```\nAnd so on…\n```xml\n<EntitySet Name=\"Customers\" EntityType=\"self.Customer\">\n  <NavigationPropertyBinding Path=\"Address/Country\" Target=\"Countries\" />\n  <NavigationPropertyBinding Path=\"Address/PreviousAddress/Country\" Target=\"Countries\" />\n  <NavigationPropertyBinding Path=\"Address/PreviousAddress/PreviousAddress/Country\" Target=\"Countries\" />\n  ...\n</EntitySet>\n```\nWhat is lacking is a way to specify that all countries returned by the PreviousAddress navigation property (recursively) are contained in a particular entity set.\n The same issue existings if Address is a contained navigation property.\n\n### Proposal\n\nClients can typically assume that binding a recursive navprop path binds recursively.  If we need to later, we can add an entityset/singleton annotation to say it doesn't.\n\nImported from [ODATA-1187](https://issues.oasis-open.org/browse/ODATA-1187)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify names that can appear in annotation of term ApplySupported/Transformations",
    "body": "The list of transformation names in section 6.1 is incomplete.\n\n### Proposal\n\nInstead of explicitly listing the names of all transformations, which are known at the time of writing, refer to them indirectly. Replace the sentence in the first point of section 6.1 with: Allowed values are the names of the standard transformations introduced in section 3 or ...\n\nImported from [ODATA-1186](https://issues.oasis-open.org/browse/ODATA-1186)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Extend transformation nest to multiple sequences",
    "body": "Currently, nest can be used to create an entity with a single containment navigation property holding the result of a transformation sequence:\n\n`nest( cnp, t )` returns\n```java\n[{ <cnp>: [ <result of t applied to input set> ] }]```\nThere are use cases to generalize this and nest the results of _multiple_ transformation sequences at once. Consider, for example, a request to combine the results of two transformations in a single response. Using transformation concat requires an extra computation of a concat index to relate an entity in the result to the corresponding concat argument (see [ODATA-1138](https://issues.oasis-open.org/browse/ODATA-1138)):\n\n`GET ~/Sales?$apply=concat(`\n `   filter(<complex expression 1>)`\n `   ``/groupby((Customer),aggregate(Amount with sum as Total))/compute(1 as concat_index),`\n `   filter(<complex expression 2>)`\n `   /groupby((Customer),aggregate(Amount with sum as Total))/compute(2 as concat_index))`\n\n \n\nIf it makes sense to keep the results of the two transformations separately, they could be retrieved via an extended syntax of the transformation nest:\n\n`GET ~/Sales?$apply=nest(`\n `   filter(<complex expression 1>)`\n `   /groupby((Customer),aggregate(Amount with sum as Total)) as part_1,`\n `   filter(<complex expression 2>)`\n `   /groupby((Customer),aggregate(Amount with sum as Total)) as part_2)`\n\n \n\n### Proposal\n\nThe nest transformation takes a comma-separated list of one or more nest expressions as parameters. A nest expression is a sequence of set transformations followed by a SimpleIdentifier, called an alias (see [OData-CSDL, section 17.2]). This alias MUST NOT collide with names of properties in the input set or with other aliases introduced in the same nest transformation.\n\nThe result set consists of a single entity having one dynamic property per nest expression. The name of the added property is the alias following the as keyword. The value of the property is the result collection of the transformation sequence in the nest expression applied to the input set:\n\n`nest( t_1 as cnp_1, ..., t_N as cnp_N )` returns\n```java\n[{ <cnp_1>: [ <result of t_1 applied to input set> ],\n  ...\n  <cnp_N>: [ <result of t_N applied to input set> ]\n}]\n```\n\nImported from [ODATA-1185](https://issues.oasis-open.org/browse/ODATA-1185)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow Singletons to be null",
    "body": "Properties of the Service Document are described by Singletons and EntitySets.\nWhile it is possible to have an empty EntitySet.  It is not currently possible to have an empty (i.e. null) Singleton.  So for a given service document, implementations are required to minimally populate all singletons, regardless of whether or not the implementation actually has a value for that property.\n\n\n### Proposal\n\nThe proposal is to allow a Singleton to be specified as Nullable.\n\nIn clause 13.3 Singleton, add:\n\n*Attribute Nullable*\n The value of Nullable is one of the Boolean literals true or false. Absence of the attribute means false. A value of true specifies that the declaring Singleton MAY have no related entity. If false, instances of the declaring Singleton MUST always have a related entity.\n\nBehavior:\n For 4.01 responses:\n -services return \"nullable\":true for nullable singleton in JSON. absence means not-nullable, as with all other nullable facets in JSON.\n -services return \"nullable=true\" for nullable singleton in XML. Absence of this attribute means not-nullable. note that this is the opposite default as for single-valued navigation properties.\n -services return 204, No Content, for null-valued singletons (just as for null-valued singleton navigation properties).\n For 4.0 responses:\n -services must return \"nullable\":false, or omit the nullable facet, for a singleton in JSON\n -services must not return the nullable attribute for a singleton in XML\n -services must return a representation of the singleton (i.e., an object with only a context Url) or an error (such as 404).\n\nImported from [ODATA-1183](https://issues.oasis-open.org/browse/ODATA-1183)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that transformation topcount keeps the order of the input set",
    "body": "For all transformations topXXX and bottomXXX except topcount it has been specified that they do not change the order of the instances in the input set.\n\n### Proposal\n\nExtend definition of topcount by the statement that it does not change the order of the instances in the input set.\n\nImported from [ODATA-1182](https://issues.oasis-open.org/browse/ODATA-1182)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify $expand=NavSingle/$count and $expand=*/$count",
    "body": "Section 4.8 only defines the /$count segment for collection-valued paths.\n\nSection 5.1.2 does not state a restriction to collection-valued navigation properties for $expand=NavProp/$count and similar paths.\n\nWe could allow /$count for all kinds of paths, returning 1 for single-valued navigation paths to an existing resource, and returning 0 for single-valued navigation paths that would return 204 or 404 without the /$count suffix.\n\nBuilding on that $expand=*/$count could be defined to return the count of related entities for all navigation properties.\n\n### Proposal\n\nWe don't want to allow these requests and their consequences for expressions in general\n\nImported from [ODATA-1181](https://issues.oasis-open.org/browse/ODATA-1181)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Cast between enumeration types and integer types",
    "body": "Enumeration members have an explicit or (only in CSDL XML) implicit numeric value.\n\nSorting and comparison of enumeration members is based in this numeric value.\n\nUnfortunately casting between enumeration types and integer types is not yet defined.\n\n### Proposal\n\nCasting between enumeration types and integer types (of sufficient width) is possible based on the numeric value.\n\nThis cast MUST be explicit, using the cast() function in URLs or the cast expression in CSDL.\n\nCall this out in URL Conventions, section 5.1.1.10.1 [cast](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_cast).\n\nPreferred wording: Services MAY support casting enumeration members to the underlying numeric values using the explicit cast function.\n\nImported from [ODATA-1180](https://issues.oasis-open.org/browse/ODATA-1180)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Enhance orderby $apply-transformation with sorting of undefined properties",
    "body": "Extend $orderby expressions accepted by the orderby transformation with the option to specify how to sort undefined properties.\n\n\nIn general, the demand for being able to specify the position of entities with undefined properties emerges from combining transformation sequences using concat or by applying groupby(rollup(...), ...). A concrete use case is described in more detail in https://www.oasis-open.org/committees/document.php?document_id=62593&wg_abbrev=odata.\n\n### Proposal\n\nDetails are described in the document “Grid-Like Access to Aggregated Data”, sections 4 and 8.1: [https://www.oasis-open.org/committees/document.php?document_id=62593&wg_abbrev=odata]\n\nExcerpt from relevant section 8.1: Extend the expressions that can be passed to the orderby transformation by an optional suffix that, if specified, determines the position of undefined values of properties that have been aggregated away:\n\nWith orderby( <orderbyItem> undefined first ) undefined values of the orderby item come before any defined value. The order among the undefined values is undefined.\n\nWith orderby( <orderbyItem> undefined last ) undefined values of the orderby item come after any defined value. The order among the undefined values is undefined.\n\nImported from [ODATA-1179](https://issues.oasis-open.org/browse/ODATA-1179)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "External targeting for action/function overloads",
    "body": "Section [14.2.2 Target](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#sec_Target) describes which model elements can be annotated via external targeting.\n\nCurrently actions and functions can only be summarily targeted, i.e. the (external) annotation applies to all overloads.\n\n### Proposal\n\nAllow external targeting of individual action/function overload with syntax similar to action/function advertisement in JSON data by optionally appending the overload signature to the action/function name.\n\nThe signature consists of parentheses containing\n- for unbound actions: nothing, just the parentheses\n- for bound actions: the name of the first (binding) parameter type\n- for functions: the comma-separated ordered list of parameter types (including the binding parameter type at the first position for bound overloads)\n\n \n\nExamples:\n```java\nMySchema.MyAction(MySchema.BindingParameterType)\nMySchema.MyFunction(MySchema.BindingParameterType,First.NonBinding.ParameterType,Second.NonBinding.ParameterType)\n```\n\nImported from [ODATA-1178](https://issues.oasis-open.org/browse/ODATA-1178)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Embed \"JSON properties\" in OData JSON requests and responses",
    "body": "Allow defining \"JSON properties\" in OData models, i.e. properties whose value is well-formed JSON, see [OData Extension for JSON Data](https://www.oasis-open.org/committees/download.php/46559/OData%20Extension%20for%20JSON%20Data%20v1.0.doc).\n\nRequirements:\n1. JSON property values are represented \"inline\" in JSON responses, i.e. `\"JSONproperty\":` _<well-formed JSON data>_\n1. Common expressions (e.g. in `$filter)` can address parts of JSON data\n1. JSON properties can specify a JSON Schema that describes/restricts their data values\n\nThis issue addresses the first requirement. The other requirements are addressed in [ODATA-1275](https://issues.oasis-open.org/browse/ODATA-1275)\n\n \n\n### Proposal\n\n\"JSON properties\" are represented in metadata as properties of type `Edm.Stream`, which may be annotated with the existing annotation `Core.AcceptableMediaTypes`, listing `application/json` to specify that the stream property contains JSON.\n\nStreams that are annotated as the `application/json` media type (or one of its subtypes, optionally with format parameters) through `@mediaContentType` instance annotation are represented as native JSON in JSON requests and responses, they are NOT represented as a base64url-encoded string values. (Note: this is similar to what we  do in the [JSON Batch format](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_BatchRequestsandResponses) for JSON request and response bodies.). The `odata.mediaContentType` control information is only necessary if the embedded JSON happens to be a JSON string, in all other cases it can be heuristically determined that the stream value is JSON. For dynamic JSON properties represented with inline JSON value the `odata.mediaContentType` control information is always necessary to distinguish them from dynamic Edm.Untyped properties.\n\nThe term `Core.AutoExpand` is extended to also apply to (stream) properties, enabling \"JSON properties\" to be implicitly expanded by the service if it is contained in a JSON response. Auto-expanded \"JSON properties\" MAY be part of the default selection, i.e. represented inline if no `$select` query option is specified.\n\nImported from [ODATA-1177](https://issues.oasis-open.org/browse/ODATA-1177)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Capabilities: add new term SelectSupport",
    "body": "Similar to other xxxRestrictions add a SelectRestrictions structured term with (for now) a single property Selectable of type Boolean:\n\nExample:\n```xml\n<Annotation Term=\"Capabilities.SelectRestrictions\">\n  <Record>\n    <PropertyValue Property=\"Selectable\" Bool=\"false\" />\n  </Record>\n </Annotation>```\n\n### Proposal\n\nTerm definition:\n```xml\n<Term Name=\"SelectSupport\" Type=\"Capabilities.SelectSupportType\" Nullable=\"false\" AppliesTo=\"EntityContainer EntitySet Singleton\">\n  <Annotation Term=\"Core.Description\" String=\"Support for $select and nested query options within $select\" />\n</Term>\n<ComplexType Name=\"SelectSupportType\">\n  <Property Name=\"Supported\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"true\">\n    <Annotation Term=\"Core.Description\" String=\"Supports $select\" />\n  </Property>\n  <Property Name=\"Expandable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$expand within $select is supported\" />\n  </Property>\n  <Property Name=\"Filterable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$filter within $select is supported\" />\n  </Property>\n  <Property Name=\"Searchable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$search within $select is supported\" />\n  </Property>\n  <Property Name=\"TopSupported\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$top within $select is supported\" />\n  </Property>\n  <Property Name=\"SkipSupported\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$skip within $select is supported\" />\n  </Property>\n  <Property Name=\"ComputeSupported\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$compute within $select is supported\" />\n  </Property>\n  <Property Name=\"Countable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$count within $select is supported\" />\n  </Property>\n  <Property Name=\"Sortable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$orderby within $select is supported\" />\n  </Property>\n</ComplexType>\n```\n \n\nAlso add corresponding property `SelectSupport` to `CollectionPropertyRestrictionsType` and `NavigationPropertyRestrictionsType`.\n\nImported from [ODATA-1176](https://issues.oasis-open.org/browse/ODATA-1176)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Capabilities: allow UpdateRestrictions also for singletons",
    "body": "Modeling a read-only singleton is more straight-forward than modeling a parameterless function and a function import.\n\nAlso the update restriction may be compatibly relaxed in a later schema version, whereas switching from a function+import to a singleton is an incompatible change.\n\nImported from [ODATA-1175](https://issues.oasis-open.org/browse/ODATA-1175)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON CSDL should not require nullable attribute for collections",
    "body": "The conformance section for JSON CSDL includes the requirement that the metadata must specify the nullable attribute for collections. This was inherited from XML CSDL because the default of nullable=true was wrong for collections.\n\nFor JSON CSDL, the default for nullable is false, which makes sense for collections as well, and should not have to be specified.\n\nImported from [ODATA-1174](https://issues.oasis-open.org/browse/ODATA-1174)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "14.4.11: Description of Null",
    "body": "14.4.11 Null says:\nThe null expression returns an untyped null value. The null expression MAY be annotated. The null expression MUST be written with element notation. \n\nTwo issues:\n1) Null relates only to the absence of value, for whatever type of the associated property, parameter, or return.\n\n### Proposal\n\nChange to:\nThe null expression indicates the absence of value.   The null expression MAY be annotated. The null expression MUST be written with element notation.\n\nImported from [ODATA-1173](https://issues.oasis-open.org/browse/ODATA-1173)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "4.5.3: use $schemaversion query option instead of SchemaVersion header",
    "body": "Section 4.5.3 Control Information: type (odata.type) still refers to the SchemaVersion request header that has been replaced with a $schemaversion system query option with [ODATA-994](https://issues.oasis-open.org/browse/ODATA-994).\n\n### Proposal\n\nCurrent text:\n----\nIf the URI references a metadata document (that is, it’s not just a fragment), and refers to a specific version of that metadata, then the object or name/value pair MUST also be annotated with the Core.SchemaVersion annotation, defined in [OData-VocCore], to indicate the version of the metadata document containing the corresponding version of the type. For streamed JSON responses, this annotation MUST immediately follow the type annotation. If the Core.SchemaVersion annotation is present, the Core.SchemaVersion header, defined in [OData-Protocol], SHOULD be used when retrieving the referenced metadata document.\n----\n\nChange to\n----\nIf the URI references a metadata document (that is, it’s not just a fragment), it MAY refer to a specific version of that metadata document using the $schemaversion system query option defined in [OData-Protocol].\n----\n\nThat is: no need for an additional annotation with Core.SchemaVersion, just follow the @odata.type URL.\n\nImported from [ODATA-1172](https://issues.oasis-open.org/browse/ODATA-1172)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consider using matrix parameters for filter segments",
    "body": "In 4.01 CS01, we introduced the ability to insert a filter into a path using a special \"filter path segment\" of the form \n\n   Customers/$filter=@q/myns.action?$@q=Age gt 18\n\n(see https://issues.oasis-open.org/browse/[ODATA-836](https://issues.oasis-open.org/browse/ODATA-836))\n\nIt turns out, the facility to append parameter information to a segment was considered over 20 years ago by Tim Berners-Lee using \"matrix parameters\" (http://www.w3.org/DesignIssues/MatrixURIs.html) -- basically, a matrix parameter is a way to add parameters to a path segment as a series of key-value pairs separated from the path segment with a semi-colon.\n\n4.01 CS01 syntax:\n   Customers/$filter=@q?$@q=name eq 'Smith'\nMatrix parameter syntax:\n   Customers;$filter=@q?$@q=name eq 'Smith'\n\nAdvantages of using matrix parameters:\n1) No possible ambiguity with key-as-segment\n2) Not inventing something new\n3) May already be supported by some systems\n\n\nImported from [ODATA-1171](https://issues.oasis-open.org/browse/ODATA-1171)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow @odata.type for isomorphy to CSDL XML",
    "body": "The XML representation of <EnumMember> constant expressions contains the enumeration type name of the enumeration value as a prefix:\n```xml\n<Annotation Term=\"Namespace1_Alias.TermEnum\">\n  <EnumMember>Namespace1_Alias.ENString/String1 Namespace1_Alias.ENString/String3</EnumMember>\n</Annotation>```\nThe JSON representation does not contain the type name:\n```\n\"@com.odata.v4.technical.scenario.TermEnum\": \"String1,String3\"\n```\nThis breaks isomorphy between XML and JSON representation of CSDL.\n\nThe JSON representation was explicitly chosen without type prefix to mirror the JSON Format representation of enumeration values in data payloads.\n\nAllowing an @odata.type control information would both be consistent with JSON Format and establish isomorphy to CSDL XML:\n```\n\"@com.odata.v4.technical.scenario.TermEnum@odata.type\": \"#Namespace1_Alias.ENString\",\n\"@com.odata.v4.technical.scenario.TermEnum\": \"String1,String3\"\n```\nThis should be optional in the normal case, required if you can't deduce the type; (i.e., if the term cannot be resolved for some reason or the type of the term is Edm.Untyped), as in the data payload.\n\n### Proposal\n\nRe-opened 2018-9-27 and revised proposal:\n\nWithin a $metadata document, control information (notably, @odata.type) is used in the same cases it would be used in a standard odata json response:\n\n1) in no metadata, no control information is returned\n\n2) in minimal metadata, control information (@odata.type) is returned for values whose type cannot be determined from metadata and cannot be heuristically determined \n\n3) in full metadata, control information (@odata.type) must be returned for all types that cannot be heuristically determined (including entity or complex types)\n\nImported from [ODATA-1170](https://issues.oasis-open.org/browse/ODATA-1170)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Transformation for nesting the result of another transformation within a single entity",
    "body": "This new feature is motivated by a concrete use case. The current version of the Data Aggregation specification already includes an example for a cross-table and describes how to retrieve its data using transformation groupby in combination with rollup. However, this data is returned as linear collection of entities. For working with data in a grid efficiently, it must be possible to access selected sections of the grid. Details are described in the document “Grid-Like Access to Aggregated Data”, sections 2 and 3: [https://www.oasis-open.org/committees/document.php?document_id=62593&wg_abbrev=odata]\n\n### Proposal\n\nAn OData representation of a grid-like result spanned by multiple axes could be achieved by a new transformation `nest()` that allows to embed data of grid cells as a nested collection of entities representing grid rows. \n\nRelevant excerpt from section 3 in the referenced document: The `nest` transformation has two parameters. The first takes the name of a dynamic containment navigation property, the second is a (chain of) $apply transformations. `nest( cnp, t )` applies transformation chain t to the input set and creates a result set containing a single entity that only contains the navigation property `cnp`, which in turn holds the result collection of t applied to the input set:\n\n\n```json\n{ <cnp>: [ <result of t applied to input set> ] }\n```\n\n\nImported from [ODATA-1169](https://issues.oasis-open.org/browse/ODATA-1169)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify the use of ETags for Avoiding Update Conflicts",
    "body": "[http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part1-protocol/odata-v4.0-errata03-os-part1-protocol-complete.html#_Data_Modification] states:\n\n11.4.1.1 Use of ETags for Avoiding Update Conflicts\n If an ETag value is specified in an If-Match or If-None-Match header of a Data Modification Request or Action Request, the operation MUST only be invoked if the if-match or if-none-match condition is satisfied.\n\nThe ETag value specified in the if-match or if-none-match request header may be obtained from an ETag header of a response for an individual entity, or may be included for an individual entity in a format-specific manner.\n\nIssue requiring clarification: we carefully need to distinguish between OData’s meaning of “entity = an instance of an entity type\" and HTTP’s meaning of “entity = the thing whose representation is transferred”. ETags (= entity tags) refer to the HTTP meaning, and thus links/references/relationships are “HTTP entities” that can have their own ETags.\n\nAlso clarify:\n- Can a \"HTTP entity\" / \"link entity\" identified by `xxx/$ref` have an ETag?\n- Is the ETag of a \"link entity\" logically independent of the ETags of the linked OData entities at either end?\n- If `xxx` is a collection resource, can the references returned by `GET xxx/$ref` contain `@odata.etag` control information to carry the individual ETag of each \"link entity\"?\n- Are `EntitySet/$ref` and `EntitySet(<key>)/$ref` only accidentally allowed by the ABNF and the prose text in [Protocol 11.2.8: Requesting Entity References](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingEntityReferences) or are these valid resource paths?\n\n### Proposal\n\nMake clear that EntityCollection/$ref and SingleEntity/$ref are intentionally allowed to return an ETag.\n\nEntityCollection/$ref (where EntityCollection is an entity set or collection-valued navigation path) may have an (own) ETag returned in the ETag header which changes if the list of references changes, i.e. a reference is added or removed.\n\nSingleNavigation/$ref (where SingleNavigation is a single-valued navigation path) may have an ETag which represents the identity of the related entity. If the relationship is changed to point to a different OData entity, the ETag MUST change.\n\nNote: the ETag for an entity reference (i.e. EntitySet(key)/$ref) can never change.\n\nIn JSON, if an object contains an etag (or other control information other than type) then it is a representation of the object, not an entity reference. \n\nso:\n{\"@id\":\"people(1)\"} \nis an entity reference to the resource in the people entity set with the key value 1, where:\n{\"@id\":\"people(1)\",\"@etag\":\"xyz123\"} \nis a minimal representation of the resource (not the reference), just as\n{\"@id\":\"people(1)\",\"name\":\"maggie\"}\nis a minimal representation of the resource.\nSo, if \n{\"@id\":\"people(1)\",\"@etag\":\"xyz123\"} \nis returned, the etag refers to the person (and not the reference) and changes if any properties of the person changes.\n\nImported from [ODATA-1168](https://issues.oasis-open.org/browse/ODATA-1168)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add way to specify which batch formats (if any) are supported by a service",
    "body": "We have annotation terms to specify supported data types and metadata types, but we don't have an annotation term to specify supported batch formats.\n\nThis is particularly important for batch because the client can't just specify an accept header for all formats that it supports, it needs to know what format to send the batch request.\n\nWe could support this by defining a top-level SupportedBatchFormats, along alongside SupportedFormats and SupportedMetadataFormats, or we could put this on our BatchSupportType\n\n### Proposal\n\nAdd a SupportedFormats property to the BatchSupportType:\n\n```xml\n<Property Name=\"SupportedFormats\" Type=\"Collection(Edm.String)\" Nullable=\"false\">\n  <Annotation Term=\"Core.Description\" String=\"Media types of supported formats for $batch\" />\n  <Annotation Term=\"Core.IsMediaType\" />\n  <Annotation Term=\"Validation.AllowedValues\">\n    <Collection>\n      <Record>\n        <PropertyValue Property=\"Value\" String=\"multipart/mixed\" />\n        <Annotation Term=\"Core.Description\"\n          String=\"Multipart Batch Format, see http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_MultipartBatchFormat\" />\n      </Record>\n      <Record>\n        <PropertyValue Property=\"Value\" String=\"application/json\" />\n        <Annotation Term=\"Core.Description\"\n          String=\"JSON Batch Format, see http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_BatchRequestsandResponses\" />\n      </Record>\n    </Collection>\n  </Annotation>\n</Property>\n```\n\nImported from [ODATA-1167](https://issues.oasis-open.org/browse/ODATA-1167)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Update JSON references to RFC8259",
    "body": "https://tools.ietf.org/html/rfc8259 obsoletes https://tools.ietf.org/html/rfc7159\n\n### Proposal\n\nUpdate normative references\n\nImported from [ODATA-1166](https://issues.oasis-open.org/browse/ODATA-1166)",
    "labels": [
      "CSDL JSON",
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Describe $compute, $expand, and $select via prose text and examples, remove ABNF snippets",
    "body": "Sections 5.1.2 $expand and 5.1.3 $select currently start with ABNF snippets and then explain allowed constructs via prose text and examples.\n\nUnfortunately the ABNF is incorrectly restrictive in some places, see [ODATA-1155](https://issues.oasis-open.org/browse/ODATA-1155), as well as overly lax on other places.\n\n### Proposal\n\nRemove ABNF snippets and make sure that prose text and examples cover all valid alternatives.\n\nFor $compute:\n> The value of $compute is a comma-separated list of compute instructions, each consisting of an expression followed by the keyword as, followed by the name for of computed dynamic property. This name MUST differ from the names of declared or other dynamic properties of the identified resources.\n> \n\ninstead of\n> Following is a (non-normative) snippet from [OData-ABNF] showing the syntax of $compute:\n>  compute = '$compute' EQ computeItem *( COMMA computeItem )\n>  computeItem = commonExpr RWS 'as' RWS computedProperty\n>  computedProperty = odataIdentifier\n> \n\n \n\nFor $expand:\n> The value of $expand is a comma-separated list of expand items. Each expand item is evaluated relative to the retrieved resource being expanded. An expand item is either a path or one of the symbols * or $value.\n> \n> A path consists of segments separated by a forward slash ( / ). Segments are either names of single- or collection-valued complex properties, or type-cast segments consisting of the qualified name of a structured type that is derived from the type identified by the preceding path segment to reach properties defined on the derived type.\n> \n> A path can end with\n> - the name of a stream property to include that stream property,\n> - a star ( * ) to expand all navigation properties of the identified structured instance, optionally followed by /$ref to expand only entity references, or\n> - a navigation property to expand the related entity or entities, optionally followed by a type-cast segment to expand only related entities of that derived type or one of its sub-types.\n> \n\n\ninstead of\n> expand            = '$expand' EQ expandItem *( COMMA expandItem )\n> \n> expandItem        = STAR [ ref / OPEN levels CLOSE ]\n>                    / \"$value\"\n>                    / expandPath\n>                      [ ref   [ OPEN expandRefOption   \n>                             *( SEMI expandRefOption   ) CLOSE ]\n>                      / count [ OPEN expandCountOption\n>                             *( SEMI expandCountOption ) CLOSE ]\n>                      /         OPEN expandOption\n>                             *( SEMI expandOption      ) CLOSE \n>                      ]\n> \n> expandPath        = [ ( qualifiedEntityTypeName\n>                        / qualifiedComplexTypeName \n>                        ) \"/\" ] \n>                      *( ( complexProperty / complexColProperty ) \"/\" \n>                         [ qualifiedComplexTypeName \"/\" ] )\n>                      ( STAR \n>                      / streamProperty\n>                      / navigationProperty [ \"/\" qualifiedEntityTypeName ]\n>                      )\n> \n> expandCountOption = filter\n>                    / search\n> \n> expandRefOption   = expandCountOption\n>                    / orderby\n>                    / skip \n>                    / top \n>                    / inlinecount\n> \n> expandOption      = expandRefOption\n>                    / select \n>                    / expand\n>                    / compute\n>                    / levels\n>                    / aliasAndValue\n> \n\nNote: all other optional segments are covered in the existing text, intermingled with examples\n\nFor $select:\n> \n> The value of $select is a comma-separated list of select items. Each select item is either a path, a qualified schema name followed by a dot ( . ) and a star ( * ), or just a star ( * ).\n> A path consists of segments separated by a forward slash ( / ). Segments are either names of single- or collection-valued complex properties, or type-cast segments consisting of the qualified name of a structured type that is derived from the type identified by the preceding path segment to reach properties defined on the derived type.\n> A path can end with\n> - the name of a structural property of the identified structured instance,\n> - the name of a navigation property to request navigation links,\n> - the qualified name of a bound action,\n> - the qualified name of a bound function to include all matching overloads, or\n> - the qualified name of a bound function followed by parentheses containing the comma-separated lists of non-binding parameters identifying a single overload.\n> \n\n\ninstead of \n> \n> select         = '$select' EQ selectItem *( COMMA selectItem )\n> \n> selectItem     = STAR                \n>                / allOperationsInSchema \n>                / [ ( qualifiedEntityTypeName\n>                    / qualifiedComplexTypeName \n>                    ) \"/\" \n>                  ] \n>                  ( selectProperty\n>                  / qualifiedActionName  \n>                  / qualifiedFunctionName  \n>                  )\n> \n> selectProperty = primitiveProperty  \n>                / primitiveColProperty \n>                  [ OPEN selectOptionPC *( SEMI selectOptionPC ) CLOSE ]\n>                / navigationProperty\n>                / selectPath\n>                  [ OPEN selectOption *( SEMI selectOption ) CLOSE\n>                  / \"/\" selectProperty\n>                  ]\n> \n> selectPath     = ( complexProperty / complexColProperty ) \n>                  [ \"/\" qualifiedComplexTypeName ]\n> \n> selectOptionPC = filter / search / inlinecount / orderby / skip / top\n> \n> selectOption   = selectOptionPC\n>                    / compute / select / expand / aliasAndValue  \n> \n\nNote: all other optional segments are covered in the existing text, intermingled with examples\n\n\nImported from [ODATA-1165](https://issues.oasis-open.org/browse/ODATA-1165)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "List of use cases for canonical functions is incomplete",
    "body": "Section 5.1.1.4 Canonical Functions states “In addition to operators, a set of functions is also defined for use with the $filter and $orderby system query option.”\n\nThe current ABNF also allows their usage in the productions parameterValue and computeItem.\n\n\n### Proposal\n\nThe set of functions can be used anywhere a common expression is applied such as $filter or $orderby.\n\nImported from [ODATA-1164](https://issues.oasis-open.org/browse/ODATA-1164)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "A Case for Common Expressions",
    "body": "Support of case expressions as known from the SQL standard would add to the ad hoc capabilities and support use cases that require such an IF-THEN-ELSE logic.\n\nImagine case( condition_1 : value_1, ..., condition_N : value_N [, else_value] ) would be available as canonical function for common expressions; an omitted else defaults to null. Here are some examples that could be addressed with it:\n\n1. Core OData: Ad-hoc calculations with logic on the current property values:\nExample: Signum(x)\n\nGET ~/XValues?$compute=case(X gt 0 : 1,X lt 0 : -1, 0) as SignumX&$select=X,SignumX\n\n2. Data Aggregation extension: Restricting aggregation to those values that occur in combination with certain groupable property values:\nExample: Comparing company revenues for years 2000 and 2017\n\nGET ~/Sales?$apply=groupby((Company), aggregate(case(Time/Year eq 2000 : Revenue) with sum as TotalRevenue2000, case(Time/Year eq 2017 : Revenue) with sum as TotalRevenue2017))\n\n3. Data Aggregation extension: Defining dynamic groupable properties\nExample: From a collection of incidents with fine-grained state model (e.g., new, assigned, resolved, verified, reopened, closed) retrieve the aggregated count of open and closed incidents:\n\nGET ~/Incidents?$apply=compute(case(Status eq ‘Closed’ : ‘Closed’, ‘Open’) as ProcessingStatus)/groupby((ProcessingStatus), aggregate($count as IncidentCount))\n\n\n### Proposal\n\nThe case function has the following signatures:\n\n`expression case(Edm.Boolean:expression, ..., Edm.Boolean:expression)`\n` expression case(Edm.Boolean:expression, ..., Edm.Boolean:expression,expression)`\n\nEach Edm.Boolean:expression parameter is a tuple separated by a colon, where the first component evaluates to a Boolean value, and the second component may be an expression of any type.\n\nThe case function returns the expression value of the leftmost parameter, whose first component evaluates to true. If none of the parameters match, case returns null, unless the last parameter is an expression, whose value is returned otherwise.\n\nRevised proposal 2018-4-19: The client SHOULD ensure that all parameter expressions are compatible. If all parameter expressions are of the same type, the type of the case expression is of that type. If all parameter expressions are of numeric type, then the type of the case expression is a numeric type capable of representing any of these expressions according to standard type promotion rules.\n\nServices MAY support case expressions containing parameters of incompatible types, in which case the case expression is treated as Edm.Untyped and its value has the type of the parameter expression selected by the case statement.\n\n*Simplified proposal 2018-08-30*: all parameters are expression pairs with a colon, the \"default\" can be achieved by making the last pair `true:expression`.\n\nImported from [ODATA-1163](https://issues.oasis-open.org/browse/ODATA-1163)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Fix data type in example model",
    "body": "Example model in section 2.2 introduces the Time property Year of type Number, which is not an Edm type.\n\n### Proposal\n\nReplace Number by Edm.Int16\n\nImported from [ODATA-1162](https://issues.oasis-open.org/browse/ODATA-1162)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify how to process hybrid results of a transformation in subsequent transformations",
    "body": "Examples for transformations producing hybrid results are groupby(rollup()…) and concat(…). The result may contain entities with properties not present in some other entities of the result. The specification does not describe how hybrid results are processed in subsequent transformations of a transformation sequence.\n\n### Proposal\n\nSection 3.16 Evaluating $apply describes in para 2 how properties that have been aggregated away are treated in $filter and $orderby. \nProposal is to add here: In subsequent transformations, they are treated like in $filter as having the null value. \n\n\nImported from [ODATA-1161](https://issues.oasis-open.org/browse/ODATA-1161)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify example 66 in section 7.5",
    "body": "Readers might infer a name clash from the double usage of “Total” for two dynamic result properties created in adjacent transformation sequences passed to concat.\n\n### Proposal\n\nAdd explanation to example: \nThis example also illustrates the special case that dynamic property names may be reused in different transformation sequences passed to concat.\n\nImported from [ODATA-1160](https://issues.oasis-open.org/browse/ODATA-1160)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify context URLs for aggregated result sets",
    "body": "Aggregated result sets created by $apply may include entities with mixed structures, if transformation concat is involved, either directly or indirectly, for example by a groupby(rollup()). \n\nApart from the general rules for context URLs defined in the OData Protocol specification, the Data Aggregation extension lacks a statement how to cope with context URLs for such hybrid result sets.\n\n\n### Proposal\n\nAdd to section 4 “Representation of Aggregated Instances”:\n\nThe context URL describes the superset of properties occurring in entities of the aggregated result set.\n\n\nImported from [ODATA-1159](https://issues.oasis-open.org/browse/ODATA-1159)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Transformations for limiting the number of entities in the result of a $apply transformation ",
    "body": "Transformation concat combines entity collections returned by two or more transformation sequences in a new, concatenated collection.\n\nFor limiting the number of items returned from the overall result collection, today the only way is to use system query options $skip and $top. It is currently not possible to limit the individual result collections of the transformation sequences passed to concat. \n\nThere are use cases requiring this ability. As an example, consider a request asking for (1) the grand total sales amount along with (2) the sales figures for the first 10 customers. Note that (1) may return a collection with more than one entry in case multiple currencies are involved, hence a global $top does not give full control to the client. In the worst case with more than ten currencies, not a single customer sales amount would be returned. If the aggregated result is put into a stable order with the orderby transformation (described in <issue>), this can be avoided with a top transformation: \n\nGET ~/Sales?$apply=\n    concat( groupby( (Currency), Amount with sum as TotalAmount ),\n            groupby( (Customer,Currency), Amount with sum as TotalAmount )\n            /orderby( Customer,Currency )\n            /top( 10 )\n          )\n\nAnother example also involving a skip transformation could be a request fetching sales amounts per customer and month in pages of ten data points per request, complemented with minimum and maximum amounts of the entities on this page. The request for the fourth page would look like:\n\nGET ~/Sales?$apply=\n    groupby( (Customer,Time/Month,Currency), Amount with sum as TotalAmount ),\n    /orderby( Customer,Time/Month,Currency )\n    /skip( 30 )/top( 10 )\n    /concat( \n         identity, \n         aggregate( Amount with min as MinAmount, Amount with max as MaxAmount ) )\n\n\n### Proposal\n\nDefine transformations skip and top:\n- The skip transformation takes a non-negative integer n as argument that excludes the first n entities of the input set. It returns all remaining entities in the same order as they occur in the input set.\n- The top transformation takes a non-negative integer n as argument and returns the first n entities of the input set, if the input set contains more than n entities, otherwise the entire input set. The entities in the result are in the same order as they occur in the input set.\n\nSince both transformations operate on the order of entities in the input set, the client needs to know how to specify meaningful requests involving these two transformations.\n\nThe transformations preceding skip/top in the sequence must first produce a certain order among the entities, and then keep this order stable for the input set of skip/top. Transformations in the first group are the topXXX and bottomXXX transformations, plus the pending orderby transformation ([ODATA-1157](https://issues.oasis-open.org/browse/ODATA-1157)). The second group consists of transformations identity and compute. The ordering constraint has already described for these transformations. Other transformations should not be restricted by such an ordering constraint to retain the current implementation flexibility. For example, an implementation of the filter transformation might involve efficient search structures that do not keep up the input set order.\n\nImported from [ODATA-1158](https://issues.oasis-open.org/browse/ODATA-1158)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Transformation for sorting entities created by a $apply transformation",
    "body": "Transformation concat allows to create result sets from the output sets of two or more transformation sequences passed to concat as arguments.\n\nIf entities of just one of these sequences shall be sorted, or the output sets shall be sorted differently, this cannot be achieved with the system query option $orderby, which always operates on the entire set produced by $apply.\n\nThis leads to the requirement for a dedicated orderby transformation. An example application is described in https://issues.oasis-open.org/browse/[ODATA-1158](https://issues.oasis-open.org/browse/ODATA-1158).\n\n### Proposal\n\nDefine transformation orderby that takes an expression also valid for the $orderby system query option and returns the entities of the input set in the same order $orderby would produce for the given expression.\n\norderby expression of the orderby transformation conforms to same abnf as the system query option; minimal bar is property path expressions (which can include computed properties) with asc/desc.\n\nImported from [ODATA-1157](https://issues.oasis-open.org/browse/ODATA-1157)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Context URL: allow empty parentheses after navigation property",
    "body": "Section 10.9 Collection of Expanded Entities states that\n\nIf the expanded navigation property does not contain a nested $select or $expand, then the expanded property is suffixed with empty parentheses.\n\nThis is currently not allowed by the ABNF\n\n### Proposal\n\nAllow empty parentheses after navigation properties\n\nImported from [ODATA-1156](https://issues.oasis-open.org/browse/ODATA-1156)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "ABNF: allow omitting default namespaces everywhere in the URL",
    "body": "Section 4.4 Default Namespaces states that\n\n    Functions, actions and types in a default namespace can be referenced in URLs with or without namespace or alias qualification.\n\nThis is currently not reflected fully in the ABNF\n\n### Proposal\n\nRelax ABNF to allow omitting namespaces for\n- functions\n- actions\n- type-cast\nin\n- path\n- query options\n\nBut NOT in the context URL.\n\nImported from [ODATA-1155](https://issues.oasis-open.org/browse/ODATA-1155)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify which OData-Version a service should return",
    "body": "Which OData-Version should a server respond if the client specifies a OData-MaxVersion of 4.01 and the service supports both 4.0 and 4.01?\n\n### Proposal\n\nThe service MUST respond with a payload compliant with the greatest supported version of the protocol that is less than or equal to the request's OData-MaxVersion, if specified. \n\nThe same request should return the same response, so in the absence of an odata-maxversion header, the service should return the same payload over time.  \"If OData-MaxVersion is not specified, then the service SHOULD interpret the request as having an OData-MaxVersion equal to the *initial default* version produced by the service\".\n\nClient is allowed to use 4.01 without specifying an OData-Version or OData-MaxVersion of 4.01. If a request has a payload, a compliant client MUST specify the OData-Version of the request body.\n\nIf the client inspects the metadata to determine the service supports 4.01, and requests a maxversion of 4.01, the proposed general rule requires that the service return 4.01 (we can introduce a min version in the future, if required).\n\nRequest and response payloads are independent. The service must honor OData-MaxVersion in a response regardless of the version of the request payload.\n\nCLARIFICATION FROM 2018-5-4: Regarding \"initial default version\"; our intention was that the behavior of the service did not change over time with respect to a client that does not specify an OData-MaxVersion header.\n\nImported from [ODATA-1154](https://issues.oasis-open.org/browse/ODATA-1154)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Core.Immutable: clarify that value can be provided *by client* in insert",
    "body": "There was a little confusion on whether Immutable was a special case of Computed with the guarantee that the value would be computed on insert and then never changed, e.g. a LastChangedAt\n\n### Proposal\n\nClarify that Immutable means that the value can be provided by the client on insert.\n\nImported from [ODATA-1153](https://issues.oasis-open.org/browse/ODATA-1153)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Align Prefer header rule with RFC7240: optional whitespace around commas",
    "body": "The ABNF rule for the Prefer header does not allow optional whitespace around commas although this is explicitly allowed by RFC7240.\n\n### Proposal\n\nAllow optional whitespace around commas as required by RFC7240\n\nImported from [ODATA-1152](https://issues.oasis-open.org/browse/ODATA-1152)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Edm.Stream and Nullable",
    "body": "Can stream properties be nullable?\n\nIf yes, how would a null value be represented?\n- if expanded: \"streamProp\":null\n- if not expanded: \"streamProp@mediaReadLink\":null, i.e. no link?\n\n### Proposal\n\n1) Expanded returns null\n2) Link is always valid, returns 204 if the value is null\n\nRemark:\n1) is consistent with the representation of structural properties of other primitive type and with expanded single-valued navigation properties\n2) is consistent with directly accessing a property that has the null value, directly accessing the raw value of a property that has the null value, and directly accessing a single-valued navigation property that has no entity related\n- http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingIndividualProperties\n- http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingaPropertysRawValueusingval\n- http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingRelatedEntities\n\n\n\nImported from [ODATA-1151](https://issues.oasis-open.org/browse/ODATA-1151)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Case Sensitivity of Property Names, EntitySets, Singletons and Operations",
    "body": "In 4.01 we add support for case-insensitive system query options, operators, built-in functions and keywords.\n\nWe don't explicitly say whether property, entity set, singleton, or operation names are case-sensitive or case-insensitive\n1) In URLs\n2) In payloads\n\nFor response payloads, we should mandate that properties are written out in the case they are advertised.\n\nIn request payloads, should services support matching property names that differ by case (first looking for a case-sensitive match and, failing that, case insensitive?) or treat as dynamic?\n\nWhat about in URLs? if resolution fails to find an exact match, should it look for a(n unambiguous) case-insensitive match, or treat as a dynamic property?\n\nWhat about instance annotations and thus namespaces and aliases?\n\n\n### Proposal\n\nInteroperable clients MUST specify identifiers (in payloads and URLs) in the case they are specified in $metadata.\n\nServices MUST return identifiers (payloads, contextUrl, etc.) in the case defined in $metadata.\n\nServices SHOULD NOT have identifiers within a uniqueness scope that differ only by case.\n\nServices MAY support case-insensitive comparisons of identifiers in URLs and request payloads if no exact match is found, following the existing precedence rules.\n\nImported from [ODATA-1150](https://issues.oasis-open.org/browse/ODATA-1150)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support Delta responses for Singletons",
    "body": "Today we are a bit unclear about whether or not deltas are supported for singletons.  \n\nIn 11.3 Requesting Changes of the Protocol document, we say:\n\"Any GET request to retrieve one or more entities MAY allow change-tracking.\"\n\nHowever, in 15.1 Delta Response of the JSON document we say:\n\"Responses from a delta request are returned as a JSON object. The JSON object MUST contain an array-valued property named value containing all added, changed, or deleted entities, as well as added links or deleted links between entities, and MAY contain additional, unchanged entities.\"\n\nThe wording from the JSON spec makes sense for 4.0, since changes to related entities and links were represented in a flattened result, but with the ability to represent nested related content, it is useful to support a delta payload (GET or PATCH) for requests anchored on a single node.\n\n\n### Proposal\n\nDeltas can be supported for singletons and single-value navigation properties as well as entities and collection-valued navigation properties.\n\nThe context url for a delta against a singleton (or single-valued nav prop) follows the same pattern of appending /$delta to the context url returned by a request against that singleton (or single-valued nav prop).\n\nThe 4.01 JSON payload for a delta request/response rooted in a single object is the single object with nested changes (i.e., propertyName@delta).\n\nWe don't define a 4.0 JSON format for a delta payload for a request/response rooted in a single object.\n\nImported from [ODATA-1149](https://issues.oasis-open.org/browse/ODATA-1149)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "PATCH with nested nav props should not remove omitted resources",
    "body": "In OData 4.0 we explicitly disallowed deep updates (i.e., including related entities in a PUT or PATCH request).  We did allow binding (through the @bind annotation).\n\nIn OData 4.01 we added the ability to do deep updates, but we are inconsistent with how we describe the behavior.\n\nIn the Protocol document we say that the nested content replaces the existing content, removing any related resources not specified in the payload:\n\n11.4.3.1 Update Related Entities When Updating an Entity (Protocol)\n…\nPayloads with an OData-Version header with a value of 4.01 or greater MAY include nested entities and entity references that specify the full set of currently related entities, or a nested delta payload representing the related entities that have been added, removed, or changed.\n\nIf the nested collection is represented identical to an expanded navigation property, then the set of nested entities and entity references specified in a successful update request represents the full set of entities to be related according to that relationship and MUST NOT include added links, deleted links, or deleted entities.\n\nHowever, this is different than the semantics we describe in section 8.5 of the JSON document (taken from 4.0), which says that the bound items are added, and don't affect the existing relationships:\n\n8.5 Bind Operation (JSON)\n…\nFor update operations a bind operation on a collection navigation property adds additional relationships, it does not replace existing relationships, while bind operations on an entity navigation property update the relationship.\n\nIn fact, for a PATCH operation, most people expect that the membership of the collection-valued nav prop is not replaced, but that specified resources are added or updated.\n\nIt would probably be more intuitive to say that PATCH updates the service with the references in the payload, and that PUT must be used in order to do the replace semantics, or @delta can be used to remove (or upsert) individual entries.\n\n\n### Proposal\n\nFor PATCH operations, nested entities should be upserted. Entities not present in the payload should remain untouched.\n\nFor PUT operations, the set of nested entities should represent the full set of entities to be related upon successful completion of the operation. Related entities missing from the payload are removed from the relationship.\n\nImported from [ODATA-1148](https://issues.oasis-open.org/browse/ODATA-1148)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Annotate a function or action as \"availability is advertised per instance\"",
    "body": "Actions and functions are by default available for all instances unless stated otherwise.\n\nOne way to state this is the term Core.OperationAvailable which currently has to evaluate to true or false.\n\nWhat is missing is a way to say \"availability of this operation cannot be determined up-front, please look into the availability advertising in its representation\".\n\n### Proposal\n\nMake term Core.OperationAvailable nullable and treat null as \"unknown up-front, check advertising in representation\"\n\nImported from [ODATA-1147](https://issues.oasis-open.org/browse/ODATA-1147)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that an enumeration type must have at least one member",
    "body": "Deviating from CSDL V4 and CSDL JSON V4.01 the CSDL XML V4.01 document states that [The edm:EnumType element] MAY contain one or more edm:Member elements defining the members of the enumeration type.\n\n### Proposal\n\nChange to \"MUST contain one or more\", same as in CSDL JSON and CSDL V4.\n\nImported from [ODATA-1146](https://issues.oasis-open.org/browse/ODATA-1146)",
    "labels": [
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Align Authorization vocabulary with OpenAPI V3",
    "body": "Our Authorization vocabulary was defined based on Swagger V2.\n\nOpenAPI V3 changes slightly the way authorization is specified.  In particular, it allows defining authorization flows, and then referencing those flows with a required set of scopes for a particular operation.\n\nOData-884 proposes adding the ability to specify the requests (and corresponding responses) associated with an entity set, singleton, etc. As part of this proposal, it makes sense to be able to associate particular flows and required scopes with those requests.  This can be done by:\n1) Adding a Name to the Authorization type in order to reference a particular authorization, and\n2) Adding a \"SecuritySchemes\" property to the HTTPRequest type that is a collection of authorization/scope requirements for invoking this particular request.\n\n### Proposal\n\n1) Add the following property to the Auth.Authorization complex type:\n\n<Property Name=\"Name\" Type=\"Edm.String\">\n  <Annotation Term=\"Core.Description\" String=\"Name that can be used to reference the authorization flow.\"/>\n</Property>\n\n2) Add the following new complex type to the Auth vocabulary:\n<ComplexType Name=\"SecurityScheme\">\n  <Property Name=\"AuthorizationSchemeName\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"The name of a required authorization scheme\"/>\n  </Property>\n  <Property Name=\"RequiredScopes\" Type=\"Collection(Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"The names of scopes required from this authorization scheme.\"/>\n  </Property>\n<ComplexType>\n\n3) Add the following property to the new HTTPRequest type proposed in [ODATA-884](https://issues.oasis-open.org/browse/ODATA-884):\n<Property Name=\"SecuritySchemes\" Type=\"Collection(Auth.SecurityScheme)\">\n  <Annotation Term=\"Core.Description\" String=\"At least one of the specified security schemes are required to make the request. This overrides any SecuritySchemes specified on the EntityContainer.\"/>\n</Property> \n\n4) Add the following term that can be applied to an EntityContainer.\n<Term Name=\"SecuritySchemes\" Type=\"Collection(Auth.SecurityScheme)\" AppliesTo=\"EntityContainer\">\n  <Annotation Term=\"Core.Description\" String=\"At least one of the specified security schemes are required to make a request against the service.\"/>\n</Term>\n\n\n\nImported from [ODATA-1145](https://issues.oasis-open.org/browse/ODATA-1145)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow percent-encoded colon in time values in URLs",
    "body": "The ABNF currently does not allow percent-encoded colons in URLs.\nThis is an unnecessary restriction and collides with the habit of many URL libraries to over-eagerly percent-encode everything except ALPHA and DIGIT.\n\n### Proposal\n\nSplit rules for timeOfDay and dateTimeOffset into a URL variant that allows percent-encoded colons, and a variant for message bodies that requires the unencoded colon.\n\nImported from [ODATA-1144](https://issues.oasis-open.org/browse/ODATA-1144)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Extend the Property metatype to allow a type that is an EntityType.",
    "body": "This proposal extends Property to allow a type declared as an EntityType or Singleton.\nThis is different from a NavigationProperty with ContainsTarget=True, in that the contained entities are not separately addressable;  (either as a property of the EntityContainer or via its key property values and its EntitySet.)\n\nUsing an EntityType in a property declaration is useful when storing the value of an Entity or collection of Entities, such as in a log or event record.\n\n\n### Proposal\n\nClose without action.\n\nFor the \"log\" or \"event record\" use case a containment navigation property can be used. The contained \"clone\" is by definition different from its \"original\".\n\nImported from [ODATA-1143](https://issues.oasis-open.org/browse/ODATA-1143)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify MaxDistance is an optional parameter in hierarchy filter functions",
    "body": "Section 6.3.2.1 describes that functions isdescendant and isancestor both include a second parameter for the maximum distance that is ought to be optional. \n\nThe definitions of these functions in the vocabulary describe the parameters as mandatory.\n\n\n### Proposal\n\nExtend the current definitions to make the maximum distance parameters optional by assigning the maximum possible distance by default (additions are enclosed in *):\n\n<Function Name=\"isdescendant\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\">\n-    \n    <Annotation Term=\"Core.OptionalParameter\"> \n      <PropertyValue Property=\"DefaultValue\" Int=\"32767\"/> \n    </Annotation>\n-    \n  </Parameter>\n  <ReturnType Type=\"Edm.Boolean\"/>\n</Function>\n<Function Name=\"isancestor\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\">\n-    \n    <Annotation Term=\"Core.OptionalParameter\"> \n      <PropertyValue Property=\"DefaultValue\" Int=\"32767\"/> \n    </Annotation>\n-    \n  </Parameter>\n  <ReturnType Type=\"Edm.Boolean\"/>\n</Function>\n\nNote that term OptionalParameter has become available in the Core vocabulary with the work on OData version 4.01.\n\nadd to this proposal:\n  - Use Validation.Minimum on the distance parameter\n- Add meaning of distance to description\n\n\nImported from [ODATA-1142](https://issues.oasis-open.org/browse/ODATA-1142)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Upsert: clarify upsert along nullable single-valued navigation path",
    "body": "Section 11.4.4 Upsert an Entity allows upsert request to any URL that identifies a single entity. It then references section 11.4.2 Create an Entity, which only talks about creating entities in a collection.\n\nThis question also arises in the context of \"deep update\" with nested entities for single-valued navigation.\n\n### Proposal\n\nPUT or PATCH to a single-valued navigation property *reference* (i.e., customers/salesperson/$ref) MUST only include the entity id, and changes which entity is referenced by the navigation property.\n\nPUT or PATCH to a single-valued navigation property (i.e., customers/salesperson) performs an update on the currently related resource. If the value of the navigation property is non-null then any key values are ignored and the referenced entity is updated. If the value of the navigation property is null, for a containment relationship a resource is created (since the single-valued navigation path identifies the resource). For a non-containment relationship, PUT or PATCH to a null single-valued navigation property returns an error.\n\nThe same semantics apply to singletons on the entity container, which are semantically contained single value navigation properties.\n\nImported from [ODATA-1141](https://issues.oasis-open.org/browse/ODATA-1141)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify: contains, startswith, endswith, indexof should all be case-sensitive",
    "body": "To avoid any possible confusion, we should explicitly state that contains, startswith, endswith, and indexof should do case-sensitive string comparisons.\n\nIt's fairly common practice to use TOUPPER or TOLOWER on the operands in order to do case-insensitive comparisons.\n\n\n### Proposal\n\nClarify the string comparison functions do case-insensitive string compares. \n\nImported from [ODATA-1139](https://issues.oasis-open.org/browse/ODATA-1139)",
    "labels": [
      "URL Conventions",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Facilitate processing of aggregated results created with concat",
    "body": "The concat transformation creates a potentially heterogeneous result set consisting of entities with different structures.\n\nThe result is a contiguous list of entities without explicit boundaries to separate the result entities created by one concat parameter from the next. In case an OData client needs to know the concat parameter to which a result entity is related, it has to evaluate the result entities with the same or similar logic expressed in the request a second time.\n\nExample:\nUsing the example model from the Data Aggregation extension, consider a request to retrieve sales amounts grouped by customer for two different subsets of sales entities qualified by complex filter expressions:\n\nGET ~/Sales?$apply=concat(\n\t  filter(<complex expression 1>)/groupby((Customer),aggregate(Amount with sum as Total)),\n \t  filter(<complex expression 2>)/groupby((Customer),aggregate(Amount with sum as Total)))\n\nWhich is the last entity in the result collection that matches complex expression 1?\n\n\n### Proposal\n\nNo action as this can be solved by the client e.g. using compute():\n\nGET ~/Sales?$apply=concat( \nfilter(<complex expression 1>)/groupby((Customer),aggregate(Amount with sum as Total))/compute(1 as concat_index), \n \tfilter(<complex expression 2>)/groupby((Customer),aggregate(Amount with sum as Total))/compute(2 as concat_index)) \n\nImported from [ODATA-1138](https://issues.oasis-open.org/browse/ODATA-1138)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify type information for dynamic properties in the aggregated result set",
    "body": "The JSON and Atom format specifications list special cases where a property value does not need to be complemented with type information using the type(odata.type) instance annotation. The current Data Aggregation specification contains several examples with dynamic properties, where the data type is missing, because they don’t fall into this category: Examples 5, 9, 10, 12, 15, 57, 58, 59, 63, 64, and 70 contain one or more dynamic properties of type Edm.Decimal without a corresponding type annotation required by [OData-JSON].\n\n### Proposal\n\nAdd ellipses (…) to all these examples to make clear that the payload is not complete, but omit the extra instance annotations from the JSON payload examples to preserve their readability. \n\nAdd a disclaimer at the end of section 3: “The JSON representation of dynamic properties in the result will include type (odata.type) annotations as additional control information where required by [OData-JSON]. For brevity, such annotations are omitted from the examples in the following sections.”\nRemove this sentence from sections 3.1 and 3.14: “The JSON representation of these dynamic properties will include odata.type annotations where required by [OData-JSON].”\n\n\nImported from [ODATA-1137](https://issues.oasis-open.org/browse/ODATA-1137)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow hierarchy filter functions for ancestors and descendants to return true for starting node",
    "body": "The current definitions of the two hierarchy filter functions isancestor and isdescendant specify that the functions return true only if the current entity is a strict ancestor/descendant of the given start node.\n\nPractical applications sometimes require the start node to be included in the result. For this purpose, both functions could be extended by an optional Boolean parameter that allows the OData client to specify, if the start node shall be included in the result. With this, the filter expression $it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA',IncludeParent=”true”) could avoid the clumsier $it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA') or ID eq 'EMEA'\n\n\n### Proposal\n\nTo stay downward compatible with the current spec, the parameter default value must be false.\n\nExtend the current definitions (additions are enclosed in *):\n\n<Function Name=\"isdescendant\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n*\n  <Parameter Name=\"IncludeParent\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.OptionalParameter\">\n      <PropertyValue Property=\"DefaultValue\" String=\"false\"/>\n    </Annotation>\n  </Parameter>\n*\n  <ReturnType Type=\"Edm.Boolean\"/>\n</Function>\n\n<Function Name=\"isancestor\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n  <ReturnType Type=\"Edm.Boolean\"/>\n*\n  <Parameter Name=\"IncludeChild\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.OptionalParameter\">\n      <PropertyValue Property=\"DefaultValue\" String=\"false\"/>\n    </Annotation>\n  </Parameter>\n*\n</Function>\n\nNote that term OptionalParameter has become available in the Core vocabulary with the work on OData version 4.01.\n\nadd to proposal:\n- extend description by explanation of newly added parameter.\n\nImported from [ODATA-1136](https://issues.oasis-open.org/browse/ODATA-1136)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Document use of JSON Schema $schema",
    "body": "JSON recommends specification of the $schema attribute for validation.\nThe specification silently supports this.\nNeed to make this explicit.\n\n\n### Proposal\n\nClose without action\n\nImported from [ODATA-1135](https://issues.oasis-open.org/browse/ODATA-1135)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add KeyAsSegmentSupported annotation term to Capabilities vocabulary",
    "body": "In OData 4.01 we introduced semantics around supporting the popular key-as-segment URL syntax, but we have no generic way for clients to know whether or not the service supports this sytnax.\n\n### Proposal\n\nAdd a new boolean term to the capabilities vocabulary, KeyAsSegmentSupported:\n\n<Term Name=\"KeyAsSegmentSupported\" Type=\"Core.Tag\" DefaultValue=\"True\" AppliesTo=\"EntityContainer\"/>\n\nImported from [ODATA-1134](https://issues.oasis-open.org/browse/ODATA-1134)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Part 1 protocol clause 1.3 Entity is unclear on template usage",
    "body": "The 10.3 Entity clause provides two templates for context URL.  However, it is not clear on which must be used in various situations.\n\n### Proposal\n\nMake template usage clear for the following 6 cases.\n1. Entity set \\{context-url}#\\{entity-set}\n1. Entity set element \\{context-url}#\\{entity-set}/$entity\n1. Contained NavProperty entity set \\{context-url}#\\{entity-set}\n1. Contained Nav Property singleton \\{context-url}#\\{entity-set}/$entity\n1. Contained NavProperty entity set element \\{context-url}#\\{entity-set}/$entity\n1. Other \\{context-url}#\\{type-name}\n\nImported from [ODATA-1133](https://issues.oasis-open.org/browse/ODATA-1133)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Propagation of NavigationRestrictions",
    "body": "Clarify whether/how navigation restrictions \"propagate\".\n\nAssume we have \n- Order entity related to single Customer entity\n- Customer entity related to multiple Address entities\n- a navigation restriction on Customers entity set which lists Addresses as filterable:false.\n\nNow a client knows that it cannot filter Customers by Addresses.\n\nShould a client assume that it also cannot filter Orders by Customer/Addresses?\n\nOr would the service have to explicitly declare navigation restrictions for all entity sets with navigation paths ending in Customer/Addresses?\n\n### Proposal\n\nAs per 2018-2-8 discussion: State that clients can assume that restrictions specified on an entity set are valid whether the request is to the entity set or through a navigation property bound to that entity set.  Service could specify a different set of restrictions specific to a path, in which case any specified restrictions take precedence.\n\nImported from [ODATA-1132](https://issues.oasis-open.org/browse/ODATA-1132)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consistent order of function parameters",
    "body": "Function overload resolution rules depend on the ordered set of parameter types.\nAlso the first parameter is the binding parameter for a bound function/action.\n\nThis implies that the order of function/action parameters has to be stable over time.\n\nClarify this in Part 1: Protocol, section 5.2 Model Versioning, and/or the CSDL documents, sections 12.9 Parameter\n\n### Proposal\n\nClarify that the defined order of parameters for functions or actions, as returned in CSDL, is stable over time.\n\nImported from [ODATA-1131](https://issues.oasis-open.org/browse/ODATA-1131)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "JSON Batch and continue-on-error",
    "body": "The JSON Format specifcation states in http://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd03/odata-json-format-v4.01-csprd03.html#sec_ProcessingaBatchRequest that\n\nThe service MAY process the individual requests and atomicity groups within a batch request in any order that is compatible with the dependencies expressed with the dependsOn name/value pair. Processing stops on the first error unless the continue-on-error preference is specified.\n\nThis makes batch processing somewhat non-deterministic.\n\nAlso it is not clear what \"stop processing\" means: \n- If the service chose to process independent groups of requests in parallel, will only groups stop that contain a failing individual request?\n- What is contained in the array of responses for \"skipped\"/\"unprocessed\" individual requests?\n\nDo we need continue-on-error at all for JSON Batch requests?\nIf yes: does it only apply to subsequent requests within \"dependency chains\"?\nOr do we intentionally leave this up to the service implementation and thus non-deterministic?\n\n\n\n### Proposal\n\nallow \"continue-on-error=false\" and \"continue-on-error=true\".  \"continue-on-error\" implies true.  If continue-on-error is not specified, then default is false in multipart mixed, true in json. In multipartmixed, continue-on-error=false means stop if any statement fails. In json it means that a best effort is requested not to spend cycles on further processing if a failure occurs outside of dependency groups because the client is not interested in the result.\n\nImported from [ODATA-1130](https://issues.oasis-open.org/browse/ODATA-1130)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow deep insert of media resources",
    "body": "Section 11.4.2.2 Create Related Entities When Creating an Entity -\n http://docs.oasis-open.org/odata/odata/v4.01/csprd03/part1-protocol/odata-v4.01-csprd03-part1-protocol.html#sec_CreateRelatedEntitiesWhenCreatinganE - states\n\nMedia entities, whose binary representation cannot be represented inline, cannot be created within a deep insert.\n\nThis is no longer true and thus an unnecessary restriction, media resources can be represented inline as a property \"$value\", see http://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd03/odata-json-format-v4.01-csprd03.html#sec_MediaEntity\n\n### Proposal\n\nRemove restriction, or better replace it with text referring to \"$value\" inline representation.\n\nNote: this only applies if the media entity is nested within a \"non-media\" entity.\n\nAlso mention inline representation of stream properties as base64url-encoded values, see [http://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd03/odata-json-format-v4.01-csprd03.html#sec_StreamProperty]\n\nImported from [ODATA-1129](https://issues.oasis-open.org/browse/ODATA-1129)",
    "labels": [
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify function imports in $filter and $orderby",
    "body": "Section 11.5.3.1 Invoking a Function - http://docs.oasis-open.org/odata/odata/v4.01/csprd03/part1-protocol/odata-v4.01-csprd03-part1-protocol.html#sec_Functions - states\n\n    Function imports MUST NOT be used inside either the $filter or $orderby system query options.\n\n\n\nThis somewhat defeats the purpose of $root, because it might be helpful to \n\nGET Stuff?$filter=ResponsibleUser eq $root/Me/Username\n\nwhere Me is a function import returning a complex value - function import instead of singleton because it is read-only.\n\n### Proposal\n\nChange the sentence to \n\n    Function imports can be used inside $filter or $orderby if preceded by the $root literal, see [OData-URL].\n\nImported from [ODATA-1128](https://issues.oasis-open.org/browse/ODATA-1128)",
    "labels": [
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "clarify support for navigation properties on deleted entries",
    "body": "In 4.01 we added support for properties within a deleted entry.  This allows us to omit the @odata.id, if key fields are included, and may provide other information about the deleted entry.\n\nWe are not clear, however, whether \"properties\" includes navigation properties and what the semantics of navigation properties on a deleted entry should be.\n\nIf you think of a delta payload as a graph of changes, the fact that a node within that graph has been deleted doesn't mean that you aren't interested in changes to other nodes within the graph; it's still interesting to report changes to nodes that may no longer be accessible (at least from the root) after applying changes.\n\n### Proposal\n\nClarify that navigation properties, as well as structural properties, are supported within a deleted entry, to show changes to entities related to the deleted entry.\n\nJust as for a regular entity in a delta response, a single-valued navigation property may reference a tombstone, in which case that related entity is also deleted, and the deleted entry may include a nested delta (represented using @delta annotation in JSON) that includes both changed and deleted related entities.\n\nImported from [ODATA-1127](https://issues.oasis-open.org/browse/ODATA-1127)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove a Reference to an Entity (public review comment c201710e00005)",
    "body": "Public review comment https://lists.oasis-open.org/archives/odata-comment/201710/msg00005.html\n\nThe document \"OData Version 4.0, Part1: Protocol\" specifies in section\n\"11.4.6.2 Remove a Reference to an Entity\":\n\n     For collection-valued navigation properties, the entity reference of\n     the entity to be removed MUST be specified using the $id query\n     string option.\n\nIt would be nice if instead of or at least additional to using the $id query\noption it would be allowed to use the key after the navigation property\nto specify which entity is referenced.\n\nExample:\n    DELETE http://host/service/Customers(1)/Orders/$ref?$id=../../Orders(4711)\ncould be expressed as\n    DELETE http://host/service/Customers(1)/Orders(4711)/$ref\n\nThis avoids a mandatory query option, handling of nested URLs, and parsing of relative or absolute URLs including verification that the URL is fitting; last but not least it is shorter and easier to understand.\n\nKind Regards,\nOliver Heinrich\n\n\n### Proposal\n\nWe could allow the simplified syntax in the same cases in which we allow addressing a member within an entity collection by key, Part 2, section 4.9: http://docs.oasis-open.org/odata/odata/v4.01/csprd03/part2-url-conventions/odata-v4.01-csprd03-part2-url-conventions.html#sec_AddressingaMemberwithinanEntityColle\n\nImported from [ODATA-1126](https://issues.oasis-open.org/browse/ODATA-1126)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Define by-value/reference expectations for action/function payloads.",
    "body": "Descriptions of parameters and return types do not explain expectations for references to Entities.  \nThe metamodel + vocabulary for CSDL allows three types of encodings:\n•\tBy-reference, represented as a string containing a URL that references the resource.\n•\tBy-reference, represented as an object containing a partial copy of the resource  that includes just the @odata.id meta property with a value that is a string containing a URL that references the resource.\n•\tBy-value, represented as an object containing a copy of the resource.\n\nFor parameters and return-types, the question is which of these are expected in a payload.\n\n\n### Proposal\n\nExpectations to be spelled out in Part 1: Protocol, documenting the by-value/by-reference expectations in Part 1: Protocol, with forward-reference to JSON Format for \"bind syntax\" / \"entity references\", to be detailed by authors, to be reviewed in document walk-through\n\n\nImported from [ODATA-1125](https://issues.oasis-open.org/browse/ODATA-1125)",
    "labels": [
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Authorization vocabulary: KeyLocation - also allow cookie as value?",
    "body": "ApiKey/KeyLocation: also allow cookie as value\n\n\n\n### Proposal\n\nAdd \"Cookie\" to the value of KeyLocation.\n\nImported from [ODATA-1124](https://issues.oasis-open.org/browse/ODATA-1124)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow 24:00:00 for Edm.TimeOfDay (public review comment c201710e00003)",
    "body": "Public review comment https://lists.oasis-open.org/archives/odata-comment/201710/msg00003.html\n\nCSDL 4.01 permits Edm.TimeOfDay values to range from 00:00:00 to 23:59:59.999*.\n\nHowever existing systems (e.g. SAP backends) frequently utilize 24:00:00 to indicate end-of-day. Requiring these values to be transmitted (e.g. to clients) as 23:59:59.999* could result in round-trip data loss.\n\n In fact such SAP systems (for V2/V4) already will return PT24H or normalization-equivalent (for the V2 format of Edm.Time using XSD duration) or 24:00:00 (for the V4 format of Edm.TimeOfDay using XSD time), which is non-compliant with OData V2-V4 specifications.\n\nTo improve interoperability, it would be preferable to standardize this behaviour.\n\nNote that the lexical format for XSD time permits 24:00:00, as it is the left-truncation of dateTime lexical representation, and dateTime lexical representation (see https://www.w3.org/TR/xmlschema-2/#dateTime) states:\n\n -    hh is a two-digit numeral that represents the hour; '24' is permitted if the minutes and seconds represented are zero, and the dateTime value so represented is the first instant of the following day (the hour property of a dateTime object in the ·value space· cannot have a value greater than 23);\n\n### Proposal\n\nResolve with no action.  ISO 8601 has explicitly removed 24:00 for information exchange in order to avoid ambiguity. As most common programming langauges don't support storing this as a distinct value (even those that accept such a value), clients would have problems roundtripping the value.\n\nImported from [ODATA-1123](https://issues.oasis-open.org/browse/ODATA-1123)",
    "labels": [
      "CSDL JSON",
      "CSDL XML"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add singletons for capability term targets",
    "body": "A number of capabilities target entity sets, and follow navigationpaths to target contained members.\n\nThese should also be able to apply to singletons defined within an entity container.\n\nTodo: enumerate the capabilities that should have \"Singleton\" added.\n\nImported from [ODATA-1122](https://issues.oasis-open.org/browse/ODATA-1122)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add FilterExpressionType values \"MultiRange\" and \"MultiRangeOrSearchExpression\"",
    "body": "Filter expression restrictions where introduced in [ODATA-816](https://issues.oasis-open.org/browse/ODATA-816) to express restricted filter capabilities on individual properties that can only be used in equality comparison or interval comparison.\n\nSimilar to MultiValue being multiple SingleValues joined by OR, MultiRange is multiple SingleRanges joined by OR, with a slight generalization: in addition to closed intervals also half-open and open intervals are allowed, as well as degenerate intervals (closed intervals with identical lower and upper boundary can be expressed simply via EQ).\n\nThis means that MultiRange subsumes SingleRange as well as MultiValue and SingleValue.\n\nFor string-valued properties this can be extended to include multiple SearchExpressions: MultiRangeOrSearchExpression, allowing to OR zero or more startswith, endswith, or contains functions comparing the property to a string literal.\n\nThese expressions are all fairly simple, including a property, a literal value, and at most one level of parentheses. They represent expressions that can be constructed by typical \"extended search\" forms that allow to pick the comparison operator and enter the comparison value (or two values for \"between\").\n\n### Proposal\n\nAdd new allowed values\n\n  <Record>\n    <PropertyValue Property=\"Value\" String=\"MultiRange\" />\n    <Annotation Term=\"Core.Description\" String=\"Property can be compared to a union of one or more closed, half-open, or open intervals\" />\n    <Annotation Term=\"Core.LongDescription\" String=\"The filter expression for this property consists of one or more interval expressions combined by OR. A single interval expression is either a single comparison of the property and a literal value with eq, le, lt, ge, or gt, or pair of boundaries combined by AND and enclosed in parentheses. The lower boundary is either ge or gt, the upper boundary either le or lt.\" />\n  </Record>\n\n\n  <Record>\n    <PropertyValue Property=\"Value\" String=\"MultiRangeOrSearchExpression\" />\n    <Annotation Term=\"Core.Description\" String=\"Property can be compared to a union of zero or more closed, half-open, or open intervals plus zero or more simple string patterns\" />\n    <Annotation Term=\"Core.LongDescription\" String=\"The filter expression for this property consists of one or more interval expressions or string comparison functions combined by OR. See MultiRange for a definition of an interval expression. See SearchExpression for the allowed string comparison functions.\" />\n  </Record>\n\nImported from [ODATA-1121](https://issues.oasis-open.org/browse/ODATA-1121)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Put entity set restrictions on NavigationPropertyDescriptions",
    "body": "In OData-958 we added FilterRestrictions and SortRestrictions to NavigationPropertyDescriptions.  This gave us a place to define such restrictions on collection-valued navigation properties.  However, we missed some other restrictions and, in OData-1055, proposed to add one of these (DeepInsertSupport) as an annotation that could be applied to a \"Collection\" (i.e., a collection-valued navigation property).  This has a number of issues:\n1) It uses the new \"Collection\" value in AppliesTo, which we did not want to return to OData 4.0 clients,\n2) It underspecifies where DeepInsertSupport can be applied (i.e., it doesn't make sense for collection-valued structural properties),\n3) It creates multiple places for the client to look to figure out what it can/can't do for a particular navigation property\n4) It puts the annotation on the navigation property within the type, which makes it difficult to re-use that type.\n\nA better, more consistent approach would be to add to NavigationPropertyRestrictions all of the restrictions we currently have for EntitySets.\n\n\n### Proposal\n\n1) Remove \"Collection\" from AppliesTo for DeepInsertSupport; keep \"EntityContainer\" and \"EntitySet\".\n2) Add DeepInsertSupport, IndexableByKey, TopSupported, SkipSupported, SearchRestrictions, InsertRestrictions, UpdateRestrictions, and DeleteRestrictions to our NavigationPropertyRestrictions.\n\nImported from [ODATA-1120](https://issues.oasis-open.org/browse/ODATA-1120)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add CollectionPropertyRestrictions capability term",
    "body": "In [ODATA-545](https://issues.oasis-open.org/browse/ODATA-545) we added the value \"Collection\" as a valid value for AppliesTo to specify that a term can target any collection.  At the time we said that it should only be returned for 4.01 or greater clients.  We said that, for 4.0 clients, we could just say \"EntitySet Property NavigationProperty\" and underspecify the restriction (i.e., it would only apply to collection-valued (nav) properties) but that would be implied by the semantics of the term.\n\nThen, in [ODATA-631](https://issues.oasis-open.org/browse/ODATA-631), we used the new term in our vocabularies for things like CountRestrictions, FilterRestrictions,TopSupported,SKipSupported, etc.  This is problematic, as we didn't want to return this to 4.0 clients, yet we only have one version of the vocabulary.\n\nIt also violates our best practice of applying annotation in the container, in order to support type-reuse, rather than annotate the type directly.\n\n\n### Proposal\n\n1) Remove \"Collection\" in AppliesTo in our capabilities vocabulary.\n2) Add a new term, \"CollectionPropertyRestrictions\", that can be applied to collection-valued structural properties to describe support for new filter/sort/page type functionality:\n\n<Term Name=\"CollectionPropertyRestrictions\" Type=\"Collection(Capabilities.CollectionPropertyRestrictionsType)\" AppliesTo=\"EntitySet\">\n    <Annotation Term=\"Core.Description\" String=\"Describes restrictions on operations applied to collection-valued structural properties\" />\n</Term>\n<ComplexType Name=\"CollectionPropertyRestrictionsType\">\n  <Property Name=\"CollectionProperty\" Type=\"Edm.PropertyPath\">\n    <Annotation Term=\"Core.Description\" String=\"Restricted Collection-valued property\" />\n  </Property>\n  <Property Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\">\n    <Annotation Term=\"Core.Description\"\n      String=\"List of functions and operators supported in $filter. If null, all functions and operators may be attempted\" />\n  </Property>\n  <Property Name=\"FilterRestrictions\" type =\"Capabilities.FilterRestrictionsType\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $filter expressions\" />\n  </Property>\n  <Property Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $search expressions\" />\n  </Property>\n  <Property Name=\"SortRestrictions\" type =\"Capabilities.SortRestrictionsType\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $orderby expressions\" />\n  </Property>\n  <Property Name=\"TopSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Supports $top\" />\n  </Property>\n  <Property Name=\"SkipSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Supports $skip\" />\n  </Property>\n  <Property Name=\"Insertable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"This collection supports inserts\" />\n  </Property>\n  <Property Name=\"Updatable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Members of this ordered collection can be updated by ordinal\" />\n  </Property>\n  <Property Name=\"Deletable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Members of this ordered collection can be deleted by ordinal\" />\n  </Property>\n</ComplexType>\n\nImported from [ODATA-1119](https://issues.oasis-open.org/browse/ODATA-1119)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clients must not specify select options to the same property more than once",
    "body": "In OData-1105 we introduced an alternate sytnax for selecting a subset of properties of a complex type, as well as specifying other select-options for doing things like filtering and sorting a collection of complex types, but we didn't define any rules around how the new syntax related to the old syntax.  I.e.\nCan the client mix the two:\n    $select=Address/City,Address($select=State)\nCan the client specify the same property in multiple places?\n    $select=Addresses/State,Addresses($select=State)\nCan the client specify the same property with and without select options?\n    $select=Addresses,Addresses($filter=State eq 'Oregon')\nCan the client specify different options for the same selectItem?\n    $select=Addresses($filter=State eq 'Oregon'),Addresses($filter=State eq 'Washington')\nCan the client specify the same property in multiple places?\n    $select=Home/Address($select=City),Home($select=Address($select=State)\nCan the client mix nav path and select options for the same select item?\n    $select=Home/Address($select=City)\n\nWith $expand we the simple rule that the same property must not appear in more than one expandItem, which is easy to make because there isn't an alternate path syntax.\n\nThe simplest rule would be to say that clients can't mix path syntax and nested $select syntax in the same URL, but that could be overly restrictive.\n\nThe next simplest rule would probably be to say that you can't mix path and nested syntax for the same selectItem.  I.e., a $select nested within a select can't specify a path, and a path can't have select options. This would be easy to validate in the ABNF. \n\nSo you could do:\n    $select=FullName/FirstName,Address($select=City)\nbut not:\n    $select=Home/Address($select=City)\n\nThis would still allow the same property to be expressed with and without select options, which we could add another rule to protect against or just say that any select options are applied.  So:\n    $select=Addresses,Addresses($select=City)\nwould be the same as:\n    $select=Addresses($select=City)\nNote that we currently don't prohibit the same select item from occurring mutiple times:\n    $select=Addresses,Addresses\nSo we should probably allow it regardless of syntax:\n    $select=Addresses/City,Addresses($select=City)\n\nAlso, note that this issue is not just restricted to $select. We now have the ability to specify a set of options for the same property, once in $select and once in $expand:\n$select=Address($expand=Residents($select=StartsWith(Name,'B')))$expand=Address/Residents($filter=StartsWith(Name,'A'))\n\n### Proposal\n\nDefine a rule that the same property cannot have options applied in more than one place.  So you can't have both select and expand options applied for the same property and can't have multiple select options applied for the same property (we already disallow mutiple expand options for the same property).\n\nImported from [ODATA-1118](https://issues.oasis-open.org/browse/ODATA-1118)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "4.01 services should support $select select option in Intermediate",
    "body": "In OData-1105 we introduced $select options.  The initial motivation for this was to provide an alternate, more concise way to specify the subset of properties of a complex type that was consistent with $expand.  Arguably, this is how nested $select properties should have been done in 4.0.\n\nOnce we introduced the syntax that was more consistent with $expand, we also discovered that some of the $expand query options could quite naturally apply to collections of structural properties as well, and added things like $filter, $orderby, $search, etc.\n\nWhen deciding where to put this new functionality in the conformance section, we made these new nested select options a SHOULD in 4.01 intermediate, and a MUST in 4.01 Advanced, since nesting $filter, $orderby, etc. within the $select represented new advanced functionality that we didn't want to make required in intermediate.\n\nHowever, we kinda forgot the initial purpose of the issues, which was to provide a more concise and consistent syntax for selecting a subset of fields within a complex type.\n\nIn order for clients to reliably take advantage of this new syntax, that (for nested $select) doesn't introduce any additional functionality, we should make support for the 4.01 syntax be at the same level as the 4.0 syntax; that is, supporting $select as a select option should be required in intermediate for a 4.01 service.\n\n\n### Proposal\n\nAdd to 4.01 Intermediate conformance level, that Services MUST support the $select select option for selecting a subset of properties of a complex type.\n\nImported from [ODATA-1117](https://issues.oasis-open.org/browse/ODATA-1117)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Introduce $this for referencing current item in $select/$expand options",
    "body": "In OData-1105 we introduced $select options which enabled filtering a collection of structural properties.  Where the collection is a collection of complex types, you can now do something like:\n\nCustomers?$select=Addresses($filter=City eq 'Paris')\n\nHowever, we don't have a way to filter primitive types.\n\nWe also don't have a way, in $select or $expand, to pass the current item into a function without binding the function to the type of the current item.\n\nWe already have $it that references the resource identified by the last segment of the resource path, but in this case we want to reference the property on which the select/expand options are specified.\n\n### Proposal\n\nadd $this to specify the property (or navigation property) on which the select (or expand) option is specified.\n\nThis supports patterns like:\nMe?$select=PhoneNumbers($filter=StartsWith($this,\"425\"))\nMe?$expand=Friends($filter=ns.IsAGoodGuy($this))\nMe?$expand=Friends(@a=$this;$expand=Friends($filter=Friends/Any(f:f/Friends eq @a)))\n\nThe last one would (I think) return all of my friends, and all of their friends that have them as a friend. \n\nImported from [ODATA-1116](https://issues.oasis-open.org/browse/ODATA-1116)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Default values for $Precision and $Scale",
    "body": "After aligning the default for $Nullable with OpenAPI and JSON Schema, we should do the same with $Precision and $Scale\n\n### Proposal\n\n$Scale defaults to \"variable\". This is in line with the \"number\" type of OpenAPI and JSON Schema.\n\n$Precision does not have a default value, omission means arbitrary precision, both for Edm.Decimal (already the case) and for temporal types. The latter is in line with the \"date-time\" format of OpenAPI and JSON Schema for timestamps.\n\nImported from [ODATA-1115](https://issues.oasis-open.org/browse/ODATA-1115)",
    "labels": [
      "CSDL JSON",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "If-Then-Else in $batch requests",
    "body": "Add an If-Then-Else construct to batch requests that allows executing a sequence of requests depending on a condition, typically the HTTP status code of a preceding request\n\nExample 1:\n1. Book specific seat for a sports event\n2. if booking failed\n   2.a. book best-match seat for a sports event\n   endif\n\nExample 2:\n1. Modify shopping cart\n2. Convert shopping cart to purchase order (bound action)\n3. if success\n   3.a. GET newly created purchase order\n   else\n   3.b. GET modified shopping cart\n   endif\n\n### Proposal\n\nAdd an optional \"if\" member to request objects that allows specifying a condition for executing the request depending on the outcome of preceding requests. \n\nThe value of \"if\" is a string containing a boolCommonExpr as in $filter that can reference preceding requests listed in \"dependsOn\". It replaces the default condition of \"all preceding requests listed in dependsOn have succeeded\".\n\nFilter expression syntax is extended, additional expressions are\n- `$<content-id>/$succeeded` to check if the referenced request succeeded \n- `$<content-id>` to reference the response body\n- `$<content-id>/<path>` to reference a part of the response body\n\nDefine new property  `RequestDependencyConditionsSupported` -`ConditionalRequestsSupported`- for `Capabilities.BatchSupportType` to advertise this new capability.\n\nIf a service does not support \"if\" the conditional request MUST fail and if the conditional request is part of an atomicity group, that group fails and is rolled back.\n\nImported from [ODATA-1114](https://issues.oasis-open.org/browse/ODATA-1114)",
    "labels": [
      "JSON Format",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Default page size for server-driven paging",
    "body": "Add new term to Capabilities or Core vocabulary to describe the default page size used for server-driven paging.\n\n### Proposal\n\nAdd new term \n\n      <Term Name=\"DefaultPageSize\" Type=\"Edm.Int32\" AppliesTo=\"EntitySet\">\n        <Annotation Term=\"Core.Description\" String=\"Default number of items in partial responses for server-driven paging.\" />\n      </Term>\n\nImported from [ODATA-1112](https://issues.oasis-open.org/browse/ODATA-1112)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Structural properties: default for $Nullable is false in CSDL JSON",
    "body": "Section 7.2.1 incorrectly states that an omitted $Nullable member means \"false\". This is contrary to its CSDL XML default as well as the default for $Nullable for parameters, return types, and navigation properties.\n\nhttp://docs.oasis-open.org/odata/odata-csdl-json/v4.01/csprd01/odata-csdl-json-v4.01-csprd01.html#sec_Nullable\n\n### Proposal\n\nSimplify the handling of null values in JSON by making $Nullable false the default value for all usages in JSON CSDL.  Additionally, we clarify the meaning of $Nullable = true for a collection (that it allows null values within the collection) and disallow $Nullable=true for collection-valued navigation properties.\n\nImported from [ODATA-1111](https://issues.oasis-open.org/browse/ODATA-1111)",
    "labels": [
      "CSDL JSON",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify that 'parameter' aliases can also be used to substitute expressions",
    "body": "11.2.6.1.3 Parameter Aliases specifies that \"Parameter aliases allow the same value to be used multiple times in a request and may be used to reference primitive values, complex, or collection values\" yet in both Example 67 and Example 79 we ourselves show that aliases can also be used to substitute expressions, something which my developers deem is against what's been specified in 11.2.6.1.3, hence the ask for clarification.\n\n### Proposal\n\nQuery parameters for $filter segment are always passed in as expressions (because that is the expected type of the parameter).  All other parameters defined as query options are evaluated in the context of the resource identified by the URL path segment in which they are used and passed as literals into the expression.\n\nAdd ability to assign values to parameter aliases within $expand, in which case they are evaluated relative to the resource context of the $expand. Also consider adding to $select when considering [ODATA-1105](https://issues.oasis-open.org/browse/ODATA-1105).\n\nImported from [ODATA-1109](https://issues.oasis-open.org/browse/ODATA-1109)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Disallow empty parens for implicit parameter syntax",
    "body": "In [ODATA-763](https://issues.oasis-open.org/browse/ODATA-763) we introduced a simplified syntax for invoking a function with implicit parameters.  While the proposal in [ODATA-763](https://issues.oasis-open.org/browse/ODATA-763) called for omitting the parens in this case, the application seems to have made the parens optional.\n\nNote that we have also made the parens optional for the case where there are no parameters to be passed to the function.\n\n### Proposal\n\nProhibit parens following the function name in the implicit parameter case.\n\nImported from [ODATA-1108](https://issues.oasis-open.org/browse/ODATA-1108)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Introduce mechanism for selecting default properties",
    "body": "Today, in the absence of $select, services can return a default set of properties that is a subset of the full set of available properties.\n\nClient can use $select=* to select all properties, but there is no way to select default properties plus one or two (potentailly non-default) properties, such as:\n\n$select=<default>,Address\n\n### Proposal\n\nPropose no action at this time; re-open if we come up with compelling client scenarios.\n\nImported from [ODATA-1106](https://issues.oasis-open.org/browse/ODATA-1106)",
    "labels": [
      "URL Conventions"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Simplify selection of properties of complex type",
    "body": "Currently, properties of complex types are individually selected, as in:\n$select=Name,Address/City,Address/State,Address/Zip\n\nWe could simplify the syntax for selecting individual properties of a complex type, similar to expand options.  Something like:\n$select=Name, Address($select=City,State,Zip)\nor\n$select=Name, Address(City,State,Zip)\n\nThe first syntax would support adding the ability, for example, to $filter or $sort a collection of complex types.\n\nWe could put $compute (or an inline expression) in the $select in as a scoped value (couldn't be used in filter/sort).\n\nPutting $expand in $select brings in all the issues of combining $expand and $select and results in two ways of doing expand.  \n\n### Proposal\n\nHarmonize syntax for complex properties within $select with syntax for navigation properties within $expand:\n- complex property can be followed by parentheses containing\n  - $expand nested in $select.  \n  - $select with same recursive syntax\n  - $compute to place computed properties within the complex type\n  - for collection-valued structural properties also $filter, $search, $count, $orderby, $skip, and $top within the parentheses\n  - support assigning values to parameter aliases within $select\n\nExtended $select syntax also allowed for $select nested within $expand.\n\n\nImported from [ODATA-1105](https://issues.oasis-open.org/browse/ODATA-1105)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Make \"@\" optional for implicit parameters",
    "body": "Similar to making the $ optional for system query options, make the \"@\" optional for query options representing parameters. Define precedence rules for resolving potential ambiguity.\n\n### Proposal\n\nMake the \"@\" prefix for implicit parameters optional.  \n\n    GET http://host/service/EmployeesByManager?ManagerID=3 \n\nIf the parameter matches a system query option, the system query option is used.  To be unambiguous and future proof, use the \"@\" prefix.\n\nKeep the \"@\" prefix in the path for explicitly introduced parameter aliases in order to disambiguate within the path, and in the query option to match the alias within the path.\n\nImported from [ODATA-1104](https://issues.oasis-open.org/browse/ODATA-1104)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Special values of temporal types (public comment c201708e0003)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201708/msg00003.html\nFollow-up to https://lists.oasis-open.org/archives/odata-comment/201707/msg00002.html / [ODATA-1091](https://issues.oasis-open.org/browse/ODATA-1091)\n\nThe addition of INF/-INF for date types does introduce a new ambiguity in the primitiveLiteral syntax though.\n\nIf I parse the value INF in an _expression_ I don't know if it is meant to be a numeric or a Date (or DateTimeOffset) type.  Numeric types can all be cast to each other (within limits) so it doesn't actually matter but in the proposed 4.01 my parser is likely to parse INF as doubleValue (or decimalValue now) and then, when attempting to use it in a context where a DateTimeOffset is required, the cast will fail and result in NULL.\n\nThe guidance here is interesting on whether to attempt INF/-INF with dates (look past the accepted answer too):\nhttps://stackoverflow.com/questions/8011914/how-to-represent-end-of-time-in-a-database\n\nPostgreSQL does use Infinity for both date types but (curiously) these special values appear to be timestamps internally (and will cast to Date as required) whereas the equivalent numeric values must be quoted (as strings) and presumably rely on cast from string to numeric.\n\nIt's a tight corner!  The trouble is that primitiveLiteral has set out to enable numeric types and date types to be parsable without any special quoting which rules out any common representations (of non-castable types).\n\nGiven that you have maxdatetime and mindatetime as functions are you now going to have maxdatetime() return INF?  Or is there now a value of DateTimeOffset that compares greater than maxdatetime()?\n\nReferring to the SO thread, it feels like you are trying to implement both patterns at once.  If you're committed to maxdatetime I suggest sticking with that.  Otherwise, promote maxdatetime/mindatetime to being a special value (of type DateTimeOffset) instead of being a function.  You will need maxdate and mindate too.\n\nSteve\n\n### Proposal\n\nRevise proposal from 8/24/2017 meeting:\n\nI propose we resolve OData-1103 by removing the support for INF and -INF for the temporal data types added in OData 4.01.\n\nImported from [ODATA-1103](https://issues.oasis-open.org/browse/ODATA-1103)",
    "labels": [
      "ABNF",
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Multiplication and division of Edm.Decimal: result has floating scale if either operand has floating scale",
    "body": "We already have the special rule that if either operand of multiplication or division is decimal with variable scale, the result is decimal with variable scale.\n\nWe need to add floating scale to the mix.\n\n### Proposal\n\nFloating scale dominates, then variable scale, then fixed scale.\n\nImported from [ODATA-1102](https://issues.oasis-open.org/browse/ODATA-1102)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "The hash (#) character is not allowed in search phrases per the ABNF definition",
    "body": "The hash character (#) has meaning in both a URL and in OData so it makes sense that the hash character is not allowed in a search word.  I would have expected though that the hash character could be used in a quoted search phrase, but the ABNF definition for search phrase does not include the hash character.\n\nsearchPhrase = quotation-mark 1*qchar-no-AMP-DQUOTE quotation-mark\n\nqchar-no-AMP-DQUOTE   = qchar-unescaped \n                      / escape ( escape / quotation-mark )\n\nqchar-unescaped       = unreserved / pct-encoded-unescaped / other-delims / \":\" / \"@\" / \"/\" / \"?\" / \"$\" / \"'\" / \"=\"\n\nunreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\nother-delims   = \"!\" /                   \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\"\n\nNone of those definitions include the hash character.  Was the hash character left out on purpose?  Is the only way to include it to percent encode it?\n\n### Proposal\n\nClarify that # characters in search phrases have to be percent-encoded because the first clear-text occurrence of the hash character (#) ends the query part of a URL and starts the fragment part, see https://tools.ietf.org/html/rfc3986#section-3.5. \n\nImported from [ODATA-1101](https://issues.oasis-open.org/browse/ODATA-1101)",
    "labels": [
      "ABNF"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add mechanism for specifying match type for $search",
    "body": "When doing text searches, many of the common algorithms we use have a number of different ways to define a match (Exact match, begins with, synonym, base word or inflection, etc).  The spec currently says it is up to the implementation as to what constitutes a match, this is fine, but in the case where the search algorithm provides different matching types it would be nice if the query writer could specify the type of match they want in the $search expression.\n\n\n\n### Proposal\n\nAdd “search modifiers” which consist of a letter sequence immediately followed by a colon and immediately followed by anything except space, parentheses, and an ampersand\n\nsearchTerm   = searchModifier / [ 'NOT' RWS ] ( searchPhrase / searchWord )\nsearchPhrase = quotation-mark 1*qchar-no-AMP-DQUOTE quotation-mark\n\nsearchModifier = searchOperator COLON searchOperand\nsearchOperator = 1*ALPHA\n; A searchOperand is a sequence of anything except ampersand, space, and parentheses, in clear-text or percent-encoded\n; Expressing this in ABNF is somewhat clumsy, so the following rule is overly generous.\nsearchOperand  = 1*qchar-no-AMP-parens\n\nThis would allow expressing e.g. a fuzziness factor or a matching algorithm\n\n$search=hello fuzzy:0.8 match:synonym\n\nAlternative: restrict search operands to search phrases (enclosed in double quotes) and search words:\n\nsearchOperand = searchPhrase / searchWord\n\n\nImported from [ODATA-1100](https://issues.oasis-open.org/browse/ODATA-1100)",
    "labels": [
      "Protocol"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add annotations to describe custom query options and custom headers",
    "body": "Some services support custom query options, either across the board, or for specific resources or resource types.\n\nOther services support or even require custom headers, e.g. for CSRF protection.\n\nWe need a way to express in metadata which custom query options and custom headers are available / required where.\n\n### Proposal\n\nSee [https://github.com/oasis-tcs/odata-vocabularies/blob/[ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099)/vocabularies/Org.OData.Capabilities.V1.md#CustomHeaders]\n\n2018-1-0: Proposal amended by unanimous consent to restrict the \"AppliesTo\" to \"EntityContainer\". This allows us to specify global (service-wide) query options or headers. Resource-specific header and query option requirements can be applied through the HttpRequests annotation term defined in [ODATA-884](https://issues.oasis-open.org/browse/ODATA-884). Update the applied change to restrict to \"EntityContainer\" and update description to specify that they are applied to service.\n\n \n\n2019-2-14: Ammend proposal to change \"RetrieveRestrictions\" to \"ReadRestrictions\"\n\nImported from [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "xxxRestrictions can be applied more broadly",
    "body": "The following terms may be applied to EntityTypes\n- NavigationRestrictions : affects implementation of navigation properties \n- ExpandRestrictions : affects implementation of navigation properties \n- UpdateRestrictions : enables use of PATCH on an instance of the type\n- DeleteRestrictions : enables use of DELETE on an instance of the type\n\n\n\n\n### Proposal\n\nRemove EntityType and Collection previously added to the AppliesTo array for each of these restrictions.\n\nImported from [ODATA-1098](https://issues.oasis-open.org/browse/ODATA-1098)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "14.4.1.1 Path Syntax: add odata.mediaETag",
    "body": "We allow only three of the for odata.media* control information names in \"term casts\", and omit the odata.mediaETag.\n\n### Proposal\n\nAdd odata.mediaETag to list of now four special values\n\nImported from [ODATA-1097](https://issues.oasis-open.org/browse/ODATA-1097)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "9.1.4 Response Code 204 No Content: rephrase second paragraph",
    "body": "The second paragraph of section 9.1.4 is a quote from RFC7231 and somewhat hard to parse. Replace it with text that expresses its intention: send an ETag only if the client can reasonably \"know\" the current entity representation that has not been sent in the response:\n\n(1) For a PUT request: if the response body of a corresponding 200 response would have been identical to the request body, i.e. no server-side modification of values sent in the request body, no \"calculated\" values. \n\n(2) We could extend this to PATCH requests and if a corresponding 200 response would have consisted of\n- values sent in PATCH request body, plus \n- server-side values corresponding to ETag sent in If-Match header of PATCH request (for values not sent in PATCH request body)\n\nImported from [ODATA-1096](https://issues.oasis-open.org/browse/ODATA-1096)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow empty edm:Schema elements",
    "body": "The current XML Schema for the EDM namespaces requires the edm:Schema element to contain at least one child element.\n\nThis is problematic in at least two use cases:\n- OData API Designer tools - when starting with a \"blank page\"\n- Services that \"shrink\" the schema to match user authorization - when the current user isn't allowed to see anything\n\nBoth require workarounds, e.g. having a dummy annotation in the schema telling that \"this schema is intentionally empty\".\n\n### Proposal\n\nSet minOccurs to zero (is currenty 1):\n\n  <xs:element name=\"Schema\">\n    <xs:complexType>\n      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n\n\nImported from [ODATA-1095](https://issues.oasis-open.org/browse/ODATA-1095)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Apply expression: allow all URL functions with prefix odata.",
    "body": "Currently the Apply annotation expression only lists four client-side functions, one of them being odata.concat, with the same semantics as the concat() URL function, including implicit cast of primitive operands to strings.\n\nThis will make the URL expression language and annotation expression language isomorphic.\n\n### Proposal\n\nGeneralize this to allow all URL functions, prefixed with odata., e.g. odata.day, odata.now, and refer to Part 2 for the definition of the function semantics.\n\nAllow Apply expressions with zero arguments (for odata.now).\n\nImported from [ODATA-1094](https://issues.oasis-open.org/browse/ODATA-1094)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "DMTF needs a feature to allow the schema references to become references to a local files.  Use cases include testing and implementations that do not allow access to the web.",
    "body": "DMTF needs a feature to allow the schema references to become references to a local files.  Use cases include testing and implementations that do not allow access to the web.\n\n### Proposal\n\nLooking for recommendations\n\nImported from [ODATA-1093](https://issues.oasis-open.org/browse/ODATA-1093)",
    "labels": [
      "CSDL JSON",
      "CSDL XML"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Navigation Property Binding (public comment c201707e0004)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201707/msg00004.html\n\nThis comment concerns navigation property bindings.  There are two parts, a general issue with 4.0 and a similar issue that has been introduced with 4.01.  The comment refers to:\n\nOData Common Schema Definition Language (CSDL) XML Representation Version 4.01\nCommittee Specification Draft 02 / Public Review Draft 02\n\n§ 8.4 says:\n\n> Containment navigation properties define an implicit entity set for each instance of its declaring structured\n> type\n\n§ 13.4 says:\n\n> If the entity type of an entity set or singleton declares navigation properties, a navigation property binding\n> allows describing which entity set or singleton will contain the related entities\n\nIt therefore makes sense that a Binding Target must identify a single entity set.\n\nMy issue is that this path is allowed to be a path to any \"containment navigation property in scope\".  Such a path only identifies an entity set uniquely in cases where the path includes a singleton.  If the path includes an EntitySet then, as per 8.4, it will be pointing to a set of EntitySets, one per entity instance.  \n\n§ 15.4 contains an example that highlights the problem:\n\n> MySchema.MyEntityContainer/MyEntitySet/MyContainmentNavigationProperty\n\nThis issue applies to both version 4.0 and 4.01.  The resulting navigation property is only weakly bound.  Anyone attempting to validate a link must exhaustively search every instance of MyEntitySet to determine the validity of the link.  You also have the strange situation that a bound navigation property may link to two different entities WITH THE SAME KEY.  (There is no requirement that keys are unique across entity sets.) This contravenes one of the methods of addressing entities in URLs:\n\nOData Version 4.01. Part 2: URL Conventions § 4.9\n\n> For [ ... ] collection-valued navigation properties with a NavigationPropertyBinding or ContainsTarget=true specification, members of the collection can be addressed by convention by appending the parenthesized key to the URL specifying the collection of entities\n\nSo the above is already a problem IMO and I propose that the target paths be restricted to traversing Singletons (that is, if an entity set is specified it must be the last component of the path).\n\nComing on to the new issue in 4.01...\n\nVersion 4.01 has modified the way navigation bindings work to allow a single navigation property to be bound, simultaneously, to multiple entity sets based on the type of the target.  Straight away this triggers the same issue, that bound navigation properties no longer have unique keys.\n\nI'm unhappy with the idea that a binding may now bind to multiple entity sets as it would involve removing the ability to append a key to uniquely identify an entity via a (bound) navigation path.  It isn't clear what problem you're trying to solve here but it feels like it is best solved using multiple navigation properties rather than attempting an 'octopus binding'.\n\nEven if you allow a single bound navigation property to bind to multiple entity sets the new feature creates the possibility of a partially bound navigation property.  If I have a navigation property called A of type Collection(TypeA) and TypeA has two sub-types, TypeB and TypeC then we can now bind any of the following:\n\nA\nA/TypeA\nA/TypeB\nA/TypeC\n\nThe most specific rule applies so the last two rules override the first two but if we only bind A/TypeC then any instances of TypeB linked to A are unbound.  The result is a partially bound navigation property.  This could be corrected by requiring a default binding (with no type cast segment) if a type-cast binding is provided.\n\nHopefully helpful.\n\nSteve\n\n### Proposal\n\n13.4.2 Binding Target\n\nClarify that a containment navigation property can only be a target if it directly or indirectly belongs to a singleton - inserted text in square brackets:\n\n    If the target is a target path, it MUST resolve to an entity set, singleton, or\n   [direct or indirect] containment navigation property [of a singleton] in scope.\"\n\n15.4 Target Path - Example 67\n\nReplace \"MyEntitySet\" with \"MySingleton\" in third and fourth example to avoid confusion.\n\n\n13.4.1 Binding Path and 13.4.2 Binding Target - Example 37\n\nPart 3) of [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674) was not applied - binding path may traverse collection-valued segments, binding applies to all members. Example 37 is supposed to show this. Add missing text for Part 3) of [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674) and refer to it in example 37.\n\n[If the path traverses collection-valued complex properties or collection-valued containment navigation properties, the binding applies to all items of these collections.]\n\n\n13.4.1 Binding Path with type-cast segment (\"octopus binding\") and Part 2, 4.9 Addressing a Member within an Entity Collection\n\nWe retain \"octopus binding\" with the semantics that:\n1) If there is a single nav prop binding with no type, you can reference members by appending the key to the nav prop.\n2) If there is a nav prop binding with a type, you must include the type when appending the key segment to the nav prop.\n3) If you want to know if you can append the key to the nav prop, you should really be looking at IndexableByKey annotation in the capabilities vocabulary. \n4) If no binding matches an instance, it is unbound (same semantics as no navigation property binding today).\n\n\nImported from [ODATA-1092](https://issues.oasis-open.org/browse/ODATA-1092)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Special values of numeric types (public comment c201707e0002)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201707/msg00002.html\n\nComment on: 4.01 Committee Specification Draft 02 / Public Review Draft 02\n\nOne of the new provisions in 4.01 is:\n\nAll numeric types allow the special numeric values ‑INF, INF, and NaN\n\nThis feels onerous given typical technologies for storing integer numeric types.  The ABNF for values of Int16, for example, now reads:\n\nint16Value = [ SIGN ] 1*5DIGIT  / nanInfinity ; numbers in the range from -32768 to 32767\n\nClearly this now requires MORE than 16 bits to store.\n\nGiven that the numeric integer types are typically used as keys for entities there are some odd implications too.  Clearly the definitions of INF and -INF can still work as they compare equal to themselves and top/tail the value range when ordering.  I'm more concerned about NaN which doesn't compare equal to itself, this is likely to cause issues if it is used as the value of an entity key.  (I believe PostgreSQL allows these values as keys but treats Nan == Nan as true and Nan > x as true for all x != Nan, this goes against IEEE but seems necessary if they are to be used in context where ordering is required.)\n\nTo use XML schema vocab, it feels like the abstract values and lexical representations have become muddled.  The desire to use special values in JSON representations of integers has serious implications for the abstract value space.\n\nThe 'special' values INF, -INF and NaN are actually values in the abstract value spaces of Single and Double types (as per IEEE, extendable to Decimal).  They are not universal special (numeric) values with a status similar to 'null'.  It feels like the language of the specification is sliding toward treating all of these in a similar way.  Witness the definition of equals in Part 2 §5.1.1.1.1\n\nEach of the special values null -INF, and INF is equal to itself, and only to itself.\nThe special value NaN is not equal to anything, even to itself.\n\nYou might find this SO answer in relation to C++ interesting: https://stackoverflow.com/questions/38795544/is-casting-of-infinity-to-integer-undefined I particularly like the parenthetical comment...\n\ntruncation of infinity is still infinity, and infinity cannot be represented in int (I hope there's no question about this part)\n \nThere's a serious point to this quote though.  W.r.t. https://issues.oasis-open.org/browse/[ODATA-785](https://issues.oasis-open.org/browse/ODATA-785) I reject point (2) in the working proposal (add +inf/-inf/nan to int) for this reason.\n\nMy proposal is to clarify that the 'special' numeric values are values of type Single, Double or Decimal only.  You already have sufficient type promotion to resolve any ambiguity when parsing the literals.  For example, the less contentious promotion of the constant parsed from the string \"42\" to any of the numeric types is already accepted without the special modifiers used in OData 2/3.\n\nThe second part of my proposal is that if the abstract result of an operation cannot be represented in the return type defined for that operation then the result should be the special value null.  This would include the special case of integer division by zero (where 4.0 says the request fails) but also covers overflow of integers in other operations.  I sense the panel dislikes failing requests so my proposal fixes that by silently carrying on - the alternative is to continue to raise an exception or put in some more general provision that says that an _expression_ that fails with a division by zero is treat as null (WITHOUT continuing the computation).  The latter version has less of an impact on existing behaviour in 4.0 I guess so might be worth considering.\n\nThe NULLIF pattern for treat division by 0 as null is fairly widespread though and it is more consistent with the definition of cast:\n\n§5.1.1.10.1\n\nNumeric primitive types are cast to each other with appropriate rounding. The cast fails if the integer\npart doesn't fit into target type.\n...\nIf the cast fails, the cast function returns null.\n\nAs a follow-up point on your open issue: https://issues.oasis-open.org/browse/[ODATA-919](https://issues.oasis-open.org/browse/ODATA-919)\n\nThe idea of doing general type promotion to the largest integer type makes sense to me, if the result overflows Int64 then you'd get null (according to my proposal) which is freely castable to any of the integer types.\n\nBut I propose that Single operations that overflow Single results should be promoted to Double in a similar way.  The definition of cast will need to be modified to allow for the cast of a Double to Single with overflow resulting in INF (not a failed cast).  The proposed difference between the way integers and floating point numbers behave in this respect is precisely because the latter can represent INF.\n\nHope this helps.\n\nSteve Lay\nhttps://www.pyslet.org/\n\n### Proposal\n\n1) Restrict the 'special' numeric values to types Single, Double, and Decimal (scale=floating), partly revoking [ODATA-920](https://issues.oasis-open.org/browse/ODATA-920)\n\n2) keep 4.0 behavior for div operator - fail for division by zero for dividends other than Single, Double, and Decimal(Scale=floating)\n\n3) support fail-safe division by zero (resulting in -INF, INF, or null) for all numeric types only in the new divby operator\n\nImported from [ODATA-1091](https://issues.oasis-open.org/browse/ODATA-1091)",
    "labels": [
      "ABNF",
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify text about referential constraint for navigation properties on complex types",
    "body": "As pointed out in https://groups.google.com/forum/#!topic/odata-discussion/God4fXB_mrw the prose text on dependent properties is geared to navigation properties declared by entity types and confusing for navigation properties declared by complex types.\n\n### Proposal\n\nUse \"dependent instance\" and point out that referential constraints can only be defined for properties \"next\" to the navigation property, i.e. paths in the Property attribute are resolved starting at the structured type declaring the navigation property.\n\nImported from [ODATA-1090](https://issues.oasis-open.org/browse/ODATA-1090)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Org.OData.Aggregation.V1 missing Nullable=\"false\" for Function ReturnType",
    "body": "Function elements like:\n\n      <Function Name=\"isroot\" IsBound=\"true\">\n        <Annotation Term=\"Core.Description\"\n          String=\"Returns true, if and only if the value of the node property of the specified hierarchy is the root of the hierarchy\" />\n        <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\" />\n        <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\" />\n        <ReturnType Type=\"Edm.Boolean\" />\n      </Function>\n\nare missing Nullable=\"false\" in the ReturnType elements.\n\nClearly it wasn't intended for these functions to return nullable Boolean values, so this should be fixed.\n\n\n\nImported from [ODATA-1089](https://issues.oasis-open.org/browse/ODATA-1089)",
    "labels": [
      "Data Aggregation",
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify effect of applying an Annotation to an element",
    "body": "My assumption is that an annotation applied to a schema element will apply to all instances of that schema element.\nThere are some examples where groups are proposing to apply annotations to specific schema instances.\n\n### Proposal\n\nChapter 14 of the CSDL specifications\n\nMetadata annotations are terms applied to model elements. Behaviors or constraints described by a metadata annotation must be consistent with the annotated model element. Such annotations define additional behaviors or constraints on the model element, such as a service, entity type, property, function, action, or parameter. For example, a metadata annotation may define ranges of valid values for a particular property.\n\nAn instance annotation is a term applied to a particular instance within an OData payload as described in [OData‑JSON]. An instance annotation can be used to define additional information associated with a particular result, entity, property, or error. For example, whether a property is read-only for a particular instance.\n\nImported from [ODATA-1088](https://issues.oasis-open.org/browse/ODATA-1088)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Discourage names differing only in case",
    "body": "When defining a schema, names differing only in case (e.g. names for structural and navigation properties within an EntityType) can reasonably expected to cause issues when mapped to a target programming language that has case-insensitive identifiers.\n\n### Proposal\n\nStrongly discourage names to be defined within a schema/type that differ only in case.\n\n\nImported from [ODATA-1087](https://issues.oasis-open.org/browse/ODATA-1087)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "AppliesTo semantics are not normative",
    "body": "The term attribute AppliesTo is documented in section \"14.1.2 Applicability\" in a way that has been interpreted to mean that the AppliesTo values are merely recommendations.  From a specification point of view, this renders the AppliesTo attribute having no semantic value.\n\nI expected that the intent is that AppliesTo values are normative restrictions, but that the set of values may be changed in future versions of the vocabulary.\n\n\n\n\n### Proposal\n\nModify 14.1.2 Applicability as follows:\nThe AppliesTo attribute MAY be used to restrict a term to a list of model elements that the term may be applied to. If no list is supplied, the term is not intended to be restricted in its application. The list of elements may be extended in future versions of the vocabulary.  As the intended usage may evolve over time, clients SHOULD be prepared for any term to be applied to any model element and SHOULD be prepared to handle unknown values within the AppliesTo attribute.\n\nImported from [ODATA-1086](https://issues.oasis-open.org/browse/ODATA-1086)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Rule searchWord is too restrictive",
    "body": "The searchWord rule is overly restrictive as it only allows ALPHA and DIGIT whereas the comment states that any Unicode letter or number is allowed.\n\nIn other places where the ABNF does not exactly describe the syntax, it allows a superset that is then further restricted by the prose specification.\n\n### Proposal\n\nExtend searchWord rule to allow percent-encoded octets. Add comment that this actually is limited to Unicode letters and numbers:\n\n; searchWord is a sequence of one or more letters, digits, commas, or dots\n; this includes Unicode characters from the Unicode categories L or N using UTF-8 and percent-encoding\n; the words AND, OR, and NOT are not a valid searchWord\n; expressing this in ABNF is somewhat clumsy, so the following rule is overly generous\nsearchWord   = 1*( ALPHA / DIGIT / COMMA / \".\" / \"%\" HEXDIG HEXDIG )\n\n\nImported from [ODATA-1084](https://issues.oasis-open.org/browse/ODATA-1084)",
    "labels": [
      "ABNF",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add annotation expressions for arithmetic operators ",
    "body": "In order to express validation rules, see [ODATA-1082](https://issues.oasis-open.org/browse/ODATA-1082), it would be helpful to also have arithmetic operators in addition to the comparison and logical operators\n\n### Proposal\n\nAdd dynamic expressions for all arithmetic operators defined in Part 2: URL Conventions.\n\nAlso add the new logical operators \"has\" and \"in\".\n\nImported from [ODATA-1083](https://issues.oasis-open.org/browse/ODATA-1083)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add term Constraint to Validation vocabulary",
    "body": "Communicating validation rules to the clients helps reduce the number of failed requests in API as well as UI scenarios.\n\nBesides the elementary rules Minimum, Maximum, Pattern, ... it would be helpful to allow expressing more complicated validation rules that involve logical and arithmetic expressions.\n\n### Proposal\n\nAdd new term\n\n<Term Name=\"Constraint\" \n           Type=\"Validation.ConstraintType\" \n           AppliesTo=\"Property EntityType ComplexType\">\n    <Annotation Term=\"Core.Description\" String=\"Condition that the annotation target has to fulfill\" />\n</Term>\n<ComplexType Name=\"ConstraintType\">\n    <Property Name=\"FailureMessage\" Type=\"Edm.String\" Nullable=\"true\">\n        <Annotation Term=\"Core.IsLanguageDependent\" />\n    </Property>\n    <Property Name=\"Condition\" Type=\"Edm.Boolean\" Nullable=\"false\">\n        <Annotation Term=\"Core.Description\"\n              String=\"Value MUST be a dynamic expression that evaluates to true if and only if the constraint is fulfilled\" />\n    </Property>\n</ComplexType>\n\nExample:\n\n <Annotation Term=\"Validation.Constraint\" Qualifier=\"Comparison\">\n    <Record>\n        <PropertyValue Property=\"FailureMessage\" String=\"Start date cannot be after end date\" />\n        <PropertyValue Property=\"Condition\">\n            <Le>\n                <Path>StartDate</Path>\n                <Path>EndDate</Path>\n            </Le>\n        </PropertyValue>\n    </Record>\n</Annotation>\n\n\n\nImported from [ODATA-1082](https://issues.oasis-open.org/browse/ODATA-1082)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Remove restriction on overriding of annotations on type definitions",
    "body": "CSDL XML states in section 11.1 that\n\n\"The use of a type definition MUST NOT specify an annotation specified in the type definition.\"\n\nThis would prevent e.g. to annotate a label \"Email Address\" on a type definition and then annotate a label \"Main Email Address\" on a property typed with this type definition. \n\n### Proposal\n\nReplace the text describing how annotations applied to type definitions are evaluated and restriction on overriding in section 11.1 with equivalent wording from section 14.2 on annotation propagation.\n\nImported from [ODATA-1081](https://issues.oasis-open.org/browse/ODATA-1081)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "$each as wildcard for keys",
    "body": "There is a use case for specifying wildcards when processing a URL for use in requests.  Typically this is outside of OData, but it seems relevant to the use of $each.  So we want to vet it here.\n\nFor example, consider the following JSON: \n\t\"Wildcards\": [ \n\t\t{ \t\"Name\": \"allSS\",\n\t\t\t\"Values\": [\"$each\"] },\n\t\t{ \t\"Name\": \"allV\",\n\t\t\t\"Values\": [\"$each\"] },\n\t\t{ \t\"Name\": \"percentStats\",\n\t\t\t\"Values\": [\"ReadIOPercent\", \"WriteIOPercent\", \"NonIOPercent\"] }\n    ],\n\t\"MetricProperties\": [\n\t\t\"/redfish/v1/StorageServices/Members({allSS})/Volumes/Members({allV})/VolumeStatistics/{percentStats}\"],\n\nIn the case of {allSS} or {allV} one natural specification would be to use \"*\" to mean all keys.  However as shown above, an alternative is to use the $each keyword to mean all.\n\nSo, several questions:\n1) Should $each be available to mean all within parenthesis?  The /$each as a segment is consistent with the alternate key format. \n2) Should we define the wildcard substitution within OData?\n3) For this purpose, should we use \"*\" for all of the above instead of $each.\n\t\t\n\n\n\n### Proposal\n\nAllow one of $each or \"*\" as a wildcard for keys.\n\nImported from [ODATA-1080](https://issues.oasis-open.org/browse/ODATA-1080)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Several issues with latest standard vocabularies",
    "body": "Org.OData.Core.V1.xml\n\n      <ComplexType Name=\"AlternateKey\">\n        <Property Type=\"Collection(Core.PropertyRef)\" Name=\"Key\">\n          <Annotation Term=\"Core.Description\" String=\"The set of properties that make up this key\" />\n        </Property>\n      </ComplexType>\n\n  should have Nullable=\"false\" in the Property\n\nOrg.OData.Temporal.V1.xml\n\n  <Term Name=\"TemporalSupported\" Type=\"Aggregation.TemporalSupportedType\" AppliesTo=\"EntityContainer EntitySet NavigationProperty\"> -->\n\n  should be:\n  \n  <Term Name=\"TemporalSupported\" Type=\"Temporal.TemporalSupportedType\" AppliesTo=\"EntityContainer EntitySet NavigationProperty\">\n\n  8 references to Term=\"Core.Documentation\" should be to Term=\"Core.Description\"\n\n\nImported from [ODATA-1079](https://issues.oasis-open.org/browse/ODATA-1079)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "What happens if lambda variable name matches a (complex) property name?",
    "body": "MUST all paths wthin a lambda operator be prefixed with either a lambda variable name (potentially from an enclosing lambda operator) or $it/ to reference properties of the base set?\nOr is $it/ not required for properties/paths in the base set? Which would require that the lambda operator MUST NOT be identical to any property name in the base set?\nMy inclination would be:\n1) It is not required\n2) In case of conflict, lambda variable name wins (you shouldn't pick a lambda variable name that conflicts...)\n\n### Proposal\n\n1) It is not required \n2) In case of conflict, lambda variable name wins (you shouldn't pick a lambda variable name that conflicts...) \n\nImported from [ODATA-1078](https://issues.oasis-open.org/browse/ODATA-1078)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Include atomicityGroup in JSON Batch Response",
    "body": "When we introduced the JSON format for a batch request we included a property, atomicityGroup, for grouping together requests within the batch that had to be executed atomically, and required that all such requests be adjacent. However that information is lost in the response; if the client wants to know which succeeded or failed as a group (i.e., they want to look for the request that caused a group of atomic requests to fail) they have to remember which requests were associated with which other requests. This is hard for a generic library to track and violates our principle that responses should be able to be fully interpreted without knowing the request that generated it.\n\nThe service has the information for the atomicity group, and must already handle the requests as a group, but the service currently has no way to convey this to the client. It makes sense to have the service return responses with the same atomicityGroup adjacent to one another, including the atomicityGroup identifier, to make it easier for the client to associate requests within a group. \n\n### Proposal\n\nInclude the atomicityGroup id in adjacent responses within a JSON Batch response.\n\nImported from [ODATA-1077](https://issues.oasis-open.org/browse/ODATA-1077)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "If-Match: align wording with RFC7232",
    "body": "The section on If-Match explicitly requires \"weak comparison\" of ETags. \n\nThis was in line with the then current draft of RFC7232, but the final version of RFC7232 requires strong comparison of ETag values for If-Match, see https://tools.ietf.org/html/rfc7232#section-3.1. \n\n\n\n### Proposal\n\nPoint out that we intentionally deviate from RFC7232, and give reason:\n\nIf present, the request MUST only be processed if the specified ETag value matches the current ETag value of the target resource. Services sending ETag headers with weak ETags that only depend on the representation-independent entity state MUST use the weak comparison function because it is sufficient to prevent accidental overwrites. This is a deviation from [RFC7232]. \n\nImported from [ODATA-1076](https://issues.oasis-open.org/browse/ODATA-1076)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Introduce operator for checking whether a collection is a subset or equal to another collection",
    "body": "Currently we \"overload\" the in operator to be \"subset of\" if the left operand is a collection.\n\nThis would block us from introducing collections of collections, and checking whether a collection is an item of a collection of collections.\n\n### Proposal\n\nRestrict \"in\" to mean just \"member of\" \nAdd \"hassubset\" function:\n\n1) hassubset always requires that each element of the right argument occurs at least as many times in the left argument, and that order does not matter so:  \n    hassubset([1,2],[1,1,2])  => false \nhassubset should never take order (or gaps) into account:\n    hassubset([4,1,3],[3,1]) => true \n    hassubset([4,1,3],[4,3]) => true\n\n2) for ordered collections, add a \"hassubsequence\" function that takes order into account and ignores gaps:\n    hassubsequence([4,1,3], [3,1])  => false \n    hassubsequence([4,1,3],[4,3]) => true\n\n3) add support for ordered collections to contains (that takes gaps into account) as well as startswith, endswith, indexof, and substring.\n\n\nImported from [ODATA-1075](https://issues.oasis-open.org/browse/ODATA-1075)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support Functions with /$each and define the representation for collection-valued actions and functions with /$each",
    "body": "Since we added the support to use /$each with actions, we have to define what the result looks like.  It seems reasonable that the result is an array of action results.  What, then, is the shape of the result if the action returns a collection? In order to be annotated with things like count and next link, the result would have to be a collection of value arrays, as in:\n{\"value\":[{\"value\":[{a=1,b=2},{a=2,b=3}]},{\"value\":[{a=4,b=5}]}]}.\n\nOnce we have defined the result of /$each for actions that return results, it seems natural that we support /$each with functions as well.\n\n### Proposal\n\nSupport /$each with functions as well as actions.\nThe result, in json, of a collection-valued function or action applied to /$each is an array of objects, each minimally containing a property named \"value\" whose value is the collection of items returned by the action or function.\n\n$it can be used to reference an item in the outermost collection, which in this case is an instance of an action/function result which may itself be a collection (in which case $it can be followed by /any, /all, or /$count).\n\n\nImported from [ODATA-1074](https://issues.oasis-open.org/browse/ODATA-1074)",
    "labels": [
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Conformance section references wrong annotation term",
    "body": "Regarding sentence: \"They MUST implement all set transformations and aggregation methods they advertise via the Custom Aggregates annotation.\"\nThe correct annotation term is ApplySupported/CustomAggregationMethods\n\n\n### Proposal\n\nReplace \"via the Custom Aggregates annotation\" by \"via the ApplySupported annotation\"\n\nImported from [ODATA-1073](https://issues.oasis-open.org/browse/ODATA-1073)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Annotation to describe supported aggregation methods",
    "body": "A service may support only a subset of all standard and custom aggregation methods advertised in annotation ApplySupported/CustomAggregationMethods for certain aggregatable properties. If deviations from the full set could be annotated at property level, clients would be able to recognize them and avoid requests that will be rejected by the server. In particular, this would also support the special case of an aggregatable property that does not support any aggregation method, but there is a CustomAggregate annotation with the name of the property as qualifier. Then, the property could still be used in the aggregate transformation without \"with\", and could also be annotated with further terms.\n\n\n### Proposal\n\nThis feature should be offered for entity containers and entity sets instead of structure properties, in the same way as we decided for other terms of the Aggregation vocabulary, cf. [ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382)--\n\nImported from [ODATA-1072](https://issues.oasis-open.org/browse/ODATA-1072)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "New term Core.OperationAvailable",
    "body": "Availability of actions and functions can be advertised in response payloads using special name-value pairs starting with a # character.\n\nDefine a new term that allows to express availability of an action or function statically, with reference to \"global\" data, e.g. from a singleton, or with reference to data of the binding parameter.\n\n### Proposal\n\nAdd to the Core vocabulary:\n\n     <Term Name=\"OperationAvailable\" Type=\"Edm.Boolean\" DefaultValue=\"true\" AppliesTo=\"Action Function\">\n        <Annotation Term=\"Core.Description\" String=\"Action or function is available\" />\n      </Term>\n\n\nImported from [ODATA-1069](https://issues.oasis-open.org/browse/ODATA-1069)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "3.12 Transformation expand: require at least two parameters, with innermost expansion requiring a filter()",
    "body": "An expand() transformation without a nested filter() is just a complicated identity transformation, so we should require a filter() for the innermost expand() transformation in a nested expand(). Outer and intermediate expand() don't need a filter() as they are necessary to reach the level where the filter() needs to be applied.\n\n### Proposal\n\nSee summary.\n\nABNF:\n\nexpandTrafo = 'expand' OPEN BWS expandPath BWS COMMA BWS \n              ( expandTrafo *( BWS COMMA BWS expandTrafo )\n              / filterTrafo *( BWS COMMA BWS expandTrafo ) \n              ) BWS CLOSE\n\nImported from [ODATA-1068](https://issues.oasis-open.org/browse/ODATA-1068)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consider ability to define computed default values",
    "body": "Currently, default values for properties and (now, as of [ODATA-1066](https://issues.oasis-open.org/browse/ODATA-1066)) parameters are static values.\n\nThere are some cases where the default value may be the result of a calculation. Examples:\n1) The value of a related property/parameter\n2) An expression based on the value of one (or more) related properties/parameters\n3) The result of invoking a function(import) on the service (with params?)\n\nIssues:  <del>how to express the value of the defaultvalue (use Edm.Untyped? -</del> this could only be supported in 4.01)\n-what is the syntax of the expression?\n-can it invoke a funciton(import) and, if so, how are parameters passed?\n\nFor parameters, could define a derived OptionalParameterType that has a DefaultValueExpression that is Edm.Untyped and only returned as that derived type in a 4.01 payload.\n\n\n### Proposal\n\nOASIS standard term [`Core.ComputedDefaultValue`](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#ComputedDefaultValue) allows tagging properties that have a computed default value without revealing the underlying (and arbitrarily complex) algorithm.\n\nVendor-specific experimental term [`Common.DerivedDefaultValue`](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Common.md#DerivedDefaultValue) allows clients to call server-side logic for computing the default value for a provided context.\n\nImported from [ODATA-1067](https://issues.oasis-open.org/browse/ODATA-1067)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consider supporting optional operation parameters",
    "body": "We have frequently had requests to support optional parameters, but have pushed back because they could introduce ambiguity in function resolution.\n\nHowever, with our current rules:\n1) The unordered set of nonbinding parameter names must be unique, and\n2) The ordered list of nonbinding parameter types must be unique\n\nWe could support making some parameters optional as a backward compatible change with the following resolution rules:\n1) If the set of provided parameters exactly matches all parameters of an overload, then that overload is chosen\n2) If the set of provided parameters matches all required and a subset of optional parameters of exactly one overload, then that overload is chosen\n\notherwise a 400 error\n\nQuestions:\n1) Should we provide a set of rules so there is never any ambiguity (i.e., there does not exist a set of parameters for which one of the two rules above is not met) or specify that the service returns 400 if the request does not resolve to a single overload?\n2) Should we define a default value for optional parameters? This would really just be documentation (the service wouldn't need you to tell it what the default value was in metadata). It could be useful in generating strongly typed function calls in languages with optional parameters (C++, C#,...) but there may not be a static default value that can be specified (i.e., current time, a computed value, etc.)  \n\n### Proposal\n\n1) Add a new OptionalParameter annotation:\n  <Term Name=\"OptionalParameter\" Type=\"Core.OptionalParameterType\" AppliesTo=\"Parameter\"> \n    <Annotation Term=\"Core.Description\" String=\"Supplying a value for the parameter is optional.\" /> \n  </Term>\n\n<ComplexType Name=\"OptionalParameterType\"> \n  <Property Name=\"IsOptional\" Type=\"Edm.Boolean\" DefaultValue = \"true\"/>\n  <Property Name=\"DefaultValue\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"Default value for an optional parameter, using the same rules for the default value facet of a property.\" /> \n  </Property>\n</ComplexType>\n\n2) All parameters marked optional must come after any parameters not marked optional\n\n3) Keep existing rules for function overloads.\n\n4) In function resolution:\n    I) If the set of specified params exactly matches a function overload, chose it.\n    ii) If the set of specified params matches a subset of parameters that includes all required parameters for exactly one function overload, choose it\n\n5) Services should avoid ambiguity. If there is ambiguity then services may return 400 with an error stating that request was ambiguous\n\nImported from [ODATA-1066](https://issues.oasis-open.org/browse/ODATA-1066)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CSD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Generalize Edm.AnyPath to be a path to any model element and rename it to Edm.ModelElementPath",
    "body": "With [ODATA-516](https://issues.oasis-open.org/browse/ODATA-516) we introduced the abstract type Edm.AnyPath as an abstraction of Edm.AnnotationPath, Edm.PropertyPath, and Edm.NavigationPropertyPath.\n\nWe now face situations where we want to reference other types of model elements, e.g. bound actions or functions.\n\nIt seems wise to use the rather generic name \"AnyPath\" really for any path to any type of model element, which would\na) postpone the need for actually adding specific types Edm.ActionPath, Edm.FunctionPath, Edm.EntityTypePath, ...\nb) allow us to later add these more specific types for the more common cases\n\n### Proposal\n\nRename Edm.AnyPath (added in 4.01, so no incompatibility) to Edm.ModelElementPath\n\n(The suffix Path is somewhat superfluous but consistent with the existing AnnotationPath, AnyPropertyPath, PropertyPath, and NavigationPropertyPath.)\n\nImported from [ODATA-1065](https://issues.oasis-open.org/browse/ODATA-1065)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add ability to annotate collections to return only count and NextLink",
    "body": "Issues with NavigationProperty\n1)\tIf AutoExpand or AutoExpandReferences is not specified, then a GET without $expand or $ref query parameters will not return any representation of declared NavigationProperties.\n2)\tIf AutoExpand or AutoExpandReferences is specified, the concern is that the returned representation of the containing entity might be too large.\n3)\tFor an EntityType containing many NavigationProperties, it is difficult to specify the desired information using query parameters.\n\nThe Redfish specification attempts to solve these issues by introducing an intermediate resource that contains the original collection as a Members collection. The intermediate resource is then referenced via a NavigationProperty with AutoExpandReferences.  The new resource is required to return $count as a metadata property of the Members collection.  The value is the size of the original collection.\n\nFor the most part, this is successful, but the solution creates several new problems.\n1)\tRedfish specifies that a POST to the intermediate resource is equivalent to doing a POST to the contained collection.  This is not conformant.\n2)\tIntroduction of many intermediate resources makes the resulting model more complex.\n\n\n### Proposal\n\n----------------\nAdd new example to Prefer header to showing use of count and navigation links\n--------------------\nTo OData Version 4.01. Part 1: Protocol, clause 8.2.8.4 Preference include-annotations (odata.include-annotations)\nAdd: \nExample 8: a Prefer header requesting that navigation links be returned in the case that the format metadata=minimal is specified in the Accept header.\n      Prefer: include-annotations=\"odata.navigationLink,odata.count\"\n\nAdd paragraph before example 3.\nRegardless of the metadata format specified, annotations specified by the include-annotations preference should be added to response.\n\n--------------------\nExample:\n\n------------------\nProposed schema\n<EntityType Name=\"Top\">\n      …\n      <NavigationProperty Name=\"Systems\" Type=\"Collection(ComputerSystem)\"/>\n      …\n</EntityType>\n----------\nExample: GET\n\nGET /redfish/v1/Top\nPrefer: include-annotations=\"odata.count,odata.navigationLink\"\n\nResponse\nPreferences-Applied: include-annotations=\"odata.count,odata.navigationLink\"\n{\n\"@odata.context\": \"/redfish/v1/$metadata#Top\",\n\"@odata.id\": \"/redfish/v1/Top\",\n\"@odata.type\": \"#Top \",\n\"Name\": \"Top\",\n… \n\"Systems@odata.count\": 15,\n\"Systems@odata.navigationLink\": {\"/redfish/v1/Systems\"} \n…\n}\n\nImported from [ODATA-1064](https://issues.oasis-open.org/browse/ODATA-1064)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow $format and custom query options for all requests",
    "body": "Requests to $metadata and $batch did not explicitly allow custom query options in the ABNF.\n\nAfter adding JSON formats for metadata and batch $format needs to be allowed for all requests.\n\nCustom query options need to be allowed for all requests for e.g. passing API keys or other implementation-specific data in the URL.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1063](https://issues.oasis-open.org/browse/ODATA-1063)",
    "labels": [
      "ABNF",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Allow key expressions in Path constructs within annotations",
    "body": "With [ODATA-960](https://issues.oasis-open.org/browse/ODATA-960) we added absolute paths to the Path syntax, which allows referencing properties of a singleton, e.g.\n\n<Annotation Term=\"Display.visible\" Path=\"/this.container/Settings/FeatureXxxIsAvailable\" />\n\nA logical extension is allowing key expressions to reference entities and their properties within an entity set:\n\n<Annotation Term=\"Display.visible\" Path=\"/this.container/SettingsCollection('FeatureXxx')/IsAvailable\" />\n\nIn addition to literal values the key values can be provided using path expressions. This enables (a third party) to address content where the service author forgot to define a navigation path:\n\n<Annotation Term=\"Display.title\" Path=\"/this.container/Products(ID=ProductID)/Name\" />\n\n### Proposal\n\nPath expressions allow key segments in parenthesis syntax after path segments that identify a collection of entities. The key values can be literals, using the same style as URL literals, or they can be path expressions, evaluated according to the rules of path expressions.\n\nThis key syntax can only be used in Path expressions as only these refer to instance values.\n\nIt cannot be used in expressions for model references, i.e. PropertyPath, NavigationPropertyPath, AnnotationPath, and their abstract supertypes AnyPropertyPath and AnyPath.\n\nImported from [ODATA-1061](https://issues.oasis-open.org/browse/ODATA-1061)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add ability to annotate revisions with information on all elements",
    "body": "Currently there is no defined means to mark revisions to schema.  Some organizations have solved this by convention of creating a new schema for each set of revisions, primarily related only by time.\nEach schema represents a new namespace, so we get a proliferation of namespaces.  Type definitions are specific to namespaces, but since the evolving types really represent the same type declaration, they are sub classed across these namespaces.  This creates an unnecessarily complex model. \n\n### Proposal\n\nCreate a 'Revisions' term in the Core vocabulary that may be applied to any element.  Elements defined in a schema may then evolve over time and with their complete revision history intact. The proposal is as follows:\n\n      <Term Name=\"Revisions\" Type=\"Collection(Core.RevisionType)\">\n        <Annotation Term=\"Core.Description\" String=\"List of revisions of a model element\" />\n      </Term>\n      <ComplexType Name=\"RevisionType\">\n        <Property Name=\"Version\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"The schema version with which this revision was first published\" />\n        </Property>\n        <Property Name=\"Kind\" Type=\"Core.RevisionKind\">\n          <Annotation Term=\"Core.Description\" String=\"The kind of revision\" />\n        </Property>\n        <Property Name=\"Description\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"Text describing the reason for the revision\" />\n        </Property>\n      </ComplexType>\n      <EnumType Name=\"RevisionKind\">\n        <Member Name=\"Added\">\n          <Annotation Term=\"Core.Description\" String=\"Model element was added\" />\n        </Member>\n        <Member Name=\"Modified\">\n          <Annotation Term=\"Core.Description\" String=\"Model element was modified\" />\n        </Member>\n        <Member Name=\"Deprecated\">\n          <Annotation Term=\"Core.Description\" String=\"Model element was deprecated\" />\n        </Member>\n      </EnumType>\n\nThis new term replaces the term Core.Deprecated proposed in [ODATA-1037](https://issues.oasis-open.org/browse/ODATA-1037).\n\nImported from [ODATA-1058](https://issues.oasis-open.org/browse/ODATA-1058)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add path segment /$each",
    "body": "As of 4.01 we support PATCH to a collection of entities. The PATCH is either interpreted as a set operation (if the payload is a single entity) or applied as a delta payload (if the payload has a context URL of #$delta.\n\nRather than distinguishing on payload, what if we said that PATCH to a collection of entities is always interpreted as an operation on the set as a whole, and a new path segment /$each is used for an atomic operation on each of the entities, especially DELETE, and PATCH with a single-instance payload.\n\n### Proposal\n\nAdd path segment /$each to apply an operation on each item of a collection, executed all-or-nothing atomically:\n\nDELETE Orders/$filter=@f/$each?@f=Age gt 3\nPATCH Orders/$each - with single payload\nPATCH Orders - with delta payload\nPOST Orders/$filter=@f/$each/Some.SingleAction?@f=Age gt 2 - binding parameter is single order\nPOST Orders/$filter=@f/Some.CollectionAction?@f=Age gt 2 - binding parameter is collection of orders\n\nImported from [ODATA-1057](https://issues.oasis-open.org/browse/ODATA-1057)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Key-as-Segment with Referential Constraints",
    "body": "Part 2 section 4.3.3 allows omitting key values that are implicitly specified by referential constraints to key values provided in previous path segments:\n\nhttps://host/service/Orders(1)/Items(OrderID=1,ItemNo=2)\nhttps://host/service/Orders(1)/Items(2)\n\nThe shorter form is preferred for parentheses-key syntax, and both are allowed.\n\nWe cannot give that choice for key-as-segment style because the number and order of path segments must be deterministic, so it is either\n\nhttps://host/service/Orders/1/Items/1/2\n\nor\n\nhttps://host/service/Orders/1/Items/2\n\nShorter is better, so it must be the second.\n\n### Proposal\n\nRequire for key-as-segment that \"redundant\" key segments MUST NOT be specified, i.e. \n\nhttps://host/service/Orders/1/Items/2\n\nfor the example where the order id in Items is tied to the order id in Orders  via referential constraint.\n\nImported from [ODATA-1056](https://issues.oasis-open.org/browse/ODATA-1056)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "DeepInsertSupport: allow applying to entity sets and collection-valued navigation properties",
    "body": "Some APIs support deep insert only on some entity sets, not on all of them. Currently DeepInsertSupport only applies to the entity container, and the descriptions reflect that scope.\n\n### Proposal\n\nAdd \"EntitySet\" and \"Collection\" to list of model elements in AppliesTo attribute and rephrase descriptions to match this generalization.\n\nImported from [ODATA-1055](https://issues.oasis-open.org/browse/ODATA-1055)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Part 1 Protocol: Add recommendations for Vary header",
    "body": "If the returned representation is influenced by presence or absence of a preference, the server SHOULD (actually MUST) send a Vary:Prefer or Vary:* response header to avoid caching problems.\n\n### Proposal\n\nAdd section on Vary response header, citing https://tools.ietf.org/html/rfc7231#section-7.1.4 and possibly https://tools.ietf.org/html/rfc7240\n\nAdd recommendation to send Vary:Prefer to all sections on preferences whose presence or absence influences the returned representation: return, omit-values, ...\n\nImported from [ODATA-1054](https://issues.oasis-open.org/browse/ODATA-1054)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "URL conventions document should have non-normative examples if primitive value syntax",
    "body": "Having a table of non-normative examples of primitive value syntax would assist client developers (especially those not using frameworks such as query builder apis) in creating correct requests.\n\n\n\n### Proposal\n\nAdd a table of non-normative examples of primitive value syntax.\n\n\nImported from [ODATA-1053](https://issues.oasis-open.org/browse/ODATA-1053)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Further simplify JSON Batch Format",
    "body": "In OData-1046 we approved addition of a JSON-format for Batch requests and responses.\n\nIn the discussion we considered a format that included groups of requests as top-level JSON objects with common batch options.\n\nWe can simplify this proposal by removing this outer grouping and allowing the individual requests to specify that they are part of a particular atomicityGroup. By adding additional semantics (members of an atomicityGroup must be adjacent in a request) we can simplify construction and processing of a batch request.\n\nExample batch request:\n\nPOST /v1.0/$batch HTTP/1.1  \n{\n  requests: [\n    {\n      id: \"1\",\n      atomicityGroup: \"atom1\",\n      method: \"post\",\n      url: \"/users\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: {\n        displayName: \"John Smith\",\n        userPrincipalName: \"jsmith@contoso.com\"\n      }\n    },\n    {\n      id: \"2\",\n      atomicityGroup: \"atom1\",\n      dependsOn: [\"1\"],\n      method: \"put\",\n      url: \"$1/photo\",\n      headers: {\n        Content-Type: \"image/jpeg\"\n      },\n      body: \"FRwvAAIAAAANAA4AFAAhAPNTUAAAAAAAAAAAAAAQUAAAAAAADHrQX+\"\n    },\n    {\n      id: \"3\",\n      method: \"get\",\n      url: \"/groups?top=10\",\n      headers: {\n        Accept: \"application/atom+xml\",\n      }\n    },\n    {\n      id: \"4\",\n      dependsOn: [\"atom1\"],\n      method: \"get\",\n      url: \"$1/thumbnail\",\n      headers: {\n        Accept: \"image/jpeg\"\n      }\n    }\n  ]\n}\n\n\n{\n  responses: [\n    {\n      id: \"1\",\n      status: 201,\n      headers: {\n        Location: \"/users/jsmith\"\n      }\n    },\n    {\n      id: \"2\",\n      status: 204\n    },\n    {\n      id: \"3\",\n      status: 406,\n      error: {\n        message: \"Atom Format not supported\"\n    },\n    {\n      id: \"4\",\n      status: 200,\n      headers: {\n        Content-Type: \"image/jpeg\"\n      },\n      body: \"FRwvAAIAAAANAA4AFAAhAPNTUAAAAAAAAAAAAAAQUAAAAAAADHrQX+\"\n    },\n  }\n}\n\n### Proposal\n\nRemove the outer object wrapper in the proposed JSON batch format.  Add an \"atomicityGroup\" property; all requests that have the same value for atomicityGroup are processed as an atomic unit.  Members with the same atomicityGroup must be adjacent in a request payload. dependsOn can reference an individual request that is not within an atomicityGroup, or the identifier for the atomicityGroup if the request is within an atomicityGroup.\n\nSupport server-driven paging in this format.\n\nFor an async batch response, the nextLink can return 202 with a location header and retry after.\n\n\nImported from [ODATA-1051](https://issues.oasis-open.org/browse/ODATA-1051)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Change sets: do not require the same content type for all request in a change set",
    "body": "The section on Change Sets currently states:\n\nEach body part representing an operation in the change set MUST include the same Content-Type header value. \n\nThis does not work for creating media resources and modifying the auto-created media entity, or for creating an entity and then updating its stream properties. \n\n### Proposal\n\nRemove this sentence.\n\nImported from [ODATA-1050](https://issues.oasis-open.org/browse/ODATA-1050)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Content referencing in batch requests",
    "body": "If a data modification is implemented as an action, a subsequent GET request may need to use values from the action response body as parameters for a filter.\n\n### Proposal\n\nAllow referencing values from response bodies in subsequent requests\n- in $filter\n- in request bodies of subsequent modification requests\n\nValue references use JSON Pointer syntax to address parts of the response body, e,g.\n\n$filter=City eq $42/Addresses/3/City\n\nPoint out that content-id value must not collide with $root or any other $ literal valid in expressions\n\nImported from [ODATA-1049](https://issues.oasis-open.org/browse/ODATA-1049)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify server-driven paging requirement",
    "body": "Why is server-driven paging a MUST for minimal conformance? It's more of a self-defense mechanism and not needed for services with modest amounts of data.\n\n### Proposal\n\nClarify: if a service returns a partial result it MUST include a nextlink as per section 11.2.5.7.\n\nImported from [ODATA-1048](https://issues.oasis-open.org/browse/ODATA-1048)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Rename $IsCollection to $Collection",
    "body": "[ODATA-879](https://issues.oasis-open.org/browse/ODATA-879) proposes to allow arrays of arrays using a syntax Type=\"Collection(...Collection(...)...)\" in CSDL XML.\n\nThe current Boolean member $IsCollection wouldn't be able to cover this.\n\n### Proposal\n\nRename $IsCollection to $Collection. Keep it Boolean for now, and switch to / additionally allow positive integer values once [ODATA-879](https://issues.oasis-open.org/browse/ODATA-879) is approved.\n\nNote: for JavaScript 1 is as true as true.\n\nImported from [ODATA-1047](https://issues.oasis-open.org/browse/ODATA-1047)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add JSON format for Batch",
    "body": "Our batch request and response format today is multipart/mime.  We've had a lot of pushback from the beginning that this format is difficult to construct and parse; there are no off-the shelf tools or libraries for doing so.\n\nNow that we have a JSON format for CSDL, a JSON client no longer needs an XML parser to read CSDL, but they still have no way of expressing or consuming a batch without parsing the difficult to understand/complex multi-part mime.\n\n### Proposal\n\nAdd a new section to the JSON format document describing a JSON batch request and response format as presented 2017-3-9.\nMove multipart/mime-specific text to the last subsection of 11.7, and refer to JSON Format for an alternative JSON Batch format.\n\nSee [ODATA-1051](https://issues.oasis-open.org/browse/ODATA-1051) for the refined proposal\n\nImported from [ODATA-1046](https://issues.oasis-open.org/browse/ODATA-1046)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Disallow propagation of Accept header on batch requests to individual requests within the batch",
    "body": "Section 8.2.1 Header Accept states (new text in 4.01, not present in 4.0):\n\nIf the Accept header is specified on an individual request within a batch, then it specifies the acceptable formats for that individual request. Requests within a batch that don’t include the Accept header inherit the acceptable formats of the overall batch request.\n\nThis would cause problems for batch requests specifying Accept:application/json with the intention of a \"default\" for the individual responses once we add a JSON Batch format. Services would not be able to respond with the JSON Batch format if they formerly treated this as a default for the individual requests\n\n### Proposal\n\nRemove the second sentence in the next draft of V4.01\n\nImported from [ODATA-1045](https://issues.oasis-open.org/browse/ODATA-1045)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Require aliases for schemas and require alias-qualified names",
    "body": "To simplify lookup of qualified names the CSDL JSON representation initially required namespace-qualified names. This got some pushback as namespaces are typically long to be unique and alias-qualified names are more readable, so aliases were re-introduced.\n\nWhy not require aliases and alias-qualified names in CSDL JSON documents to further increase readability by avoiding the arbitrary mix of namespace- and alias-qualified names.\n\n### Proposal\n\nDocuments SHOULD define aliases for schemas.\nIf an alias is defined for a schema, it MUST be used in qualified names.\n\nImported from [ODATA-1044](https://issues.oasis-open.org/browse/ODATA-1044)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify purpose of context URL",
    "body": "1) Chapter 10 states: The context URL describes the content of the payload. It consists of the canonical metadata document URL and a fragment *identifying the relevant portion of the metadata document.*\n\nThis is somewhat violated by context urls using the template variable {entity} whose value is the canonical URL of an entity, including its key values - the key values aren't needed to identify the relevant portion of the metadata document, for this purpose the type is sufficient.\n\n2) Chapter 10 states: Request payloads generally do not require context URLs as the type of the payload can generally be determined from the request URL.\n\nCan we have the same for response payloads? Most responses for requests to entity sets or singletons using canonical URLs would not need a context URL, same for navigation paths with a navigation property binding. Instances with a type derived from the declared type carry the @odata.type annotation, so even those don't need a context URL. Same for responses to actions/functions with an EntitySetPath, or action/function imports with a an EntitySet.\n\n### Proposal\n\nState in chapter 10 that one purpose of the context URL is to make responses \"self-contained\" and allow the client to e.g. construct navigation links for selected navigation properties.\n\nOtherwise no action, and no relaxation of the context URL patterns.\n\nImported from [ODATA-1043](https://issues.oasis-open.org/browse/ODATA-1043)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Cast annotation expression and Unicode facet",
    "body": "Can cast expressions (and the URL cast() function) cast Unicode strings to non-Unicode strings and vice versa?\n\n\n### Proposal\n\nCasting ASCII to Unicode always succeeds.\n\nCasting Unicode to ASCII only succeeds for string values with characters limited to the ASCII character set.\n\nImported from [ODATA-1042](https://issues.oasis-open.org/browse/ODATA-1042)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Broaden definitions of transformations topcount and bottomcount",
    "body": "Definitions in section 3.2 and 3.6 state that the second parameter must result in a primitive numeric value. This is too restrictive, actually it is only required that there is a total ordering on these values.\n\nConsider, for example, getting the latest stock by product: $apply=groupby((Product),topcount(1,Date))\n\n\n### Proposal\n\nReplace current definitions by \"[...] and MUST result in values of a primitive type whose values are totally ordered.\".\n\nImported from [ODATA-1041](https://issues.oasis-open.org/browse/ODATA-1041)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarification of term \"expression\"",
    "body": "At some places, the document refers to expressions without specifying their kind. \n\nAffects sections 3.1.2, 3.1.4, 3.2 - 3.7 (re: second parameter)\n\n\n### Proposal\n\nIn section 2.1\n1) add a definition of expressions: is a common expression from the ABNF\n2) aggregatable primitive type is a primitive type other than geo or stream\n3) add a definition of an aggregatable expression is a value of an aggregatable primitive type\n\nImported from [ODATA-1040](https://issues.oasis-open.org/browse/ODATA-1040)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Relax constraints on namespace names",
    "body": "Currently a namespace has to consist of several dot-separated segments, and each segment has to be a SimpleIdentifier (essentially a JavaScipt/Java/Swift/C# variable name).\n\nWe could relax this and allow - at least for the second, third, ... segment, additional characters, most prominently the dash (-), and allow to have purely numeric segments, e.g. Some.Namespace.3.1.4 to allow for semantic versioning of namespaces.\n\n### Proposal\n\n- Allow purely numeric segments after the first segment. First segment still needs to start with with a letter\n- Allow dash in all segments (except as first character in first segment)\n\nImported from [ODATA-1039](https://issues.oasis-open.org/browse/ODATA-1039)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify term \"simple value\"",
    "body": "The term \"simple value\" is used several times in the document, but lacks a definition.\n\n### Proposal\n\nThe intended meaning of \"simple value\" is \"value of aggregatable primitive type\" where aggregatable primitive type is defined in [ODATA-1040](https://issues.oasis-open.org/browse/ODATA-1040). \n\nReplace all occurrencies in the document:\n- section 3.1, Transformation aggregate:  second para and last para\n- section 3.14 Transformationm compute: second para\n\n\nImported from [ODATA-1038](https://issues.oasis-open.org/browse/ODATA-1038)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add tagging term Core.Deprecated to mark deprecated model elements",
    "body": "Our model versioning rules only allow adding optional model elements, they don't allow removing model elements.\n\nOne way to deal with this is to leave outdated model elements in a service and just mark them as \"deprecated\".\n\n### Proposal\n\nDo not add new Core term\n\n      <Term Name=\"Deprecated\" Type=\"Core.Tag\" DefaultValue=\"true\">\n        <Annotation Term=\"Core.Description\" String=\"Model elements annotated with this term are deprecated and should no longer be used. They may be removed in a future version of the service.\" />\n      </Term>\n\nInstead close this as a duplicate (subset) of [ODATA-1058](https://issues.oasis-open.org/browse/ODATA-1058)\n\nImported from [ODATA-1037](https://issues.oasis-open.org/browse/ODATA-1037)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "10.7/8: Simplify context URL for \"all operations in schema\"",
    "body": "The context URL for a structured instance or collection of structured instances mirrors the $select query option used to request that representation. It already supports the * operator to express \"all structural properties\". It currently lacks the namespace.* operator to express \"all actions and functions from a certain namespace\".\n\nAdding this would drastically reduce the size of the context URL, especially if using an alias instead of the fully qualified namespace.\n\nTypical use would be self.* with \"self\" being the alias for the service's namespace (note: \"self\" is just an example, not even a convention).\n\n\n### Proposal\n\nExtend the context URL pattern {select-list} to also support the $select pattern \n\n    allOperationsInSchema = namespace \".\" STAR   \n\ne.g. Model2.* to include all operations from namespace/alias Model2\n\nImported from [ODATA-1036](https://issues.oasis-open.org/browse/ODATA-1036)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "10.13: Simplify context URL for Property Value",
    "body": "The context URL for a property value contains the keys of the entity. \nThis seems overly specific as the context URL is a pointer to structural metadata, so why should it vary from entity to structurally identical entity?\nNote that the context URL for an entity does not contain the key, nor is it required that the key properties are always present in the response.\n\n### Proposal\n\nAllow the context URL pattern\n\n    {context-url}#{type-name}{select-list}\n\nalso for property values.\n\nIf something more specific is desired, the pattern could be\n\n    {context-url}#{entity-set}/{property-path}{select-list}\n\nImported from [ODATA-1035](https://issues.oasis-open.org/browse/ODATA-1035)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support the notion of a collection of name/value pairs where the type of the value is known",
    "body": "There is currently no easy way (read: without specifying an additional wrapper entity type) of specifying a, what most people would likely refer to as a, dictionary, or a collection of name/value pair, in which I can specify the type of the values!\n\nSo where we would need to do something today like:\n\n      <EntityType Name=\"ValueType\">\n        <Key>\n          <PropertyRef Name=\"Key\"/>\n        </Key>\n        <Property Name=\"Key\" Type=\"Edm.String\" Nullable=\"false\"/>\n        <Property Name=\"PropA\" ... />\n        ...\n      </EntityType>\n\n      <EntityType Name=\"ValueTypeDictionaryWrapper\">\n        <Key>\n          <PropertyRef Name=\"Name\"/>\n        </Key>\n        <Property Name=\"Name\" Type=\"Edm.String\" Nullable=\"false\"/>\n        <NavigationProperty Name=\"Value\" Type=\"ns.ValueType\" Nullable=\"false\"/>\n      </EntityType>\n\n      <AnyStructuredType Name=\"ValueTypeDictionaryContainer\">\n        ...\n        <NavigationProperty Name=\"Values\" Type=\"Collection(ns.ValueTypeDictionaryWrapper)\" Nullable=\"false\"/>\n        ...\n      </AnyStructuredType>\n\nNote that the wrapper has to be an entity type to be able to use the name (key) to index into the 'dictionary'. This is even a bit weirder if what we are putting in the dictionary is actually complex types that one would want to treat just like a collection of that complex type.\n\nThe payload would look something like this:\n\n    {\n      \"@odata.context\": \"$metadata#AnyStructuredType(Values(Value))/$entity\",\n      ...,\n      \"Values\": [{\n        \"Name\": \"foo\",\n        \"Value\": {\n          \"Key\": \"38hfgs8\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        \"Name\": \"bar\",\n        \"Value\": {\n          \"Key\": \"f93d8r3\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        ...\n      }],\n      ...\n    }\n\nNeedless to say that this JSON representation of an, expanded, payload doesn't look like what a typical JSON consumer would expect and it requiring the wrapped value to be expanded as well..\n\nSo what I'm looking at being able to do is, using the same example, do something like:\n\n      <EntityType Name=\"ValueType\">\n        <Key>\n          <PropertyRef Name=\"Key\"/>\n        </Key>\n        <Property Name=\"Key\" Type=\"Edm.String\" Nullable=\"false\"/>\n        <Property Name=\"PropA\" ... />\n        ...\n      </EntityType>\n\n      <AnyStructuredType Name=\"ValueTypeDictionaryContainer\">\n        ...\n        <NavigationProperty Name=\"Values\" Type=\"Dictionary(ns.ValueTypeDictionaryWrapper)\" Nullable=\"false\"/>\n        ...\n      </AnyStructuredType>\n\nAnd the resulting JSON payload for requests would look something like:\n\n    {\n      \"@odata.context\": \"$metadata#AnyStructuredType(Values)/$entity\",\n      ...,\n      \"Values\": {\n        \"foo\": {\n          \"Key\": \"38hfgs8\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        \"bar\": {\n          \"Key\": \"f93d8r3\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        ...\n      },\n      ...\n    }\n\nNote the more intuitive typical JSON response and that we don't need to expand the value in the wrapper any longer. \n\n### Proposal\n\n1) Define a complex type \"Dictionary\" in OData.Core as an open complex type with no properties.\n2) Define a Validation term \"OpenPropertyTypeConstraint\" whose value is a collection of qualified type names. It can be applied to an open entity or complex type definition and constrains open properties of that type to the specified values.\n3) Define a Validation term \"DerivedTypeConstraint\" whose value is a collection of qualified type names. It can be added to a property (or TypeDefinition) to constrain the derived types of that property. If a specified type is not a derived type of the property to which it is applied then it is ignored.\n\nImported from [ODATA-1034](https://issues.oasis-open.org/browse/ODATA-1034)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Interoperability issue when using escaped slash/backslash in URLs",
    "body": "We have encountered issues with Tomcat servers handling %-encoded slashes (and backslashes) in URLs. In particular, even when getting URL using HttpServletRequest.getRequestURI (which shouldn't do URL decoding) a percent-encoded backslash (e.g. in a quoted string within the URL) will appear in the result of getRequestURI as a forward slash.\n\nNow Tomcat apparently offers an option to permit this, but...\n\nAccording to http://stackoverflow.com/questions/9719224/coding-forward-and-backward-slashes-in-tomcat-7\n\n*Do not enable non-standard parsing of the URI. Disabled by default, but still in the application for backwards compatibility reasons are two system properties, org.apache.catalina.connector.CoyoteAdapter.ALLOW_BACKSLASH and org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH, that allow non-standard parsing of the URI. These properties significantly improve your chances of a directory traversal attack and are therefore strongly recommended to avoid using.*\n\nIf correct handling of URLs requires the use of web server configurations that are strongly recommended against for security reasons, we might want to consider what recommendations/accommodations should be made in the OData specification to ensure end-to-end interoperability of strings containing 'special' characters.\n\n\n### Proposal\n\nWe already have an implicit cast rule: \"Primitive types are cast to Edm.String or a type definition based on it by using the literal representation used in payloads\". This means that binary literals are cast to strings containing the base64url-encoded value.\n\nAlternative proposal: both problematic components (Tomcat, .NET client) can deal with plain-text or percent-encoded forward- and backslashes if they appear in the query part of the URL.\n\nThis means parameter aliases are sufficient to defer problematic key values to the query part of the URL.\n\nServices that support forward-slash in key values MUST support passing key values as parameters. \n\nPut this issue on \"Implementing OData\" to add a recommendation for clients and servers on \"problematic\" infrastructures.\n\n----------------------------------------------------------------\nOld, inapplicable proposal:\n\nAdd an implicit cast rule that allows binary values in place of string values, where the base64url-encoded binary is the UTF-8 representation of the string value: \n\nGET Categories(binary'Q29tZWR5L011c2ljYWw=')\n\nServices are required to support an implicit cast from binary to string (anywhere). Clients are advised to use this form when passing a string value containing a forwardslash, backslash, and a null character (%5C,  %2F, %00)\n\nImported from [ODATA-1033](https://issues.oasis-open.org/browse/ODATA-1033)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Define comparison for numeric value exceptions",
    "body": "We describe comparison operations with null, but not with NaN, -INF and INF.\n\nFor NaN IEEE754, says that NaN is unordered and not equal to itself, meaning that NaN compared to anything, including NaN, is false except for != which is true.\n\nThis makes sense mathematically; however, this makes it very hard to find all resources with a property value of NaN (we would have to add a separate IsNaN() operator, and comparisons would have to account for this in their expressions).  We could say that NaN==NaN, similar to how we say Null==Null to make it easier to search for Null values.\n\nFor INF, -INF, IEEE754 appears to define INF==INF and -INF==-INF, so we would have:\nINF == INF: True\nINF != INF: False\nINF < INF: False\nINF <= INF: True\nINF > INF: False\nINF >= INF: True\nINF < <valid number>: False\nINF <= <valid number>: False\nINF > <valid number: True\nINF >= <valid number>: True\nINF > -INF: True\n-INF == -INF: True\n-INF != -INF: False\n-INF < -INF: False\n-INF <= -INF: True\n-INF > -INF: False\n-INF >= -INF: Tru\n-INF < <valid number>: True\n-INF <= <valid number>: True\n-INF > <valid number>: False\n-INF >= <valid number>: False\n-INF > INF: False\n\n\n### Proposal\n\nAccept the IEEE754 rules for INF, -INF, as described below, as well as the IEEE754 rules for NaaN (unordered and not equal to anything)\n\nImported from [ODATA-1032](https://issues.oasis-open.org/browse/ODATA-1032)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Define term for links to related information",
    "body": "Define term for links to related information, e.g. \"latest-version\" or similar.\nSources of inspiration: the <atom:link> element and the Link HTTP header.\n\n### Proposal\n\nDefine new Core term:\n\n      <Term Name=\"Links\" Type=\"Collection(Core.Link)\">\n        <Annotation Term=\"Core.Description\" String=\"Link to related information\" />\n        <Annotation Term=\"Core.LongDescription\"\n          String=\"The Link term is inspired by the `atom:Link` element, see [RFC4287](https://tools.ietf.org/html/rfc4287#section-4.2.7) and the `Link` HTTP header, see [RFC5988](https://tools.ietf.org/html/rfc5988)\" />\n      </Term>\n      <ComplexType Name=\"Link\">\n        <Property Name=\"rel\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\"\n            String=\"Link relation type, see [IANA Link Relations](http://www.iana.org/assignments/link-relations/link-relations.xhtml)\" />\n        </Property>\n        <Property Name=\"href\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.IsURL\" />\n          <Annotation Term=\"Core.Description\" String=\"URL of related information\" />\n        </Property>\n      </ComplexType>\n\n      <!-- Example -->\n      <Annotation Term=\"Core.Links\">\n        <Collection>\n            <Record>\n              <PropertyValue Property=\"rel\" String=\"latest-version\" />\n              <PropertyValue Property=\"href\"\n                 String=\"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml\" />\n           </Record>\n        </Collection>\n      </Annotation>\n\n\nImported from [ODATA-1031](https://issues.oasis-open.org/browse/ODATA-1031)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Consider support of NavigationPropertyBindings to non-contained nav props",
    "body": "NavigationPropertyBindings are used to identify the set in which members of a navigation property are *defined*.  The target set can be an entity set or an instance of a containment navigation property.\n\nThere are cases where it is interesting to specify that members of a navigation property are *members of* another navigation property that may not necessarily be where they are defined.\n\nFor example, if I have a customer with navigation properties \"AllOrders\", \"OpenOrders\", and \"ClosedOrders\", it may be useful to define that members of \"OpenOrders\" and \"ClosedOrders\" are all members of the \"AllOrders\" navigation property, even though they are defined in an \"Orders\" entity set. \n\nNavigationPropertyBinding has the right syntax and semantics for this, if we relax the constraint that the target of the navigationpropertybinding must terminate on a *containment* navigation property.\n\nHowever, this may be mixing semantics of the existing NavigationPropertyBinding, which specifies the set in which an entity is defined, and a constraint that says members of one navigation property must be children of another navigation property, so perhaps we should instead define a NavigationPropertyConstraint that says instances are members of a related navigation property that may or may not be the one in which they are defined...\n\n### Proposal\n\nApply [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674) as an annotation term in the Validation vocabulary \"ItemsOf\". The value of the ItemsOf annotation is a collection of complex types containing two path properties; \"path\" and \"target\". A path indicating the same navigation property can occur multiple times, appended with different cast segments, in which case the most specific path is applied. The target can be any collection-valued navigation property.  If the target is a containment navigation property then the constraint defines where the entity lives.\n\nImported from [ODATA-1030](https://issues.oasis-open.org/browse/ODATA-1030)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "5.1.1.10.2: clarify that all() is always true if applied to an empty collection",
    "body": "\n\n### Proposal\n\nall() applied to an empty collection always returns true.\nany() applied to an empty collection always returns false.\n\nSQL does it the same way.\n\nImported from [ODATA-1029](https://issues.oasis-open.org/browse/ODATA-1029)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "4.3.4 and 4.4: clarify resolution of relative URLs in system query option $id",
    "body": "4.3.4 Resolving an Entity-Id states that \n\nThe entity-id may be expressed as an absolute IRI or relative to the service root URL.\n\nExample 23: request the entity representation for an entity-id\nhttp://host/service/$entity?$id=Products(0)\n\n\nThis was correct until we introduced type-cast segments after $entity with [ODATA-528](https://issues.oasis-open.org/browse/ODATA-528). \n\nNow relative URLs should rather be relative to the request URL, as in all other places, especially in \n\n\n4.4 Addressing References between Entities\n\nThe entity-id specified by $id may be expressed absolute or relative to the request URL.\n\n\n### Proposal\n\nClarify that relative URLs passed with query option $id are relative to the path to be consistent with $ref.\n\nImported from [ODATA-1028](https://issues.oasis-open.org/browse/ODATA-1028)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Support instance annotations in $orderby",
    "body": "In OData-933 we added the ability to use annotations in $filter. Early feedback suggests this would also be useful in $orderby.  Seems reasonable...\n\n### Proposal\n\nSupport use of instance annotations in $orderby, just as we do in $filter.\n\nImported from [ODATA-1027](https://issues.oasis-open.org/browse/ODATA-1027)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Clarify when $it is required",
    "body": "The description of $it says it CAN be used in a number of cases (see section 5.1.11.4 in the URL conventions document) but it isn't specific about when $it MUST be used.  We should clarify when $it is required.  For example, my understanding is that both of these queries are equivalent (in which case the $it is not required):\n\nhttp://host/service/Customers?$filter=Orders/any(d:d/Quantity ge Age)\nvs.\nhttp://host/service/Customers?$filter=Orders/any(d:d/Quantity ge $it/Age)\n\nHowever, my understanding is that in the case below the $it is required:\n\nhttp://host/service/Customers?$expand=Orders($filter=$it/Address/City eq ShipTo/City)\n\nImported from [ODATA-1026](https://issues.oasis-open.org/browse/ODATA-1026)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Treatment of same query option in multiple \"spellings\"",
    "body": "V4.01 allows to omit the $ prefix for system query options and makes the query option name case-insensitive.\n\nHow should servers react if a request contains e.g. $top=5&Top=10\n\nShould the request be rejected as the same (logical) query option appears twice, or should it succeed and $top is preferred over Top?\n\nWhat if it contains top=5&TOP=10?\n\n### Proposal\n\nIn Section 5.1, System Query Options], of URL Conventions, change:\n\n \"The same system query option MUST NOT be specified more than once for any resource.\" \n\nto:\n\n\"The same system query option, irrespective of casing or whether or not it is prefixed with \"$\", MUST NOT be specified more than once for any resource.\" \n\n\nImported from [ODATA-1025](https://issues.oasis-open.org/browse/ODATA-1025)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "5.1.1.5.7 substring: explicitly state that the index N (second parameter value) is zero-based",
    "body": "The zero-based indexing is only explicitly mentionen in section 5.1.1.5.4 indexof. It would be helpful to repeat this in section 5.1.1.5.7 substring.\n\nAlso add an \"e.g. Alfreds Futterkiste\" to the example, not all of our readers are familiar with the Northwind sample data set :-)\n\n### Proposal\n\nClarify that the index parameter to the substring function is zero-based.\n\nImported from [ODATA-1024](https://issues.oasis-open.org/browse/ODATA-1024)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Provide stable anchors to all sections",
    "body": "Provide stable named anchors to all sections; the auto-generated _Toc anchors are not stable.\n\nInclude table of contents with full depth for all documents.\n\n### Proposal\n\nsee description\n\nImported from [ODATA-1023](https://issues.oasis-open.org/browse/ODATA-1023)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  }
]