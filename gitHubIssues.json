[
  {
    "title": "Restrict values of edm:Bool in edm.xsd to lower-case \"true\" and \"false\" ",
    "body": "The specification document defines in section 17.6 that only the values \"true\" and \"false\" are allowed.\n\nThe XML schema file edm.xsd uses type xs:boolean, which also allows \"0\" and \"1\".\n\n### Proposal\n\nSee summary.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-488\n\nImported from [ODATA-488](https://issues.oasis-open.org/browse/ODATA-488)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify where relative URLs follow the rules in section 4.3 and where they follow different rules",
    "body": "In several places the JSON specification states that URLs may be \"relative to the context URL\". This is more restrictive than the rules defined in section 4.3.\n\nIn most some cases this seems to be a left-over from before inserting section 4.3.\n\n\n\nImported from [ODATA-487](https://issues.oasis-open.org/browse/ODATA-487)",
    "labels": [
      "JSON Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Missing <Record> wrapper in three examples",
    "body": "In three examples for annotations using complex terms the <Record> wrapper is missing\n\n### Proposal\n\nAdd <Record> wrapper to \n- Chapter 14 Example 33\n- Section 14.5.11 Example 63\n- Section 14.5.13 Example 65\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-486\n\nImported from [ODATA-486](https://issues.oasis-open.org/browse/ODATA-486)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for UrlRef expression that contains a literal string that is a URL",
    "body": "The second sentence in section 14.5.15 Expression UrlRef states that\n\n    The edm:UrlRef element MUST contain exactly one expression of type Edm.String. \n\nThis caused questions whether the correct form is\n\n    <UrlRef>http://some/url </UrlRef>\n\nor\n\n    <UrlRef><String>http://some/url <String></UrlRef>\n\nOnly the second form is allowed.\n\n### Proposal\n\nAdd example with allowed form for \"static\" URL. State that <String> wrapper is required\n\nAccepted: https://www.oasis-open.org/committees/download.php/50677/odata-meeting-51_on-20130912-minutes.html#odata-485\n\nImported from [ODATA-485](https://issues.oasis-open.org/browse/ODATA-485)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove reference to \"fixed-length or variable-length\" primitive values",
    "body": "While service implementations may in fact use fixed-length fields internally we've removed the FixedLength attribute that allows to tell this to clients, so referring to \"fixed-length or variable-length\" strings and binaries is confusing for readers with V3 background, and makes not much sense for stream properties anyway.\n\n### Proposal\n\nRemove  phrase \"Fixed-length or variable-length\" in text for Edm.Binary, Edm.Stream, and Edm.String in section 4.4\n\nImported from [ODATA-484](https://issues.oasis-open.org/browse/ODATA-484)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Include all section levels in table of contents, provide anchors for all document sections",
    "body": "Currently the HTML flavor of the specification documents contains mostly section bookmarks of the form _Toc followed by a nine-digit number. \n\nAlso not all sections are listed in the table of contents, so referencing to a section on level 4 or 5 requires inspecting the generated HTML code of the specification. \n\nThis is not made easier by the fact that most sections have about a dozen of the _Tocnnnnnnnnn anchors instead of one memorable anchor.\n\n### Proposal\n\nInclude all section levels in table of contents.\n\nThis also allows bookmarking the auto-generated _Toc anchors without inspecting the HTML source.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-483\n\nImported from [ODATA-483](https://issues.oasis-open.org/browse/ODATA-483)",
    "labels": [
      "ATOM Format",
      "CSDL XML",
      "Data Aggregation",
      "Extension for JSON Data",
      "JSON Format",
      "Protocol",
      "Temporal",
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow inlining stream properties and media resources",
    "body": "Stream properties are similar to navigation properties as they \"defer\" content to a separate resource. It would be nice to be able to inline that related content similarly to related entities.\n\nThis could be done by generalizing $expand, by adding a special query option $inline or $include for stream properties, or in $select as proposed in [ODATA-10](https://issues.oasis-open.org/browse/ODATA-10).\n\n### Proposal\n\n1) Allow payloads to contain Base64-encoded streams\n    a) GET response payloads\n    b) POST/PUT/PATCH requests\n    c) Delta payloads\n2) Media streams in the payload are named using the name of the property\n3) Media-entity stream is represented with a property named \"$value\"\n4) Generalize $expand to also allow stream properties and represent the related content in Base64-encoded form. \n\nFor stream property: GET People(1)?$expand=photo\nFor media entity: GET Resumes(1)?$expand=$value\n\nExpand=*  =>only navigation properties - streams are not included automatically by * but may be included explicitly.\n\nImported from [ODATA-482](https://issues.oasis-open.org/browse/ODATA-482)",
    "labels": [
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Annotation/Navigation/Path expressions: allow paths to continue after multi-valued navigation to e.g. drill into complex properties",
    "body": "CSDL 14.5.12 restricts path expressions to contain at most one multi-valued navigation property which can only be followed by a single type cast or term cast.\n\nThis is overly restrictive: drilling into a complex type path after a navigation is straight-forward, and even multiple multi-valued navigations could be resolved by building the union of all targeted collections.\n\n### Proposal\n\nAllow paths to contain an arbitrary number of single- or multi-valued navigation segments at arbitrary positions.\n\nChange section 14.5.12, second paragraph after bullet list from\n\n    If a path segment is the name of a navigation property that has a cardinality of many, the path MUST \n    NOT have any subsequent segments other than type casts, term casts, or a $count segment. If the last \n    segment is a $count segment, the path evaluates to the number of related entities.\n\nto\n\n    If a path segment is the name of a multi-valued structural or navigation property, the path identifies a collection of instances.\n    This collection is obtained by evaluating the remaining path for each instance of the collection identified by the path up to the multi-valued property.\n    If the remaining path evaluates to a collection of entities, the full path evaluates to the union of these collections.\n    If the remaining path evaluates to a collection of primitive or complex type instances, the full path evaluates to the concatenation of these collections.\n    If the remaining path evaluates to a single entity, the full path evaluates to the set of these entities.\n    If the remaining path evaluates to a single primitive or complex type instance, the full path evaluates to the collection of these instances.\n\n    If the last segment is a $count segment, the path evaluates to the number of instances identified by the preceding path.\n\nExamples:\n- Path=\"Items/Product\" identifies a collection of products (entities)\n- Path=\"Items/Product/Supplier/Address\" identifies a collection of addresses (complex type instances)\n- Path=\"Friends/EmailAddresses\" identifies a collection of email addresses (strings)\n\nProvide a similar example for <PropertyPath> traversing a containment relationship.\n\nAccepted: https://www.oasis-open.org/committees/download.php/50840/odata-meeting-53_on-20130926-minutes.html#odata-481\n\nImported from [ODATA-481](https://issues.oasis-open.org/browse/ODATA-481)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$batch: remove restriction \"within the same change set \" for Content-ID referencing",
    "body": "Currently we restrict content-id referencing to entities created within the same change set. As we define that the content-id must be unique within a batch request, this is unnecessary.\n\n### Proposal\n\nRemove restriction \"within the same change set \" for Content-ID referencing and allow referencing requests within the same batch that appear before the reference and thus already have been processed.\n\nAdd term BatchContentIdReferencingAcrossChangeSetsSupported to Capabilities vocabulary, similar to the existing term BatchContentIdReferencingInRequestBodiesSupported.\n\nImported from [ODATA-480](https://issues.oasis-open.org/browse/ODATA-480)",
    "labels": [
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Content-ID referencing in request bodies for inserting links to newly created entities",
    "body": "Object graphs that are not trees can require inserting links to entities that just have been created in the same change set. This can only be done with content-id references within request bodies.\n\n### Proposal\n\nContent-ID referencing in request bodies is allowed:\n\nPUT $2/SingleValuedNavigationProperty\n{\n  \"@odata.context\": \"http://host/service/$metadata#$ref\",\n  \"@odata.id\": \"$1\"\n}\n\nPOST SomeEntitySet\n{\n    ...,\n    \"SingleNavigationProperty@odata.bind\":\"$2\",\n    \"MultiValuedNavigationProperty@odata.bind\":[\"$1\",\"$3\",\"SomeEntitySet(42)\"],\n    ...\n}\n\n\nServices allowing $<content-id value> syntax in request bodies for inserting links SHOULD advertise this with the new term BatchContentIdReferencingInRequestBodiesSupported in the Capabilities vocabulary:\n\n      <Term Name=\"BatchContentIdReferencingInRequestBodiesSupported\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"EntityContainer\">\n        <Annotation Term=\"Core.Description\" String=\"Service supports Content-ID referencing in request bodies\" />\n      </Term>\n\n\nApplied:\nhttps://tools.oasis-open.org/version-control/browse/wsvn/odata/trunk/spec/vocabularies/Org.OData.Capabilities.V1.xml?rev=679\n\nApplied:\nhttps://www.oasis-open.org/committees/download.php/55616/odata-v4.0-wd08-part1-protocol-2015-05-07.docx\n\nImported from [ODATA-479](https://issues.oasis-open.org/browse/ODATA-479)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.0_ERRATA03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify format for values of Content-ID header in $batch parts",
    "body": "Part 1 refers to RFC2045, which in turn refers to RFC822, which limits values to email-address-like strings enclosed in \"<\" and \">\" that are globally unique.\n\n### Proposal\n\nDo not refer to RFC2045 and allow any number or token\n\nImported from [ODATA-478](https://issues.oasis-open.org/browse/ODATA-478)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that dynamic properties can be used in all system query options",
    "body": "We currently only state this explicitly for $select, but we also talked about this in $filter.\n\n### Proposal\n\nSee summary.\n\nAlso a dynamic property evaluates to null if it is not defined on an instance, and the normal null-propagation rules as defined in URL Conventions apply.\n\nImported from [ODATA-477](https://issues.oasis-open.org/browse/ODATA-477)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that type-cast segments are required for properties of derived types in system query options",
    "body": "We allow type-cast segments in expressions, but we don't specify whether they are required.\n\nAs a property name is unique within an instance, the type-cast segment is not necessary for evaluating the expression, but it helps evaluating the expression.\n\n### Proposal\n\nSee summary.\n\nImported from [ODATA-476](https://issues.oasis-open.org/browse/ODATA-476)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Document that the value \"%\" is used for annotating percentages with Measures.Unit",
    "body": "Percentages are a common case of measured quantities, and we fail to define what standard unit to assign these.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-475](https://issues.oasis-open.org/browse/ODATA-475)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add example for POST/PUT/PATCH/DELETE on function result",
    "body": "We mention that this is possible. An example would be helpful for implementing the specification.\n\n### Proposal\n\nhttps://www.oasis-open.org/committees/download.php/50850/odata-v4.0-wd04-part1-protocol-2013-09-27.docx\n\n\nImported from [ODATA-474](https://issues.oasis-open.org/browse/ODATA-474)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Harmonize description of function overload advertisement in Atom and JSON",
    "body": "Both texts are correct, but cover different aspects of the topic. Compose text that covers all aspects and use the same text in both specifications.\n\nImported from [ODATA-473](https://issues.oasis-open.org/browse/ODATA-473)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly state how dynamic properties are represented if they are not defined on an entity",
    "body": "\n\n### Proposal\n\nDynamic properties that are requested in $select are listed in the context URL.\n\nIf a requested property is not defined for an instance of an open type that otherwise matches the request, the instance is part of the response and is represented without the undefined property.\n\nRequesting undeclared properties for types that are not open results in an error.\n\nImported from [ODATA-472](https://issues.oasis-open.org/browse/ODATA-472)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Property names must also be a valid XML Names (NCName)",
    "body": "Otherwise we run into trouble in Atom with <d:propertyName>\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-471](https://issues.oasis-open.org/browse/ODATA-471)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify behavior of /$value requests to properties of type Edm.Binary or Edm.Geo*",
    "body": "Part 1, section 11.2.3.1 states the behavior for single-valued primitive properties of types except Edm.Binary and the Edm.Geo types and does not state what has to happen in these special cases\n\n### Proposal\n\nThe default format for Edm.Geo* types is text/plain using the WKT (well-known text) format, see ABNF rules fullPointLiteral etc.\n\nThe default format for Edm.Binary is the format specified by the Core.MediaType annotation of this property if this annotation is present. If not annotated, the format cannot be predicted by the client.\n\nImported from [ODATA-470](https://issues.oasis-open.org/browse/ODATA-470)",
    "labels": [
      "Protocol",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Type of Extends attribute in edm.xsd must be TQualifiedName instead of TSimpleIdentifier",
    "body": "CSDL section 13.1.2 specifies that the Extends attribute has a QualifiedName as its value. Unfortunately edm.xsd contains a typo and defines the attribute to be a TSimpleIdentifier. \n\n### Proposal\n\nCorrect edm.xsd.\n\nImported from [ODATA-469](https://issues.oasis-open.org/browse/ODATA-469)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define explicit concepts in ABNF for referenced sets of rules",
    "body": "There are a few places today where we reference things like \"xxx\" rule in the ABNF. That is, a set of rules that match a particular pattern.\n\nFor example, [CSDL] contains the following text:\n\n    \"Default values MUST be represented according to the xxxValue rule defined in [OData-ABNF] that is appropriate for the type of the property.\" \n\nWhich is intended to mean the \"unprefixed primitive literal values\". However, users looking at the documentation won't find \"xxxValue\" and, in fact, won't find \"xxxValue\" rules for some of the primitives (for example, there is no \"StringValue\".\n\nAlso note that constant expressions reference the xml schema serialization rules, rather than the rules in our ABNF (which are hopefully equivalent?). To make sure we are in sync, documents should reference the primitive value serialization defined in the [ABNF], which should reference xml schema as appropriate.\n\n### Proposal\n\nDefine terms in the [ABNF] for particular patterns referenced elsewhere. For example, define \"primitiveValue\" rule as a wrapper for the xxxValue values.\n\nMake sure other documents reference the [ABNF], rather than directly reference xml schema or other external definitions, for serialization formats.\n\nImported from [ODATA-468](https://issues.oasis-open.org/browse/ODATA-468)",
    "labels": [
      "ABNF",
      "CSDL XML",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify relationship between EntitySet in Function/ActionImport and EntitySetPath in Function/Action definition",
    "body": "Functions may optionally contain an EntitySetPath attribute, that specifies the entity set that returned entities belong to relative to the entity set of the binding parameter.\nFunctionImports may optionally specify an EntitySet which is a specific entityset that returned entities belong to.\n\nWe are not explicit on how EntitySetPath is used for FunctionImports. It could be ignored, it could be the default if EntitySet is not specified, or it could be illegal to specify EntitySet if EntitySetPath is specified.\n\nSame is true for Actions.\n\n### Proposal\n\nEntitySetPath, if specified, is the default path for the Function/ActionImport. EntitySet, if specified in the function/action import, overrides whatever entitysetpath may have been specified in the function/action definition.\n\nImported from [ODATA-467](https://issues.oasis-open.org/browse/ODATA-467)",
    "labels": [
      "CSDL XML",
      "V4.0_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Edm.Binary should be base64-encoded (as with OData V3), not base16-encoded (as per current ABNF)",
    "body": "OData V3 encodes Edm.Binary using base64 encoding, as defined by RFC4648.\n\nOData V4 JSON and ATOM specs for encoding of primitive values refer to \"binaryValue\" in the ABNF.\n\nIt this an intentional change for the encoding of binary values in payload (switching from base16 to base64)?\n\nOr have we accidentally (by having URL conventions and ATOM/JSON documents referring to the same binaryValue ABNF rule) changed to base16?\n\nAlso, I note that odata4j does base64 encoding including CR/LF, whereas RFC 4648 (referred to by OData V3 spec) states:\n\n   Implementations MUST NOT add line feeds to base-encoded data unless\n   the specification referring to this document explicitly directs base\n   encoders to add line feeds after a specific number of characters.\n\nMy reason for pointing this out is that if we decide to revert OData V4 to using base64-encoding for binary values in payload, then we might consider explicitly mentioning that CR/LF is disallowed in the encoding. Even although that should be apparent if we have a suitable ABNF rule for base64 that doesn't permit CR/LF, we should be clear so that implementors are reminded not to make the same mistake that was made in odata4j.\n\n\n### Proposal\n\nConsistently use base64url encoding for binary data throughout OData, see http://tools.ietf.org/html/rfc4648#section-5. This variant of base64 is URL-safe.\n\nThe pad character = is allowed but not necessary as the encoded value is prefixed and enclosed in single quotes in URLs, enclosed in double quotes in JSON, and represented as an attribute or element value in XML (CSDL, Atom format). \n\nOnly allow \"binary\" as prefix in URLs as the prefix 'X' would misleadingly suggest HEX encoding.\n\nImported from [ODATA-466](https://issues.oasis-open.org/browse/ODATA-466)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "URL Conventions",
      "V4.0_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly mention that complex type instances can have stream properties (public comment c201307e00000)",
    "body": "Chapter 9 of Atom and JSON only talked about entities and forgot to mention complex type instances\n\nThe public comment [c201307e00000](https://lists.oasis-open.org/archives/odata-comment/201307/msg00000.html) with title \"Are Edm.Stream properties supported in complex types?\" states:\n\n\"\"\"\nSection 9 of CSDL doc states that:\n\n\"A complex type can define two types of properties. A structural property is a named reference to a primitive, complex, or enumeration type, or a collection of primitive, complex, or enumeration types. A navigation property is a named reference to an entity type or a collection of entity types...\"\n\nSection 4.4 of the same documents includes Edm.Stream into Primitive Types.\n\nBut section 9 of Atom format doc states that:\n \"An entity MAY have one or more stream properties (for example, a photo property of an employee entity). Properties that represent streams have a type of Edm.Stream.\"\n\nThat does not mention complex types.\n\nCould you clarify wheter complex types support Edm.Stream properties?\n\nPersonally, I would like that feature, an I don't think there is any trouble with it, Complex types support Navigation Properties already.\n\nCSDL Doc: http://docs.oasis-open.org/odata/odata/v4.0/csprd02/part3-csdl/odata-v4.0-csprd02-part3-csdl.html#_Toc360208810\nAtom Doc: http://docs.oasis-open.org/odata/odata-atom-format/v4.0/csprd02/odata-atom-format-v4.0-csprd02.html\n\"\"\"\n\n### Proposal\n\nExplicitly mention complex type instances\n\nImported from [ODATA-465](https://issues.oasis-open.org/browse/ODATA-465)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Disallows $format for delta and next links",
    "body": "currently the only system query option we allow appending to delta links and next links is $format. this doesn't really add any value, since the client can specify the format in the accept header, and is currently the only system query option we allow the client to append. we should simplify this by just saying no system query options are supported\n\n### Proposal\n\ndisallow all system query options from delta link and next link\n\nImported from [ODATA-464](https://issues.oasis-open.org/browse/ODATA-464)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Deleted-entry, link, and deleted-link should include {entity-set} in context URL",
    "body": "the Context URL for deleted entry, link, and deleted-link should include the {entity-set} segment. this is consistent with {entity-set}/#$entity for single entities as well.\n\n### Proposal\n\nadd {entity-set} to context URL for deleted entry, link, and deleted-link context URLs\n\nImported from [ODATA-463](https://issues.oasis-open.org/browse/ODATA-463)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support for HTTP verb tunnelling is essential because client libraries may not support PATCH",
    "body": "Some client libraries (e.g. HttpURLConnection in JDK 1.7) don't support PATCH, e.g. see this stack trace:\n\njava.net.ProtocolException: Invalid HTTP method: PATCH\n    at java.net.HttpURLConnection.setRequestMethod(HttpURLConnection.java:428)\n\nTo ensure maximum interoperability with clients (and not force clients to use PUT rather than PATCH), we should require OData services to support HTTP verb tunnelling.\n\nSee X-HTTP-Method in http://msdn.microsoft.com/en-us/library/dd541471.aspx\n\n\n### Proposal\n\nRequire services to support  HTTP verbs other than GET and POST to be tunnelled inside a POST using the X-HTTP-Method header.\n\n\nImported from [ODATA-462](https://issues.oasis-open.org/browse/ODATA-462)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add terms to capability vocabulary",
    "body": "Currently we advertise some capabilities of services through the Capability-Vocabulary. But we missed so far to define terms for the following capabilities:\nSnapshotSupported,\nBatchContinueonErrorSupported,\nIncludeAnnotationSupported\nServerDrivenPagingSupported\nChangeTrackingSupported\nAsynchronousReqeustSupported\nWaitSupported\ncallbackSupported or we change the sentence \"Services that support odata.callback SHOULD support notifying the client through HTTP and can advertise support for additional callback protocols using the CallbackProtocols annotation term defined in [OData-VocCap].\"  in the spec to  \"Services that support odata.callback SHOULD support notifying the client through HTTP and SHOULD advertise support for callback protocols using the CallbackProtocols annotation term defined in [OData-VocCap].\",\n\n\n### Proposal\n\nAdd appropriate Terms to Capabilities Vocabulary for \nSnapshotSupported,\nBatchContinueonErrorSupported,\nAsynchronousReqeustSupported\n\nModify term for callback to a complextype with a collection of protocols. The collection of protocols, if present, is the full set of protocols.\n\nImported from [ODATA-460](https://issues.oasis-open.org/browse/ODATA-460)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "State consequences of using IRIs that are not URLs",
    "body": "\n\n### Proposal\n\nUsing an IRI that is not a URL as an entity-id requires to have in addition an edit link or read link. Even if the edit link is the standard encoded version of the IRI, they are treated as different and need to be represented separately in JSON\n\nThe client must be prepared to accept any IRI but that services must use URIs in 4.0 since we have no lossless representation of an IRI in the entity-id header.\n\nImported from [ODATA-459](https://issues.oasis-open.org/browse/ODATA-459)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "odata.isolation should be a header rather than an expectation",
    "body": "[ODATA-317](https://issues.oasis-open.org/browse/ODATA-317) added support for snapshot isolation by specifying a new odata.isolation expect header. However, upon further research, expect headers must be understood by intermediaries or rejected. so even though a service might support snapshot isolation, intermediaries would likely return expectation failed.\n\nWe discussed making this a preference, but earlier we had said that the desired behavior was for the service to fail the request if the client specified snapshot and the service was unable to provide that level of isolation, and preferences should not cause errors.\n\nSo it seems the best way to support this functionality is to introduce a new odata header for isolation.\n\n### Proposal\n\nintroduce an OData-Isolation header with a single value defined of \"snapshot\" in place of the expect header proposed in [ODATA-317](https://issues.oasis-open.org/browse/ODATA-317).\n\nImported from [ODATA-458](https://issues.oasis-open.org/browse/ODATA-458)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Require hash (#) on odata.type",
    "body": "[ODATA-445](https://issues.oasis-open.org/browse/ODATA-445) made odata.type relative to containing odata.type or (at the root) odata.context. In applying this change the rules around optionality of the hash (#) for type names in the current document seemed arbitrary and overly complex without adding much value.\n\nWe should consider making the hash required (as it is in context url) except possibly for built-in primitive types (which are already special in that we require them not to specify the edm prefix)\n\n### Proposal\n\nRequire the hash for all except built-in primitive types. built in primitive types are always simple identifiers.\n\nImported from [ODATA-457](https://issues.oasis-open.org/browse/ODATA-457)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "Extension for JSON Data",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Don't require client to specify odata.trackchanges preference on each page",
    "body": "Today we require that, if a client wants change tracking on a paged result, they must specify odata.trackchanges preference on each page.\n\nIt is much easier for the service to encode in the next link the fact that the client wants change tracking than to have the client have the logic to add this to each next page request (the service already has to hold on to the \"low water mark\" or other delta token from the initial request). The client can also specify the odata.changetracking preference on GET to delta link to signal they will want to continue tracking changes after apply the current set of changes.\n\nImported from [ODATA-456](https://issues.oasis-open.org/browse/ODATA-456)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make EntityContainer a Singleton in MetadataService",
    "body": "We've restricted a service to a single entity container, so we could change the metadata service to expose a singleton EntityContainer instead of an entity set EntityContainers.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-455](https://issues.oasis-open.org/browse/ODATA-455)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Need a way to specify a property is unavailable",
    "body": "We have added the ability for services to select the set of properties returned in a feed or individual entity, which allows the service to optimize results (for example, when sending to a device). However, we currently require that the service specify in the metadata url the set of properties returned, and that each entity in the result contain the same set of properties.\n\nThere are times when a particular property is not available to the client (for example, due to permissions), and that permission may vary between different elements of a feed. For example, a manager may be able to see salaries for those reporting to them but not to their peers. It's wrong to report \"null\" for the salaries of their peers; their peers have a salary, it's just not available to them.\n\nWe could define a \"Permissions\" term in either core or capabilities vocabularies that could apply to an entity set or property in metadata and could be overwritten in the instance data.\n\nIt is important to do this in V4, so that client know to look for this annotation in the absence of a value for a property. We might want to rationalize this with permissions for update versus readonly in the capabilities vocabulary.\n\n### Proposal\n\n1) Define a core term that can be used as a data/metadata annotation:\n\n<Term Name=\"Permissions\" Type=\"Core.Permission\" AppliesTo=\"Edm.Property\"/>\n<EnumType Name=\"Permission\" Flags=\"true\">\n  <Member Name=\"None\" Value=\"0\" />\n  <Member Name=\"Read\" Value=\"1\" />\n  <Member Name=\"Write\" Value=\"2\" />\n  <Member Name=\"ReadWrite\" Value=\"3\" />\n</EnumType>\n\n1a) For 4.0, we will omit the Write member.\n\n2) Allow the service to omit properties from the payload that are specified in metadata, even if they are selected. Such omitted properties have no value (as distinct from null) and should be annotated with the Core.Permissions term. Instances with omitted values for properties that appear in the $filter expression are excluded from the result. Accessing an omitted value returns 404.\n\n3) In the payload, properties that the client does not have permission to read are omitted from the payload (no data:property-name element in ATOM and no name/value pair in JSON) and annotated with the \"None\" permission.\n\nImported from [ODATA-454](https://issues.oasis-open.org/browse/ODATA-454)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "deal with KEY function",
    "body": "today the KEY function can be used to pass a reference to an existing entity as a parameter value. i.e.;\n\n~foo(KEY(Customers('ALFKI')))\n\nThe name \"KEY\" is poor; really this is similar to the urlref annotation expression.\n\nWe want a way to pass relative to the root of the service or the \"current\" entity.\n\nOption 1: rename \"KEY\" to \"urlref\" and constrain this to only take the canonical url of an entity for 4.0 (we can relax this in the future). url may be relative to the service if it starts with \"/\", otherwise it's relative to the \"current\" resource. only support as a function parameter (as today). \n\nOption 2: Allow use of a first member expression rooted at current instance, or / for relative to root service. so\n\n~foo(entity=$root/Customers('ALFKI'))\n\nrooted at service always uses \"/\"\n\n/Orders/ns.foo(entity=$root/Customers('ALFKI'))\n\n/Orders/ns.foo(entity\n\n### Proposal\n\nRemove KEY(...) syntax.\n\nAllow passing first member expression rooted at the service root with $root.\n\nCan be used anywhere in custom expression.\n\nEspecially can be used in URL arrays and objects: [$root/Products(0),$root/Products(1)]\n\n\nImported from [ODATA-453](https://issues.oasis-open.org/browse/ODATA-453)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Services should be allowed to filter changes based on selected fields",
    "body": "Currently, users are allowed to specify $select in a query for which they track changes, but the $select must not be used to determine whether or not a change matches. That is, the service must return a change to the record even if it doesn't match one of the selected fields. Also, we allow the client to specify a $select on the delta link to request back a different set of fields than on the initial query.\n\nWhile many services will not be able to filter based on the set of selected fields (at least until they do change tracking on filtered results), we should allow those that do to be able to do so. Not filtering based on selected fields simply results in over-notification, so this doesn't break anything, but if a client is expecting to get changes for non-selected fields and does not then it would be a data loss.\n\n### Proposal\n\nServices may filter changes based on selected properties, returning only those rows that have changes to the selected fields. Clients must not attempt to compose $select to the delta link.\n\nClient should not be allowed to append any query options to delta links, with the exception of $format (consistent with next link). We have a preference for max page size, so $top/$skip is not needed (and is potentially dangerous based on ordering).\n\nImported from [ODATA-452](https://issues.oasis-open.org/browse/ODATA-452)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Provide section that clearly indicates what system query options are allowed on the various combinations of URL type and HTTP method (public comment c201306e00012)",
    "body": "We received the public Comment #20130600012 on 2013-06-14 with title \"feedback/discussion now that public comment period is over\".\n\nText was: \n\"\"\"\nWhere can I send comments about or have discussion regarding the OData v4 spec now that the public comment period is over?\n\nI would like to know if the $select and $expand system query options are allowed on insert entity requests to limit or expand the data that is returned (when it is requested via a PREFER header that data be returned).  A section that clearly indicates what system query options are allowed on the various combinations of URL type and HTTP method would be helpful (unless it exists already and I just missed it).\n\"\"\"\n\n### Proposal\n\nWhen inserting an entity we already specified that the service MUST return at least the expansion level that was present in the (deep) insert request.\n\nAs clients should have a complete representation of how the service interpreted their request, the response MUST NOT be projected by the service (this rule is new).\n\nConsequently $expand and $select are not allowed on insert requests, and none of the other system query options make sense either.\n\nSimilar argument for update requests: no system query options on update requests.\n\nDelete request don't return data, so no question here.\n\nSummary: CUD operations don't allow system query options.\n\nThe rationale for actions is different: there's no predefined semantics for actions, so all system query options applicable to the return type are allowed. For functions they are allowed anyway.\n\nImported from [ODATA-451](https://issues.oasis-open.org/browse/ODATA-451)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ordering of association link , navigation link, expanded nav prop",
    "body": "atom and json each have slightly different constraints about ordering of association link, navigation link, and expanded navigation. we should define consistent rules for ordering of association link, navigation link, and expanded navigation between atom and json.\n\n### Proposal\n\nAssociation link, if written, should immediately precede navigation link,if written, should immediately precede expanded nav prop. \nThe navigation link is present whenever the nav prop is expanded.\nThe association link does not need to be written in atom or json if it follows convention (associationlink/$ref)\n\nImported from [ODATA-450](https://issues.oasis-open.org/browse/ODATA-450)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify restrictions for action/function overloads, rename IsBindable to IsBound",
    "body": "The goal for action and function overload resolution is that the overload can be identified by inspecting the URL only.\n\nThis goal leads to restrictions on which overloads can be defined.\n\n\nActions\n- non-bindable actions cannot have overloads because the URL just contains the action name, all parameters are in the POST body\n- bindable actions can have overloads based on the binding parameter type because the binding parameter is specified in the URL\n\nThis is captured in the current spec text.\n\n\nFunctions\n- the first parameter for bindable functions can be specified as a path prefix, not specifying the parameter name\n- other parameters are specified with name and value in the URL\n- numeric literal values don't differ within the type families \"Integer\" and \"Float\"\n\nSo for bindable functions the following information is available for overload selection:\n- names of non-binding parameters\n- type of binding parameter\n- type family of non-binding parameters\n\nFor non-bindable functions the following information is available for overload selection:\n- names of  all parameters\n- type family of all parameters\n\nType families are\n- Integer: Edm.SByte, Edm.Byte, Edm.Int16, Edm.Int32, Edm.Int64, Edm.Decimal with Scale equal to zero\n- Float: Edm.Single, Edm.Double, Edm.Decimal with Scale not equal to zero.\n\n### Proposal\n\nActions/functions are bound or not bound. --> IsBindable attribute is renamed to IsBound\n\nActions:\n\nBound actions can only be called via a path prefix.\nUnbound actions can only be called via an ActionImport.\nOnly bound actions whose first parameter is (a collection of) an entity type can have an EntitySetPath.\n\nFunctions:\n\nFor unbound functions the combination of the function name and unordered set of parameter names MUST identify a particular function overload. \nOnly unbound functions can be used in function imports.\n\nAll unbound overloads MUST have the same return type.\n\nFor bound functions the combination of the function name, the binding parameter type, and the unordered set of parameter names for non-binding parameters MUST identify a particular function overload. \n\nAll bound overloads with a given binding parameter type MUST have the same return type.\n\nRemove default values for parameters. client passes values for each parameter.\n\n\nImported from [ODATA-449](https://issues.oasis-open.org/browse/ODATA-449)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add Nullable facet to edm:ReturnType",
    "body": "Functions or actions currently have no way to signal to clients that they may return a null result.\n\n### Proposal\n\nAdd Nullable to list of allowed facets for edm:ReturnType element. Nullable=\"false\" means that the function or action will never return a null value but instead fail with 4xx if it cannot compute a result. For functions that return a single entity 404 Not Found is the appropriate answer.\n\nImported from [ODATA-448](https://issues.oasis-open.org/browse/ODATA-448)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rename Metadata URL to Context",
    "body": "We've been adding a lot of information into the metadata URL: the metadata base URL, the entity set, the derived type, the selected properties, ...\n\nThis requires clients to parse this string, taking away some of the simplicity of using transport formats for structured data (JSON, XML).\n\nWe could represent the metadata URL in parsed syntax:\n\nJSON\n- rename the odata.metadata annotation to odata.context\n- make it an object with properties\n-- url: string\n-- set: string\n-- type: string (qualified name, (relative) url, \"$ref\")\n-- projection: array of selected properties as strings or objects, the latter having name-value pairs name, recursive, projection\n\nAtom\n- replace the metadata:metadata attribute with a metadata:context element\n- structure is\n-- url: xs:anyUri\n-- set: SimpleIdentifier\n-- type: string\n-- projection: ...\n\nNo change to the odata.metadata=none | full | minimal in the json format parameter.\n\nIn the docs refer to the \"odata context\".\n\nExample\n\nmetadata URL:\n  \"odata.metadata\":\"http://host/service/$metadata#Employees/Sales.Manager(DirectReports+(FirstName,LastName))\"\n\ncontext object:\n  \"odata.context\":{\n    \"url\":\"http://host/service/$metadata\",\n    \"set\":\"Employees\",\n    \"type\":\"Sales.Manager\",\n    \"projection\":[\n      \"*\",\n      {\n        \"property\":\"DirectReports\",\n        \"recursive\":true,\n        \"projection\":[\n          \"FirstName\",\n          \"LastName\"\n        ]\n      }\n    ]\n  }\n\n### Proposal\n\nRename \"odata.metadata\" annotation in json to \"odata.context\". rename \"metadata:metadata\" attribute in atom to \"metadata:context\".\n\nImported from [ODATA-447](https://issues.oasis-open.org/browse/ODATA-447)",
    "labels": [
      "ATOM Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rename Named Stream to Stream Property",
    "body": "The name \"Named Stream\" caused some confusion, so we should change it to \"Stream Property\"\n\n### Proposal\n\nSee Summary\n\nImported from [ODATA-446](https://issues.oasis-open.org/browse/ODATA-446)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "odata.type relative to odata.type in surrounding entities",
    "body": "\n\n### Proposal\n\nodata.type value can be relative to odata.type in enclosing objects, and only after that relative to odata.metadata\n\n\nImported from [ODATA-445](https://issues.oasis-open.org/browse/ODATA-445)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Representation of entity references",
    "body": "\n\n### Proposal\n\nEntity references in ATOM/JSON\n- MUST contain odata.metadata, \n- MAY contain additional annotations in any namespace\n- MAY especially contain odata.type\n\n\nImported from [ODATA-444](https://issues.oasis-open.org/browse/ODATA-444)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Last page of delta response MUST contain a delta link",
    "body": "Currently section 11.3 in protocol part 1 says that the last page of a delta response SHOULD contain a delta link.  Replace SHOULD with MUST.\n\n### Proposal\n\nChange wording; in order to continue tracking changes, the service returns a delta-link on the next page.\nClients continue to specify the track-changes prefer header when following the delta link in order to make sure the service knows it wants to continue to track changes after applying the current set of changes.\nAlso, service returns preference applied to signal that change tracking has been enabled, and the client will see a delta-link on the last page.\n\nImported from [ODATA-443](https://issues.oasis-open.org/browse/ODATA-443)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Adapt metadata service",
    "body": "When reviewing the metadata service some topics came up.\n\n### Proposal\n\nKey of model elements:\n- Schema key is Namespace instead of Fullname\n- Type key is QualifiedName instead of Fullname\n\nAdd Meta.StructuredType as common abstract base type of Meta.EntityType and Meta.ComplexType that declares Properties and NavigationProperties that serve as Partner for the back links on Meta.Property and Meta.NavigationProperty\n\nNavigation properties Properties and NavigationProperties on entity type StructuredType: \n- only properties that are directly declared by this type\n- functions Meta.AllProperties and Meta.AllNavigationProperties that list all (navigation) properties a type declares or inherits\n\nNavigation property EntitySets on EntityType: \n- only entity sets that declare that type directly, not entity sets where this type can appear because it is derived from the declared type\n- function Meta.AllEntitySets that lists all entity sets this type can appear in\n\nRename Meta.SecondaryAnnotation to Meta.InlineAnnotation, use it in Meta.OnDelete, Meta.ReferentialConstraint, and Meta.NavigationPropertyBinding instead of navigation property to Meta.Annotation.\n\nEntity set Annotations contains all annotations of externally annotatable model element, independent of whether these were actually embedded or stated externally, and independently of whether these were in $metadata or included from a referenced document.\n\nImported from [ODATA-442](https://issues.oasis-open.org/browse/ODATA-442)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify canonical form of entity-id",
    "body": "Slightly modified proposal:\n\nBy convention, the entity-id does not end with a cast segment even if the entity type is part of an inheritance hierarchy.\nThe canonical representation of the edit/self link is the id plus the cast segment [as required]\nThe canonical representation of the navigation link is the self link plus the navigation property\nThe canonical representation of the association link is to append /$ref to the navigation link.\n\nThis simplifies rules by putting the cast segment on the self link rather than conditionally applying it to each navigation property/advertised function/etc.\n\n### Proposal\n\nSlightly modified proposal:\n\nBy convention, the entity-id does not end with a cast segment even if the entity type is part of an inheritance hierarchy.\nThe canonical representation of the edit/self link is the id plus the cast segment [as required]\nThe canonical representation of the navigation link is the self link plus the navigation property\nThe canonical representation of the association link is to append /$ref to the navigation link.\n\nThis simplifies rules by putting the cast segment on the self link rather than conditionally applying it to each navigation property/advertised function/etc.\n\nImported from [ODATA-441](https://issues.oasis-open.org/browse/ODATA-441)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify response for function or action that returns a single null value",
    "body": "With [ODATA-412](https://issues.oasis-open.org/browse/ODATA-412) we decided that a null value has no \"stand-alone\" representation and instead requests to resource that has the null value return 404 Not Found.\n\nWe did not consider actions and functions that return a single value.\n\nFor functions it would be somewhat surprising if they would return 404 No Content if the result for a value combination is null. Especially if the function is composable and composing another function that takes this null value and produces a result from it would respond with 200 OK:\n\nGET ~/Foo(1) --> 404 Not Found\nGET ~/Foo(1)/Bar(2) --> 200 OK\n\nAlso we already define that actions that do not declare a return type respond with 204 OK, and having \"sometimes no result\" work differently from \"always no result\" seems odd.\n\n### Proposal\n\nFunctions, actions, single-valued properties and single-valued navigation properties return 204 No Content if null, and can be composed with functions that accept null binding parameter values.\nIf a Entity key lookup returns 404 the request returns 404 even if composed with functions/actions that accept null binding parameter values.\n\nImported from [ODATA-440](https://issues.oasis-open.org/browse/ODATA-440)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Complete Context URL patterns",
    "body": "Some Metadata URL patterns are missing:\n- singletons\n- contained entities: with key of parent?\n- function returning entity or collection of entity from an entity set (EntitySet attribute on function/action)\n\nMetadata URL for single reference is rather long: #$ref/$entity.\n\nMetadata URL for cross-join\n\n### Proposal\n\nSingletons:\n#{singleton-name}\n\nContained entities\n#{entity-set}\n#{entity-set}/$entity\nentity-set here is the canonical URL for the containment navigation property of the containing entity, e.g. Orders(4711)/Items\n\nSingle reference\n#$ref\n\nCollection of references\n#Collection($ref)\nSame as for collection of primitive/complex type\n\nFunction/action result that is extract of entity set: same pattern as for that entity set\nOtherwise: Collection({entity-type})\n\nResult of $crossjoin\n#Collection(Edm.ComplexType)\n\nResult of $all\n#Collection(Edm.EntityType)\n\n\n\n\nImported from [ODATA-439](https://issues.oasis-open.org/browse/ODATA-439)",
    "labels": [
      "ABNF",
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rename edm:Url to edm:UrlRef",
    "body": "People are confused by the element name \"Url\". To cleary point out that this is an expression, we should rename edm:Url. We proposeas a new element name edm:UrlRef.\n\n### Proposal\n\nRename edm:Url to edm:UrlRef\n\nImported from [ODATA-438](https://issues.oasis-open.org/browse/ODATA-438)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Describe path syntax for edm:Annotations/@Target ",
    "body": "Most CSDL elements can be annotated by adding edm:Annotation child elements.\n\nThe edm:Annotations element allows to annotate named CSDL elements by specifying them as the Target using a path expression. Unfortunately the syntax of these path expressions is not defined.\n\n### Proposal\n\nExternal targeting is only possible for EDM elements that are uniquely identified by a name within their parent, and all their *(grand)parent elements are uniquely identified by a name within their parent.\n\nThis excludes edmx:Reference because it is not an EDM element, and externally annotating a reference seems odd anyway.\nThis excludes Action, Function, Parameter, and ReturnType because action and function overloads are indistinguishable by name.\nThis also excludes OnDelete, ReferentialConstraint, NavigationPropertyBinding, and all constant and dynamic annotation expressions because they are unnamed.\n\nQualifiedName of schema child, optionally followed by a slash and name of nested element:\n\nExamples:\n- Schema.Type\n- Schema.EntityType/Property\n- Schema.ComplexType/NavigationProperty\n- Schema.EnumType/Member\n- Schema.EntityContainer\n- Schema.EntityContainer/EntitySet\n\nImported from [ODATA-437](https://issues.oasis-open.org/browse/ODATA-437)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow annotating edm:Annotation element, disallow annotating edm:Collection element",
    "body": "Sometimes it is necessary to explain the application of a term, not the term itself. Which is why most annotation expressions can be annotated. \n\nUnfortunately neither constant expressions nor the Annotation element itself can be annotated, so we can't express why a simple value was annotated.\n\nAllowing annotations on edm:Annotation will solve that, and also make it unnecessary to annotate edm:Collection because all the surrounding expressions can be annotated now.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-436](https://issues.oasis-open.org/browse/ODATA-436)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify URL syntax and CSDL by restricting services to exactly one entity container",
    "body": "We had to introduce a URL convention for addressing children of non-default entity containers using names with at least two dots in them (e.g. namespace.container.entityset), which already lead to some confusion.\n\nWe can simplify that by restricting services to one entity container, defined in the central $metadata CSDL document.\n\nThis would also remove the IsDefaultEntityContainer attribute from CSDL\n\n### Proposal\n\nCSDL\n- a schema can have at most one entity container\n- the metadata document of a service MUST have exactly one entity container, multiple schemas are allowed and can be used to group model elements\n- entity containers still have a Name attribute\n- an entity container can still extend the entity container of another schema, the Extends attribute will name the entity container whose container is extended\n- EntitySet attribute of ActionImport and FunctionImport elements only allow a SimpleIdentifier because there's no need to qualify entity set names\n\nURL/ABNF\n- remove optional container qualifier (rule containerQualifier) from URL conventions\n\nImported from [ODATA-435](https://issues.oasis-open.org/browse/ODATA-435)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce path segment for cross-joins on entity-container level",
    "body": "The current URL convention allows querying the cross-join of entity sets via requests targeting the entity container.\n\nThis leads to potential name clashes:\n\n\tGET ~/Foo.Fred.Waldo\n\ncan be a query targeting the entity container Waldo in schema Foo.Fred, or a query targeting entity set Waldo in container Fred of schema Foo.\n\nThis clash can be avoided by using a path segment, similar to the path segment /$all that we use to address the union of all entities in a container.\n\n\n\n### Proposal\n\nDefine path segment $crossjoin that takes a list of one or more entity set names as its parameters. The listed entity sets define the structure of the cross-join result, no abuse of $select any more, no \"semantic overload\" of the entity container.\n\nExample:\n\nGET ~/$crossjoin(Products,Customers)?$filter=Products/Name eq Customers/Name\n\n\nImported from [ODATA-434](https://issues.oasis-open.org/browse/ODATA-434)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rollback requirement that services support $expand",
    "body": "In applying [ODATA-402](https://issues.oasis-open.org/browse/ODATA-402) we realized that the trick of including a next-link does not work for to-one navigation properties. That means that requiring services to support $expand may be very difficult/expensive, particularly for distributed services.\n\nI propose we rollback [ODATA-402](https://issues.oasis-open.org/browse/ODATA-402).\n\n### Proposal\n\nRollback [ODATA-402](https://issues.oasis-open.org/browse/ODATA-402); make $expand optional at all conformance levels (SHOULD at advanced level)\n\nReintroduce capability annotation for $expand\n\nImported from [ODATA-433](https://issues.oasis-open.org/browse/ODATA-433)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add $expand=*, $expand=*/$ref, $expand=*($levels=...) for expanding all navigation properties",
    "body": "$select=* allows selecting all structural properties, including dynamic structural properties.\n$expand=* would allow expanding all navigation properties, including dynamic navigation properties.\n\nThis is a not only a convenient shortcut, it also covers cases where metadata inspection wouldn't help: dynamic navigation properties.\n\nIn combination with the suffix /$ref this includes entity references for all related entities.\n\nIn combination with the $level operator this allows expanding an entity graph in all directions up to the given distance to the central entity.\n\n### Proposal\n\n$expand=* expands all navigation properties, including dynamic navigation properties.\n\n$expand=*/$ref inlcudes entity references for all related entities.\n\n$expand=*($levels=2) expands all navigation properties and all navigation properties on related entities.\n\nExplicit naming of a navigation property takes precedence over *.\n\nExamples:\n- $expand=Foo,*/$ref,Bar, means that Foo and Bar are inlined as full representations, and everything else is inlined as references\n- $expand=*,Foo/$ref means that Foo is inlined as references, and everything else as full representations\n\nImported from [ODATA-431](https://issues.oasis-open.org/browse/ODATA-431)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add term Core.ResourcePath to describe unconventional resource paths in CSDL",
    "body": "Currently the resource path for top-level resources (direct children of entity containers) is only represented in the service document, and even there only for most, but not all top-level resources.\n\nAdding resource paths that do not follow the URL conventions to the metadata document has two benefits:\n- the resource path can be stated for all top-level resources\n- the metadata document  contains a superset of the information contained in the service document\n\n### Proposal\n\nAdd term to Core vocabulary\n\n      <Term Name=\"ResourcePath\" Type=\"Edm.String\" AppliesTo=\"EntitySet SingletonEntity ActionImport FunctionImport\">\n        <Annotation Term=\"Core.Description\" String=\"Resource path for entity container child, can be relative\" />\n        <Annotation Term=\"Core.IsUrl\" />\n      </Term>\n\nRefer to term in CSDL and URL Conventions\n\n\"Relative\" has the same meaning as for other URLs: xml:base if present, Content-Location if present, request URL as last resort\n\nImported from [ODATA-430](https://issues.oasis-open.org/browse/ODATA-430)",
    "labels": [
      "CSDL XML",
      "URL Conventions",
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add Boolean property RequiresFilter to Capabilities.FilterRestrictionsType",
    "body": "The current FilterRestrictionsType can specify whether an entity set allows filters or not, and it can specify which properties are required in a filter.\n\nThis does not allow to specify that a filter is required but does not require a specific property in all cases. \n\n### Proposal\n\nAdapt FilterRestrictionsType to include:\n\n      <ComplexType Name=\"FilterRestrictionsType\">\n        ...\n        <Property Name=\"RequiresFilter\" Type=\"Edm.Boolean\" Nullable=\"true\">\n          <Annotation Term=\"Core.Description\" String=\"$filter is required\" />\n        </Property>\n        ...\n      </ComplexType>\n\nImported from [ODATA-429](https://issues.oasis-open.org/browse/ODATA-429)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce dynamic expression AnnotationPath and accompanying abstract type Edm.AnnotationPath",
    "body": "The Path dynamic expression allows to refer to the value identified by a path through an entity graph. Path expressions can end in a\n- property\n- navigation property\n- term cast with optional qualifiers.\n\nIn some situations the path itself is of primary interest, which is why we introduced the dynamic expressions PropertyPath and NavigationPropertyPath.\n\nUnfortunately we forgot the AnnotationPath for paths ending in a term cast with optional qualifiers.\n\n\n### Proposal\n\nThe edm:AnnotationPath expression provides a value for terms or term properties that specify the built-in abstract type Edm.AnnotationPath. It uses the same syntax and rules as the edm:Path expression, with the added restriction that the last path segment MUST be a term cast with optional qualifier in the context of the preceding path part.\nIn contrast to the edm:Path expression the value of the edm:AnnotationPath expression is the path itself, not the value of the annotation identified by the path. This is useful for terms that reuse or refer to other terms.\nThe edm:AnnotationPath expression MAY be provided using element notation or attribute notation.\nExample xx:\n<Annotation Term=\"UI.ReferenceFacet\" AnnotationPath=\"Product/Supplier@UI.LineItem\" />\n\n<Annotation Term=\"UI.CollectionFacet\" Qualifier=\"Contacts\">\n  <Collection>\n    <AnnotationPath>Supplier/@Communication.Contact</AnnotationPath>\n    <AnnotationPath>Customer/@Communication.Contact</AnnotationPath>\n  </Collection>\n</Annotation>\n\nImported from [ODATA-428](https://issues.oasis-open.org/browse/ODATA-428)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider Providing More Information For Changed Links In a Delta Response",
    "body": "Currently when a link changes, a delta response will contain only the entity-IDs of the entities and the name of the relationship.  The entity-IDs alone do not provide sufficient information for the client to build the relationship locally between the two entities because no assumptions about the entity-IDs format can be made.  For the client to make the relationship it either has to request the entities matching those IDs from the server or keep a local mapping of entity IDs to entities (a hash map of sorts).  Since no assumptions can be made about the amount of data, this mapping must be persisted, which means updating links (even with in-memory caching) in a worst case scenario requires an extra read from the persisted local store.\n\nTo be able to locally hash the mapping for delta responses also enforces an order of operations on the server.  Links must be updated AFTER entities are changed to make sure the client gets the entities for hashing purposes before link changes.  Although this seems like a natural order, technically it is not necessary if the data store is a database that checks referential integrity on commit.\n\nIf we can provide additional information about the entities, in particular their key values and fully qualified entity set, the above issues can be avoided.\n\n### Proposal\n\nDefine Core annotations \n\n      <Term Name=\"ConventionalIDs\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"EntityContainer\">\n        <Annotation Term=\"Core.Description\" String=\"Entity-ids follow OData URL conventions\" />\n      </Term>\n\n      <Term Name=\"DereferenceableIDs\" Type=\"Core.Tag\" DefaultValue=\"true\" AppliesTo=\"EntityContainer\">\n        <Annotation Term=\"Core.Description\" String=\"Entity-ids are URLs that locate the identified entity\" />\n      </Term>\n\nThese allow clients to optimize management of offline caches based on information parsed from the entity-ids.\n\nImported from [ODATA-427](https://issues.oasis-open.org/browse/ODATA-427)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Metadata URL for nested objects can be relative to metadata URL of enclosing object",
    "body": "In odata-422, we define a metadataurl representation for references, as well as links, deleted links, and deleted entities. This replaced \"odata.kind\" and established the metadataurl as the single place to look to understand what a particular object represented.\nHowever, understanding that a particular JSON object represents a reference, link, deleted link, or deleted entity is not dependent upon the base metadataurl of the service. these are defined by odata.\n\nThus, the metadata urls should not depend on the metadataurl of the service, but should be defined relative to a (virtual) odata url. for example:\n\n{metadata-url}#$ref                  =>  odata:#ref \n{metadata-url}#@deletedEntity  =>  odata:#deletedEntity\n{metadata-url}#@link                =>  odata:#link\n{metadata-url}#@deletedLink    =>   odata:#deletedLink\n\n### Proposal\n\nSpecify in JSON that metadata URLs of \"nested\" objects are relative to the metadata URL of the enclosing object, thus shortening the metadata URL of references, links, deleted links, and deleted entities in collections to just\n\n#$ref\n#$link\n#$deletedLink\n#$deletedEntity\n\nThis allows single references to point back to their originating service, and is even shorter for the other three as these so far only appear within delta responses, i.e. wrapped in a collection.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49447/odata-meeting-40_on-20130606-minutes.html#odata-426\n\nImported from [ODATA-426](https://issues.oasis-open.org/browse/ODATA-426)",
    "labels": [
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify rules around parameter overloads and return types",
    "body": "Functions and actions today support overloads. Actions overloads must differ by binding parameter, function overloads must differ by a unique combination of parameter names.\n\nWe don't say anything today about whether or not different overloads of the same function/action can return the same type.\n\nThere are scenarios where it is interesting for multiple function/action overloads to return the same type (for example, a \"GetByID\" function or \"Create\" action bound to a collection of entities of a certain type). However, supporting overloads within a path makes it impossible for a simple parser to know the types of the segments; something a parser with metadata information should be able to do. As a general rule, the segments of a path should be strongly typed.\n\nThere is a fairly simple solution to these two seemingly incongruous requirements; the scenarios in which it is interesting to vary the return type by overload are exactly the scenarios in which we have a binding parameter. And, if we have a binding parameter, and we know the type of each segment, we know the overload from parsing just the path.\n\nThe one exception to this rule is the fact that we currently support a legacy style of passing parameters by name in the query string without defining aliases in the path. For example, we currently support:\n\n    ~Customers/GetById?id='ALFKI'\n\nThis third way of binding parameters is only supported for a function/action in the final segment and its only usefulness is that a service could advertise a function/action, and the client could call it without having to parse the path and see what names were chosen for the parameters.\n\nThe solution to this scenario is to require that advertised functions/actions utilize parameter markers named according to the parameter names defined in metadata. So, for example, if a function \"GetById\" takes a parameter named \"Id\", then the advertised form of the function, following convention, would be:\n    ~Customers/GetById(id=@id)\nand the client would call by providing the id parameter in the query string:\n    ~Customers/GetById(id=@id)?@id='ALFKI'\n\nThis simplifies the current model by removing a third variation of parameter passing that is restricted only to a narrow usage and at the same time ensuring that the functions within a path are always strongly typed.\n\n\n### Proposal\n\n1) Specify that the return types of all function/action overloads may only differ according to the binding parameter; all function/action overloads with a given binding parameter must have the same return type.\n2) Specify that the opaque URL advertised for functions/actions in the payload must accept parameters passed as aliases with the same name as the parameters defined in the metadata, preceded with an @ sign\n3) Remove the third \"parameter name\" binding syntax\n\nAccepted: https://www.oasis-open.org/committees/download.php/49447/odata-meeting-40_on-20130606-minutes.html#odata-425\n\nImported from [ODATA-425](https://issues.oasis-open.org/browse/ODATA-425)",
    "labels": [
      "ABNF",
      "CSDL XML",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rename edm:Entity to edm:Singleton",
    "body": "A \"named entity\" is rather a \"singleton entity\". \n\nIt is not clear why a singleton needs a key, i.e. must be an entity. To allow a future generalization to instances of complex type we should name it \"Singleton\".\n\n### Proposal\n\nRename edm:Entity to edm:Singleton, keep its Type attribute to be on the safe side for future generalization\n\nImported from [ODATA-423](https://issues.oasis-open.org/browse/ODATA-423)",
    "labels": [
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add metadata URL to representations of entity references, define format for collections of references",
    "body": "We've defined a metadata URL pattern for entity references and collections of entity references in Part 1: Protocol but haven't yet defined that entity reference representations need a metadata URL.\n\nWe've also defined representations for single entity references, but not for a collection of entity references.\n\n### Proposal\n\nProtocol: adapt metadata URL pattern for entity references: no need for prefixing the reference with an entity set, just use $metadata#$ref and $metadata#$ref/@Element.\n\nAtom: add metadata:metadata attribute to metadata:ref element. Require it in single reference and in collection of entity references.\n\nJSON: define odata.metadata name/value pair for entity references, use odata.id instead of odata.ref, define format for collection.\n\nExample for single reference\n\t\t{\n\t\t  \"odata.metadata\": \"http://host/service/$metadata#$ref/@Element\",\n\t\t  \"odata.id\": \"Orders(10643)\"\n\t\t}\n\nExample for collection of references\n\t\t{\n\t\t  \"odata.metadata\": \"http://host/service/$metadata#$ref\",\n\t\t  \"value\": [{\"odata.id\":\"\"},...]\n\t\t}\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-422\n\nImported from [ODATA-422](https://issues.oasis-open.org/browse/ODATA-422)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove odata.kind from JSON and add metadata URL templates for link, deletedLink, and deletedEntity",
    "body": "The odata.kind name/value pair allows distinguishing between types of JSON objects in a delta response.\n\nIn all other cases we distinguish different objects using the metadata URL, and it's strange not to do this also in this case.\n\n### Proposal\n\nRemove odata.kind name/value pair.\n\nAdd metadata URL templates $metadata#@link, @deletedLink, @deletedEntity to mark these objects.\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-421\n\nImported from [ODATA-421](https://issues.oasis-open.org/browse/ODATA-421)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Response codes 404 and 405: MUST instead of SHOULD",
    "body": "It is unclear what the service might do if it doesn't want to respond with 404 Not Found to a non-existing resource or 405 Method Not Allowed for an existing resource.\n\n### Proposal\n\nProposal: rewrite descriptions so as not to make a conformance statement.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-420\n\nImported from [ODATA-420](https://issues.oasis-open.org/browse/ODATA-420)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify ETag handling more precisely",
    "body": "The specification should be more specific about the ETag handling. E.g. should a weak or strong ETag be generated on the server? \n\nThis has consequences because [RFC-2616] (chapters 13.3, 14.24 and 14.26) seem to define the ETag handling slightly different than in this spec.\n\nThis affects sections \"8.3.1 ETag Header\", \"8.2.3 Header If-Match\", \"8.2.4 Header If-Non-Match\" and \"11.4.1.1 Use of ETags for Avoiding Update Conflicts\".\n\nAlso state whether we expect ETags for collections that advertise actions, or whether we expect the advertised action to contain an action-specific ETag.\n\n### Proposal\n\nRecommend using weak ETags and refer to HTTPbis for the new semantics of weak ETags with If-Match\n\nAlign ETag-related sections \"8.3.1 ETag Header\", \"8.2.3 Header If-Match\", \"8.2.4 Header If-Non-Match\" and \"11.4.1.1 Use of ETags for Avoiding Update Conflicts\" with HTTPbis.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49447/odata-meeting-40_on-20130606-minutes.html#odata-419\n\nImported from [ODATA-419](https://issues.oasis-open.org/browse/ODATA-419)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "EntitySet attribute or NavigationPropertyBinding child elements for Named Entities (edm:Entity)",
    "body": "We currently don't have a mechanism for specifying either membership of a named entity in an entity set, or specifying navigation property bindings for navigation properties of a named entity that is not a member of any declared entity set.\n\n### Proposal\n\nAllow edm:NavigationPropertyBinding child elements in the edm:Entity to express into which entity sets its navigation properties will lead.\n\nAllow a NavigationPropertyBinding to indicate a named entity as well as an entity set.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-418\n\nImported from [ODATA-418](https://issues.oasis-open.org/browse/ODATA-418)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define content negotiation and default format for paths ending in /$value, /$count, /$metadata and /$batch",
    "body": "With [ODATA-390](https://issues.oasis-open.org/browse/ODATA-390) we introduced GML and GeoJSON representations for primitive properties of Geo types.\n\nThis raises the question what format requests to the \"raw\" value of a Geo property return:\n\nGET ~/Customers(1)/Address/GeoLocation/$value\n\nThis could be\n- the \"unwrapped\" GML or GeoJSON value\n- the WKT plain text value\n- ...\n\nAllowing content negotiation for /$value paths would solve this elegantly and works also well for canonical URLs to media resources.\n\n### Proposal\n\nContent negotiation with Accept header and $format is allowed for paths ending in /$value.\n\nContent negotiation for paths in ending in /$count is not allowed, the result is always text/plain\n\nContent negotiation for /$batch is not allowed, the result is always multipart/mixed.\n\nContent negotiation for /$metadata is allowed, but the media types application/atom+xml and application/json and its sub-types and parameterized variants are reserved for future versions of this specification.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-417\n\nImported from [ODATA-417](https://issues.oasis-open.org/browse/ODATA-417)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Non-normative text in conformance 13.1 of part 1",
    "body": "Under 13.1 oDATA Service Conformance Levels, the following non-normative text appears outside of a note:\n\n*****\nThe conformance levels are design to correspond to different service scenarios. For example, a service that publishes data compliant with one or more of the OData defined formats may comply with the OData Minimal Conformance Level without supporting any additional functionality. A service that offers more control over the data that the client retrieves may comply with the OData Intermediate Conformance Level. Services that conform to the OData Advanced Conformance Level can expect to interoperate with the most functionality against the broadest range of generic clients.\n\nServices are encouraged to support as much additional functionality beyond their level of conformance as is appropriate for their intended scenario. Services can advertise their level of conformance by annotating entity containers with the ConformanceLevel annotation defined in [OData-VocCap][OData-VocCap].\n*****\n\nThe entire first paragraph is non-normative.\n\nThe second sentence of the second paragraph may be normative, but then it should not appear here, but rather under ConformanceLevel annotation.\n\n\n\n### Proposal\n\n1. Mark non-normative text as \"note\".\n2. Create new subsection \"OData Conformance Level Annotation\" with normative text.\n\nImported from [ODATA-416](https://issues.oasis-open.org/browse/ODATA-416)",
    "labels": [
      "Protocol"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Use of \"MUST,\" \"MAY,\" \"SHOULD,\" etc in Part 3 CSDL definitions",
    "body": "The prose in CSDL is a mixture of stating the definitions for elements and attributes and occassionally using RFC 2119 control language for other elements and attributes. \n\nFirst, definitions of elements and attributes are just stated as facts. ODATA is defining its elements/attributes and the use of MUST/SHOULD/MAY don't add anything to a definition. Either an element or attribute meets the definition, or it doesn't.\n\nSecond, the mixture of RDF 2119 terms risks leaving readers with the impression that some definitions are subject to greater precision than others. My assumption is that all definitions in CSDL, when appropriate, must be met by a conforming service or client. \n\nA couple of examples:\n\n*****\n3.1 Element edmx:Edmx\n\nThe metadata document MUST contain a single root edmx:Edmx element. This element MUST contain a single direct child edmx:DataServices element. \n\nIn addition to the data services element, the Edmx element contains zero or more edmx:Reference elements. Reference elements specify the location of schemas used by the OData service.\n*****\n\nThe first paragraph uses \"MUST\" but we are missing a \"MAY for the edmx:Reference elements. But neither one is needed.\n\nFor example:\n\n*****\nThe edmx:Edmx element is the root element of a metadata document. Every edmx:Edmx element contains one direct child edmx:DataServices element.\n\nA edmx:Edmx element may contain zero or more edmx:Reference elements.\n*****\n\nI would move the \"Reference elements specify the location of schemas used by the OData service.\" to where refernece elements are defined. \n\nMostly because if the definitions of a reference element change, it will be very difficult to track down all the places where it is mentioned in passing.\n\nAnother example:\n\n*****\n3.1.1 Attribute Version\n\nThe Version attribute MUST be present on the edmx:Edmx element.\n\nThe Version attribute is a string value that specifies the version of the EDMX wrapper, and must be of the form <majorversion>.<minorversion>. This version of the specification defines version 4.0 of the EDMX Wrapper.\n*****\n\nI would say:\n\n*****\nEvery edmx:Edmx element has a Version attribute.\n\nThe Version attribute is a string value that specifies the version of the EDMX wrapper, and has the form <majorversion>.<minorversion>. \n*****\n\nI would make \"This version of the specification defines version 4.0 of the EDMX Wrapper.\" into a note (non-normative) and add what the value should be for the <minorversion>. The value for minorversion maybe defined elsewhere but if a note is to be helpful, it should give the complete information needed by a reader.  \n\nBTW, probably just my lack of familiarity with the spec but I didn't see a convention for specifying values? I am assuming <majorversion>.<minorversion> is satisfied by 4.0 but that is a guess on my part. Could be 4. or <4>.<0>. \n\nPS: I think among the XML community saying \"root\" for a document qualifies as being a single element. \n\n### Proposal\n\nClose without action\n\nImported from [ODATA-415](https://issues.oasis-open.org/browse/ODATA-415)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Fix syntax for deleting links to support containment",
    "body": "Today the syntax for deleting a link from Products(5) to the orderdetail whose id is 1  is as follows:\n\nDELETE ~Products(5)/OrderedIn(1)/$ref\n\nWe did this as a shortcut to repeating the collection and id following the $ref.\n\nThere are two problems with this syntax. First, it is semantically a bit weird in that Products(5)/OrderedIn/$ref represents the set of entity references of order details referenced by the OrderedIn nav prop of Products(5). More significantly, it doesn't work for containment scenarios, or anywhere there is no navigationpropertybinding, as the key appended to the nav property is not guaranteed to uniquely identify the related entity.\n\nThe second problem is a manifestation of the first conceptual problem. In order to delete a relationship we need 3 pieces of information: (1) the source entity, (2) the navigation property, and (3) the id of the thing being no longer related. In a 1:1 or many:1 relationship the id of the thing being removed is implicit, but in many:many we need to specify which thing to unrelated. The current syntax assumes that this information can be derived by applying the key to the nav prop, but this alone is not sufficient.\n\nFor collections, we could append id to the URL representing the collection of links, as in:\n   DELETE ~Products(5)/OrderedIn/$ref/OrderDetails(1)\nfor non-contained OrderDetails, or:\n   DELETE ~Products(5)/OrderedIn/$ref/Orders(123)/Details(1)\nfor contained OrderDetails\n\nFor single-valued relationships we would simply omit the id, since it points to a single references (and is therefore not valid to index with an id)\n\n### Proposal\n\nDefine \"the URL that represents the reference to the related entity\" in a collection (used in section \"11.5.6.2 Remove a Reference to an Entity\" in [Protocol]) as the URL representing the relationships between two entities (defined in section \"4.4 Addressing References Between Entities\" in [URL]) with the id of the reference being deleted passed in the $id query option. For a to-one relationship, this is just the URL that represent the reference to the related entity (no need to add the id; in fact, it would be illegal)\n\nNote that this id can be relative to the service root.\n\nSo, to delete a reference in a collection of related entities, you would do:\n\nDELETE ~Customers('ALFKI')/Orders/$ref?$id=Orders(1)\n\nWhere http://myservice.svc/Orders(1) is the id of the order being removed from Customers(1).\n\nFor containment, this would look like:\n\nDELETE ~Products(5)/OrderedIn/$ref?$id=Orders(1)/Lines(3)\n\nNot specifying the $id would be illegal (reserved for possibly doing set operations in a future version).\n\nTo delete a reference in a to-1 relationship you omit the id:\n\nDELETE ~Orders(1)/Customer/$ref\n\nIt is illegal to specify $id in this case, as the target identified by the path is a single entity reference, as opposed to a collection.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-414\n\nImported from [ODATA-414](https://issues.oasis-open.org/browse/ODATA-414)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Replace conformance clauses in URL and CSDL with references to Protocol",
    "body": "The current text reads:\n\n*****\nConforming services MUST follow all rules of this specification for the types, sets, functions, actions, containers and annotations they expose. \n\nConforming clients MUST be prepared to consume a model that uses any or all of the constructs defined in this specification, including custom annotations defined by the service, and MUST ignore any elements or attributes not defined in this version of the specification.\n*****\n\nIt isn't clear if \"this specification,\" (2x) or \"this version of the specification\" are referring to part 3 or do they mean to refer to parts 1 - 3?\n\nIf part 3 is purely a definitional document that is relied upon by other documents, other documents that have conformance clauses, I don't know that we need a conformance clause here. Best to check with the TC Admin but definitions don't require conformance clauses, IMHO.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/49447/odata-meeting-40_on-20130606-minutes.html#odata-413\n\nImported from [ODATA-413](https://issues.oasis-open.org/browse/ODATA-413)",
    "labels": [
      "CSDL XML",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consistent representation of empty values",
    "body": "We currently use different representations for empty values.\n\nThe consistent cases are:\n- empty collections of primitive values, complex values, and entities are represented with 200 OK and the format-specific representation of an empty collection of the appropriate type (<m:value/>, <atom:feed/>, {\"value\":[]})\n- empty primitive values in Atom and JSON are represented with 200 OK and the format-specific representation of a null value (<m:value m:null=\"true\"/> or {\"value\":null})\n- empty complex values in Atom are represented with 200 OK and the Atom representation of a null value (<m:value m:null=\"true\"/>)\n\nThe exceptions are:\n- empty single entity is currently represented with 204 No Content\n- empty complex property is represented with 200 OK and a special NULL payload in JSON ({\"odata.metadata\": \"http://host/service/$metadata#Edm.Null\"})\n\nThe first exception is because an atom:entry cannot be empty, the second is because we wanted(?) to represent complex type instances as JSON objects without a {\"value:...} wrapper and thus need a special representation of an \"unwrapped null value\".\n\nAlso when we try to index an entity set by key, as in ~Customers('nonexistentkey') we currently return 404 NOT Found. This is particularly strange when you consider containment, because the canonical URL (which we say returns 404 NOT FOUND if the item doesn't exist) is the navigation link (which we say returns 204 no content if the item doesn't exist). \n\n\n### Proposal\n\nServices MUST respond with 404 Not Found if the addressed \"single\" resource does not exist/has no value\n- primitive property that is null\n- complex property that is null\n- navigation property with multiplicity 0..1 where no entity is related\n- key lookup in a collection of entities and the entity identified by that key is not part of the collection \n-- contained: entity does not exist\n-- non-contained: entity does not exist or exists and is not related\n\nServices MUST respond with 200 OK and a representation of an empty collection if the addressed collection has no items\n- collection of primitive\n- collection of complex type instances\n- collection of entities\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-412\n\nImported from [ODATA-412](https://issues.oasis-open.org/browse/ODATA-412)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Reconsider placement and semantics of OnDelete element",
    "body": "Currently the OnDelete element is on the dependent side and specifies \"what happens here if over there the last thing goes away\", i.e. an observer/event subscription pattern. This may have been inspired by SQL's ON DELETE, which is also specified on the dependent side.\n\nThe \"original\" OnDelete element of OData V2/V3 seems to be specified on the principal side of the association, unfortunately not explicitly stated, only deducible from the only given example:\n\n  <Association Name=\"CProductCategory\">\n    <End Type=\"Self.CProduct\" Multiplicity=\"*\" />\n    <End Type=\"Self.CCategory\" Multiplicity=\"0..1\">\n      <OnDelete Action=\"Cascade\" />\n    </End>\n  </Association>\n\nIf the category goes away, it notifies its products to also go away.\n\n### Proposal\n\nPlace OnDelete on principal side to allow expressing existential dependency in containment without needing a backlink to the containing type, see [ODATA-406](https://issues.oasis-open.org/browse/ODATA-406)\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-411\n\nImported from [ODATA-411](https://issues.oasis-open.org/browse/ODATA-411)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider moving terms OptimisticConcurrencyControl and AcceptableMediaTypes from Core to Capabilities",
    "body": "\n\n### Proposal\n\nClose without action\n\nImported from [ODATA-410](https://issues.oasis-open.org/browse/ODATA-410)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.3.3.1 conflicts with conformance for intermediate and advanced OData",
    "body": "11.3.3.1 reads in part: \"A service SHOULD support retrieving the raw value of a primitive type property.\"\n\n13.1.1 OData Minimal Conformance Level does not mention this capability.\n\n13.1.2 OData Intermediate Conformance Level reads in part: \"MUST support /$value on media entities and individual properties (section Requesting a Property's Raw Value using $value)\" contradicting 11.3.3.1.\n\n13.1.3 OData Advanced Conformance Level incorporates 13.1.2 by reference and so also contradicts 11.3.3.1.\n\nPart of the issue may lie in the use of may, should, must in the normative prose. \n\nFor example: \"A service SHOULD support retrieving the raw value of a primitive type property.\"\n\nCould be expressed:\n\n\"The $value operator in a property value URL retrieves the raw value of a primitive type property.\"\n\nOrganizationally, I would follow that with the rules for Edm.Binary, other properties and NULLs.\n\nFor example, a client using a GET request with $value:\n\nhttp://host/service/Products(1)/Name/$value\n\n\n\nImported from [ODATA-409](https://issues.oasis-open.org/browse/ODATA-409)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.2.3 OData services MAY/SHOULD/MUST expose their data model",
    "body": "Checking against the conformance clauses:\n\nOData Minimal Conformance Level is missing: \"MAY publish metadata at /$metadata according to [OData-CSDL] (section Metadata Document Request)\"\n\nOData Intermediate Conformance Level has: \"SHOULD publish metadata at /$metadata according to [OData-CSDL] (section Metadata Document Request)\"\n\nOData Advanced Conformance Level has: \"MUST publish metadata at /$metadata according to [OData-CSDL] (section Metadata Document Request)\"\n\nSuggest defining OData Metadata Service at 11.2.3, therefore delete: \"OData services MAY/SHOULD/MUST expose their data model as an OData Metadata Service.\" and let the conformance clauses refer to this section to say may, should or must.\n\nJust a nit, I would say \"A\" metadata service..., since not every conforming OData implementation will offer a metadata service. And \"A\" Metadata Service Document URL, same reasoning.\n\n\n\n### Proposal\n\nDelete in 11.2.3 \"OData services MAY/SHOULD/MUST expose their data model as an OData Metadata Service.\"\n\nChange first sentence, last paragraph of 11.2.3 from \"The\" to \"A\". Same for start of second sentence, last paragraph. \n\nAdd in 13.1.1 \"MAY publish metadata at /$metadata according to [OData-CSDL] (section Metadata Document Request)\"\n\n\n\nImported from [ODATA-408](https://issues.oasis-open.org/browse/ODATA-408)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Navigation Properties in Complex Types (public comment c201305e00012)",
    "body": "The public comment [c201305e00012](https://lists.oasis-open.org/archives/odata-comment/201305/msg00012.html) with title \"Navigation Properties in Complex Types\" states:\n\n\n\"\"\"\n[OData-Part3] (CSDL Defintion) states:\n\nAs structural and navigation properties MAY be returned by the service on instances of any structured type, whether or not the type is marked as open. Clients MUST always be prepared to deal with additional properties on instances of any structured type, see [OData-Protocol].\n\nIn this light, I wonder, what is the reason tat complex types cannot declare navigation properties in metadata? I would serve a lot of real -life cases\nFor example, the Address complex type used throughout the documents is a bit unrealistic, as in most real cases it should contain a navigation property \"Country\", referencing another enitity, not just text representaion\n\"\"\"\n\n### Proposal\n\nNavigation properties in Atom are atom:link elements.\n\nComplex properties can be collection-valued, so the atom:link elements have to be placed within the representation of each single complex type instance.\n\nIn [ODATA-346](https://issues.oasis-open.org/browse/ODATA-346) we decided that collections are NOT arrays, and items in a collection CANNOT be accessed by index. This makes features like the /$ref segment unavailable for navigation properties of complex types.\n\nThis also requires that href attribute values in links within complex type instances MUST be direct links and CANNOT be indirect via the current entities, as they are by convention in OData V2 and V3 implementations.\n\nExample 1: Orders is indirect via customer entity, Country is direct with specified key\n<atom:entry>\n  <atom:link rel=\"http://docs.oasis-open.org/odata/ns/related/Orders\" \n         type=\"application/atom+xml;type=entry\" title=\"Orders\" \n         href=\"Customers('ALFKI')/Orders\" />\n  ...\n  <metadata:properties>\n    <Addresses>\n      <metadata:element>\n        <atom:link rel=\"http://docs.oasis-open.org/odata/ns/related/Country\" \n               type=\"application/atom+xml;type=entry\" title=\"Country of residence\" \n               href=\"Countries('DE')\" />\n        <Street>Obere Str. 57</Street>\n        <City>Berlin</City>\n        <PostalCode>D-12209</PostalCode>\n      </metadata:element>\n      ...\n    </Addresses>\n    ...\n  </metadata:properties>\n  ...\n</atom:entry>\n\nImported from [ODATA-407](https://issues.oasis-open.org/browse/ODATA-407)",
    "labels": [
      "ATOM Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Attribute ContainsTarget (public comment c201305e00009)",
    "body": "The public comment [c201305e00009](https://lists.oasis-open.org/archives/odata-comment/201305/msg00009.html) with title \"Attribute ContainsTarget\" states:\n\n\"\"\"\nIn section 7.1.5 Attribute ContainsTarget  of [OData-Part3]  the semantics is unlclear.\nThe following wording is used:\n\nIf the value assigned to the ContainsTarget attribute is true, entities of the entity type that specifies the navigation property contain the entities referenced by the navigation property.\n\nWhat does \"contain\" mean? Does it impose any additional restriction?\n\n\"\"\"\n\n### Proposal\n\nEntities are members of at most one set, and are identified within their entity set by their key property values. Typically the entity set is a declared entity set that is declared within an entity container.\n\nContained entities are members of undeclared entity sets that are implicitly defined by their containing entity. \n\nConsequently an entity can be contained by at most one other entity, and it is identified by its key values only within the undeclared, implicit entity set. \n\nAlso a contained entity cannot be a member of a declared entity set within an entity container, because it is already a member of an undeclared, implicit entity set.\n\nConsequently navigation properties specifying ContainsTarget=\"true\" MUST NOT have any navigation property binding, removing several confusing sentences from section 7.1.5.\n\nThis also means that GET requests to declared entity sets will never return contained entities.\n\nThese statements apply to recursive as well as non-recursive containment. \n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-406\n\nImported from [ODATA-406](https://issues.oasis-open.org/browse/ODATA-406)",
    "labels": [
      "CSDL XML",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Deep Updates (public comment c201305e00008)",
    "body": "The public comment [c201305e00008](https://lists.oasis-open.org/archives/odata-comment/201305/msg00008.html) with title \"Deep Updates\" states:\n\n\"\"\"\nIn section   8.4 Deep Inserts of OData-Atom-Format-v4.0 it is stated that \n\n\"Deep inserts are not allowed in update operations using PUT or PATCH requests.\"\n\nThis is a great pity, as supporting deep updates would enable the very common scenario of saving a document with its lines as a whole.\n\nCould it be possible to add this feature?\n\n\"\"\"\n\n### Proposal\n\nDefer to 4.1\n\nImported from [ODATA-405](https://issues.oasis-open.org/browse/ODATA-405)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Make Capabilities vocabulary a part of OData 4.0",
    "body": "We need a set of terms that are related to capabilities of a service, e.g. to express which conformance level the service fulfills, and which additional capabilities it has.\n\nWe've already crafted an example Capabilities vocabulary that we can now make a part of the OData 4.0 work product.\n\n### Proposal\n\nTransform the example Capabilities vocabulary into a part of the standard.\n\nhttps://tools.oasis-open.org/version-control/browse/wsvn/odata/trunk/spec/examples/Org.OData.Capabilities.V1.xml?rev=311\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-404\n\nImported from [ODATA-404](https://issues.oasis-open.org/browse/ODATA-404)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Mechanism to advertise conformance level of OData services",
    "body": "OData v4 defines three conformance levels for services: Minimal, Intermediate, and Advanced. We need a mechanism that would allow compliant services to advertise their conformance level.\n\nCould OData vocabularies be used for this purpose?\n\n### Proposal\n\nAdd term in Capabilities vocabulary (see [ODATA-404](https://issues.oasis-open.org/browse/ODATA-404))\n\n      <Term Name=\"ConformanceLevel\" Type=\"Capabilities.ConformanceLevelType\" AppliesTo=\"EntityContainer\" />\n      <EnumType Name=\"ConformanceLevelType\">\n        <Member Name=\"Minimal\"/>\n        <Member Name=\"Intermediate\"/>\n        <Member Name=\"Advanced\" />\n      </EnumType>\n\nSee https://tools.oasis-open.org/version-control/browse/wsvn/odata/trunk/spec/examples/Org.OData.Capabilities.V1.xml?rev=311\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-403\n\nImported from [ODATA-403](https://issues.oasis-open.org/browse/ODATA-403)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Require services to support $expand on navigation properties",
    "body": "Today service may or may not support $expand on navigation properties. The service is required to return an error if it can't support $expand, making it difficult for clients to have a consistent way to request that a graph be expanded.\n\nServices are already allowed to return partial results in any collection of entities (including an expanded navigation property) by including a next link in the result. Clients must be prepared for such a next link in any response.\n\nThis actually gives a way that a service can trivially support $expand by returning an empty collection with a next link containing the navigation link. The client logic would then kick in and follow the next link in order to get the \"rest\" of the members. This gives the client a reliable way to ask for the expansion and all services the ability to give the client what they can.\n\n### Proposal\n\nMake $expand required at all levels for any navigation property. Services can simply return the navigation link as the next link in an empty collection if it doesn't have the ability to do the expand inline.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-402\n\n\nImported from [ODATA-402](https://issues.oasis-open.org/browse/ODATA-402)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Replace \"substringof\" canonical function with \"contains\"",
    "body": "The current definition of substringof takes first the string being searched for, and second the string being searched in.\nThis is widely held to be the wrong order, especially since other string functions generally take the string as the first argument.\nThis issue has long been a source of confusion in OData, made worse by the fact that the documentation often disagreed with the examples, and the documentation has changed several times.\n\nTo prevent any confusion with legacy, I propose we retire the \"substringof\" function all together and replace it with \"contains\" with the argument in the more intuitive order (sourcestring, searchtext)\n\n### Proposal\n\nReplace \"substringof\" canonical function with \"contains\". The first parameter being the sourcestring, and the second being the searchtext.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-401\n\nImported from [ODATA-401](https://issues.oasis-open.org/browse/ODATA-401)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow JSON values also in common expressions, not only in parameter aliases",
    "body": "Currently we allow JSON values (arrays, complex types, entities) only in parameter aliases. This leads to constructions like\n\nhttp://host/service/Orders?$filter=$it eq @ref&@ref={\"odata.ref\":\"http://host/service/ZqV5t\"}\n\nThe \"natural\" form without the unnecessary alias\n\nhttp://host/service/Orders?$filter=$it eq {\"odata.ref\":\"http://host/service/ZqV5t\"}\n\nis not allowed.\n\n### Proposal\n\nAllow JSON objects and JSON arrays also in common expressions\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-400\n\n\nImported from [ODATA-400](https://issues.oasis-open.org/browse/ODATA-400)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Describe expected life cycle management of next-links inside 11.2.4.7 Server-Driven Paging",
    "body": "We should say something about what to expect when a next-link expires (as we are storage model agnostic and cannot assume, that this \nwill always be a reconstructable query).\n\nThis might apply to other opaque tokens that act as URLs to retrievable resources.\n\nAs of now we do not describe this in any detail.\n\nA common scenario from the interactive browsing would be a client stepping through a paged result set and \"bookmarking\" a certain page for later retrieval. This might be due to relevance of the pages content or as a planned re-entrance point for resuming some analysis of the result set (both motivations assuming the result set is somewhat constant or only  slowly changing).\n\n### Proposal\n\nInsert inside the Protocol work product (as of CSD01 PR), in some appropriate place, the folllowing paragraph:\n\nOData services are hypermedia driven services that return URLs to the client. If a client subsequently requests the resource and the URL has expired, then the server SHOULD send HTTP 410 Gone as the response code in case where this is feasible, else the service MUST respond with a HTTP 404 Not found.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-399\n\nImported from [ODATA-399](https://issues.oasis-open.org/browse/ODATA-399)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define canonical function as a path segment that allows retrieving an entity by its id",
    "body": "Ids are the primary way to reference an instance in OData; they are used in relationships, in deltas, and can take the place of instances in payloads. We recommend, but do not require that ids be dereferenceable.\n\nClients need a dependable way to get from an id to a reference, whether or not the reference is dereferencable. Although they could construct a query if they know the root set the id comes from, it would be useful and more discoverable to introduce a canonical query function, at the service root, for returning an instance given its id.\n\nNote that, since the id is likely to contain illegal characters, we have to pass the id as a query option, and will need to double single quotes in reference\n\nOptions:\n\nGET ~myservice/getbyid(@id)?@id='.....'\nGET ~myservice/$getbyid?@id='.....'\n\n\n### Proposal\n\nDefine a $entity path segment which can be appended to the service root to specify an individual resource.\n\nGET ~myservice/$entity?$id=...\n\nThis path segment can be followed by a cast segment and combined with other query options that are applicable for resource paths identifying a single entity:\n\nGET ~myservice/$entity/Northwind.Customer?$id=http://myservice/Customers('ALFKI')\n                                   &$select=CompanyName,ContactName&$expand=Orders\n\nThis is functionally equivalent to a key-lookup for that resource. The metadata URL and payload are identical to a request addressing the same entity via its read URL.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-398\n\nImported from [ODATA-398](https://issues.oasis-open.org/browse/ODATA-398)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Lazy loading of Annotations: Add optional Attribute \"TargetNamespace\" to edmx:IncludeAnnotations element",
    "body": "If a term is annotated at a model element (with an optional qualifier), this annotation is uniquely identified by (the \"target\" model element, the term, the qualifier). E.g. the following annotation is identified by (com.sap.erp.products.Product,UIVA.DataFieldWithNavigation,FirstDataField):\n      <Annotations Target=\"com.sap.erp.products.Product\">\n        <Annotation Term=\"UIVA.DataFieldWithNavigation\" Qualifier=\"FirstDataField\">\n          <Record>\n            <PropertyValue Property=\"Label\" String=\"Supplier\" />\n            <PropertyValue Property=\"Value\" Path=\"@com.sap.AnnoCrossReferenceTerm.Supplier#Foo/SupplierName\" />\n          </Record>\n        </Annotation>\n      </Annotations>\nThis annotation uses a other annotation in the path attribute identified by (com.sap.erp.products.Product,com.sap.AnnoCrossReferenceTerm.Supplier,Foo). If this annotation is not included in the same file as the sample annotation above, the consumer has to load this annotation to figure out the annotation value. How can he find the right edmx:reference URI? Today we can qualify an edmx:includeAnnotation element inside an edmx:reference element by a TermNamspace attribute (MUST) and a Qualifier attribute (MAY). In our example he can search for (com.sap.AnnoCrossReferenceTerm,Foo) inside the edmx:includeAnnotation elements and load all matching edmx:reference files. There can be many. \nIf we allow annotation providers to express in addition to the TermNamespace and the Qualifier a so called TargetNamespace (the namespace the annotated model element belongs to), the number of matching files could be reduced, because the consumer can search for (com.sap.erp.products,com.sap.AnnoCrossReferenceTerm,Foo) inside the edmx:includeAnnotation elements and load only the  edmx:reference files matching this more specific search query.\n\n### Proposal\n\nAdd a section 3.5.3 to CSDL Spec:\n\n3.5.3 Attribute TargetNamespace\n\nAn edmx:IncludeAnnotations element MAY specify a Namespace value for the TargetNamespace attribute. \nIf the TargetNamespace is specified, only those annotations which apply a term from the specified TermNamespace (if present) to an element of the Targetnamespace with the specified Qualifier (if present) SHOULD be imported. If TargetNamespace is not specified, all annotations within the document from the specified TermNamespace (taking into account the Qualifier, if present) SHOULD be applied. \nIf a value is supplied, the include element will import the set of annotations that apply terms from the namespace in the value. The TargetNamespace attribute also provides consumers insight about what namespaces are used in the annotations document. If there are no target elements that have a  namespace of interest to the consumer, the consumer can opt not to download the document.\n\nReformulate 3.5.2 \"Attribute Qualifier\" accordingly, and extend example under 3.5. and change edmx schema definition\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-397\n\nImported from [ODATA-397](https://issues.oasis-open.org/browse/ODATA-397)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Partner attribute of edm:NavigationProperty is a property path, not a SimpleIdentifier",
    "body": "When introducing navigation properties on complex types, we forgot to adapt the type of the Partner attribute. A SimpleIdentifier is no longer sufficient as the partner navigation property may be located in a complex property. \n\nThis is similar to the Name attribute of an edm:PropertyRef within an edm:Key and the Property and ReferencedProperty attributes of an edm:ReferentialConstraint.\n\n### Proposal\n\nSee summary\n\nAccepted:https://www.oasis-open.org/committees/download.php/49212/odata-meeting-37_on-20130516-minutes.html#odata-396\n\nImported from [ODATA-396](https://issues.oasis-open.org/browse/ODATA-396)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify rule for implicit values of enumeration members",
    "body": "Enumeration members have an optional Value attribute for specifying an integer equivalent to the symbolic member name that is for ordering.\n\nThe current rule for implicitly numbering the enumeration members is cloned from the C family of programming languages and allows specifying values for some members while having the other members being numbered implicitly. This can lead to surprising results for the uninitiated:\n\n<EnumType Name=\"ShippingMethod\">\n  <Member Name=\"VIP\"/>\n  <Member Name=\"FirstClass\"/>\n  <Member Name=\"TwoDay\" Value=\"0\"/>\n  <Member Name=\"Overnight\"/>\n</EnumType>\n\nThe result is that both VIP and TwoDay get the value zero and both FirstClass and Overnight get the value 1.\n\nWhile we see value in having Value optional, we see no value in providing a value for some members only.\n\n\n\n### Proposal\n\nRequire that the Value attribute must be specified either for all members or for no member if IsFlags=\"false\".\nIf no values are specified, the members are consecutively numbered in document order, starting with zero.\n\nNote: Value is already required for all members if IsFlags=\"true\".\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-395\n\nImported from [ODATA-395](https://issues.oasis-open.org/browse/ODATA-395)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce path segment /$all for search on service and entity container level",
    "body": "With [ODATA-228](https://issues.oasis-open.org/browse/ODATA-228) we introduced free-text search on service and entity-container level with the system query option $search.\n\nThis simplistic approach has the drawback of making the resource type dependent on the presence or absence of the $search query option: if present, the URL identifies a collection of entities, if absent the service root identifies the service document and the entity containers identify the Cartesian product of their entity sets.\n\n### Proposal\n\nIntroduce symbolic resources\n\n(a) service-root/$all\n(b) service-root/Entity.Container/$all\n\nthat identify (a) the union of all entities in the service or (b) the union of all entities in the container.\n\nThese are of type Collection(Edm.EntityType) and allow $search plus all query options applicable to collections of entities.\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-394\n\nImported from [ODATA-394](https://issues.oasis-open.org/browse/ODATA-394)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow querying collections of primitive type instances similar to other collections",
    "body": "Collections of entities and complex type instances are now treated equally, but collections of primitive values are somewhat neglected. They do allow the path suffix /$count, and the query options $count, $top and $skip are straight-forward.\n\nFor $filter and $orderby we need one tiny generalization: we currently allow common expressions within the lambda operators any() and all() to use $it for addressing the current entity, and we can use that to filter collections of primitive values:\n\nGET ~/Customers(1)/EmailAddresses?$filter=endswith($it,'.com')\n\nThis increased flexibility is also useful for querying collections of entities:\n\nGET ~/Employees?$filter=$it eq Manager\n\nWould return all employees who are their own manager.\n\nThis also allows retrieving the entity for a given reference:\n\nGET ~/Employees?filter=$it eq { odata.id: .... }\n\n### Proposal\n\nAllow same set of system query options for all collections.\n\nAllow using $it in $filter and $orderby outside of lambda operators.\n\nAccepted:https://www.oasis-open.org/committees/download.php/49212/odata-meeting-37_on-20130516-minutes.html#odata-393\n\nImported from [ODATA-393](https://issues.oasis-open.org/browse/ODATA-393)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Expanded Navigation Properties should be implicitly added to $select",
    "body": "We had a long discussion in Boston over whether $expanded navigation properties were implicitly added to a $select.\n\nThe argument against doing this was that it was more correct and simpler to keep the two separate; $expand is part of defining the extent of the result, and $select is used to say which properties are returned. Implicitly adding the expanded navigation properties to the $select would mean a serializer would have to look both in $select and $expand to figure out which properties to put on the wire.\n\nThe argument for implicitly adding $expanded properties to $select was that it wasn't meaningful to do a $expand if you weren't going to return the expanded property, so why require the client to add it to the $select?\n\nAs strong as the first argument is, we have empirical evidence that customers *do* get tripped up today by having to add the $expanded navigation properties to $select. OData needs to be simple and predictable, so though I like the cleanliness of keeping them separate I propose we follow the principle of least astonishment by making the expanded navigation properties implicit in the $select.\n\nNote that this means the metadata url has to specify selected or expanded properties, and can't just copy the $select, but we already moved away from just using the $select in the metadataurl in order to handle selects on expanded properties w/o going back to path notation.\n\n### Proposal\n\nImplicitly add $expanded navigation properties to $select.\n\nAccepted:https://www.oasis-open.org/committees/download.php/49212/odata-meeting-37_on-20130516-minutes.html#odata-392\n\nImported from [ODATA-392](https://issues.oasis-open.org/browse/ODATA-392)",
    "labels": [
      "URL Conventions",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add query function isdefined(PropertyPath) to determine whether an instance has a property of that name",
    "body": "We allow clients to add dynamic/undeclared properties to instances of open types, but we can't express filter conditions on the existence of a property of that name.\n\nThis is also useful in the context of data aggregation to determine if a property has been \"aggregated away\". Here the extension will define that defined(...) returns false even for declared properties if they are not defined on an entity of the result set as an effect of groupby(), rollup(), or aggregate().\n\n### Proposal\n\nAdd a canonical function \n\n    Edm.Boolean isdefined(Edm.PropertyPath)\n\nthat returns true if the property identified by the path is defined on that instance.\n\nExample:\n\n    GET ~/Products?$filter=isdefined(Product/SecondaryColor)\n\nAccepted: https://www.oasis-open.org/committees/download.php/49325/odata-meeting-38_on-20130523-minutes.html#odata-391\n\nImported from [ODATA-391](https://issues.oasis-open.org/browse/ODATA-391)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Additional description of use of GeoJSON in OData JSON.",
    "body": "The following verbage from OData 3.0's description of the use of GeoJSON within an OData JSON payload is missing from our OData JSON 4.0 specification. I believe this was an accidental omission, and that it should be added:\n\n2.2.6.3.1.1   Modifications to GeoJSON for Use in OData\nAny GeoJSON value that is used in OData SHOULD order the keys with type first, then coordinates, then any other keys. This improves streaming parser performance when parsing values on open types or in other cases where metadata is not present.\nThe GeoJSON [GeoJSON] standard requires that LineString contains a minimum number of Positions in its coordinates collection. This prevents serializing certain valid geospatial values. Therefore, in the GeoJSON requirement \"For type 'LineString', the 'coordinates' member must be an array of two or more positions\" is replaced with the requirement \"For type 'LineString', the 'coordinates' member must be an array of positions\" when used in OData.\nAll other arrays in GeoJSON are allowed to be empty, so no change is necessary. GeoJSON does require that any LinearRing contain a minimum of four positions. That requirement still holds that LinearRings can show up only in other arrays and that those arrays can be empty.\nGeoJSON allows multiple types of CRS. In OData, only one of those types is allowed. In GeoJSON in OData, a CRS MUST be a Named CRS. In addition, OGC CRS URNs are not supported. The CRS identifier MUST be an EPSG SRID legacy identifier.\n\n\n### Proposal\n\nIn section 7.1, Primitive Value, replace the following sentence:\n\"Geography and geometry values are represented as defined in [GeoJSON].\"\nwith:\n\"Geography and geometry values are represented as defined in [GeoJSON], with the following modifications:\n-Keys SHOULD be ordered with type first, then coordinates, then any other keys\n-The 'coordinates' member of a 'LineString\" can have zero or more positions\n-If the optional CRS object is present, it MUST be of type name where the value of the contained properties object name member is an EPSG SRID legacy identifier \n\nAccepted:https://www.oasis-open.org/committees/download.php/49212/odata-meeting-37_on-20130516-minutes.html#odata-390\n\nImported from [ODATA-390](https://issues.oasis-open.org/browse/ODATA-390)",
    "labels": [
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON: use odata.kind values \"Entity\" and \"deletedEntity\", Atom: use metadata:link and metadata:deleted-link ",
    "body": "The current naming of the odata.kind values \"Entry\", \"deletedEntry\", and \"linkEntry\" in JSON reflects the \"Atom-origin\" of the OData formats.\n\nWe now consistently use of \"entity\" when speaking in OData terminology and use \"entry\" only when intentionally using the Atom terminology, so it is odd to have Atom terminology in the new JSON format. Also different parts of the JSON document use different values, unintentionally reflecting the change history of this concept.\n\nTo increase consistency between JSON and Atom the OData-specific \"link\" and \"deletedLink\" are better represented using medata:link and metadata:deleted-link without the suffix \"-entry\". This is also more consistent with Atom as these OData-specific elements reflect changes to the atom:link element.\n\n### Proposal\n\nAtom: use metadata:link and metadata:deleted-link instead of metadata:link-entry and metadata:deleted-link-entry\n\nJSON: use odata.kind values \"entity\", \"deletedEntity\", \"link\", and \"deletedLink\" instead of \"entry\", \"deletedEntry\", \"linkEntry\", and \"deletedLink\"\n\nImported from [ODATA-389](https://issues.oasis-open.org/browse/ODATA-389)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove \"when\" from OData-specific items in delta responses",
    "body": "We added when to added/deleted links in ATom because it was part of the Atom tombstone specification for deleted entries. We added when to JSON to be consistent with Atom.\n\nHowever, because we impose an ordering on the returned changes that leads to eventual consistency, knowing \"when\" a change occurred is of dubious value.\n\nAs we don't currently have an annotation for last change in JSON, nor do we have a way for the client to say whether or not they want/care about such information, we should remove the \"when\" name/value pair from added/deleted links and tombstones in JSON, so it only appears for well-formedness in Atom tombstones with no semantic meaning in OData, and perhaps we can get it optional there as well.\n\n### Proposal\n\nAtom: remove when attribute from metadata:link and metadata:deleted-link elements.\n\nJSON: remove \"when\" name/value pair from deletedEntity, link, and deletedLink objects in delta responses.\n\nState that when is required in atom deleted entries, but clients should not infer any semantics.\n\nAccepted:https://www.oasis-open.org/committees/download.php/49212/odata-meeting-37_on-20130516-minutes.html#odata-388\n\nImported from [ODATA-388](https://issues.oasis-open.org/browse/ODATA-388)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Replace (at least) the second example in Section 13 of the CSDL document (public comment c201305e00002)",
    "body": "The public comment [c201305e00002](https://lists.oasis-open.org/archives/odata-comment/201305/msg00002.html) with title \"DiscontinuedProducts is a really bad example'\" challenges the second example given in the document revision of CSDL that participates in CSD01 public review as \"really bad at best\"(citation).\n\nThe example (as copied from the html version of the CSD01 PR document) for \"Other entity models may expose multiple entity sets per type. For instance, an entity model may have the following entity sets:\" goes like this:\n\"\"\"\n<EntitySet Name=\"Products\" EntityType=\"Self.Product\"/>\n<EntitySet Name=\"DiscontinuedProducts\" EntityType=\"Self.Product\"/>\n\"\"\" \n\nThe original poster (OP) further states w.r.t the current example, that: \"It means a Product instance changes its entity set when it becomes discontinued, and that means any existing relationships to it become illegal.  There are still Order instances that need to refer to it (assuming it was ordered before it was discontinued), but now they can't intuitively refer to it because it doesn't exist in the Products entity set anymore -- it moved to the DiscontinuedProducts entity set.  An Order entity would need to a DiscontinuedProduct navigation property in order to refer to it.\n\nHe then points to an example by Mike Pizzo of exposing a single type across multiple entity sets as provided to the odata.org mailing list [1](http://mailinglist.odata.org/scripts/wa-ODATA.exe?A2=ODATA;bc4700a0.1302).  The commenter thinks, that \"Including this example would not only provide a correct example, but it would also demonstrate a situation where the new NavigationPropertyBinding element of EntitySet is required in order to disambiguate the target entity sets of navigation properties.\"(citation)\n\nFor further details and possibly additional issues raised by the comment cf. [c201305e00002](https://lists.oasis-open.org/archives/odata-comment/201305/msg00002.html)\n\nEDIT(in the light of subsequent postings to the comments mailing list in the same \"thread\"):\n\nIt is currently under investigation, if the following holds true:\n\"\"\"\nThe mailing list messages as documented at [c201305e00006](https://lists.oasis-open.org/archives/odata-comment/201305/msg00006.html), amending and including also [c201305e00005](https://lists.oasis-open.org/archives/odata-comment/201305/msg00005.html), in turn amending and including also [c201305e00004](https://lists.oasis-open.org/archives/odata-comment/201305/msg00004.html) also amending and including [c201305e00002](https://lists.oasis-open.org/archives/odata-comment/201305/msg00002.html) further delivered details and suggested content for the resolution of the issue pointed out by [c201305e00002](https://lists.oasis-open.org/archives/odata-comment/201305/msg00002.html) and to be resolved by [ODATA-387](https://issues.oasis-open.org/browse/ODATA-387).\n\"\"\"\n\n\n### Proposal\n\nProvide an example that shows BOTH the use of a navigation property binding (for the case where the target is known) and that does not (for the case where the target is not known). Clarify that the navigation property binding is used where this information is available, not excluded if it is \"implicit\". \n\nExample text: \n\nIn the following example there are separate entity sets for standard customers and preferred customers, but only one entity set for orders. The entity sets for standard customers and preferred customers both have navigation property bindings to the orders entity set, but the orders entity set does not have a navigation property binding for the Customer navigation property, since it could lead to either set of customers:\n\n<EntityContainer Name=\"Sales\" IsDefaultEntityContainer=\"true\"> \n  <EntitySet Name=\"StandardCustomers\" EntityType=\"Self.Customer\"> \n    <NavigationPropertyBinding Path=\"Orders\" EntitySet=\"Orders\"/> \n  </EntitySet> \n  <EntitySet Name=\"PreferredCustomer\" EntityType=\"Self.Customer\"> \n    <NavigationPropertyBinding Path=\"Orders\" EntitySet=\"Orders \"/> \n  </EntitySet> \n   <EntitySet Name=\"Orders\" EntityType=\"Self.Order\"/> \n</EntityContainer> \n\nAlso state in definition of Partner attribute for edm:NavigationProperty that:\n- if the identified partner navigation property is single-valued, it will lead back to the source entity from all related entities\n- if the identified partner navigation property is multi-valued, the source entity will be part of that collection\n- if no partner navigation property is specified, no assumptions can be made as to whether one of the navigation properties on the target type will lead back to the source entity.\n\nAccepted:https://www.oasis-open.org/committees/download.php/49212/odata-meeting-37_on-20130516-minutes.html#odata-387\n\nImported from [ODATA-387](https://issues.oasis-open.org/browse/ODATA-387)",
    "labels": [
      "CSDL XML",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "odata-v4.0-csprd01-part1-protocol, 3 Data Model, appears to be an unnumbered list of definitions, with annotations defined in a separate subsection - suggest new format, etc.",
    "body": "odata-v4.0-csprd01-part1-protocol, section 3 is titled \"Data Model\" but appears to be an unnumbered list of definitions. And, annotations are split out into a separate subsection.\n\nThe wording of the definitions (if that is what they are) is consistent from definition to definition. To illustrate:\n\n****\nEntity types are nominal structured types with a key. They define the named properties of an entity and MAY define relationships with, or derived by single inheritance from, other entity types.\n\nThe entity key of an entity type is formed from a subset of primitive properties (e.g. CustomerId, OrderId, LineId, etc.) of the entity type\n\nComplex types are keyless nominal structured types consisting of a set of properties. These are value types that lack identity. Complex types are commonly used as property values in an entity or as parameters to operations.\n****\n\nFirst, note that \"nominal\" isn't defined until 4.1. \n\nIf this is a list of definitions or details of the data model, shouldn't it be inclusive and complete?\n\nSecond, \"Entity types are nominal structured types with a key.\"\n\nkey?\n\nDo we mean \"entity key,\" which is defined in the next paragraph?\n\nThird, \"Complex types are keyless nominal structured types consisting of a set of properties. These are value types that lack identity.\"\n\nlack identity? If nominal means what 4.1 suggests, then complex types have names. That leads me to puzzle over what it means to lack identity? Do we mean it lacks a key?\n\nFYI, identity is used only one other time in odata-v4.0-csprd01-part1-protocol, at 11.4.9.4 to say that:\n\n\"have no individual identity, PATCH is not supported for collection properties. \nServices MUST treat collection properties as a unit.\"\n\nSo I am assuming \"identity\" isn't central to the data model.\n\nI am curious about the reason for nominal versus named, unless that is just a legacy practice. \n\nBTW, the irony of:\n\n\"Refer to [OData-CSDL] for more information on the OData entity data model.\" \n\nin CSDL was not lost on me. ;-)\n\n\n\n### Proposal\n\n3\tData Model\nThis section provides a high-level description of the Entity Data Model (EDM): the abstract data model that is used to describe the data exposed by an OData service. An OData Metadata Document is a representation of a service's data model exposed for client consumption.\n\nThe central concepts in the EDM are entities, relationships, entity sets, actions, and functions.\n\nEntities are instances of entity types (e.g. Customer, Employee, etc.). \n\nEntity types are named structured types with a key. They define the named properties and relationships of an entity. Entity types may derive by single inheritance from other entity types.\n\nThe key of an entity type is formed from a subset of the primitive properties (e.g. CustomerId, OrderId, LineId, etc.) of the entity type.\n\nComplex types are keyless named structured types consisting of a set of properties. These are value types whose instances cannot be referenced outside of their containing entity. Complex types are commonly used as property values in an entity or as parameters to operations.\n\nProperties declared as part of a structured type's definition are called declared properties. Instances of structured types may contain additional undeclared dynamic properties. A dynamic property cannot have the same name as a declared property. Entity or complex types which allow clients to persist additional undeclared properties are called open types.\n\nRelationships from one entity to another are represented as navigation properties. Navigation properties are generally defined as part of an entity type, but can also appear on entity instances as undeclared dynamic navigation properties. Each relationship has a cardinality. \n\nEnumeration types are named primitive types whose values are named constants with underlying integer values.\n\nType definitions are named primitive types with fixed facet values such as maximum length or precision. Type definitions can be used in place of primitive typed properties, for example, within property definitions.\n\nEntity sets are named collections of entities (e.g. Customers is an entity set containing Customer entities). An entity's key uniquely identifies the entity within an entity set. An entity can be a member of at most one entity set at any given point in time. Entity sets provide entry points into the data model. \n\nOperations allow the execution of custom logic on parts of a data model. Functions are operations that do not have side effects and can be further composed, for example, with additional filter operations, functions or an action. Actions are operations that allow side effects, such as data modification, and cannot be further composed in order to avoid non-deterministic behavior. \n\nActions and functions are either bound to a type, enabling them to be called as members of an instance of that type, or unbound, in which case they are called as static operations. Action imports and function imports enable unbound actions and functions to be called from the service root.\n\nSingletons are single entities which are accessed as children of the entity container.\n\nAn OData resource is anything in the model that can be addressed (an entity set, entity, property, or operation).\nRefer to [OData-CSDL] for more information on the OData entity data model.\n\n3.1 Annotations\nModel and instance elements can be decorated with Annotations.\n\nAnnotations can be used to specify an individual fact about an element, such as whether it is read-only, or to define a common concept, such as a person or a movie.\n\nApplied annotations consist of a term (the namespace-qualified name of the annotation being applied), a target (the model or instance element to which the term is applied), and a value. The value may be a static value, or an expression that may contain a path to one or more properties of an annotated entity.\n\nAnnotation terms are defined in metadata and have a name and a type. \n\nA set of related terms in a common namespace comprises a Vocabulary.\n\n\nImported from [ODATA-386](https://issues.oasis-open.org/browse/ODATA-386)",
    "labels": [
      "Protocol",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]