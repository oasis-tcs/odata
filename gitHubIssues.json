[
  {
    "title": "Propagation of NavigationRestrictions",
    "body": "Clarify whether/how navigation restrictions \"propagate\".\n\nAssume we have \n- Order entity related to single Customer entity\n- Customer entity related to multiple Address entities\n- a navigation restriction on Customers entity set which lists Addresses as filterable:false.\n\nNow a client knows that it cannot filter Customers by Addresses.\n\nShould a client assume that it also cannot filter Orders by Customer/Addresses?\n\nOr would the service have to explicitly declare navigation restrictions for all entity sets with navigation paths ending in Customer/Addresses?\n\n### Proposal\n\nAs per 2018-2-8 discussion: State that clients can assume that restrictions specified on an entity set are valid whether the request is to the entity set or through a navigation property bound to that entity set.  Service could specify a different set of restrictions specific to a path, in which case any specified restrictions take precedence.\n\nImported from [ODATA-1132](https://issues.oasis-open.org/browse/ODATA-1132)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consistent order of function parameters",
    "body": "Function overload resolution rules depend on the ordered set of parameter types.\nAlso the first parameter is the binding parameter for a bound function/action.\n\nThis implies that the order of function/action parameters has to be stable over time.\n\nClarify this in Part 1: Protocol, section 5.2 Model Versioning, and/or the CSDL documents, sections 12.9 Parameter\n\n### Proposal\n\nClarify that the defined order of parameters for functions or actions, as returned in CSDL, is stable over time.\n\nImported from [ODATA-1131](https://issues.oasis-open.org/browse/ODATA-1131)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON Batch and continue-on-error",
    "body": "The JSON Format specifcation states in http://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd03/odata-json-format-v4.01-csprd03.html#sec_ProcessingaBatchRequest that\n\nThe service MAY process the individual requests and atomicity groups within a batch request in any order that is compatible with the dependencies expressed with the dependsOn name/value pair. Processing stops on the first error unless the continue-on-error preference is specified.\n\nThis makes batch processing somewhat non-deterministic.\n\nAlso it is not clear what \"stop processing\" means: \n- If the service chose to process independent groups of requests in parallel, will only groups stop that contain a failing individual request?\n- What is contained in the array of responses for \"skipped\"/\"unprocessed\" individual requests?\n\nDo we need continue-on-error at all for JSON Batch requests?\nIf yes: does it only apply to subsequent requests within \"dependency chains\"?\nOr do we intentionally leave this up to the service implementation and thus non-deterministic?\n\n\n\n### Proposal\n\nallow \"continue-on-error=false\" and \"continue-on-error=true\".  \"continue-on-error\" implies true.  If continue-on-error is not specified, then default is false in multipart mixed, true in json. In multipartmixed, continue-on-error=false means stop if any statement fails. In json it means that a best effort is requested not to spend cycles on further processing if a failure occurs outside of dependency groups because the client is not interested in the result.\n\nImported from [ODATA-1130](https://issues.oasis-open.org/browse/ODATA-1130)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow deep insert of media resources",
    "body": "Section 11.4.2.2 Create Related Entities When Creating an Entity -\n http://docs.oasis-open.org/odata/odata/v4.01/csprd03/part1-protocol/odata-v4.01-csprd03-part1-protocol.html#sec_CreateRelatedEntitiesWhenCreatinganE - states\n\nMedia entities, whose binary representation cannot be represented inline, cannot be created within a deep insert.\n\nThis is no longer true and thus an unnecessary restriction, media resources can be represented inline as a property \"$value\", see http://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd03/odata-json-format-v4.01-csprd03.html#sec_MediaEntity\n\n### Proposal\n\nRemove restriction, or better replace it with text referring to \"$value\" inline representation.\n\nNote: this only applies if the media entity is nested within a \"non-media\" entity.\n\nAlso mention inline representation of stream properties as base64url-encoded values, see [http://docs.oasis-open.org/odata/odata-json-format/v4.01/csprd03/odata-json-format-v4.01-csprd03.html#sec_StreamProperty]\n\nImported from [ODATA-1129](https://issues.oasis-open.org/browse/ODATA-1129)",
    "labels": [
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify function imports in $filter and $orderby",
    "body": "Section 11.5.3.1 Invoking a Function - http://docs.oasis-open.org/odata/odata/v4.01/csprd03/part1-protocol/odata-v4.01-csprd03-part1-protocol.html#sec_Functions - states\n\n    Function imports MUST NOT be used inside either the $filter or $orderby system query options.\n\n\n\nThis somewhat defeats the purpose of $root, because it might be helpful to \n\nGET Stuff?$filter=ResponsibleUser eq $root/Me/Username\n\nwhere Me is a function import returning a complex value - function import instead of singleton because it is read-only.\n\n### Proposal\n\nChange the sentence to \n\n    Function imports can be used inside $filter or $orderby if preceded by the $root literal, see [OData-URL].\n\nImported from [ODATA-1128](https://issues.oasis-open.org/browse/ODATA-1128)",
    "labels": [
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "clarify support for navigation properties on deleted entries",
    "body": "In 4.01 we added support for properties within a deleted entry.  This allows us to omit the @odata.id, if key fields are included, and may provide other information about the deleted entry.\n\nWe are not clear, however, whether \"properties\" includes navigation properties and what the semantics of navigation properties on a deleted entry should be.\n\nIf you think of a delta payload as a graph of changes, the fact that a node within that graph has been deleted doesn't mean that you aren't interested in changes to other nodes within the graph; it's still interesting to report changes to nodes that may no longer be accessible (at least from the root) after applying changes.\n\n### Proposal\n\nClarify that navigation properties, as well as structural properties, are supported within a deleted entry, to show changes to entities related to the deleted entry.\n\nJust as for a regular entity in a delta response, a single-valued navigation property may reference a tombstone, in which case that related entity is also deleted, and the deleted entry may include a nested delta (represented using @delta annotation in JSON) that includes both changed and deleted related entities.\n\nImported from [ODATA-1127](https://issues.oasis-open.org/browse/ODATA-1127)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove a Reference to an Entity (public review comment c201710e00005)",
    "body": "Public review comment https://lists.oasis-open.org/archives/odata-comment/201710/msg00005.html\n\nThe document \"OData Version 4.0, Part1: Protocol\" specifies in section\n\"11.4.6.2 Remove a Reference to an Entity\":\n\n     For collection-valued navigation properties, the entity reference of\n     the entity to be removed MUST be specified using the $id query\n     string option.\n\nIt would be nice if instead of or at least additional to using the $id query\noption it would be allowed to use the key after the navigation property\nto specify which entity is referenced.\n\nExample:\n    DELETE http://host/service/Customers(1)/Orders/$ref?$id=../../Orders(4711)\ncould be expressed as\n    DELETE http://host/service/Customers(1)/Orders(4711)/$ref\n\nThis avoids a mandatory query option, handling of nested URLs, and parsing of relative or absolute URLs including verification that the URL is fitting; last but not least it is shorter and easier to understand.\n\nKind Regards,\nOliver Heinrich\n\n\n### Proposal\n\nWe could allow the simplified syntax in the same cases in which we allow addressing a member within an entity collection by key, Part 2, section 4.9: http://docs.oasis-open.org/odata/odata/v4.01/csprd03/part2-url-conventions/odata-v4.01-csprd03-part2-url-conventions.html#sec_AddressingaMemberwithinanEntityColle\n\nImported from [ODATA-1126](https://issues.oasis-open.org/browse/ODATA-1126)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define by-value/reference expectations for action/function payloads.",
    "body": "Descriptions of parameters and return types do not explain expectations for references to Entities.  \nThe metamodel + vocabulary for CSDL allows three types of encodings:\n•\tBy-reference, represented as a string containing a URL that references the resource.\n•\tBy-reference, represented as an object containing a partial copy of the resource  that includes just the @odata.id meta property with a value that is a string containing a URL that references the resource.\n•\tBy-value, represented as an object containing a copy of the resource.\n\nFor parameters and return-types, the question is which of these are expected in a payload.\n\n\n### Proposal\n\nExpectations to be spelled out in Part 1: Protocol, documenting the by-value/by-reference expectations in Part 1: Protocol, with forward-reference to JSON Format for \"bind syntax\" / \"entity references\", to be detailed by authors, to be reviewed in document walk-through\n\n\nImported from [ODATA-1125](https://issues.oasis-open.org/browse/ODATA-1125)",
    "labels": [
      "Protocol",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Authorization vocabulary: KeyLocation - also allow cookie as value?",
    "body": "ApiKey/KeyLocation: also allow cookie as value\n\n\n\n### Proposal\n\nAdd \"Cookie\" to the value of KeyLocation.\n\nImported from [ODATA-1124](https://issues.oasis-open.org/browse/ODATA-1124)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow 24:00:00 for Edm.TimeOfDay (public review comment c201710e00003)",
    "body": "Public review comment https://lists.oasis-open.org/archives/odata-comment/201710/msg00003.html\n\nCSDL 4.01 permits Edm.TimeOfDay values to range from 00:00:00 to 23:59:59.999*.\n\nHowever existing systems (e.g. SAP backends) frequently utilize 24:00:00 to indicate end-of-day. Requiring these values to be transmitted (e.g. to clients) as 23:59:59.999* could result in round-trip data loss.\n\n In fact such SAP systems (for V2/V4) already will return PT24H or normalization-equivalent (for the V2 format of Edm.Time using XSD duration) or 24:00:00 (for the V4 format of Edm.TimeOfDay using XSD time), which is non-compliant with OData V2-V4 specifications.\n\nTo improve interoperability, it would be preferable to standardize this behaviour.\n\nNote that the lexical format for XSD time permits 24:00:00, as it is the left-truncation of dateTime lexical representation, and dateTime lexical representation (see https://www.w3.org/TR/xmlschema-2/#dateTime) states:\n\n -    hh is a two-digit numeral that represents the hour; '24' is permitted if the minutes and seconds represented are zero, and the dateTime value so represented is the first instant of the following day (the hour property of a dateTime object in the ·value space· cannot have a value greater than 23);\n\n### Proposal\n\nResolve with no action.  ISO 8601 has explicitly removed 24:00 for information exchange in order to avoid ambiguity. As most common programming langauges don't support storing this as a distinct value (even those that accept such a value), clients would have problems roundtripping the value.\n\nImported from [ODATA-1123](https://issues.oasis-open.org/browse/ODATA-1123)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add singletons for capability term targets",
    "body": "A number of capabilities target entity sets, and follow navigationpaths to target contained members.\n\nThese should also be able to apply to singletons defined within an entity container.\n\nTodo: enumerate the capabilities that should have \"Singleton\" added.\n\nImported from [ODATA-1122](https://issues.oasis-open.org/browse/ODATA-1122)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add FilterExpressionType values \"MultiRange\" and \"MultiRangeOrSearchExpression\"",
    "body": "Filter expression restrictions where introduced in [ODATA-816](https://issues.oasis-open.org/browse/ODATA-816) to express restricted filter capabilities on individual properties that can only be used in equality comparison or interval comparison.\n\nSimilar to MultiValue being multiple SingleValues joined by OR, MultiRange is multiple SingleRanges joined by OR, with a slight generalization: in addition to closed intervals also half-open and open intervals are allowed, as well as degenerate intervals (closed intervals with identical lower and upper boundary can be expressed simply via EQ).\n\nThis means that MultiRange subsumes SingleRange as well as MultiValue and SingleValue.\n\nFor string-valued properties this can be extended to include multiple SearchExpressions: MultiRangeOrSearchExpression, allowing to OR zero or more startswith, endswith, or contains functions comparing the property to a string literal.\n\nThese expressions are all fairly simple, including a property, a literal value, and at most one level of parentheses. They represent expressions that can be constructed by typical \"extended search\" forms that allow to pick the comparison operator and enter the comparison value (or two values for \"between\").\n\n### Proposal\n\nAdd new allowed values\n\n  <Record>\n    <PropertyValue Property=\"Value\" String=\"MultiRange\" />\n    <Annotation Term=\"Core.Description\" String=\"Property can be compared to a union of one or more closed, half-open, or open intervals\" />\n    <Annotation Term=\"Core.LongDescription\" String=\"The filter expression for this property consists of one or more interval expressions combined by OR. A single interval expression is either a single comparison of the property and a literal value with eq, le, lt, ge, or gt, or pair of boundaries combined by AND and enclosed in parentheses. The lower boundary is either ge or gt, the upper boundary either le or lt.\" />\n  </Record>\n\n\n  <Record>\n    <PropertyValue Property=\"Value\" String=\"MultiRangeOrSearchExpression\" />\n    <Annotation Term=\"Core.Description\" String=\"Property can be compared to a union of zero or more closed, half-open, or open intervals plus zero or more simple string patterns\" />\n    <Annotation Term=\"Core.LongDescription\" String=\"The filter expression for this property consists of one or more interval expressions or string comparison functions combined by OR. See MultiRange for a definition of an interval expression. See SearchExpression for the allowed string comparison functions.\" />\n  </Record>\n\nImported from [ODATA-1121](https://issues.oasis-open.org/browse/ODATA-1121)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Put entity set restrictions on NavigationPropertyDescriptions",
    "body": "In OData-958 we added FilterRestrictions and SortRestrictions to NavigationPropertyDescriptions.  This gave us a place to define such restrictions on collection-valued navigation properties.  However, we missed some other restrictions and, in OData-1055, proposed to add one of these (DeepInsertSupport) as an annotation that could be applied to a \"Collection\" (i.e., a collection-valued navigation property).  This has a number of issues:\n1) It uses the new \"Collection\" value in AppliesTo, which we did not want to return to OData 4.0 clients,\n2) It underspecifies where DeepInsertSupport can be applied (i.e., it doesn't make sense for collection-valued structural properties),\n3) It creates multiple places for the client to look to figure out what it can/can't do for a particular navigation property\n4) It puts the annotation on the navigation property within the type, which makes it difficult to re-use that type.\n\nA better, more consistent approach would be to add to NavigationPropertyRestrictions all of the restrictions we currently have for EntitySets.\n\n\n### Proposal\n\n1) Remove \"Collection\" from AppliesTo for DeepInsertSupport; keep \"EntityContainer\" and \"EntitySet\".\n2) Add DeepInsertSupport, IndexableByKey, TopSupported, SkipSupported, SearchRestrictions, InsertRestrictions, UpdateRestrictions, and DeleteRestrictions to our NavigationPropertyRestrictions.\n\nImported from [ODATA-1120](https://issues.oasis-open.org/browse/ODATA-1120)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add CollectionPropertyRestrictions capability term",
    "body": "In [ODATA-545](https://issues.oasis-open.org/browse/ODATA-545) we added the value \"Collection\" as a valid value for AppliesTo to specify that a term can target any collection.  At the time we said that it should only be returned for 4.01 or greater clients.  We said that, for 4.0 clients, we could just say \"EntitySet Property NavigationProperty\" and underspecify the restriction (i.e., it would only apply to collection-valued (nav) properties) but that would be implied by the semantics of the term.\n\nThen, in [ODATA-631](https://issues.oasis-open.org/browse/ODATA-631), we used the new term in our vocabularies for things like CountRestrictions, FilterRestrictions,TopSupported,SKipSupported, etc.  This is problematic, as we didn't want to return this to 4.0 clients, yet we only have one version of the vocabulary.\n\nIt also violates our best practice of applying annotation in the container, in order to support type-reuse, rather than annotate the type directly.\n\n\n### Proposal\n\n1) Remove \"Collection\" in AppliesTo in our capabilities vocabulary.\n2) Add a new term, \"CollectionPropertyRestrictions\", that can be applied to collection-valued structural properties to describe support for new filter/sort/page type functionality:\n\n<Term Name=\"CollectionPropertyRestrictions\" Type=\"Collection(Capabilities.CollectionPropertyRestrictionsType)\" AppliesTo=\"EntitySet\">\n    <Annotation Term=\"Core.Description\" String=\"Describes restrictions on operations applied to collection-valued structural properties\" />\n</Term>\n<ComplexType Name=\"CollectionPropertyRestrictionsType\">\n  <Property Name=\"CollectionProperty\" Type=\"Edm.PropertyPath\">\n    <Annotation Term=\"Core.Description\" String=\"Restricted Collection-valued property\" />\n  </Property>\n  <Property Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\">\n    <Annotation Term=\"Core.Description\"\n      String=\"List of functions and operators supported in $filter. If null, all functions and operators may be attempted\" />\n  </Property>\n  <Property Name=\"FilterRestrictions\" type =\"Capabilities.FilterRestrictionsType\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $filter expressions\" />\n  </Property>\n  <Property Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $search expressions\" />\n  </Property>\n  <Property Name=\"SortRestrictions\" type =\"Capabilities.SortRestrictionsType\">\n    <Annotation Term=\"Core.Description\" String=\"Restrictions on $orderby expressions\" />\n  </Property>\n  <Property Name=\"TopSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Supports $top\" />\n  </Property>\n  <Property Name=\"SkipSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Supports $skip\" />\n  </Property>\n  <Property Name=\"Insertable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"This collection supports inserts\" />\n  </Property>\n  <Property Name=\"Updatable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Members of this ordered collection can be updated by ordinal\" />\n  </Property>\n  <Property Name=\"Deletable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">\n     <Annotation Term=\"Core.Description\" String=\"Members of this ordered collection can be deleted by ordinal\" />\n  </Property>\n</ComplexType>\n\nImported from [ODATA-1119](https://issues.oasis-open.org/browse/ODATA-1119)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clients must not specify select options to the same property more than once",
    "body": "In OData-1105 we introduced an alternate sytnax for selecting a subset of properties of a complex type, as well as specifying other select-options for doing things like filtering and sorting a collection of complex types, but we didn't define any rules around how the new syntax related to the old syntax.  I.e.\nCan the client mix the two:\n    $select=Address/City,Address($select=State)\nCan the client specify the same property in multiple places?\n    $select=Addresses/State,Addresses($select=State)\nCan the client specify the same property with and without select options?\n    $select=Addresses,Addresses($filter=State eq 'Oregon')\nCan the client specify different options for the same selectItem?\n    $select=Addresses($filter=State eq 'Oregon'),Addresses($filter=State eq 'Washington')\nCan the client specify the same property in multiple places?\n    $select=Home/Address($select=City),Home($select=Address($select=State)\nCan the client mix nav path and select options for the same select item?\n    $select=Home/Address($select=City)\n\nWith $expand we the simple rule that the same property must not appear in more than one expandItem, which is easy to make because there isn't an alternate path syntax.\n\nThe simplest rule would be to say that clients can't mix path syntax and nested $select syntax in the same URL, but that could be overly restrictive.\n\nThe next simplest rule would probably be to say that you can't mix path and nested syntax for the same selectItem.  I.e., a $select nested within a select can't specify a path, and a path can't have select options. This would be easy to validate in the ABNF. \n\nSo you could do:\n    $select=FullName/FirstName,Address($select=City)\nbut not:\n    $select=Home/Address($select=City)\n\nThis would still allow the same property to be expressed with and without select options, which we could add another rule to protect against or just say that any select options are applied.  So:\n    $select=Addresses,Addresses($select=City)\nwould be the same as:\n    $select=Addresses($select=City)\nNote that we currently don't prohibit the same select item from occurring mutiple times:\n    $select=Addresses,Addresses\nSo we should probably allow it regardless of syntax:\n    $select=Addresses/City,Addresses($select=City)\n\nAlso, note that this issue is not just restricted to $select. We now have the ability to specify a set of options for the same property, once in $select and once in $expand:\n$select=Address($expand=Residents($select=StartsWith(Name,'B')))$expand=Address/Residents($filter=StartsWith(Name,'A'))\n\n### Proposal\n\nDefine a rule that the same property cannot have options applied in more than one place.  So you can't have both select and expand options applied for the same property and can't have multiple select options applied for the same property (we already disallow mutiple expand options for the same property).\n\nImported from [ODATA-1118](https://issues.oasis-open.org/browse/ODATA-1118)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "4.01 services should support $select select option in Intermediate",
    "body": "In OData-1105 we introduced $select options.  The initial motivation for this was to provide an alternate, more concise way to specify the subset of properties of a complex type that was consistent with $expand.  Arguably, this is how nested $select properties should have been done in 4.0.\n\nOnce we introduced the syntax that was more consistent with $expand, we also discovered that some of the $expand query options could quite naturally apply to collections of structural properties as well, and added things like $filter, $orderby, $search, etc.\n\nWhen deciding where to put this new functionality in the conformance section, we made these new nested select options a SHOULD in 4.01 intermediate, and a MUST in 4.01 Advanced, since nesting $filter, $orderby, etc. within the $select represented new advanced functionality that we didn't want to make required in intermediate.\n\nHowever, we kinda forgot the initial purpose of the issues, which was to provide a more concise and consistent syntax for selecting a subset of fields within a complex type.\n\nIn order for clients to reliably take advantage of this new syntax, that (for nested $select) doesn't introduce any additional functionality, we should make support for the 4.01 syntax be at the same level as the 4.0 syntax; that is, supporting $select as a select option should be required in intermediate for a 4.01 service.\n\n\n### Proposal\n\nAdd to 4.01 Intermediate conformance level, that Services MUST support the $select select option for selecting a subset of properties of a complex type.\n\nImported from [ODATA-1117](https://issues.oasis-open.org/browse/ODATA-1117)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce $this for referencing current item in $select/$expand options",
    "body": "In OData-1105 we introduced $select options which enabled filtering a collection of structural properties.  Where the collection is a collection of complex types, you can now do something like:\n\nCustomers?$select=Addresses($filter=City eq 'Paris')\n\nHowever, we don't have a way to filter primitive types.\n\nWe also don't have a way, in $select or $expand, to pass the current item into a function without binding the function to the type of the current item.\n\nWe already have $it that references the resource identified by the last segment of the resource path, but in this case we want to reference the property on which the select/expand options are specified.\n\n### Proposal\n\nadd $this to specify the property (or navigation property) on which the select (or expand) option is specified.\n\nThis supports patterns like:\nMe?$select=PhoneNumbers($filter=StartsWith($this,\"425\"))\nMe?$expand=Friends($filter=ns.IsAGoodGuy($this))\nMe?$expand=Friends(@a=$this;$expand=Friends($filter=Friends/Any(f:f/Friends eq @a)))\n\nThe last one would (I think) return all of my friends, and all of their friends that have them as a friend. \n\nImported from [ODATA-1116](https://issues.oasis-open.org/browse/ODATA-1116)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Default values for $Precision and $Scale",
    "body": "After aligning the default for $Nullable with OpenAPI and JSON Schema, we should do the same with $Precision and $Scale\n\n### Proposal\n\n$Scale defaults to \"variable\". This is in line with the \"number\" type of OpenAPI and JSON Schema.\n\n$Precision does not have a default value, omission means arbitrary precision, both for Edm.Decimal (already the case) and for temporal types. The latter is in line with the \"date-time\" format of OpenAPI and JSON Schema for timestamps.\n\nImported from [ODATA-1115](https://issues.oasis-open.org/browse/ODATA-1115)",
    "labels": [
      "CSDL JSON",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "If-Then-Else in $batch requests",
    "body": "Add an If-Then-Else construct to batch requests that allows executing a sequence of requests depending on a condition, typically the HTTP status code of a preceding request\n\nExample 1:\n1. Book specific seat for a sports event\n2. if booking failed\n   2.a. book best-match seat for a sports event\n   endif\n\nExample 2:\n1. Modify shopping cart\n2. Convert shopping cart to purchase order (bound action)\n3. if success\n   3.a. GET newly created purchase order\n   else\n   3.b. GET modified shopping cart\n   endif\n\n### Proposal\n\nAdd an optional \"if\" member to request objects that allows specifying a condition for executing the request depending on the outcome of preceding requests. \n\nThe value of \"if\" is a string containing a boolCommonExpr as in $filter that can reference preceding requests listed in \"dependsOn\". It replaces the default condition of \"all preceding requests listed in dependsOn have succeeded\".\n\nFilter expression syntax is extended, additional expressions are\n- `$<content-id>/$succeeded` to check if the referenced request succeeded \n- `$<content-id>` to reference the response body\n- `$<content-id>/<path>` to reference a part of the response body\n\nDefine new property  `RequestDependencyConditionsSupported` -`ConditionalRequestsSupported`- for `Capabilities.BatchSupportType` to advertise this new capability.\n\nIf a service does not support \"if\" the conditional request MUST fail and if the conditional request is part of an atomicity group, that group fails and is rolled back.\n\nImported from [ODATA-1114](https://issues.oasis-open.org/browse/ODATA-1114)",
    "labels": [
      "JSON Format",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Default page size for server-driven paging",
    "body": "Add new term to Capabilities or Core vocabulary to describe the default page size used for server-driven paging.\n\n### Proposal\n\nAdd new term \n\n      <Term Name=\"DefaultPageSize\" Type=\"Edm.Int32\" AppliesTo=\"EntitySet\">\n        <Annotation Term=\"Core.Description\" String=\"Default number of items in partial responses for server-driven paging.\" />\n      </Term>\n\nImported from [ODATA-1112](https://issues.oasis-open.org/browse/ODATA-1112)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Structural properties: default for $Nullable is false in CSDL JSON",
    "body": "Section 7.2.1 incorrectly states that an omitted $Nullable member means \"false\". This is contrary to its CSDL XML default as well as the default for $Nullable for parameters, return types, and navigation properties.\n\nhttp://docs.oasis-open.org/odata/odata-csdl-json/v4.01/csprd01/odata-csdl-json-v4.01-csprd01.html#sec_Nullable\n\n### Proposal\n\nSimplify the handling of null values in JSON by making $Nullable false the default value for all usages in JSON CSDL.  Additionally, we clarify the meaning of $Nullable = true for a collection (that it allows null values within the collection) and disallow $Nullable=true for collection-valued navigation properties.\n\nImported from [ODATA-1111](https://issues.oasis-open.org/browse/ODATA-1111)",
    "labels": [
      "CSDL JSON",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that 'parameter' aliases can also be used to substitute expressions",
    "body": "11.2.6.1.3 Parameter Aliases specifies that \"Parameter aliases allow the same value to be used multiple times in a request and may be used to reference primitive values, complex, or collection values\" yet in both Example 67 and Example 79 we ourselves show that aliases can also be used to substitute expressions, something which my developers deem is against what's been specified in 11.2.6.1.3, hence the ask for clarification.\n\n### Proposal\n\nQuery parameters for $filter segment are always passed in as expressions (because that is the expected type of the parameter).  All other parameters defined as query options are evaluated in the context of the resource identified by the URL path segment in which they are used and passed as literals into the expression.\n\nAdd ability to assign values to parameter aliases within $expand, in which case they are evaluated relative to the resource context of the $expand. Also consider adding to $select when considering [ODATA-1105](https://issues.oasis-open.org/browse/ODATA-1105).\n\nImported from [ODATA-1109](https://issues.oasis-open.org/browse/ODATA-1109)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Disallow empty parens for implicit parameter syntax",
    "body": "In [ODATA-763](https://issues.oasis-open.org/browse/ODATA-763) we introduced a simplified syntax for invoking a function with implicit parameters.  While the proposal in [ODATA-763](https://issues.oasis-open.org/browse/ODATA-763) called for omitting the parens in this case, the application seems to have made the parens optional.\n\nNote that we have also made the parens optional for the case where there are no parameters to be passed to the function.\n\n### Proposal\n\nProhibit parens following the function name in the implicit parameter case.\n\nImported from [ODATA-1108](https://issues.oasis-open.org/browse/ODATA-1108)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce mechanism for selecting default properties",
    "body": "Today, in the absence of $select, services can return a default set of properties that is a subset of the full set of available properties.\n\nClient can use $select=* to select all properties, but there is no way to select default properties plus one or two (potentailly non-default) properties, such as:\n\n$select=<default>,Address\n\n### Proposal\n\nPropose no action at this time; re-open if we come up with compelling client scenarios.\n\nImported from [ODATA-1106](https://issues.oasis-open.org/browse/ODATA-1106)",
    "labels": [
      "URL Conventions",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Simplify selection of properties of complex type",
    "body": "Currently, properties of complex types are individually selected, as in:\n$select=Name,Address/City,Address/State,Address/Zip\n\nWe could simplify the syntax for selecting individual properties of a complex type, similar to expand options.  Something like:\n$select=Name, Address($select=City,State,Zip)\nor\n$select=Name, Address(City,State,Zip)\n\nThe first syntax would support adding the ability, for example, to $filter or $sort a collection of complex types.\n\nWe could put $compute (or an inline expression) in the $select in as a scoped value (couldn't be used in filter/sort).\n\nPutting $expand in $select brings in all the issues of combining $expand and $select and results in two ways of doing expand.  \n\n### Proposal\n\nHarmonize syntax for complex properties within $select with syntax for navigation properties within $expand:\n- complex property can be followed by parentheses containing\n  - $expand nested in $select.  \n  - $select with same recursive syntax\n  - $compute to place computed properties within the complex type\n  - for collection-valued structural properties also $filter, $search, $count, $orderby, $skip, and $top within the parentheses\n  - support assigning values to parameter aliases within $select\n\nExtended $select syntax also allowed for $select nested within $expand.\n\n\nImported from [ODATA-1105](https://issues.oasis-open.org/browse/ODATA-1105)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make \"@\" optional for implicit parameters",
    "body": "Similar to making the $ optional for system query options, make the \"@\" optional for query options representing parameters. Define precedence rules for resolving potential ambiguity.\n\n### Proposal\n\nMake the \"@\" prefix for implicit parameters optional.  \n\n    GET http://host/service/EmployeesByManager?ManagerID=3 \n\nIf the parameter matches a system query option, the system query option is used.  To be unambiguous and future proof, use the \"@\" prefix.\n\nKeep the \"@\" prefix in the path for explicitly introduced parameter aliases in order to disambiguate within the path, and in the query option to match the alias within the path.\n\nImported from [ODATA-1104](https://issues.oasis-open.org/browse/ODATA-1104)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Special values of temporal types (public comment c201708e0003)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201708/msg00003.html\nFollow-up to https://lists.oasis-open.org/archives/odata-comment/201707/msg00002.html / [ODATA-1091](https://issues.oasis-open.org/browse/ODATA-1091)\n\nThe addition of INF/-INF for date types does introduce a new ambiguity in the primitiveLiteral syntax though.\n\nIf I parse the value INF in an _expression_ I don't know if it is meant to be a numeric or a Date (or DateTimeOffset) type.  Numeric types can all be cast to each other (within limits) so it doesn't actually matter but in the proposed 4.01 my parser is likely to parse INF as doubleValue (or decimalValue now) and then, when attempting to use it in a context where a DateTimeOffset is required, the cast will fail and result in NULL.\n\nThe guidance here is interesting on whether to attempt INF/-INF with dates (look past the accepted answer too):\nhttps://stackoverflow.com/questions/8011914/how-to-represent-end-of-time-in-a-database\n\nPostgreSQL does use Infinity for both date types but (curiously) these special values appear to be timestamps internally (and will cast to Date as required) whereas the equivalent numeric values must be quoted (as strings) and presumably rely on cast from string to numeric.\n\nIt's a tight corner!  The trouble is that primitiveLiteral has set out to enable numeric types and date types to be parsable without any special quoting which rules out any common representations (of non-castable types).\n\nGiven that you have maxdatetime and mindatetime as functions are you now going to have maxdatetime() return INF?  Or is there now a value of DateTimeOffset that compares greater than maxdatetime()?\n\nReferring to the SO thread, it feels like you are trying to implement both patterns at once.  If you're committed to maxdatetime I suggest sticking with that.  Otherwise, promote maxdatetime/mindatetime to being a special value (of type DateTimeOffset) instead of being a function.  You will need maxdate and mindate too.\n\nSteve\n\n### Proposal\n\nRevise proposal from 8/24/2017 meeting:\n\nI propose we resolve OData-1103 by removing the support for INF and -INF for the temporal data types added in OData 4.01.\n\nImported from [ODATA-1103](https://issues.oasis-open.org/browse/ODATA-1103)",
    "labels": [
      "ABNF",
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Multiplication and division of Edm.Decimal: result has floating scale if either operand has floating scale",
    "body": "We already have the special rule that if either operand of multiplication or division is decimal with variable scale, the result is decimal with variable scale.\n\nWe need to add floating scale to the mix.\n\n### Proposal\n\nFloating scale dominates, then variable scale, then fixed scale.\n\nImported from [ODATA-1102](https://issues.oasis-open.org/browse/ODATA-1102)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "The hash (#) character is not allowed in search phrases per the ABNF definition",
    "body": "The hash character (#) has meaning in both a URL and in OData so it makes sense that the hash character is not allowed in a search word.  I would have expected though that the hash character could be used in a quoted search phrase, but the ABNF definition for search phrase does not include the hash character.\n\nsearchPhrase = quotation-mark 1*qchar-no-AMP-DQUOTE quotation-mark\n\nqchar-no-AMP-DQUOTE   = qchar-unescaped \n                      / escape ( escape / quotation-mark )\n\nqchar-unescaped       = unreserved / pct-encoded-unescaped / other-delims / \":\" / \"@\" / \"/\" / \"?\" / \"$\" / \"'\" / \"=\"\n\nunreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n\nother-delims   = \"!\" /                   \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\"\n\nNone of those definitions include the hash character.  Was the hash character left out on purpose?  Is the only way to include it to percent encode it?\n\n### Proposal\n\nClarify that # characters in search phrases have to be percent-encoded because the first clear-text occurrence of the hash character (#) ends the query part of a URL and starts the fragment part, see https://tools.ietf.org/html/rfc3986#section-3.5. \n\nImported from [ODATA-1101](https://issues.oasis-open.org/browse/ODATA-1101)",
    "labels": [
      "ABNF",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add mechanism for specifying match type for $search",
    "body": "When doing text searches, many of the common algorithms we use have a number of different ways to define a match (Exact match, begins with, synonym, base word or inflection, etc).  The spec currently says it is up to the implementation as to what constitutes a match, this is fine, but in the case where the search algorithm provides different matching types it would be nice if the query writer could specify the type of match they want in the $search expression.\n\n\n\n### Proposal\n\nAdd “search modifiers” which consist of a letter sequence immediately followed by a colon and immediately followed by anything except space, parentheses, and an ampersand\n\nsearchTerm   = searchModifier / [ 'NOT' RWS ] ( searchPhrase / searchWord )\nsearchPhrase = quotation-mark 1*qchar-no-AMP-DQUOTE quotation-mark\n\nsearchModifier = searchOperator COLON searchOperand\nsearchOperator = 1*ALPHA\n; A searchOperand is a sequence of anything except ampersand, space, and parentheses, in clear-text or percent-encoded\n; Expressing this in ABNF is somewhat clumsy, so the following rule is overly generous.\nsearchOperand  = 1*qchar-no-AMP-parens\n\nThis would allow expressing e.g. a fuzziness factor or a matching algorithm\n\n$search=hello fuzzy:0.8 match:synonym\n\nAlternative: restrict search operands to search phrases (enclosed in double quotes) and search words:\n\nsearchOperand = searchPhrase / searchWord\n\n\nImported from [ODATA-1100](https://issues.oasis-open.org/browse/ODATA-1100)",
    "labels": [
      "Protocol",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add annotations to describe custom query options and custom headers",
    "body": "Some services support custom query options, either across the board, or for specific resources or resource types.\n\nOther services support or even require custom headers, e.g. for CSRF protection.\n\nWe need a way to express in metadata which custom query options and custom headers are available / required where.\n\n### Proposal\n\nSee [https://github.com/oasis-tcs/odata-vocabularies/blob/[ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099)/vocabularies/Org.OData.Capabilities.V1.md#CustomHeaders]\n\n2018-1-0: Proposal amended by unanimous consent to restrict the \"AppliesTo\" to \"EntityContainer\". This allows us to specify global (service-wide) query options or headers. Resource-specific header and query option requirements can be applied through the HttpRequests annotation term defined in [ODATA-884](https://issues.oasis-open.org/browse/ODATA-884). Update the applied change to restrict to \"EntityContainer\" and update description to specify that they are applied to service.\n\n \n\n2019-2-14: Ammend proposal to change \"RetrieveRestrictions\" to \"ReadRestrictions\"\n\nImported from [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "xxxRestrictions can be applied more broadly",
    "body": "The following terms may be applied to EntityTypes\n- NavigationRestrictions : affects implementation of navigation properties \n- ExpandRestrictions : affects implementation of navigation properties \n- UpdateRestrictions : enables use of PATCH on an instance of the type\n- DeleteRestrictions : enables use of DELETE on an instance of the type\n\n\n\n\n### Proposal\n\nRemove EntityType and Collection previously added to the AppliesTo array for each of these restrictions.\n\nImported from [ODATA-1098](https://issues.oasis-open.org/browse/ODATA-1098)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.4.1.1 Path Syntax: add odata.mediaETag",
    "body": "We allow only three of the for odata.media* control information names in \"term casts\", and omit the odata.mediaETag.\n\n### Proposal\n\nAdd odata.mediaETag to list of now four special values\n\nImported from [ODATA-1097](https://issues.oasis-open.org/browse/ODATA-1097)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "9.1.4 Response Code 204 No Content: rephrase second paragraph",
    "body": "The second paragraph of section 9.1.4 is a quote from RFC7231 and somewhat hard to parse. Replace it with text that expresses its intention: send an ETag only if the client can reasonably \"know\" the current entity representation that has not been sent in the response:\n\n(1) For a PUT request: if the response body of a corresponding 200 response would have been identical to the request body, i.e. no server-side modification of values sent in the request body, no \"calculated\" values. \n\n(2) We could extend this to PATCH requests and if a corresponding 200 response would have consisted of\n- values sent in PATCH request body, plus \n- server-side values corresponding to ETag sent in If-Match header of PATCH request (for values not sent in PATCH request body)\n\nImported from [ODATA-1096](https://issues.oasis-open.org/browse/ODATA-1096)",
    "labels": [
      "Protocol",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow empty edm:Schema elements",
    "body": "The current XML Schema for the EDM namespaces requires the edm:Schema element to contain at least one child element.\n\nThis is problematic in at least two use cases:\n- OData API Designer tools - when starting with a \"blank page\"\n- Services that \"shrink\" the schema to match user authorization - when the current user isn't allowed to see anything\n\nBoth require workarounds, e.g. having a dummy annotation in the schema telling that \"this schema is intentionally empty\".\n\n### Proposal\n\nSet minOccurs to zero (is currenty 1):\n\n  <xs:element name=\"Schema\">\n    <xs:complexType>\n      <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n\n\nImported from [ODATA-1095](https://issues.oasis-open.org/browse/ODATA-1095)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Apply expression: allow all URL functions with prefix odata.",
    "body": "Currently the Apply annotation expression only lists four client-side functions, one of them being odata.concat, with the same semantics as the concat() URL function, including implicit cast of primitive operands to strings.\n\nThis will make the URL expression language and annotation expression language isomorphic.\n\n### Proposal\n\nGeneralize this to allow all URL functions, prefixed with odata., e.g. odata.day, odata.now, and refer to Part 2 for the definition of the function semantics.\n\nAllow Apply expressions with zero arguments (for odata.now).\n\nImported from [ODATA-1094](https://issues.oasis-open.org/browse/ODATA-1094)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "DMTF needs a feature to allow the schema references to become references to a local files.  Use cases include testing and implementations that do not allow access to the web.",
    "body": "DMTF needs a feature to allow the schema references to become references to a local files.  Use cases include testing and implementations that do not allow access to the web.\n\n### Proposal\n\nLooking for recommendations\n\nImported from [ODATA-1093](https://issues.oasis-open.org/browse/ODATA-1093)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Navigation Property Binding (public comment c201707e0004)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201707/msg00004.html\n\nThis comment concerns navigation property bindings.  There are two parts, a general issue with 4.0 and a similar issue that has been introduced with 4.01.  The comment refers to:\n\nOData Common Schema Definition Language (CSDL) XML Representation Version 4.01\nCommittee Specification Draft 02 / Public Review Draft 02\n\n§ 8.4 says:\n\n> Containment navigation properties define an implicit entity set for each instance of its declaring structured\n> type\n\n§ 13.4 says:\n\n> If the entity type of an entity set or singleton declares navigation properties, a navigation property binding\n> allows describing which entity set or singleton will contain the related entities\n\nIt therefore makes sense that a Binding Target must identify a single entity set.\n\nMy issue is that this path is allowed to be a path to any \"containment navigation property in scope\".  Such a path only identifies an entity set uniquely in cases where the path includes a singleton.  If the path includes an EntitySet then, as per 8.4, it will be pointing to a set of EntitySets, one per entity instance.  \n\n§ 15.4 contains an example that highlights the problem:\n\n> MySchema.MyEntityContainer/MyEntitySet/MyContainmentNavigationProperty\n\nThis issue applies to both version 4.0 and 4.01.  The resulting navigation property is only weakly bound.  Anyone attempting to validate a link must exhaustively search every instance of MyEntitySet to determine the validity of the link.  You also have the strange situation that a bound navigation property may link to two different entities WITH THE SAME KEY.  (There is no requirement that keys are unique across entity sets.) This contravenes one of the methods of addressing entities in URLs:\n\nOData Version 4.01. Part 2: URL Conventions § 4.9\n\n> For [ ... ] collection-valued navigation properties with a NavigationPropertyBinding or ContainsTarget=true specification, members of the collection can be addressed by convention by appending the parenthesized key to the URL specifying the collection of entities\n\nSo the above is already a problem IMO and I propose that the target paths be restricted to traversing Singletons (that is, if an entity set is specified it must be the last component of the path).\n\nComing on to the new issue in 4.01...\n\nVersion 4.01 has modified the way navigation bindings work to allow a single navigation property to be bound, simultaneously, to multiple entity sets based on the type of the target.  Straight away this triggers the same issue, that bound navigation properties no longer have unique keys.\n\nI'm unhappy with the idea that a binding may now bind to multiple entity sets as it would involve removing the ability to append a key to uniquely identify an entity via a (bound) navigation path.  It isn't clear what problem you're trying to solve here but it feels like it is best solved using multiple navigation properties rather than attempting an 'octopus binding'.\n\nEven if you allow a single bound navigation property to bind to multiple entity sets the new feature creates the possibility of a partially bound navigation property.  If I have a navigation property called A of type Collection(TypeA) and TypeA has two sub-types, TypeB and TypeC then we can now bind any of the following:\n\nA\nA/TypeA\nA/TypeB\nA/TypeC\n\nThe most specific rule applies so the last two rules override the first two but if we only bind A/TypeC then any instances of TypeB linked to A are unbound.  The result is a partially bound navigation property.  This could be corrected by requiring a default binding (with no type cast segment) if a type-cast binding is provided.\n\nHopefully helpful.\n\nSteve\n\n### Proposal\n\n13.4.2 Binding Target\n\nClarify that a containment navigation property can only be a target if it directly or indirectly belongs to a singleton - inserted text in square brackets:\n\n    If the target is a target path, it MUST resolve to an entity set, singleton, or\n   [direct or indirect] containment navigation property [of a singleton] in scope.\"\n\n15.4 Target Path - Example 67\n\nReplace \"MyEntitySet\" with \"MySingleton\" in third and fourth example to avoid confusion.\n\n\n13.4.1 Binding Path and 13.4.2 Binding Target - Example 37\n\nPart 3) of [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674) was not applied - binding path may traverse collection-valued segments, binding applies to all members. Example 37 is supposed to show this. Add missing text for Part 3) of [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674) and refer to it in example 37.\n\n[If the path traverses collection-valued complex properties or collection-valued containment navigation properties, the binding applies to all items of these collections.]\n\n\n13.4.1 Binding Path with type-cast segment (\"octopus binding\") and Part 2, 4.9 Addressing a Member within an Entity Collection\n\nWe retain \"octopus binding\" with the semantics that:\n1) If there is a single nav prop binding with no type, you can reference members by appending the key to the nav prop.\n2) If there is a nav prop binding with a type, you must include the type when appending the key segment to the nav prop.\n3) If you want to know if you can append the key to the nav prop, you should really be looking at IndexableByKey annotation in the capabilities vocabulary. \n4) If no binding matches an instance, it is unbound (same semantics as no navigation property binding today).\n\n\nImported from [ODATA-1092](https://issues.oasis-open.org/browse/ODATA-1092)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Special values of numeric types (public comment c201707e0002)",
    "body": "Public Review Comment https://lists.oasis-open.org/archives/odata-comment/201707/msg00002.html\n\nComment on: 4.01 Committee Specification Draft 02 / Public Review Draft 02\n\nOne of the new provisions in 4.01 is:\n\nAll numeric types allow the special numeric values ‑INF, INF, and NaN\n\nThis feels onerous given typical technologies for storing integer numeric types.  The ABNF for values of Int16, for example, now reads:\n\nint16Value = [ SIGN ] 1*5DIGIT  / nanInfinity ; numbers in the range from -32768 to 32767\n\nClearly this now requires MORE than 16 bits to store.\n\nGiven that the numeric integer types are typically used as keys for entities there are some odd implications too.  Clearly the definitions of INF and -INF can still work as they compare equal to themselves and top/tail the value range when ordering.  I'm more concerned about NaN which doesn't compare equal to itself, this is likely to cause issues if it is used as the value of an entity key.  (I believe PostgreSQL allows these values as keys but treats Nan == Nan as true and Nan > x as true for all x != Nan, this goes against IEEE but seems necessary if they are to be used in context where ordering is required.)\n\nTo use XML schema vocab, it feels like the abstract values and lexical representations have become muddled.  The desire to use special values in JSON representations of integers has serious implications for the abstract value space.\n\nThe 'special' values INF, -INF and NaN are actually values in the abstract value spaces of Single and Double types (as per IEEE, extendable to Decimal).  They are not universal special (numeric) values with a status similar to 'null'.  It feels like the language of the specification is sliding toward treating all of these in a similar way.  Witness the definition of equals in Part 2 §5.1.1.1.1\n\nEach of the special values null -INF, and INF is equal to itself, and only to itself.\nThe special value NaN is not equal to anything, even to itself.\n\nYou might find this SO answer in relation to C++ interesting: https://stackoverflow.com/questions/38795544/is-casting-of-infinity-to-integer-undefined I particularly like the parenthetical comment...\n\ntruncation of infinity is still infinity, and infinity cannot be represented in int (I hope there's no question about this part)\n \nThere's a serious point to this quote though.  W.r.t. https://issues.oasis-open.org/browse/[ODATA-785](https://issues.oasis-open.org/browse/ODATA-785) I reject point (2) in the working proposal (add +inf/-inf/nan to int) for this reason.\n\nMy proposal is to clarify that the 'special' numeric values are values of type Single, Double or Decimal only.  You already have sufficient type promotion to resolve any ambiguity when parsing the literals.  For example, the less contentious promotion of the constant parsed from the string \"42\" to any of the numeric types is already accepted without the special modifiers used in OData 2/3.\n\nThe second part of my proposal is that if the abstract result of an operation cannot be represented in the return type defined for that operation then the result should be the special value null.  This would include the special case of integer division by zero (where 4.0 says the request fails) but also covers overflow of integers in other operations.  I sense the panel dislikes failing requests so my proposal fixes that by silently carrying on - the alternative is to continue to raise an exception or put in some more general provision that says that an _expression_ that fails with a division by zero is treat as null (WITHOUT continuing the computation).  The latter version has less of an impact on existing behaviour in 4.0 I guess so might be worth considering.\n\nThe NULLIF pattern for treat division by 0 as null is fairly widespread though and it is more consistent with the definition of cast:\n\n§5.1.1.10.1\n\nNumeric primitive types are cast to each other with appropriate rounding. The cast fails if the integer\npart doesn't fit into target type.\n...\nIf the cast fails, the cast function returns null.\n\nAs a follow-up point on your open issue: https://issues.oasis-open.org/browse/[ODATA-919](https://issues.oasis-open.org/browse/ODATA-919)\n\nThe idea of doing general type promotion to the largest integer type makes sense to me, if the result overflows Int64 then you'd get null (according to my proposal) which is freely castable to any of the integer types.\n\nBut I propose that Single operations that overflow Single results should be promoted to Double in a similar way.  The definition of cast will need to be modified to allow for the cast of a Double to Single with overflow resulting in INF (not a failed cast).  The proposed difference between the way integers and floating point numbers behave in this respect is precisely because the latter can represent INF.\n\nHope this helps.\n\nSteve Lay\nhttps://www.pyslet.org/\n\n### Proposal\n\n1) Restrict the 'special' numeric values to types Single, Double, and Decimal (scale=floating), partly revoking [ODATA-920](https://issues.oasis-open.org/browse/ODATA-920)\n\n2) keep 4.0 behavior for div operator - fail for division by zero for dividends other than Single, Double, and Decimal(Scale=floating)\n\n3) support fail-safe division by zero (resulting in -INF, INF, or null) for all numeric types only in the new divby operator\n\nImported from [ODATA-1091](https://issues.oasis-open.org/browse/ODATA-1091)",
    "labels": [
      "ABNF",
      "CSDL JSON",
      "CSDL XML",
      "URL Conventions",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify text about referential constraint for navigation properties on complex types",
    "body": "As pointed out in https://groups.google.com/forum/#!topic/odata-discussion/God4fXB_mrw the prose text on dependent properties is geared to navigation properties declared by entity types and confusing for navigation properties declared by complex types.\n\n### Proposal\n\nUse \"dependent instance\" and point out that referential constraints can only be defined for properties \"next\" to the navigation property, i.e. paths in the Property attribute are resolved starting at the structured type declaring the navigation property.\n\nImported from [ODATA-1090](https://issues.oasis-open.org/browse/ODATA-1090)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Org.OData.Aggregation.V1 missing Nullable=\"false\" for Function ReturnType",
    "body": "Function elements like:\n\n      <Function Name=\"isroot\" IsBound=\"true\">\n        <Annotation Term=\"Core.Description\"\n          String=\"Returns true, if and only if the value of the node property of the specified hierarchy is the root of the hierarchy\" />\n        <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\" />\n        <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\" />\n        <ReturnType Type=\"Edm.Boolean\" />\n      </Function>\n\nare missing Nullable=\"false\" in the ReturnType elements.\n\nClearly it wasn't intended for these functions to return nullable Boolean values, so this should be fixed.\n\n\n\nImported from [ODATA-1089](https://issues.oasis-open.org/browse/ODATA-1089)",
    "labels": [
      "Data Aggregation",
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify effect of applying an Annotation to an element",
    "body": "My assumption is that an annotation applied to a schema element will apply to all instances of that schema element.\nThere are some examples where groups are proposing to apply annotations to specific schema instances.\n\n### Proposal\n\nChapter 14 of the CSDL specifications\n\nMetadata annotations are terms applied to model elements. Behaviors or constraints described by a metadata annotation must be consistent with the annotated model element. Such annotations define additional behaviors or constraints on the model element, such as a service, entity type, property, function, action, or parameter. For example, a metadata annotation may define ranges of valid values for a particular property.\n\nAn instance annotation is a term applied to a particular instance within an OData payload as described in [OData‑JSON]. An instance annotation can be used to define additional information associated with a particular result, entity, property, or error. For example, whether a property is read-only for a particular instance.\n\nImported from [ODATA-1088](https://issues.oasis-open.org/browse/ODATA-1088)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Discourage names differing only in case",
    "body": "When defining a schema, names differing only in case (e.g. names for structural and navigation properties within an EntityType) can reasonably expected to cause issues when mapped to a target programming language that has case-insensitive identifiers.\n\n### Proposal\n\nStrongly discourage names to be defined within a schema/type that differ only in case.\n\n\nImported from [ODATA-1087](https://issues.oasis-open.org/browse/ODATA-1087)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "AppliesTo semantics are not normative",
    "body": "The term attribute AppliesTo is documented in section \"14.1.2 Applicability\" in a way that has been interpreted to mean that the AppliesTo values are merely recommendations.  From a specification point of view, this renders the AppliesTo attribute having no semantic value.\n\nI expected that the intent is that AppliesTo values are normative restrictions, but that the set of values may be changed in future versions of the vocabulary.\n\n\n\n\n### Proposal\n\nModify 14.1.2 Applicability as follows:\nThe AppliesTo attribute MAY be used to restrict a term to a list of model elements that the term may be applied to. If no list is supplied, the term is not intended to be restricted in its application. The list of elements may be extended in future versions of the vocabulary.  As the intended usage may evolve over time, clients SHOULD be prepared for any term to be applied to any model element and SHOULD be prepared to handle unknown values within the AppliesTo attribute.\n\nImported from [ODATA-1086](https://issues.oasis-open.org/browse/ODATA-1086)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02",
      "V4.01_CSD03"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rule searchWord is too restrictive",
    "body": "The searchWord rule is overly restrictive as it only allows ALPHA and DIGIT whereas the comment states that any Unicode letter or number is allowed.\n\nIn other places where the ABNF does not exactly describe the syntax, it allows a superset that is then further restricted by the prose specification.\n\n### Proposal\n\nExtend searchWord rule to allow percent-encoded octets. Add comment that this actually is limited to Unicode letters and numbers:\n\n; searchWord is a sequence of one or more letters, digits, commas, or dots\n; this includes Unicode characters from the Unicode categories L or N using UTF-8 and percent-encoding\n; the words AND, OR, and NOT are not a valid searchWord\n; expressing this in ABNF is somewhat clumsy, so the following rule is overly generous\nsearchWord   = 1*( ALPHA / DIGIT / COMMA / \".\" / \"%\" HEXDIG HEXDIG )\n\n\nImported from [ODATA-1084](https://issues.oasis-open.org/browse/ODATA-1084)",
    "labels": [
      "ABNF",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add annotation expressions for arithmetic operators ",
    "body": "In order to express validation rules, see [ODATA-1082](https://issues.oasis-open.org/browse/ODATA-1082), it would be helpful to also have arithmetic operators in addition to the comparison and logical operators\n\n### Proposal\n\nAdd dynamic expressions for all arithmetic operators defined in Part 2: URL Conventions.\n\nAlso add the new logical operators \"has\" and \"in\".\n\nImported from [ODATA-1083](https://issues.oasis-open.org/browse/ODATA-1083)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add term Constraint to Validation vocabulary",
    "body": "Communicating validation rules to the clients helps reduce the number of failed requests in API as well as UI scenarios.\n\nBesides the elementary rules Minimum, Maximum, Pattern, ... it would be helpful to allow expressing more complicated validation rules that involve logical and arithmetic expressions.\n\n### Proposal\n\nAdd new term\n\n<Term Name=\"Constraint\" \n           Type=\"Validation.ConstraintType\" \n           AppliesTo=\"Property EntityType ComplexType\">\n    <Annotation Term=\"Core.Description\" String=\"Condition that the annotation target has to fulfill\" />\n</Term>\n<ComplexType Name=\"ConstraintType\">\n    <Property Name=\"FailureMessage\" Type=\"Edm.String\" Nullable=\"true\">\n        <Annotation Term=\"Core.IsLanguageDependent\" />\n    </Property>\n    <Property Name=\"Condition\" Type=\"Edm.Boolean\" Nullable=\"false\">\n        <Annotation Term=\"Core.Description\"\n              String=\"Value MUST be a dynamic expression that evaluates to true if and only if the constraint is fulfilled\" />\n    </Property>\n</ComplexType>\n\nExample:\n\n <Annotation Term=\"Validation.Constraint\" Qualifier=\"Comparison\">\n    <Record>\n        <PropertyValue Property=\"FailureMessage\" String=\"Start date cannot be after end date\" />\n        <PropertyValue Property=\"Condition\">\n            <Le>\n                <Path>StartDate</Path>\n                <Path>EndDate</Path>\n            </Le>\n        </PropertyValue>\n    </Record>\n</Annotation>\n\n\n\nImported from [ODATA-1082](https://issues.oasis-open.org/browse/ODATA-1082)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove restriction on overriding of annotations on type definitions",
    "body": "CSDL XML states in section 11.1 that\n\n\"The use of a type definition MUST NOT specify an annotation specified in the type definition.\"\n\nThis would prevent e.g. to annotate a label \"Email Address\" on a type definition and then annotate a label \"Main Email Address\" on a property typed with this type definition. \n\n### Proposal\n\nReplace the text describing how annotations applied to type definitions are evaluated and restriction on overriding in section 11.1 with equivalent wording from section 14.2 on annotation propagation.\n\nImported from [ODATA-1081](https://issues.oasis-open.org/browse/ODATA-1081)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$each as wildcard for keys",
    "body": "There is a use case for specifying wildcards when processing a URL for use in requests.  Typically this is outside of OData, but it seems relevant to the use of $each.  So we want to vet it here.\n\nFor example, consider the following JSON: \n\t\"Wildcards\": [ \n\t\t{ \t\"Name\": \"allSS\",\n\t\t\t\"Values\": [\"$each\"] },\n\t\t{ \t\"Name\": \"allV\",\n\t\t\t\"Values\": [\"$each\"] },\n\t\t{ \t\"Name\": \"percentStats\",\n\t\t\t\"Values\": [\"ReadIOPercent\", \"WriteIOPercent\", \"NonIOPercent\"] }\n    ],\n\t\"MetricProperties\": [\n\t\t\"/redfish/v1/StorageServices/Members({allSS})/Volumes/Members({allV})/VolumeStatistics/{percentStats}\"],\n\nIn the case of {allSS} or {allV} one natural specification would be to use \"*\" to mean all keys.  However as shown above, an alternative is to use the $each keyword to mean all.\n\nSo, several questions:\n1) Should $each be available to mean all within parenthesis?  The /$each as a segment is consistent with the alternate key format. \n2) Should we define the wildcard substitution within OData?\n3) For this purpose, should we use \"*\" for all of the above instead of $each.\n\t\t\n\n\n\n### Proposal\n\nAllow one of $each or \"*\" as a wildcard for keys.\n\nImported from [ODATA-1080](https://issues.oasis-open.org/browse/ODATA-1080)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Several issues with latest standard vocabularies",
    "body": "Org.OData.Core.V1.xml\n\n      <ComplexType Name=\"AlternateKey\">\n        <Property Type=\"Collection(Core.PropertyRef)\" Name=\"Key\">\n          <Annotation Term=\"Core.Description\" String=\"The set of properties that make up this key\" />\n        </Property>\n      </ComplexType>\n\n  should have Nullable=\"false\" in the Property\n\nOrg.OData.Temporal.V1.xml\n\n  <Term Name=\"TemporalSupported\" Type=\"Aggregation.TemporalSupportedType\" AppliesTo=\"EntityContainer EntitySet NavigationProperty\"> -->\n\n  should be:\n  \n  <Term Name=\"TemporalSupported\" Type=\"Temporal.TemporalSupportedType\" AppliesTo=\"EntityContainer EntitySet NavigationProperty\">\n\n  8 references to Term=\"Core.Documentation\" should be to Term=\"Core.Description\"\n\n\nImported from [ODATA-1079](https://issues.oasis-open.org/browse/ODATA-1079)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "What happens if lambda variable name matches a (complex) property name?",
    "body": "MUST all paths wthin a lambda operator be prefixed with either a lambda variable name (potentially from an enclosing lambda operator) or $it/ to reference properties of the base set?\nOr is $it/ not required for properties/paths in the base set? Which would require that the lambda operator MUST NOT be identical to any property name in the base set?\nMy inclination would be:\n1) It is not required\n2) In case of conflict, lambda variable name wins (you shouldn't pick a lambda variable name that conflicts...)\n\n### Proposal\n\n1) It is not required \n2) In case of conflict, lambda variable name wins (you shouldn't pick a lambda variable name that conflicts...) \n\nImported from [ODATA-1078](https://issues.oasis-open.org/browse/ODATA-1078)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Include atomicityGroup in JSON Batch Response",
    "body": "When we introduced the JSON format for a batch request we included a property, atomicityGroup, for grouping together requests within the batch that had to be executed atomically, and required that all such requests be adjacent. However that information is lost in the response; if the client wants to know which succeeded or failed as a group (i.e., they want to look for the request that caused a group of atomic requests to fail) they have to remember which requests were associated with which other requests. This is hard for a generic library to track and violates our principle that responses should be able to be fully interpreted without knowing the request that generated it.\n\nThe service has the information for the atomicity group, and must already handle the requests as a group, but the service currently has no way to convey this to the client. It makes sense to have the service return responses with the same atomicityGroup adjacent to one another, including the atomicityGroup identifier, to make it easier for the client to associate requests within a group. \n\n### Proposal\n\nInclude the atomicityGroup id in adjacent responses within a JSON Batch response.\n\nImported from [ODATA-1077](https://issues.oasis-open.org/browse/ODATA-1077)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "If-Match: align wording with RFC7232",
    "body": "The section on If-Match explicitly requires \"weak comparison\" of ETags. \n\nThis was in line with the then current draft of RFC7232, but the final version of RFC7232 requires strong comparison of ETag values for If-Match, see https://tools.ietf.org/html/rfc7232#section-3.1. \n\n\n\n### Proposal\n\nPoint out that we intentionally deviate from RFC7232, and give reason:\n\nIf present, the request MUST only be processed if the specified ETag value matches the current ETag value of the target resource. Services sending ETag headers with weak ETags that only depend on the representation-independent entity state MUST use the weak comparison function because it is sufficient to prevent accidental overwrites. This is a deviation from [RFC7232]. \n\nImported from [ODATA-1076](https://issues.oasis-open.org/browse/ODATA-1076)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce operator for checking whether a collection is a subset or equal to another collection",
    "body": "Currently we \"overload\" the in operator to be \"subset of\" if the left operand is a collection.\n\nThis would block us from introducing collections of collections, and checking whether a collection is an item of a collection of collections.\n\n### Proposal\n\nRestrict \"in\" to mean just \"member of\" \nAdd \"hassubset\" function:\n\n1) hassubset always requires that each element of the right argument occurs at least as many times in the left argument, and that order does not matter so:  \n    hassubset([1,2],[1,1,2])  => false \nhassubset should never take order (or gaps) into account:\n    hassubset([4,1,3],[3,1]) => true \n    hassubset([4,1,3],[4,3]) => true\n\n2) for ordered collections, add a \"hassubsequence\" function that takes order into account and ignores gaps:\n    hassubsequence([4,1,3], [3,1])  => false \n    hassubsequence([4,1,3],[4,3]) => true\n\n3) add support for ordered collections to contains (that takes gaps into account) as well as startswith, endswith, indexof, and substring.\n\n\nImported from [ODATA-1075](https://issues.oasis-open.org/browse/ODATA-1075)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support Functions with /$each and define the representation for collection-valued actions and functions with /$each",
    "body": "Since we added the support to use /$each with actions, we have to define what the result looks like.  It seems reasonable that the result is an array of action results.  What, then, is the shape of the result if the action returns a collection? In order to be annotated with things like count and next link, the result would have to be a collection of value arrays, as in:\n{\"value\":[{\"value\":[{a=1,b=2},{a=2,b=3}]},{\"value\":[{a=4,b=5}]}]}.\n\nOnce we have defined the result of /$each for actions that return results, it seems natural that we support /$each with functions as well.\n\n### Proposal\n\nSupport /$each with functions as well as actions.\nThe result, in json, of a collection-valued function or action applied to /$each is an array of objects, each minimally containing a property named \"value\" whose value is the collection of items returned by the action or function.\n\n$it can be used to reference an item in the outermost collection, which in this case is an instance of an action/function result which may itself be a collection (in which case $it can be followed by /any, /all, or /$count).\n\n\nImported from [ODATA-1074](https://issues.oasis-open.org/browse/ODATA-1074)",
    "labels": [
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Conformance section references wrong annotation term",
    "body": "Regarding sentence: \"They MUST implement all set transformations and aggregation methods they advertise via the Custom Aggregates annotation.\"\nThe correct annotation term is ApplySupported/CustomAggregationMethods\n\n\n### Proposal\n\nReplace \"via the Custom Aggregates annotation\" by \"via the ApplySupported annotation\"\n\nImported from [ODATA-1073](https://issues.oasis-open.org/browse/ODATA-1073)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Annotation to describe supported aggregation methods",
    "body": "A service may support only a subset of all standard and custom aggregation methods advertised in annotation ApplySupported/CustomAggregationMethods for certain aggregatable properties. If deviations from the full set could be annotated at property level, clients would be able to recognize them and avoid requests that will be rejected by the server. In particular, this would also support the special case of an aggregatable property that does not support any aggregation method, but there is a CustomAggregate annotation with the name of the property as qualifier. Then, the property could still be used in the aggregate transformation without \"with\", and could also be annotated with further terms.\n\n\n### Proposal\n\nThis feature should be offered for entity containers and entity sets instead of structure properties, in the same way as we decided for other terms of the Aggregation vocabulary, cf. [ODATA-1382](https://issues.oasis-open.org/browse/ODATA-1382)--\n\nImported from [ODATA-1072](https://issues.oasis-open.org/browse/ODATA-1072)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "New term Core.OperationAvailable",
    "body": "Availability of actions and functions can be advertised in response payloads using special name-value pairs starting with a # character.\n\nDefine a new term that allows to express availability of an action or function statically, with reference to \"global\" data, e.g. from a singleton, or with reference to data of the binding parameter.\n\n### Proposal\n\nAdd to the Core vocabulary:\n\n     <Term Name=\"OperationAvailable\" Type=\"Edm.Boolean\" DefaultValue=\"true\" AppliesTo=\"Action Function\">\n        <Annotation Term=\"Core.Description\" String=\"Action or function is available\" />\n      </Term>\n\n\nImported from [ODATA-1069](https://issues.oasis-open.org/browse/ODATA-1069)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "3.12 Transformation expand: require at least two parameters, with innermost expansion requiring a filter()",
    "body": "An expand() transformation without a nested filter() is just a complicated identity transformation, so we should require a filter() for the innermost expand() transformation in a nested expand(). Outer and intermediate expand() don't need a filter() as they are necessary to reach the level where the filter() needs to be applied.\n\n### Proposal\n\nSee summary.\n\nABNF:\n\nexpandTrafo = 'expand' OPEN BWS expandPath BWS COMMA BWS \n              ( expandTrafo *( BWS COMMA BWS expandTrafo )\n              / filterTrafo *( BWS COMMA BWS expandTrafo ) \n              ) BWS CLOSE\n\nImported from [ODATA-1068](https://issues.oasis-open.org/browse/ODATA-1068)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider ability to define computed default values",
    "body": "Currently, default values for properties and (now, as of [ODATA-1066](https://issues.oasis-open.org/browse/ODATA-1066)) parameters are static values.\n\nThere are some cases where the default value may be the result of a calculation. Examples:\n1) The value of a related property/parameter\n2) An expression based on the value of one (or more) related properties/parameters\n3) The result of invoking a function(import) on the service (with params?)\n\nIssues:  <del>how to express the value of the defaultvalue (use Edm.Untyped? -</del> this could only be supported in 4.01)\n-what is the syntax of the expression?\n-can it invoke a funciton(import) and, if so, how are parameters passed?\n\nFor parameters, could define a derived OptionalParameterType that has a DefaultValueExpression that is Edm.Untyped and only returned as that derived type in a 4.01 payload.\n\n\n### Proposal\n\nOASIS standard term [`Core.ComputedDefaultValue`](https://github.com/oasis-tcs/odata-vocabularies/blob/main/vocabularies/Org.OData.Core.V1.md#ComputedDefaultValue) allows tagging properties that have a computed default value without revealing the underlying (and arbitrarily complex) algorithm.\n\nVendor-specific experimental term [`Common.DerivedDefaultValue`](https://github.com/SAP/odata-vocabularies/blob/main/vocabularies/Common.md#DerivedDefaultValue) allows clients to call server-side logic for computing the default value for a provided context.\n\nImported from [ODATA-1067](https://issues.oasis-open.org/browse/ODATA-1067)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider supporting optional operation parameters",
    "body": "We have frequently had requests to support optional parameters, but have pushed back because they could introduce ambiguity in function resolution.\n\nHowever, with our current rules:\n1) The unordered set of nonbinding parameter names must be unique, and\n2) The ordered list of nonbinding parameter types must be unique\n\nWe could support making some parameters optional as a backward compatible change with the following resolution rules:\n1) If the set of provided parameters exactly matches all parameters of an overload, then that overload is chosen\n2) If the set of provided parameters matches all required and a subset of optional parameters of exactly one overload, then that overload is chosen\n\notherwise a 400 error\n\nQuestions:\n1) Should we provide a set of rules so there is never any ambiguity (i.e., there does not exist a set of parameters for which one of the two rules above is not met) or specify that the service returns 400 if the request does not resolve to a single overload?\n2) Should we define a default value for optional parameters? This would really just be documentation (the service wouldn't need you to tell it what the default value was in metadata). It could be useful in generating strongly typed function calls in languages with optional parameters (C++, C#,...) but there may not be a static default value that can be specified (i.e., current time, a computed value, etc.)  \n\n### Proposal\n\n1) Add a new OptionalParameter annotation:\n  <Term Name=\"OptionalParameter\" Type=\"Core.OptionalParameterType\" AppliesTo=\"Parameter\"> \n    <Annotation Term=\"Core.Description\" String=\"Supplying a value for the parameter is optional.\" /> \n  </Term>\n\n<ComplexType Name=\"OptionalParameterType\"> \n  <Property Name=\"IsOptional\" Type=\"Edm.Boolean\" DefaultValue = \"true\"/>\n  <Property Name=\"DefaultValue\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"Default value for an optional parameter, using the same rules for the default value facet of a property.\" /> \n  </Property>\n</ComplexType>\n\n2) All parameters marked optional must come after any parameters not marked optional\n\n3) Keep existing rules for function overloads.\n\n4) In function resolution:\n    I) If the set of specified params exactly matches a function overload, chose it.\n    ii) If the set of specified params matches a subset of parameters that includes all required parameters for exactly one function overload, choose it\n\n5) Services should avoid ambiguity. If there is ambiguity then services may return 400 with an error stating that request was ambiguous\n\nImported from [ODATA-1066](https://issues.oasis-open.org/browse/ODATA-1066)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CSD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Generalize Edm.AnyPath to be a path to any model element and rename it to Edm.ModelElementPath",
    "body": "With [ODATA-516](https://issues.oasis-open.org/browse/ODATA-516) we introduced the abstract type Edm.AnyPath as an abstraction of Edm.AnnotationPath, Edm.PropertyPath, and Edm.NavigationPropertyPath.\n\nWe now face situations where we want to reference other types of model elements, e.g. bound actions or functions.\n\nIt seems wise to use the rather generic name \"AnyPath\" really for any path to any type of model element, which would\na) postpone the need for actually adding specific types Edm.ActionPath, Edm.FunctionPath, Edm.EntityTypePath, ...\nb) allow us to later add these more specific types for the more common cases\n\n### Proposal\n\nRename Edm.AnyPath (added in 4.01, so no incompatibility) to Edm.ModelElementPath\n\n(The suffix Path is somewhat superfluous but consistent with the existing AnnotationPath, AnyPropertyPath, PropertyPath, and NavigationPropertyPath.)\n\nImported from [ODATA-1065](https://issues.oasis-open.org/browse/ODATA-1065)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add ability to annotate collections to return only count and NextLink",
    "body": "Issues with NavigationProperty\n1)\tIf AutoExpand or AutoExpandReferences is not specified, then a GET without $expand or $ref query parameters will not return any representation of declared NavigationProperties.\n2)\tIf AutoExpand or AutoExpandReferences is specified, the concern is that the returned representation of the containing entity might be too large.\n3)\tFor an EntityType containing many NavigationProperties, it is difficult to specify the desired information using query parameters.\n\nThe Redfish specification attempts to solve these issues by introducing an intermediate resource that contains the original collection as a Members collection. The intermediate resource is then referenced via a NavigationProperty with AutoExpandReferences.  The new resource is required to return $count as a metadata property of the Members collection.  The value is the size of the original collection.\n\nFor the most part, this is successful, but the solution creates several new problems.\n1)\tRedfish specifies that a POST to the intermediate resource is equivalent to doing a POST to the contained collection.  This is not conformant.\n2)\tIntroduction of many intermediate resources makes the resulting model more complex.\n\n\n### Proposal\n\n----------------\nAdd new example to Prefer header to showing use of count and navigation links\n--------------------\nTo OData Version 4.01. Part 1: Protocol, clause 8.2.8.4 Preference include-annotations (odata.include-annotations)\nAdd: \nExample 8: a Prefer header requesting that navigation links be returned in the case that the format metadata=minimal is specified in the Accept header.\n      Prefer: include-annotations=\"odata.navigationLink,odata.count\"\n\nAdd paragraph before example 3.\nRegardless of the metadata format specified, annotations specified by the include-annotations preference should be added to response.\n\n--------------------\nExample:\n\n------------------\nProposed schema\n<EntityType Name=\"Top\">\n      …\n      <NavigationProperty Name=\"Systems\" Type=\"Collection(ComputerSystem)\"/>\n      …\n</EntityType>\n----------\nExample: GET\n\nGET /redfish/v1/Top\nPrefer: include-annotations=\"odata.count,odata.navigationLink\"\n\nResponse\nPreferences-Applied: include-annotations=\"odata.count,odata.navigationLink\"\n{\n\"@odata.context\": \"/redfish/v1/$metadata#Top\",\n\"@odata.id\": \"/redfish/v1/Top\",\n\"@odata.type\": \"#Top \",\n\"Name\": \"Top\",\n… \n\"Systems@odata.count\": 15,\n\"Systems@odata.navigationLink\": {\"/redfish/v1/Systems\"} \n…\n}\n\nImported from [ODATA-1064](https://issues.oasis-open.org/browse/ODATA-1064)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow $format and custom query options for all requests",
    "body": "Requests to $metadata and $batch did not explicitly allow custom query options in the ABNF.\n\nAfter adding JSON formats for metadata and batch $format needs to be allowed for all requests.\n\nCustom query options need to be allowed for all requests for e.g. passing API keys or other implementation-specific data in the URL.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1063](https://issues.oasis-open.org/browse/ODATA-1063)",
    "labels": [
      "ABNF",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow key expressions in Path constructs within annotations",
    "body": "With [ODATA-960](https://issues.oasis-open.org/browse/ODATA-960) we added absolute paths to the Path syntax, which allows referencing properties of a singleton, e.g.\n\n<Annotation Term=\"Display.visible\" Path=\"/this.container/Settings/FeatureXxxIsAvailable\" />\n\nA logical extension is allowing key expressions to reference entities and their properties within an entity set:\n\n<Annotation Term=\"Display.visible\" Path=\"/this.container/SettingsCollection('FeatureXxx')/IsAvailable\" />\n\nIn addition to literal values the key values can be provided using path expressions. This enables (a third party) to address content where the service author forgot to define a navigation path:\n\n<Annotation Term=\"Display.title\" Path=\"/this.container/Products(ID=ProductID)/Name\" />\n\n### Proposal\n\nPath expressions allow key segments in parenthesis syntax after path segments that identify a collection of entities. The key values can be literals, using the same style as URL literals, or they can be path expressions, evaluated according to the rules of path expressions.\n\nThis key syntax can only be used in Path expressions as only these refer to instance values.\n\nIt cannot be used in expressions for model references, i.e. PropertyPath, NavigationPropertyPath, AnnotationPath, and their abstract supertypes AnyPropertyPath and AnyPath.\n\nImported from [ODATA-1061](https://issues.oasis-open.org/browse/ODATA-1061)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add ability to annotate revisions with information on all elements",
    "body": "Currently there is no defined means to mark revisions to schema.  Some organizations have solved this by convention of creating a new schema for each set of revisions, primarily related only by time.\nEach schema represents a new namespace, so we get a proliferation of namespaces.  Type definitions are specific to namespaces, but since the evolving types really represent the same type declaration, they are sub classed across these namespaces.  This creates an unnecessarily complex model. \n\n### Proposal\n\nCreate a 'Revisions' term in the Core vocabulary that may be applied to any element.  Elements defined in a schema may then evolve over time and with their complete revision history intact. The proposal is as follows:\n\n      <Term Name=\"Revisions\" Type=\"Collection(Core.RevisionType)\">\n        <Annotation Term=\"Core.Description\" String=\"List of revisions of a model element\" />\n      </Term>\n      <ComplexType Name=\"RevisionType\">\n        <Property Name=\"Version\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"The schema version with which this revision was first published\" />\n        </Property>\n        <Property Name=\"Kind\" Type=\"Core.RevisionKind\">\n          <Annotation Term=\"Core.Description\" String=\"The kind of revision\" />\n        </Property>\n        <Property Name=\"Description\" Type=\"Edm.String\">\n          <Annotation Term=\"Core.Description\" String=\"Text describing the reason for the revision\" />\n        </Property>\n      </ComplexType>\n      <EnumType Name=\"RevisionKind\">\n        <Member Name=\"Added\">\n          <Annotation Term=\"Core.Description\" String=\"Model element was added\" />\n        </Member>\n        <Member Name=\"Modified\">\n          <Annotation Term=\"Core.Description\" String=\"Model element was modified\" />\n        </Member>\n        <Member Name=\"Deprecated\">\n          <Annotation Term=\"Core.Description\" String=\"Model element was deprecated\" />\n        </Member>\n      </EnumType>\n\nThis new term replaces the term Core.Deprecated proposed in [ODATA-1037](https://issues.oasis-open.org/browse/ODATA-1037).\n\nImported from [ODATA-1058](https://issues.oasis-open.org/browse/ODATA-1058)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add path segment /$each",
    "body": "As of 4.01 we support PATCH to a collection of entities. The PATCH is either interpreted as a set operation (if the payload is a single entity) or applied as a delta payload (if the payload has a context URL of #$delta.\n\nRather than distinguishing on payload, what if we said that PATCH to a collection of entities is always interpreted as an operation on the set as a whole, and a new path segment /$each is used for an atomic operation on each of the entities, especially DELETE, and PATCH with a single-instance payload.\n\n### Proposal\n\nAdd path segment /$each to apply an operation on each item of a collection, executed all-or-nothing atomically:\n\nDELETE Orders/$filter=@f/$each?@f=Age gt 3\nPATCH Orders/$each - with single payload\nPATCH Orders - with delta payload\nPOST Orders/$filter=@f/$each/Some.SingleAction?@f=Age gt 2 - binding parameter is single order\nPOST Orders/$filter=@f/Some.CollectionAction?@f=Age gt 2 - binding parameter is collection of orders\n\nImported from [ODATA-1057](https://issues.oasis-open.org/browse/ODATA-1057)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Key-as-Segment with Referential Constraints",
    "body": "Part 2 section 4.3.3 allows omitting key values that are implicitly specified by referential constraints to key values provided in previous path segments:\n\nhttps://host/service/Orders(1)/Items(OrderID=1,ItemNo=2)\nhttps://host/service/Orders(1)/Items(2)\n\nThe shorter form is preferred for parentheses-key syntax, and both are allowed.\n\nWe cannot give that choice for key-as-segment style because the number and order of path segments must be deterministic, so it is either\n\nhttps://host/service/Orders/1/Items/1/2\n\nor\n\nhttps://host/service/Orders/1/Items/2\n\nShorter is better, so it must be the second.\n\n### Proposal\n\nRequire for key-as-segment that \"redundant\" key segments MUST NOT be specified, i.e. \n\nhttps://host/service/Orders/1/Items/2\n\nfor the example where the order id in Items is tied to the order id in Orders  via referential constraint.\n\nImported from [ODATA-1056](https://issues.oasis-open.org/browse/ODATA-1056)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "DeepInsertSupport: allow applying to entity sets and collection-valued navigation properties",
    "body": "Some APIs support deep insert only on some entity sets, not on all of them. Currently DeepInsertSupport only applies to the entity container, and the descriptions reflect that scope.\n\n### Proposal\n\nAdd \"EntitySet\" and \"Collection\" to list of model elements in AppliesTo attribute and rephrase descriptions to match this generalization.\n\nImported from [ODATA-1055](https://issues.oasis-open.org/browse/ODATA-1055)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Part 1 Protocol: Add recommendations for Vary header",
    "body": "If the returned representation is influenced by presence or absence of a preference, the server SHOULD (actually MUST) send a Vary:Prefer or Vary:* response header to avoid caching problems.\n\n### Proposal\n\nAdd section on Vary response header, citing https://tools.ietf.org/html/rfc7231#section-7.1.4 and possibly https://tools.ietf.org/html/rfc7240\n\nAdd recommendation to send Vary:Prefer to all sections on preferences whose presence or absence influences the returned representation: return, omit-values, ...\n\nImported from [ODATA-1054](https://issues.oasis-open.org/browse/ODATA-1054)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "URL conventions document should have non-normative examples if primitive value syntax",
    "body": "Having a table of non-normative examples of primitive value syntax would assist client developers (especially those not using frameworks such as query builder apis) in creating correct requests.\n\n\n\n### Proposal\n\nAdd a table of non-normative examples of primitive value syntax.\n\n\nImported from [ODATA-1053](https://issues.oasis-open.org/browse/ODATA-1053)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Further simplify JSON Batch Format",
    "body": "In OData-1046 we approved addition of a JSON-format for Batch requests and responses.\n\nIn the discussion we considered a format that included groups of requests as top-level JSON objects with common batch options.\n\nWe can simplify this proposal by removing this outer grouping and allowing the individual requests to specify that they are part of a particular atomicityGroup. By adding additional semantics (members of an atomicityGroup must be adjacent in a request) we can simplify construction and processing of a batch request.\n\nExample batch request:\n\nPOST /v1.0/$batch HTTP/1.1  \n{\n  requests: [\n    {\n      id: \"1\",\n      atomicityGroup: \"atom1\",\n      method: \"post\",\n      url: \"/users\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: {\n        displayName: \"John Smith\",\n        userPrincipalName: \"jsmith@contoso.com\"\n      }\n    },\n    {\n      id: \"2\",\n      atomicityGroup: \"atom1\",\n      dependsOn: [\"1\"],\n      method: \"put\",\n      url: \"$1/photo\",\n      headers: {\n        Content-Type: \"image/jpeg\"\n      },\n      body: \"FRwvAAIAAAANAA4AFAAhAPNTUAAAAAAAAAAAAAAQUAAAAAAADHrQX+\"\n    },\n    {\n      id: \"3\",\n      method: \"get\",\n      url: \"/groups?top=10\",\n      headers: {\n        Accept: \"application/atom+xml\",\n      }\n    },\n    {\n      id: \"4\",\n      dependsOn: [\"atom1\"],\n      method: \"get\",\n      url: \"$1/thumbnail\",\n      headers: {\n        Accept: \"image/jpeg\"\n      }\n    }\n  ]\n}\n\n\n{\n  responses: [\n    {\n      id: \"1\",\n      status: 201,\n      headers: {\n        Location: \"/users/jsmith\"\n      }\n    },\n    {\n      id: \"2\",\n      status: 204\n    },\n    {\n      id: \"3\",\n      status: 406,\n      error: {\n        message: \"Atom Format not supported\"\n    },\n    {\n      id: \"4\",\n      status: 200,\n      headers: {\n        Content-Type: \"image/jpeg\"\n      },\n      body: \"FRwvAAIAAAANAA4AFAAhAPNTUAAAAAAAAAAAAAAQUAAAAAAADHrQX+\"\n    },\n  }\n}\n\n### Proposal\n\nRemove the outer object wrapper in the proposed JSON batch format.  Add an \"atomicityGroup\" property; all requests that have the same value for atomicityGroup are processed as an atomic unit.  Members with the same atomicityGroup must be adjacent in a request payload. dependsOn can reference an individual request that is not within an atomicityGroup, or the identifier for the atomicityGroup if the request is within an atomicityGroup.\n\nSupport server-driven paging in this format.\n\nFor an async batch response, the nextLink can return 202 with a location header and retry after.\n\n\nImported from [ODATA-1051](https://issues.oasis-open.org/browse/ODATA-1051)",
    "labels": [
      "JSON Format",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Change sets: do not require the same content type for all request in a change set",
    "body": "The section on Change Sets currently states:\n\nEach body part representing an operation in the change set MUST include the same Content-Type header value. \n\nThis does not work for creating media resources and modifying the auto-created media entity, or for creating an entity and then updating its stream properties. \n\n### Proposal\n\nRemove this sentence.\n\nImported from [ODATA-1050](https://issues.oasis-open.org/browse/ODATA-1050)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Content referencing in batch requests",
    "body": "If a data modification is implemented as an action, a subsequent GET request may need to use values from the action response body as parameters for a filter.\n\n### Proposal\n\nAllow referencing values from response bodies in subsequent requests\n- in $filter\n- in request bodies of subsequent modification requests\n\nValue references use JSON Pointer syntax to address parts of the response body, e,g.\n\n$filter=City eq $42/Addresses/3/City\n\nPoint out that content-id value must not collide with $root or any other $ literal valid in expressions\n\nImported from [ODATA-1049](https://issues.oasis-open.org/browse/ODATA-1049)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify server-driven paging requirement",
    "body": "Why is server-driven paging a MUST for minimal conformance? It's more of a self-defense mechanism and not needed for services with modest amounts of data.\n\n### Proposal\n\nClarify: if a service returns a partial result it MUST include a nextlink as per section 11.2.5.7.\n\nImported from [ODATA-1048](https://issues.oasis-open.org/browse/ODATA-1048)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rename $IsCollection to $Collection",
    "body": "[ODATA-879](https://issues.oasis-open.org/browse/ODATA-879) proposes to allow arrays of arrays using a syntax Type=\"Collection(...Collection(...)...)\" in CSDL XML.\n\nThe current Boolean member $IsCollection wouldn't be able to cover this.\n\n### Proposal\n\nRename $IsCollection to $Collection. Keep it Boolean for now, and switch to / additionally allow positive integer values once [ODATA-879](https://issues.oasis-open.org/browse/ODATA-879) is approved.\n\nNote: for JavaScript 1 is as true as true.\n\nImported from [ODATA-1047](https://issues.oasis-open.org/browse/ODATA-1047)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add JSON format for Batch",
    "body": "Our batch request and response format today is multipart/mime.  We've had a lot of pushback from the beginning that this format is difficult to construct and parse; there are no off-the shelf tools or libraries for doing so.\n\nNow that we have a JSON format for CSDL, a JSON client no longer needs an XML parser to read CSDL, but they still have no way of expressing or consuming a batch without parsing the difficult to understand/complex multi-part mime.\n\n### Proposal\n\nAdd a new section to the JSON format document describing a JSON batch request and response format as presented 2017-3-9.\nMove multipart/mime-specific text to the last subsection of 11.7, and refer to JSON Format for an alternative JSON Batch format.\n\nSee [ODATA-1051](https://issues.oasis-open.org/browse/ODATA-1051) for the refined proposal\n\nImported from [ODATA-1046](https://issues.oasis-open.org/browse/ODATA-1046)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Disallow propagation of Accept header on batch requests to individual requests within the batch",
    "body": "Section 8.2.1 Header Accept states (new text in 4.01, not present in 4.0):\n\nIf the Accept header is specified on an individual request within a batch, then it specifies the acceptable formats for that individual request. Requests within a batch that don’t include the Accept header inherit the acceptable formats of the overall batch request.\n\nThis would cause problems for batch requests specifying Accept:application/json with the intention of a \"default\" for the individual responses once we add a JSON Batch format. Services would not be able to respond with the JSON Batch format if they formerly treated this as a default for the individual requests\n\n### Proposal\n\nRemove the second sentence in the next draft of V4.01\n\nImported from [ODATA-1045](https://issues.oasis-open.org/browse/ODATA-1045)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Require aliases for schemas and require alias-qualified names",
    "body": "To simplify lookup of qualified names the CSDL JSON representation initially required namespace-qualified names. This got some pushback as namespaces are typically long to be unique and alias-qualified names are more readable, so aliases were re-introduced.\n\nWhy not require aliases and alias-qualified names in CSDL JSON documents to further increase readability by avoiding the arbitrary mix of namespace- and alias-qualified names.\n\n### Proposal\n\nDocuments SHOULD define aliases for schemas.\nIf an alias is defined for a schema, it MUST be used in qualified names.\n\nImported from [ODATA-1044](https://issues.oasis-open.org/browse/ODATA-1044)",
    "labels": [
      "CSDL JSON",
      "V4.01_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify purpose of context URL",
    "body": "1) Chapter 10 states: The context URL describes the content of the payload. It consists of the canonical metadata document URL and a fragment *identifying the relevant portion of the metadata document.*\n\nThis is somewhat violated by context urls using the template variable {entity} whose value is the canonical URL of an entity, including its key values - the key values aren't needed to identify the relevant portion of the metadata document, for this purpose the type is sufficient.\n\n2) Chapter 10 states: Request payloads generally do not require context URLs as the type of the payload can generally be determined from the request URL.\n\nCan we have the same for response payloads? Most responses for requests to entity sets or singletons using canonical URLs would not need a context URL, same for navigation paths with a navigation property binding. Instances with a type derived from the declared type carry the @odata.type annotation, so even those don't need a context URL. Same for responses to actions/functions with an EntitySetPath, or action/function imports with a an EntitySet.\n\n### Proposal\n\nState in chapter 10 that one purpose of the context URL is to make responses \"self-contained\" and allow the client to e.g. construct navigation links for selected navigation properties.\n\nOtherwise no action, and no relaxation of the context URL patterns.\n\nImported from [ODATA-1043](https://issues.oasis-open.org/browse/ODATA-1043)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Cast annotation expression and Unicode facet",
    "body": "Can cast expressions (and the URL cast() function) cast Unicode strings to non-Unicode strings and vice versa?\n\n\n### Proposal\n\nCasting ASCII to Unicode always succeeds.\n\nCasting Unicode to ASCII only succeeds for string values with characters limited to the ASCII character set.\n\nImported from [ODATA-1042](https://issues.oasis-open.org/browse/ODATA-1042)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CSD01",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Broaden definitions of transformations topcount and bottomcount",
    "body": "Definitions in section 3.2 and 3.6 state that the second parameter must result in a primitive numeric value. This is too restrictive, actually it is only required that there is a total ordering on these values.\n\nConsider, for example, getting the latest stock by product: $apply=groupby((Product),topcount(1,Date))\n\n\n### Proposal\n\nReplace current definitions by \"[...] and MUST result in values of a primitive type whose values are totally ordered.\".\n\nImported from [ODATA-1041](https://issues.oasis-open.org/browse/ODATA-1041)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarification of term \"expression\"",
    "body": "At some places, the document refers to expressions without specifying their kind. \n\nAffects sections 3.1.2, 3.1.4, 3.2 - 3.7 (re: second parameter)\n\n\n### Proposal\n\nIn section 2.1\n1) add a definition of expressions: is a common expression from the ABNF\n2) aggregatable primitive type is a primitive type other than geo or stream\n3) add a definition of an aggregatable expression is a value of an aggregatable primitive type\n\nImported from [ODATA-1040](https://issues.oasis-open.org/browse/ODATA-1040)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Relax constraints on namespace names",
    "body": "Currently a namespace has to consist of several dot-separated segments, and each segment has to be a SimpleIdentifier (essentially a JavaScipt/Java/Swift/C# variable name).\n\nWe could relax this and allow - at least for the second, third, ... segment, additional characters, most prominently the dash (-), and allow to have purely numeric segments, e.g. Some.Namespace.3.1.4 to allow for semantic versioning of namespaces.\n\n### Proposal\n\n- Allow purely numeric segments after the first segment. First segment still needs to start with with a letter\n- Allow dash in all segments (except as first character in first segment)\n\nImported from [ODATA-1039](https://issues.oasis-open.org/browse/ODATA-1039)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify term \"simple value\"",
    "body": "The term \"simple value\" is used several times in the document, but lacks a definition.\n\n### Proposal\n\nThe intended meaning of \"simple value\" is \"value of aggregatable primitive type\" where aggregatable primitive type is defined in [ODATA-1040](https://issues.oasis-open.org/browse/ODATA-1040). \n\nReplace all occurrencies in the document:\n- section 3.1, Transformation aggregate:  second para and last para\n- section 3.14 Transformationm compute: second para\n\n\nImported from [ODATA-1038](https://issues.oasis-open.org/browse/ODATA-1038)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add tagging term Core.Deprecated to mark deprecated model elements",
    "body": "Our model versioning rules only allow adding optional model elements, they don't allow removing model elements.\n\nOne way to deal with this is to leave outdated model elements in a service and just mark them as \"deprecated\".\n\n### Proposal\n\nDo not add new Core term\n\n      <Term Name=\"Deprecated\" Type=\"Core.Tag\" DefaultValue=\"true\">\n        <Annotation Term=\"Core.Description\" String=\"Model elements annotated with this term are deprecated and should no longer be used. They may be removed in a future version of the service.\" />\n      </Term>\n\nInstead close this as a duplicate (subset) of [ODATA-1058](https://issues.oasis-open.org/browse/ODATA-1058)\n\nImported from [ODATA-1037](https://issues.oasis-open.org/browse/ODATA-1037)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02",
      "duplicate"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "10.7/8: Simplify context URL for \"all operations in schema\"",
    "body": "The context URL for a structured instance or collection of structured instances mirrors the $select query option used to request that representation. It already supports the * operator to express \"all structural properties\". It currently lacks the namespace.* operator to express \"all actions and functions from a certain namespace\".\n\nAdding this would drastically reduce the size of the context URL, especially if using an alias instead of the fully qualified namespace.\n\nTypical use would be self.* with \"self\" being the alias for the service's namespace (note: \"self\" is just an example, not even a convention).\n\n\n### Proposal\n\nExtend the context URL pattern {select-list} to also support the $select pattern \n\n    allOperationsInSchema = namespace \".\" STAR   \n\ne.g. Model2.* to include all operations from namespace/alias Model2\n\nImported from [ODATA-1036](https://issues.oasis-open.org/browse/ODATA-1036)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "10.13: Simplify context URL for Property Value",
    "body": "The context URL for a property value contains the keys of the entity. \nThis seems overly specific as the context URL is a pointer to structural metadata, so why should it vary from entity to structurally identical entity?\nNote that the context URL for an entity does not contain the key, nor is it required that the key properties are always present in the response.\n\n### Proposal\n\nAllow the context URL pattern\n\n    {context-url}#{type-name}{select-list}\n\nalso for property values.\n\nIf something more specific is desired, the pattern could be\n\n    {context-url}#{entity-set}/{property-path}{select-list}\n\nImported from [ODATA-1035](https://issues.oasis-open.org/browse/ODATA-1035)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support the notion of a collection of name/value pairs where the type of the value is known",
    "body": "There is currently no easy way (read: without specifying an additional wrapper entity type) of specifying a, what most people would likely refer to as a, dictionary, or a collection of name/value pair, in which I can specify the type of the values!\n\nSo where we would need to do something today like:\n\n      <EntityType Name=\"ValueType\">\n        <Key>\n          <PropertyRef Name=\"Key\"/>\n        </Key>\n        <Property Name=\"Key\" Type=\"Edm.String\" Nullable=\"false\"/>\n        <Property Name=\"PropA\" ... />\n        ...\n      </EntityType>\n\n      <EntityType Name=\"ValueTypeDictionaryWrapper\">\n        <Key>\n          <PropertyRef Name=\"Name\"/>\n        </Key>\n        <Property Name=\"Name\" Type=\"Edm.String\" Nullable=\"false\"/>\n        <NavigationProperty Name=\"Value\" Type=\"ns.ValueType\" Nullable=\"false\"/>\n      </EntityType>\n\n      <AnyStructuredType Name=\"ValueTypeDictionaryContainer\">\n        ...\n        <NavigationProperty Name=\"Values\" Type=\"Collection(ns.ValueTypeDictionaryWrapper)\" Nullable=\"false\"/>\n        ...\n      </AnyStructuredType>\n\nNote that the wrapper has to be an entity type to be able to use the name (key) to index into the 'dictionary'. This is even a bit weirder if what we are putting in the dictionary is actually complex types that one would want to treat just like a collection of that complex type.\n\nThe payload would look something like this:\n\n    {\n      \"@odata.context\": \"$metadata#AnyStructuredType(Values(Value))/$entity\",\n      ...,\n      \"Values\": [{\n        \"Name\": \"foo\",\n        \"Value\": {\n          \"Key\": \"38hfgs8\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        \"Name\": \"bar\",\n        \"Value\": {\n          \"Key\": \"f93d8r3\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        ...\n      }],\n      ...\n    }\n\nNeedless to say that this JSON representation of an, expanded, payload doesn't look like what a typical JSON consumer would expect and it requiring the wrapped value to be expanded as well..\n\nSo what I'm looking at being able to do is, using the same example, do something like:\n\n      <EntityType Name=\"ValueType\">\n        <Key>\n          <PropertyRef Name=\"Key\"/>\n        </Key>\n        <Property Name=\"Key\" Type=\"Edm.String\" Nullable=\"false\"/>\n        <Property Name=\"PropA\" ... />\n        ...\n      </EntityType>\n\n      <AnyStructuredType Name=\"ValueTypeDictionaryContainer\">\n        ...\n        <NavigationProperty Name=\"Values\" Type=\"Dictionary(ns.ValueTypeDictionaryWrapper)\" Nullable=\"false\"/>\n        ...\n      </AnyStructuredType>\n\nAnd the resulting JSON payload for requests would look something like:\n\n    {\n      \"@odata.context\": \"$metadata#AnyStructuredType(Values)/$entity\",\n      ...,\n      \"Values\": {\n        \"foo\": {\n          \"Key\": \"38hfgs8\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        \"bar\": {\n          \"Key\": \"f93d8r3\",\n          \"PropA\": \"APropA_value\",\n          ...\n        },\n        ...\n      },\n      ...\n    }\n\nNote the more intuitive typical JSON response and that we don't need to expand the value in the wrapper any longer. \n\n### Proposal\n\n1) Define a complex type \"Dictionary\" in OData.Core as an open complex type with no properties.\n2) Define a Validation term \"OpenPropertyTypeConstraint\" whose value is a collection of qualified type names. It can be applied to an open entity or complex type definition and constrains open properties of that type to the specified values.\n3) Define a Validation term \"DerivedTypeConstraint\" whose value is a collection of qualified type names. It can be added to a property (or TypeDefinition) to constrain the derived types of that property. If a specified type is not a derived type of the property to which it is applied then it is ignored.\n\nImported from [ODATA-1034](https://issues.oasis-open.org/browse/ODATA-1034)",
    "labels": [
      "Vocabularies",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Interoperability issue when using escaped slash/backslash in URLs",
    "body": "We have encountered issues with Tomcat servers handling %-encoded slashes (and backslashes) in URLs. In particular, even when getting URL using HttpServletRequest.getRequestURI (which shouldn't do URL decoding) a percent-encoded backslash (e.g. in a quoted string within the URL) will appear in the result of getRequestURI as a forward slash.\n\nNow Tomcat apparently offers an option to permit this, but...\n\nAccording to http://stackoverflow.com/questions/9719224/coding-forward-and-backward-slashes-in-tomcat-7\n\n*Do not enable non-standard parsing of the URI. Disabled by default, but still in the application for backwards compatibility reasons are two system properties, org.apache.catalina.connector.CoyoteAdapter.ALLOW_BACKSLASH and org.apache.tomcat.util.buf.UDecoder.ALLOW_ENCODED_SLASH, that allow non-standard parsing of the URI. These properties significantly improve your chances of a directory traversal attack and are therefore strongly recommended to avoid using.*\n\nIf correct handling of URLs requires the use of web server configurations that are strongly recommended against for security reasons, we might want to consider what recommendations/accommodations should be made in the OData specification to ensure end-to-end interoperability of strings containing 'special' characters.\n\n\n### Proposal\n\nWe already have an implicit cast rule: \"Primitive types are cast to Edm.String or a type definition based on it by using the literal representation used in payloads\". This means that binary literals are cast to strings containing the base64url-encoded value.\n\nAlternative proposal: both problematic components (Tomcat, .NET client) can deal with plain-text or percent-encoded forward- and backslashes if they appear in the query part of the URL.\n\nThis means parameter aliases are sufficient to defer problematic key values to the query part of the URL.\n\nServices that support forward-slash in key values MUST support passing key values as parameters. \n\nPut this issue on \"Implementing OData\" to add a recommendation for clients and servers on \"problematic\" infrastructures.\n\n----------------------------------------------------------------\nOld, inapplicable proposal:\n\nAdd an implicit cast rule that allows binary values in place of string values, where the base64url-encoded binary is the UTF-8 representation of the string value: \n\nGET Categories(binary'Q29tZWR5L011c2ljYWw=')\n\nServices are required to support an implicit cast from binary to string (anywhere). Clients are advised to use this form when passing a string value containing a forwardslash, backslash, and a null character (%5C,  %2F, %00)\n\nImported from [ODATA-1033](https://issues.oasis-open.org/browse/ODATA-1033)",
    "labels": [
      "Protocol",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define comparison for numeric value exceptions",
    "body": "We describe comparison operations with null, but not with NaN, -INF and INF.\n\nFor NaN IEEE754, says that NaN is unordered and not equal to itself, meaning that NaN compared to anything, including NaN, is false except for != which is true.\n\nThis makes sense mathematically; however, this makes it very hard to find all resources with a property value of NaN (we would have to add a separate IsNaN() operator, and comparisons would have to account for this in their expressions).  We could say that NaN==NaN, similar to how we say Null==Null to make it easier to search for Null values.\n\nFor INF, -INF, IEEE754 appears to define INF==INF and -INF==-INF, so we would have:\nINF == INF: True\nINF != INF: False\nINF < INF: False\nINF <= INF: True\nINF > INF: False\nINF >= INF: True\nINF < <valid number>: False\nINF <= <valid number>: False\nINF > <valid number: True\nINF >= <valid number>: True\nINF > -INF: True\n-INF == -INF: True\n-INF != -INF: False\n-INF < -INF: False\n-INF <= -INF: True\n-INF > -INF: False\n-INF >= -INF: Tru\n-INF < <valid number>: True\n-INF <= <valid number>: True\n-INF > <valid number>: False\n-INF >= <valid number>: False\n-INF > INF: False\n\n\n### Proposal\n\nAccept the IEEE754 rules for INF, -INF, as described below, as well as the IEEE754 rules for NaaN (unordered and not equal to anything)\n\nImported from [ODATA-1032](https://issues.oasis-open.org/browse/ODATA-1032)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define term for links to related information",
    "body": "Define term for links to related information, e.g. \"latest-version\" or similar.\nSources of inspiration: the <atom:link> element and the Link HTTP header.\n\n### Proposal\n\nDefine new Core term:\n\n      <Term Name=\"Links\" Type=\"Collection(Core.Link)\">\n        <Annotation Term=\"Core.Description\" String=\"Link to related information\" />\n        <Annotation Term=\"Core.LongDescription\"\n          String=\"The Link term is inspired by the `atom:Link` element, see [RFC4287](https://tools.ietf.org/html/rfc4287#section-4.2.7) and the `Link` HTTP header, see [RFC5988](https://tools.ietf.org/html/rfc5988)\" />\n      </Term>\n      <ComplexType Name=\"Link\">\n        <Property Name=\"rel\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.Description\"\n            String=\"Link relation type, see [IANA Link Relations](http://www.iana.org/assignments/link-relations/link-relations.xhtml)\" />\n        </Property>\n        <Property Name=\"href\" Type=\"Edm.String\" Nullable=\"false\">\n          <Annotation Term=\"Core.IsURL\" />\n          <Annotation Term=\"Core.Description\" String=\"URL of related information\" />\n        </Property>\n      </ComplexType>\n\n      <!-- Example -->\n      <Annotation Term=\"Core.Links\">\n        <Collection>\n            <Record>\n              <PropertyValue Property=\"rel\" String=\"latest-version\" />\n              <PropertyValue Property=\"href\"\n                 String=\"https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml\" />\n           </Record>\n        </Collection>\n      </Annotation>\n\n\nImported from [ODATA-1031](https://issues.oasis-open.org/browse/ODATA-1031)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider support of NavigationPropertyBindings to non-contained nav props",
    "body": "NavigationPropertyBindings are used to identify the set in which members of a navigation property are *defined*.  The target set can be an entity set or an instance of a containment navigation property.\n\nThere are cases where it is interesting to specify that members of a navigation property are *members of* another navigation property that may not necessarily be where they are defined.\n\nFor example, if I have a customer with navigation properties \"AllOrders\", \"OpenOrders\", and \"ClosedOrders\", it may be useful to define that members of \"OpenOrders\" and \"ClosedOrders\" are all members of the \"AllOrders\" navigation property, even though they are defined in an \"Orders\" entity set. \n\nNavigationPropertyBinding has the right syntax and semantics for this, if we relax the constraint that the target of the navigationpropertybinding must terminate on a *containment* navigation property.\n\nHowever, this may be mixing semantics of the existing NavigationPropertyBinding, which specifies the set in which an entity is defined, and a constraint that says members of one navigation property must be children of another navigation property, so perhaps we should instead define a NavigationPropertyConstraint that says instances are members of a related navigation property that may or may not be the one in which they are defined...\n\n### Proposal\n\nApply [ODATA-674](https://issues.oasis-open.org/browse/ODATA-674) as an annotation term in the Validation vocabulary \"ItemsOf\". The value of the ItemsOf annotation is a collection of complex types containing two path properties; \"path\" and \"target\". A path indicating the same navigation property can occur multiple times, appended with different cast segments, in which case the most specific path is applied. The target can be any collection-valued navigation property.  If the target is a containment navigation property then the constraint defines where the entity lives.\n\nImported from [ODATA-1030](https://issues.oasis-open.org/browse/ODATA-1030)",
    "labels": [
      "CSDL XML",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.1.10.2: clarify that all() is always true if applied to an empty collection",
    "body": "\n\n### Proposal\n\nall() applied to an empty collection always returns true.\nany() applied to an empty collection always returns false.\n\nSQL does it the same way.\n\nImported from [ODATA-1029](https://issues.oasis-open.org/browse/ODATA-1029)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "4.3.4 and 4.4: clarify resolution of relative URLs in system query option $id",
    "body": "4.3.4 Resolving an Entity-Id states that \n\nThe entity-id may be expressed as an absolute IRI or relative to the service root URL.\n\nExample 23: request the entity representation for an entity-id\nhttp://host/service/$entity?$id=Products(0)\n\n\nThis was correct until we introduced type-cast segments after $entity with [ODATA-528](https://issues.oasis-open.org/browse/ODATA-528). \n\nNow relative URLs should rather be relative to the request URL, as in all other places, especially in \n\n\n4.4 Addressing References between Entities\n\nThe entity-id specified by $id may be expressed absolute or relative to the request URL.\n\n\n### Proposal\n\nClarify that relative URLs passed with query option $id are relative to the path to be consistent with $ref.\n\nImported from [ODATA-1028](https://issues.oasis-open.org/browse/ODATA-1028)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support instance annotations in $orderby",
    "body": "In OData-933 we added the ability to use annotations in $filter. Early feedback suggests this would also be useful in $orderby.  Seems reasonable...\n\n### Proposal\n\nSupport use of instance annotations in $orderby, just as we do in $filter.\n\nImported from [ODATA-1027](https://issues.oasis-open.org/browse/ODATA-1027)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify when $it is required",
    "body": "The description of $it says it CAN be used in a number of cases (see section 5.1.11.4 in the URL conventions document) but it isn't specific about when $it MUST be used.  We should clarify when $it is required.  For example, my understanding is that both of these queries are equivalent (in which case the $it is not required):\n\nhttp://host/service/Customers?$filter=Orders/any(d:d/Quantity ge Age)\nvs.\nhttp://host/service/Customers?$filter=Orders/any(d:d/Quantity ge $it/Age)\n\nHowever, my understanding is that in the case below the $it is required:\n\nhttp://host/service/Customers?$expand=Orders($filter=$it/Address/City eq ShipTo/City)\n\nImported from [ODATA-1026](https://issues.oasis-open.org/browse/ODATA-1026)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Treatment of same query option in multiple \"spellings\"",
    "body": "V4.01 allows to omit the $ prefix for system query options and makes the query option name case-insensitive.\n\nHow should servers react if a request contains e.g. $top=5&Top=10\n\nShould the request be rejected as the same (logical) query option appears twice, or should it succeed and $top is preferred over Top?\n\nWhat if it contains top=5&TOP=10?\n\n### Proposal\n\nIn Section 5.1, System Query Options], of URL Conventions, change:\n\n \"The same system query option MUST NOT be specified more than once for any resource.\" \n\nto:\n\n\"The same system query option, irrespective of casing or whether or not it is prefixed with \"$\", MUST NOT be specified more than once for any resource.\" \n\n\nImported from [ODATA-1025](https://issues.oasis-open.org/browse/ODATA-1025)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "5.1.1.5.7 substring: explicitly state that the index N (second parameter value) is zero-based",
    "body": "The zero-based indexing is only explicitly mentionen in section 5.1.1.5.4 indexof. It would be helpful to repeat this in section 5.1.1.5.7 substring.\n\nAlso add an \"e.g. Alfreds Futterkiste\" to the example, not all of our readers are familiar with the Northwind sample data set :-)\n\n### Proposal\n\nClarify that the index parameter to the substring function is zero-based.\n\nImported from [ODATA-1024](https://issues.oasis-open.org/browse/ODATA-1024)",
    "labels": [
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Provide stable anchors to all sections",
    "body": "Provide stable named anchors to all sections; the auto-generated _Toc anchors are not stable.\n\nInclude table of contents with full depth for all documents.\n\n### Proposal\n\nsee description\n\nImported from [ODATA-1023](https://issues.oasis-open.org/browse/ODATA-1023)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.01_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]