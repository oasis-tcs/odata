[
  {
    "title": "Clarifications for select-list in ContextUrl",
    "body": "The use of select-list is defined in prose in the Protocol document:\n\n{panel:title=10.8 Projected Entity}\nContext URL templates:\n```\n  {context-url}#{entity-set}{/type-name}{select-list}/$entity\n  {context-url}#{singleton}{select-list}\n  {context-url}#{type-name}{select-list}\n```\nIf a single entity contains a subset of properties, the parenthesized comma-separated list of the selected defined or dynamic properties, navigation properties, functions, and actions is appended to the entity-set after an optional type-cast segment and prior to appending /$entity. If the response is not bound to a single entity set, the select-list is instead appended to the {type-name} of the returned entity. \nThe shortcut * represents the list of all structural properties. Properties defined on types derived from the type of the entity set (or type specified in the type-cast segment if specified) are prefixed with the qualified name of the derived type as defined in [OData-ABNF]. *Note that expanded properties are implicitly selected*.\nOData 4.01 responses MAY use the shortcut pattern namespace.* to represent the list of all bound actions or functions available for entities in the collection, see system query option $select.\n{panel}\n\nWe go on to say:\n\n{panel:title=10.9 Collection of Expanded Entities}\nContext URL template:\n```\n  {context-url}#{entity-set}{/type-name}{select-list}\n  {context-url}#Collection({type-name}){select-list}\n``` \nFor a 4.01 response, if a navigation property is explicitly expanded, then in addition to any non-suffixed names of any selected properties, navigation properties, functions or actions, the comma-separated list of properties MUST include the name of the expanded property, suffixed with the parenthesized comma-separated list of any properties of the expanded navigation property that are selected or expanded. If the expanded navigation property does not contain a nested $select or $expand, then the expanded property is suffixed with empty parentheses. If the expansion is recursive for nested children, a plus sign is infixed between the navigation property name and the opening parenthesis. \nFor a 4.0 response, the expanded navigation property suffixed with parentheses MAY be omitted from the select-list if it does not contain a nested $select or $expand, but MUST still be present, without a suffix, if it is explicitly selected. \n{panel}\n\nQuestions:\n\n1) We should clarify that, if the contextUrl includes only expanded navigation properties (i.e., only navigation properties suffixed with parens), then implicitly the default set of properties is selected.  This is never spelled out, but is implied by our example 22:\n\n{panel:title=Example 22: resource URL and corresponding context URL}\nhttp://host/service/Employees(1)/Sales.Manager?\n                   $expand=DirectReports($select=FirstName,LastName;$levels=4)\nhttp://host/service/$metadata\n       #Employees/Sales.Manager(DirectReports+(FirstName,LastName))/$entity\n{panel}\n\nNote that, in this example, there is no $select applied to the top level entity (Employees(1)) implying that the default set of properties should be returned for the sales manager, which appears to be implied by the contextUrl only including the expanded properties.\n\n2) What do we mean by \"Note that expanded properties are implicitly selected.\"?  Does this mean that expanded properties are implicitly in the response, or does it mean that expanded properties also have their navigation link included?  In 4.01 we say that, in the contextUrl, the expanded navigation property must appear with open/close parens *in addition to* any selected or expanded navigation properties.  i.e., if it both selected and expanded, then it appears twice; once with, and once without, the parens.  If we read the first statement as \"also have their navigation link included\" then it seems unnecessary to represent the expanded navigation property in the contextUrl without the parens.\n\n3) Now that we have introduced select options, how do we represent select options within the contextUrl.  We already have a syntax for nested select, using path syntax:\n\n```\nselect         = ( \"$select\" / \"select\" ) EQ selectItem *( COMMA selectItem )\nselectItem     = STAR\n               / allOperationsInSchema \n               / [ ( qualifiedEntityTypeName / qualifiedComplexTypeName ) \"/\" ] \n                 ( selectProperty\n                 / qualifiedActionName  \n                 / qualifiedFunctionName  \n                 )\nselectProperty = primitiveProperty  \n               / primitiveColProperty [ OPEN selectOptionPC *( SEMI selectOptionPC ) CLOSE ]\n               / navigationProperty\n               / selectPath [ OPEN selectOption *( SEMI selectOption ) CLOSE\n                            / \"/\" selectProperty \n                            ]\n```\n\nThis is somewhat more verbose, but it would be breaking (and somewhat ambiguous between dynamic properties with select options and expanded dynamic nav props) to change it to use the parens syntax. But, what about nested expands within $select? \n\n4) We say that explicitly selected functions are also represented in the contextUrl. Should these be represented with, or without, parens?  \n\nLooking again at our ABNF, we see that qualifiedFunctionName is defined generally as:\n\n```\nqualifiedFunctionName = namespace \".\" function [ OPEN parameterNames CLOSE ]\n```\n\nwhich implies that you could include or omit the parens (we should pick one).\nIf we don't include the parens, then we can't differentiate between overloads.\nIf we do include the parens, then how can we differentiate between dynamic functions and dynamic expanded navigation properties?\n\n5) We say that the contextUrl for a collection of references (i.e., Customers/$ref) is #Collection($ref), and the contextUrl for a single reference (i.e., Orders(1)/Customer/$ref) is #$ref, but we don't say how an expanded reference (i.e., Customers?$expand=Orders/$ref) is represented in the contextUrl.  Note that defining new syntax for this (for example, Customers(Orders/$ref)) would be a breaking change.  Also, it's not really necessary to know about the $ref in order to interpret the results, understand metadata, or materialize missing information in a JSON minimal metadata format.  So there may be no need to represent it at all. \n\n\n### Proposal\n\nMake sure the following are clear in the documentation:\n1) If the contextUrl includes only expanded navigation properties (i.e., only navigation properties suffixed with parens), then all structural properties are implicitly selected (same as if there were no properties listed in the select-list)\n2)  In section 10.8, Projected Entity, change:\n\"Note that expanded properties are implicitly selected.\" to \"Note that expanded properties are automatically included in the response.\"\n3) Regardless of how contained structural properties are represented in the request URL (as paths or as select options) they are represented in the contextUrl using path syntax, as defined in 4.0. Similarly, expands nested within $select are represented the same as expands outside of $select.\n4) Operations in the ContextUrl should always be represented using the full namespace- or alias- qualified name, so if it has a dot it is an operation. Functions suffixed with parens represent a specific overload, while functions without parens represent all overloads of the function.\n5) Navigation properties with expanded references are not represented in the ContextUrl.  i.e., the contextUrl for Customers?$expand=Orders/$ref would just be $metadata#Customers.\n\nImported from [ODATA-1238](https://issues.oasis-open.org/browse/ODATA-1238)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "How to specify static result entity set for bound actions/functions?",
    "body": "Bound actions/functions that return a single entity or a collection of entities can specify the entity set of the returned entities relative to the binding parameter via the EntitySetPath attribute.\n\nHow to specify that the returned entities always belong to a statically known entity set that cannot be reached via navigation from the binding parameter type?\n\n### Proposal\n\nNo action.\n\nWe intentionally constructed bound functions/actions this way to make the function/action definition independent of the schema that defines the binding target.\n\nAlso we intentionally don't have references from Schema children to an Entity Container.\n\nModel designers are encouraged to add navigation paths that allow them specifying an EntitySetPath.\n\nImported from [ODATA-1237](https://issues.oasis-open.org/browse/ODATA-1237)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "What should be returned for inserted non-entity value?",
    "body": "In [ODATA-616](https://issues.oasis-open.org/browse/ODATA-616) we introduced the ability to post to a collection of non-entity types.  The new wording appears in [Section 11.4.9.4, Update a Collection Property, of Protocol](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#_Toc505771257):\n\n{panel}\nA successful POST request to the edit URL of a collection property adds an item to the collection. The body of the request MUST be a single item to be added to the collection. If the collection is ordered, the item is added to the end of the collection, and $index MAY be used to specify a zero-based ordinal position to insert the new value, with a negative value indicating an ordinal position from the end of the collection.\n{panel}\n\nAnd later, we say:\n{panel}\n    On success, the response MUST be a valid update response.\n{panel}\n\nHowever, we don't say *what* response code, or body, to return for this case.\n\nFor a created entity, we would typically return 201 Created and the newly created resource in the body, unless the return=minimal preference was applied, in which case we would return 204.  But 201 Created requires a Location header (and, in OData, an Entity-id header). So, if we return 201, what would we return for the location (and entity-id) headers?\n\nDoes it matter whether the collection is ordered (in which case we have a location for the added resource)?\n\nOr, perhaps we always return 204, no content (and no body)?\n\nOr do we view this as an update and return 200, along with the newly inserted value? Or 200 with the full collection? Or 200 with the entity containing (at least?) the populated collection?\n\n### Proposal\n\n1) We shouldn't have different behavior for ordered versus non-ordered collections.\n2) Inserting into a non-entity collection (in general) isn't creating a resource, so 201 is not appropriate, which resolves the issue of the location and entity-id headers.\n3) By default, we should return 204, no content (and no body)\n4) If we support the return=representation header, we should return the updated collection.\n\nImported from [ODATA-1236](https://issues.oasis-open.org/browse/ODATA-1236)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow relative URLs in headers",
    "body": "We currently mention the use of relative URLs in request and response payloads but do not mention anything about allows relative URLs in headers.  HTTP allows relative URLs in headers (for example, see [https://tools.ietf.org/html/rfc7231#section-7.1.2] ) so the OData standard should mention it as well.\n\n### Proposal\n\nAllow URLs relative to the request URL in headers.\n\nPoint this out in Part 1: Protocol, section 4.1\n\nImported from [ODATA-1234](https://issues.oasis-open.org/browse/ODATA-1234)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support Union types",
    "body": "Type inheritance implies polymorphism implies that a property may be any of type derived from the declared type. In some cases, a property may be able to be one of a discrete set of types.\n\nFor example, in the Schema.org schemas, many of the references can point to either a person or an organization.  Person and Organization may derive from a common type, but other types derived from that common base type are not allowed.\n\nThere are several possible approaches for representing such unions:\n1) Allow defining a discrete set of types for a property, that may or may not have a common base type, rather than a single type.\n2) Define a \"union\" type structure that is an open complex type with properties for each \"type\"\n3) Define an annotation that allows you to restrict the set of derived types of a property. The types must derive from the declared type of the property, which could be an abstract type (i.e., Edm.EntityType). \n\n\n### Proposal\n\nDerivedTypeConstraint already exists, just need to extend its use and clarify:\n\nProposal:\n\n1) Add \"EntitySet, Singleton, NavigationProperty, Function, Action, and Parameter to AppliesTo.\n\n2) Clarify in the description that types derived from allowed types are also allowed\n\nImported from [ODATA-1232](https://issues.oasis-open.org/browse/ODATA-1232)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove $Kind for entity container children",
    "body": "There is some redundancy for entity container chilldren, and inconsistency in not including $iscollection for an entityset.\n\n### Proposal\n\nRemove $Kind for entity container children.\n\nAction imports are identified by having a $Action member.\n\nFunction imports are identified by having a $Function member.\n\nEntity sets are identified by having a $Type member and a $Collection:true member.\n\nSingletons are identified by having a $Type member and no $Collection member (preferred) or a $Collection:false member (not recommended, omit instead).\n\nImported from [ODATA-1231](https://issues.oasis-open.org/browse/ODATA-1231)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "/$filter(...) segments in paths and expressions",
    "body": "\n\n### Proposal\n\nAdd /$filter(...) segment that can be used in commonExpr after a collection-valued property\n\nChange syntax of /$filter path segment to also use parentheses instead of an = sign\n\nThis introduces Nav/$filter(...)/$count as an alternative to Nav/$count($filter=...)\n\nSupport expression or parameter within parens.\n\n \n\nImported from [ODATA-1230](https://issues.oasis-open.org/browse/ODATA-1230)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce LocalDateTime TypeDef to apply to string datatype",
    "body": "One of our first actions as a Technical Committee was to remove the Edm.DateTime datatype in favor of Edm.DateTimeOffset. See [ODATA-11](https://issues.oasis-open.org/browse/ODATA-11).\n\nWhile there were good reasons for doing this, it has been a singularly unpopular decision, especially for services integrating with legacy systems that don't carry timezone information.\n\nIt would be a breaking change to add a new datatype in 4.x, would add complexity by expanding the set of data types (especially when all date/time values are serialized as string in JSON) and would encourage a particular anti-pattern (DateTime values without timezone).\n\nStill, we should listen to the continual feedback (for example, see [https://github.com/OData/WebApi/issues/136]) and provide a means of representing such values.\n\nToday, the fallback is to represent such values as strings, but the semantics of what the string represents, including use within a URL and client representation in a strongly typed language, are lost.\n\nA reasonable compromise would be to add a core vocabulary term that could be used to annotate a string as representing a \"LocalTime\" value. The format of the string would have to comply with the Date and Time portions of the existing Edm.DateTimeOffset data type. We could require services that use this annotation to support implicit conversions of such properties (and correctly formatted string literals?) to DateTimeOffset with UTC.\n\n### Proposal\n\n1) Introduce a new Core type annotation:\n```xml\n<TypeDefinition Name=\"LocalDateTime\" UnderlyingType=\"Edm.String\">\n  <Annotation Term=\"Description\" String=\"A string representing a Local DateTime value with no offset.\"/>\n   <Annotation Term=\"Validation.Pattern\" String=\"^[0-9]{4}-(0[1-9]](1[0-2))-(0[1-9]]([12)[0-9]](3[01))T([01][0-9]](2[0-3)):[0-5][0-9](:[0-5][0-9](\\\\.[0-9]+)?)?$\"/>\n</TypeDefinition>\n```\n2) Define the cast function to Edm.DateTimeOffset to allow a string representation of a datetime value with no offset; the result is the specified value as UTC.\n\nImported from [ODATA-1229](https://issues.oasis-open.org/browse/ODATA-1229)",
    "labels": [
      "URL Conventions",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support non-batch mechanism for long URLs",
    "body": "From the early days of OData we have had issues with requests exceeding the maximum URL length for servers.\n\nThe typical response has been to use $batch, which passes the request in the body.  However, using $batch is a bit overkill for this common scenario, and has several drawbacks:\n1) using $batch is non-intuitive and introduces extra complexity and concepts for executing a single request\n2) the /$batch request and response must both be wrapped, with things like headers, request verbs, and response codes hidden within the payload.\n3) the /$batch endpoint is at the root, which means that the request is not routed according the URL but the request body must be parsed in order to determine routing\n\nInstead of relying on batch, we can define a /$query segment that can be applied to a resource path.  Clients POST to the URL, providing the query string in the body. Any query options specified in the URL are combined with the query options specified in the body.\n\nThe format of the querystring in the body is an interesting discussion.  One option is to provide it as a simple string, which would be the most consistent with the existing query string.  Alternatively, we could provide a JSON payload of name/value pairs for each query string option. The two are not mutually exclusive; the client could indicate through the content-type header which format they are using (applicaiton/text versus application/xml).\n\nWe could also explore other structured representations of certain query options. For example, we could provide an AST representation of the $filter query option that could be simpler and more efficient to build and parse than serializing as a string. \n\nThe drawback to defining multiple formats is that services either need to support both, or clients need to check which format(s) are supported by the service.\n\n\n### Proposal\n\nDefine a /$query segment that can be appended to a resource. Clients make POST requests to this endpoint, with no query options specified, and a content-type of text/plain. The body of the request is a string following the syntax rules of the query portion of the URL, using the same percent-encoding rules.\n\nOpen a new issue to track defining an application/json representation of the payload that could include structured representations of things like $filter, $expand, $select, etc.\n\nImported from [ODATA-1228](https://issues.oasis-open.org/browse/ODATA-1228)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve description of filter expression restrictions",
    "body": "Filter expression restrictions define an allowed subset of filter expressions for a single property. We did not explicitly state that it is allowed to combine valid (restricted) expressions for different properties by \"and\".\n\n### Proposal\n\nChange description (green text is new)\n> These properties only allow a subset of filter expressions. {color:#008000}A valid filter expression for a single property can be enclosed in parentheses and combined by `and` with valid expressions for other filterable properties{color}.\n> \n\n\nImported from [ODATA-1227](https://issues.oasis-open.org/browse/ODATA-1227)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Ambiguity with Capabilities.ChangeTracking annotation",
    "body": "Suppose I have an entity type with 2 structural properties (A, B) and 2 navigation properties (C, D).\n\n \n\nThen I use :\n\n \n\n<Annotation Term=”Capabilities.ChangeTracking”>\n\n  <Record>\n\n    <PropertyValue Property=”FilterableProperties”/>\n\n      <Collection>\n\n        <PropertyPath>A</PropertyPath>\n\n      </Collection>\n\n    </Record>\n\n</Annotation>\n\n \n\nNow it is clear that A is filterable and B is not. But how is the client to interpret ExpandableProperties not being specified (defaults to an empty Collection(NavigationPropertyPath))?\n\n \n1. The server omitted these properties from the annotation because they (C, D) are *all* expandable.\n1. The server omitted these properties from the annotation because they (C, D) are *not* expandable.\n\n \n\nThe interpretation of an empty collection here is ambiguous.\n\n### Proposal\n\nRemove EntityContainer from the AppliesTo list. Part 1: Protocol only mentions this term for annotating entity sets.\n\nAdd a LongDescription to FilterableProperties and ExpandableProperties:\n> If no properties are specified or Filterable/ExpandableProperties is omitted, clients cannot assume support for filtering on/expanding any properties.\n> \n\n\nImported from [ODATA-1226](https://issues.oasis-open.org/browse/ODATA-1226)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Correct example 68",
    "body": "The result of example 68 does not match the description of the model function applied in the request. The function is supposed to return an extra entity with a single property holding the aggregated value of all entities not considered.\n\nIn the shown response, these entities contain also a property Product/Name = \"\\*\\*Other\\*\\*\", which is unexpected.\n\n### Proposal\n\nReplace with this response:\n{noformat}\n{\n  \"@odata.context\": \"$metadata#Sales(Customer(Country),Product(Name),Total)\",\n  \"value\": [\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"Netherlands\" },\n      \"Product\": { \"Name\": \"Paper\" }, \"Total\": 3 },\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"Netherlands\" },\n      \"Total\":  2 },\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"USA\" },\n      \"Product\": { \"Name\": \"Coffee\" }, \"Total\": 12 },\n    { \"@odata.id\": null, \"Customer\": { \"Country\": \"USA\" },\n      \"Total\": 5 }\n  ]\n}\n\n{noformat}\n\nImported from [ODATA-1225](https://issues.oasis-open.org/browse/ODATA-1225)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make [OData-]EntityId header optional if the same as Location header",
    "body": "On create and upsert request returning 204 No Content we currently MUST return an [OData-]EntityId header which, if following convention, always has the same value as the, always required, Location header.\n\n### Proposal\n\nMake the [OData-]EntityId header optional if it has the same value then the Location header.\n\nImported from [ODATA-1224](https://issues.oasis-open.org/browse/ODATA-1224)",
    "labels": [
      "Protocol",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add OData- prefix back to EntityId header",
    "body": "The following is feedback received from the IANA OData Header registration.  The summary of the feed back is that the EntityId and Isolation header names may be too generic\n\n \n\nSee also [https://protect-us.mimecast.com/s/6cHPCQWX4XfkDzX5iPE-q-?domain=mnot.net]\n\n \n\nFrom: *Ted Hardie* <[ted.ietf@gmail.com](mailto:ted.ietf@gmail.com)>\n Date: Wed, Aug 29, 2018 at 2:58 PM\n Subject: Re: [Ietf-message-headers] Registration request for EntityId, Isolation, OData-MaxVersion, and OData-Version\n To: Chet Ensign <[chet.ensign@oasis-open.org](mailto:chet.ensign@oasis-open.org)>\n Cc: [ietf-message-headers@ietf.org](mailto:ietf-message-headers@ietf.org), \"Mark Biamonte (Progress)\" <[Mark.Biamonte@progress.com](mailto:Mark.Biamonte@progress.com)>\n\nHi Chet,\n\n \n\nI'm a little confused on one point.  The Isolation header states that it was called OData-Isolation in version 4.0, but the linked ABNF document says:\n\n \n\nisolation  = [ \"OData-\" ] \"Isolation\" \":\" OWS \"snapshot\"\n\nThat seems to indicate that both ODate-Isolation and Isolation are expected to be valid for this token.  The ABNF for EntityID is similar:\n\n \n\nentityid   = [ \"OData-\" ] \"EntityID\" \":\" OWS IRI-in-header\n\n \n\nCan you clarify the intent here?  Are both expressions of this token expected to continue?\n\n \n\nIn general, \"Isolation\" seems to be a very general concept, and the reservation of it, unadorned, for a single token use (\"snapshot\") is somewhat surprising compared to the more-obviously scoped OData-isolation.  EntityID seems similar board in possible usage outside the OData specification. \n\n \n\nregards,\n\n \n\nTed Hardie\n\n \n\nHi Mark,\n\n \n\nOn Thu, Aug 30, 2018 at 6:49 PM, Mark Biamonte <[Mark.Biamonte@progress.com](mailto:Mark.Biamonte@progress.com)> wrote:\n\nHi Ted,\n\n \n\nI am a member of the OData Technical Committee (TC).  Chet submitted the request for OASIS on behalf of the OData TC.  You are correct, in OData 4.0 the Headers were titled OData-Isolation and OData-EntityID.  In the latest OData 4.01 spec the header name was changed to just Isolation and EntityID.  The OData- prefixed versions are still supported for backwards compatibility. \n\n \n\n[TH] Okay; I was probing to find out if this superseded the previous header, but it sounds like you expect both to be used at least during the compatibility period.\n\n \n\nThis change was made based on feedback for users and implementors of the OData standard.  I gather your preference would be that we use the OData-prefixed version for the registrations.  If so I will need to discuss that with the TC and get back to you.\n\n \n\n \n\n[TH] While that would be my personal preference, it is simply that:  my opinion as an individual.  I'm primarily concerned that other, unregistered or pre-registration uses of these more general concepts may occur.  While recording them in the registry will help avoid collisions, there is always some risk and the more general the term, the higher the risk.\n\n \n\nregards,\n\n \n\nTed Hardie\n\n> On 1 Sep 2018, at 2:54 am, Ted Hardie <[ted.ietf@gmail.com](mailto:ted.ietf@gmail.com)> wrote:\n > \n >> This change was made based on feedback for users and implementors of the OData standard. I gather your preference would be that we use the OData-prefixed version for the registrations. If so I will need to discuss that with the TC and get back to you.\n > \n > \n > While that would be my personal preference, it is simply that: my opinion as an individual. I'm primarily concerned that other, unregistered or pre-registration uses of these more general concepts may occur. While recording them in the registry will help avoid collisions, there is always some risk and the more general the term, the higher the risk.\n >\n\nSpeaking personally, I'd second that concern. It's least confusing when headers that are specific to an application (in this case, OData) include that application's name in their field name.\n\nCheers,\n\n–\n Mark Nottingham [https://www.mnot.net/](https://protect-us.mimecast.com/s/6cHPCQWX4XfkDzX5iPE-q-?domain=mnot.net)\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1223](https://issues.oasis-open.org/browse/ODATA-1223)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Validation: add terms MinItems and MaxItems",
    "body": "Add terms MinItems and MaxItems that apply to anything collection-valued and allows specifying the expected minimum and maximum number of items in the collection.\n\nSimilar to minimum and maximum this is along the lines of JSON Schema minItems and maxItems, see [https://tools.ietf.org/html/draft-handrews-json-schema-validation-01#section-6.4.3]\n\nImported from [ODATA-1222](https://issues.oasis-open.org/browse/ODATA-1222)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Apply, as much as possible, our JSON Format to our annotations as well",
    "body": "In [ODATA-1170](https://issues.oasis-open.org/browse/ODATA-1170) we added the ability to add the type to a term of an enum type.\n\nThe solution chosen was to annotate the predefined, one and only, $EnumMember property, which, by itself, does not add anything other then telling the consumer that he/she is dealing with the name of a member of an enum type, still requiring the $metadata document to find out what the actual enum type is.\n\nThat raises the question why one needs that object wrapper to begin with and why we, like with regular enum typed structured properties, don't simply use the same format and return the enum members name as a string value of that term. \n\nAnd if we do so for enum types why wouldn't we do that for all primitive types for which we introduced a similar wrapper object with one predefined $-property?\n\n \n\nSide question: Does our XML to JSON CSDL conversion correctly convert our annotations to begin with? I'd be tempted to say that enum properties IN complex types used in terms should use the standard JSON format and not the object wrapper with the $EnumMember property either not?\n\n### Proposal\n\nUse same representation for constant expressions as for primitive values in JSON format, i.e. no object wrapper such as\n```java\n\"@some.binary.term\":{\"$Binary\":\"...\" }\n```\nInstead use the plain value: \n```java\n\"@some.binary.term\":\"...\"\n```\nThis puts some burden on clients to \"know\" or look up the term definition to determine the actual type of a JSON string value, but that has to be done for JSON data responses anyway.\n\nNote that no way to distinguish between strings and data exception, datetime, guid values in a collection of Edm.PrimitiveType. In such a case, generic libraries should treat as string and clients must use out of band knowledge to interpret it as some other value.\n\nSame argument applies to model element path expressions: here the client knows from the term definition that the value is a model element path or one of its concreter sub-types, so the value can simply be a string containing the path without object wrapper:\n```\n\"NonExpandableProperties\":[\"Customer\",\"Country\"]\n```\nInstance path expressions still need the object wrapper to distinguish them from actual string values:\n```\n\"@Core.Description\":{\"$Path\",\"CompanyName\"}\n```\n \n\nImported from [ODATA-1221](https://issues.oasis-open.org/browse/ODATA-1221)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Instance annotations section only refers to the XML CSDL, not JSON CSDL",
    "body": "In our OData JSON format specification, chapter 20 Instance Annotations, we, only, refer to the XML CSDL. I think what we really are trying to say is that the annotations have to be defined in CSDL, irrespective of the format, and should find a way to express that here. \n\n### Proposal\n\nAdd/correct wording to express that annotations have to be defined in CSDL, irrespective of the format used.\n\nImported from [ODATA-1220](https://issues.oasis-open.org/browse/ODATA-1220)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Be more explicit about the purpose of $DefaultValue in a Term definition",
    "body": "It appears to be unclear what the purpose is of having a $DefaultValue for a term definition in our JSON CSDL as, as stated in the specification as is, in our JSON CSDL a value MUST always be specified anyway. And while a $DefaultValue might be obvious for some terms, most notably boolean typed terms (read: tags) where the values is typically true, and there maybe a value for some enum and numerically based terms, this is less so the case for any of the other types.\n\nThe reference to it being for documentation purposes raised different questions.\n\nOn the other hand, if a term is of a structured type, default values of the individual structural properties are indeed implied in absence of the property, which is not the case for terms not being applied to any model element it could have been applied to, which further would speak to not having a $DefaultValue in terms potentially causing confusion.\n\nOur XML CSDL however didn't require the value to be there, merely 'tagging' a model element with the annotation term would suffice, implying the DefaultValue specified in the XML CSDL. Therefore, arguably, the only remaining 'function' of this $DefaultValue is to allow for full fidelity round-tripping between our XML and JSON versions of the CSDL.\n\n### Proposal\n\nAt a minimum I think we should be extremely clear in our JSON CSDL specification that this full fidelity between multiple formats of our CSDL is the sole purpose of this $DefaultValue to exists and to not confuse it with $DefaultValue of properties that, when omitted, are presumed to be applied.\n\nImported from [ODATA-1219](https://issues.oasis-open.org/browse/ODATA-1219)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enhance hierarchy processing",
    "body": "Working with hierarchies often involves functionality to select sub-hierarchies, to retrieve hierarchy nodes in a specified tree order, and to aggregate bottom-up along the hierarchy paths.\n\n### Proposal\n\nOverview and examples: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/65934/Enhanced%20support%20for%20hierarchy%20use%20cases%20-%20Examples.pptx]\n\nContext, use cases and proposals for new transformations: [https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68535/Enhanced%20support%20for%20hierarchy%20use%20cases%20V1.6.4.1.docx](https://www.oasis-open.org/apps/org/workgroup/odata/download.php/68535/Enhanced%20support%20for%20hierarchy%20use%20cases%20V1.6.4.1.docx) (covers all feedback items from the review discussion)\n\n \n\nImported from [ODATA-1218](https://issues.oasis-open.org/browse/ODATA-1218)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clients should read symbolic values in CSDL case-insensitive",
    "body": "We currently define special symbolic values in CSDL for things like \"variable\" or \"floating\" scale, or \"max\" MaxLength.\n\nSome services return these using different casing than defined in the spec.  \n\n### Proposal\n\nServices SHOULD use lower case for symbolic values \"variable\" and \"floating\" for Scale, and \"max\" for MaxLength, as specified in the specification; clients SHOULD handle these symbolic values in a case-insensitive manner in order to be more robust.\n\nImported from [ODATA-1217](https://issues.oasis-open.org/browse/ODATA-1217)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Terms for POST/PATCH/PUT with system query options to shape response",
    "body": "Services need a way to advertise whether they support response-shaping system query options for certain operations.\n\n### Proposal\n\nRevised proposal from 2018-11-8. \n\nAdd ModificationQueryOptionsType\nAdd  ModificationQueryOptions as a top-level annotation term.\nAdd QueryOptions property to InsertRestrictions \nAdd QueryOptions property to UpdateRestrictions\n\nImported from [ODATA-1216](https://issues.oasis-open.org/browse/ODATA-1216)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify datatype of virtual property $count",
    "body": "In the Data Aggregation extension, the virtual property $count has type Edm.Decimal (http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/cs02/odata-data-aggregation-ext-v4.0-cs02.html#_Toc435016573). In contrast the JSON Format specification states that the result of the system query option has type Edm.Int64 (http://docs.oasis-open.org/odata/odata-json-format/v4.0/os/odata-json-format-v4.0-os.html#_Toc372793054).\n\nSince aggregation rather reduces the number of entities in a result collection, question is whether there is some unmentioned reason for this discrepancy.\n\n### Proposal\n\nIf no argument speaks for keeping Edm.Decimal, the proposal is to align both features by assigning Edm.Int64 also to the virutal property $count.\n\nImported from [ODATA-1215](https://issues.oasis-open.org/browse/ODATA-1215)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Address use of 201 Created for Create Link Requests",
    "body": "Section 9.1.2 Response Code 201 Created says that a 201 can be returned for a “Create Link” request which references section 11.4.6.  But all of section 11.4.6 says that successful responses MUST be 204.\n\n### Proposal\n\nRemove \"Create Link\" from section 9.1.2 meaning that only 204 No Content is a valid response status code.\n\nImported from [ODATA-1213](https://issues.oasis-open.org/browse/ODATA-1213)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Validation term for allowed terms in Annotation Paths ",
    "body": "Annotation paths allow referencing annotations.\n\nOften the referenced annotation has to have one of certain \"allowed\" terms that can be interpreted in that context.\n\nCurrently these \"allowed terms\" cannot be expressed in the term or property definition.\n\n### Proposal\n\nMention term Validation.AllowedTerms in CSDL sections 14.4.1.3 Annotation Path.\n\nAdd to Validation vocabulary:\n\n```xml\n<Term Name=\"AllowedTerms\" Type=\"Collection(Core.QualifiedTermName)\" AppliesTo=\"Term Property\">\n  <Annotation Term=\"Core.Description\"\n    String=\"Annotate a property or term of type AnnotationPath to restrict the terms that can be targeted by the path.\" />\n  <Annotation Term=\"Core.LongDescription\"\n    String=\"Annotation path expressions assigned to the annotated term or property are intended to resolve to annotations with one of the listed terms. For forward compatibility, clients should be prepared for the annotation to reference terms besides those listed.\" />\n  <Annotation Term=\"Core.RequiresType\" String=\"Edm.AnnotationPath\" />\n</Term>\n```\n\nAdd to Core vocabulary:\n```xml\n<TypeDefinition Name=\"QualifiedTermName\" UnderlyingType=\"Edm.String\">\n  <Annotation Term=\"Core.Description\" String=\"The qualified name of a term in scope.\" />\n</TypeDefinition>\n```\n\nImported from [ODATA-1212](https://issues.oasis-open.org/browse/ODATA-1212)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "4.2 and 5.1: Explicitly state that an alias MUST NOT be identical to any other alias or namespace in the same document.",
    "body": "This was decided in [ODATA-681](https://issues.oasis-open.org/browse/ODATA-681) but apparently didn't make it into the documents\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1211](https://issues.oasis-open.org/browse/ODATA-1211)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "CSDL ReturnType element needs to specify rules for Nullable and Collection with entity types",
    "body": "It is reasonable to assume:\n- A collection of entities never contains null because the “null entity” has no meaning.\n- A function returning a single entity would have to return 204 No Content to signal “no entity returned”, similar to following a single-valued navigation property with nothing associated at that point in time.\n\nTherefore:\n- A function returning entities behaves like a navigation property.\n- A function returning structured or primitive instances behaves like a structural property.\n\nIn regard to CSDL XML/JSON 4.01, we should specify:\n\nNullable should never be specified for a Collection(SomeEntityType), and it must always be considered to be false by default. This would bring consistency with navigation properties.\n\nGoing one step further, we should probably apply this reasoning to Parameter elements, i.e. a parameter of type Collection(SomeEntityType) should also never have an explicit Nullable facet.\n\nImported from [ODATA-1210](https://issues.oasis-open.org/browse/ODATA-1210)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Term for original OData version of (auto-)converted $metadata",
    "body": "We have several cases of generic clients that can interact with V2 and V4 services and internally only use V4 syntax and semantics. One aspect of this is that the client converts the V2 $metadata into V4 $metadata and needs to \"remember\" whether the original protocol version - and the one to use for URL generation and payload serialization is something else than V4.\n\n### Proposal\n\nAdd term Core.OriginalProtocolVersion with allowed values \"2.0\". \"3.0\", and \"4.0\".\n\nImported from [ODATA-1209](https://issues.oasis-open.org/browse/ODATA-1209)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Specify the finest possible granularity for Duration",
    "body": "Edm.Duration allows to expressing via the Precision facet which number of decimal places can be stored/sent.\n\nWe have applications which don't even support second granularity for durations and only can store durations in days, hours, or minutes (all three variants exist).\n\n\n\n### Proposal\n\nAdd a Measures term DurationGranularity with allowed values \"days\", \"hours\", and \"minutes\". Absence of the annotation means \"seconds with sub-seconds according to Precision\". \n\nImported from [ODATA-1208](https://issues.oasis-open.org/browse/ODATA-1208)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify need for @odata.id in nested response structures",
    "body": "This issue is to clarify, if nested entities included in the response to an aggregation request need to be equipped with an @odata.id control information.\n\nConsider example 24 from the Data Aggregation specification:\n\n`GET ~/Sales?$apply=groupby((Customer/Country,Product/Name),aggregate(Amount with sum as Total))`\n\nresults in\n```java\n{\n  \"@odata.context\": \"$metadata#Sales(Customer(Country),Product(Name),Total)\",\n  \"value\": [\n    { \"@odata.id\": null,\n      \"Customer\": { \"Country\" : \"Netherlands\" },\n      \"Product\": { \"Name\": \"Paper\" },\n      \"Total\": 3 },\n   [...]\n \n```\nTop-level entities do have an @odata.id, but nested projections of related entities currently not. Is this according to rules defined in the format specs to be considered as a gap that needs to be discussed for the Data Aggregation spec?\n\nThe JSON specification describes in section 8.3 for expanded navigation properties that the content is to be rendered according to the entity representation. Two cases exist: 1) If the nested entity is a projection of a \"real\" entity, this could imply mentioning its @odata.id in the response. 2) If the nested entity is a result of an aggregation and therefore transient, section 4.5.8 of the JSON spec states: \"If the entity is transient (i.e. cannot be read or updated), the id annotation MUST appear and have the null value.\"\n\n### Proposal\n\nExamples in the document should comply with the rules stated in the JSON format specification. Since the current examples throughout the document that return transient aggregated entities based on 4.0, all examples having responses with nested projections of related entities should have included an \"@odata.id\":null annotation.\n\n \n\nProposal is to make a blanket statement for V4.01 that clients must be prepared to receive entities having neither @odata.id nor key fields and, in the absence of any additional information, must treat such entities as transient.\n\nWe will update the examples in the aggregation specification to be 4.01 and thus all @odata.id:null (as well as other 4.01 simplifications).\n\nMention in Aggregation that all examples are based on OData V4.01, and call out what would be different across examples for V4.0.\n\nImported from [ODATA-1207](https://issues.oasis-open.org/browse/ODATA-1207)",
    "labels": [
      "Data Aggregation",
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Explicitly note support for collection-valued navigation/complex properties in property paths in aggregate/groupby",
    "body": "It is intended to support aggregation of property values reached via paths that may involve _collection-valued_ navigation properties (see example 53). Likewise, it is intended to support grouping by properties reached via paths that may involve _collection-valued_ navigation properties (see example 54).\n\nSo far, these possibilities are mentioned only by examples, but should be described explicitly in the prose text.\n\n### Proposal\n\n*Add to section 3.1 Transformation aggregate* (insertions surrounded by *):\n An aggregate expression may be\n - an expression valid in a $filter system query option on the input set that results in a simple value, e.g. the path to an aggregatable property, with a specified aggregation method,\n - \\* an aggregatable property, with a specified aggregation method, that can be reached via a path consisting of a sequence of navigation properties, complex properties and complex collection properties. \\*\n [...]\n\n*Update of section 3.10.1 Simple Grouping* (insertions surrounded by *):\n In its simplest form the first parameter of groupby specifies the grouping properties, a comma-separated list of one or more single-valued property paths (paths ending in a single-valued primitive, complex, or navigation property) that is enclosed in parentheses. * A path may consist of a sequence of navigation properties, complex properties and complex collection properties.*\n\nImported from [ODATA-1206](https://issues.oasis-open.org/browse/ODATA-1206)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Examples 53, 54, and 59 are not compliant with Data Aggregation ABNF",
    "body": "Section 3.1 Transformation aggregate defines:\n\nAn aggregate expression may be: \n• an expression valid in a $filter system query option on the input set that results in a simple value, e.g. the path to an aggregatable property, with a specified aggregation method,\n\nThe above-mentioned examples refer to property paths with collection-valued navigation properties, which cannot be created from a CommonExpression that is referenced in rule aggregateExpr of the current ABNF for Data Aggregation.\n\n \n\n### Proposal\n\n \n\nExtend ABNF rule (insertion surrounded with *):\n```java\naggregateExpr   = customAggregate [ customFrom asAlias ]\n                / commonExpr aggregateWith [ aggregateFrom ] asAlias\n-                / pathPrefix primitiveProperty aggregateWith [ aggregateFrom ] asAlias *\n                / pathPrefix '$count' asAlias \n                / pathPrefix customAggregate\n                / pathPrefix pathSegment OPEN aggregateExpr CLOSE```\n \n\n \n\nImported from [ODATA-1205](https://issues.oasis-open.org/browse/ODATA-1205)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow numeric indexes in Path constructs within annotations",
    "body": "With [ODATA-1061](https://issues.oasis-open.org/browse/ODATA-1061) we allowed key segments in parenthesis syntax after path segments that identify a collection of entities.\n\nA logical extension is allowing numeric indexes to reference entities or complex type instances within a collection:\n\n```xml\n<Annotation Term=\"Some.Term\" Path=\"ComplexCollection/0/SomeProperty\" />\n```\n\nThis would address the first item in the collection. If the item is structured, additional path segments can follow after the index segment.\n\n### Proposal\n\nPath expressions allow index segments after path segments that identify an ordered collection of primitive or complex types. The index is zero-based and MUST be an integer literal. Negative integers count from the end of the collection, with -1 representing the last item in the collection.\n\nThis key syntax can only be used in Path expressions as only these refer to instance values.\n\nIt cannot be used in expressions for model references, i.e. PropertyPath, NavigationPropertyPath, AnnotationPath, and their abstract supertypes AnyPropertyPath and AnyPath.\n\n \n\nImported from [ODATA-1203](https://issues.oasis-open.org/browse/ODATA-1203)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Deep update with nested delta items should allow Core.ContentID",
    "body": "The spec only mentions using Core.ContentID with deep insert.\n\nBut deep update may create additional entities and clients may need/wish to be able to correlate keys in the return representation with entities from the request payload.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-1202](https://issues.oasis-open.org/browse/ODATA-1202)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve the syntax of aggregation exceptions with \"from\"",
    "body": "Current syntax:\n\n \n```java\naggregateExpression    (1)\n  as alias             (3)\n  from groupableProperty_1 with aggregationMethod_1 [ with aggregationMethod_1 ] (2) \n  ... \n  from groupableProperty_n with aggregationMethod_n [ with aggregationMethod_n ] \n```\nIt first takes (1) the standard aggregate expression followed by (3) the alias for the final aggregated value followed by (2) \"from\" clauses for exceptions. Since there is a certain processing order defined, which is 1, 2, 3, the syntax would express the intention more clearly, if it would be (1) (2) (3)\n\n \n\n### Proposal\n\nChange the current syntax in section 3.1.4 to\n```java\naggregateExpression\n  from groupableProperty_1 with aggregationMethod_1 [ with aggregationMethod_1 ]\n  ...\n  from groupableProperty_n with aggregationMethod_n [ with aggregationMethod_n ]\n  as alias\n```\n\nImported from [ODATA-1201](https://issues.oasis-open.org/browse/ODATA-1201)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support sample values for types, parameters, request/response bodies",
    "body": "[ODATA-884](https://issues.oasis-open.org/browse/ODATA-884) currently specifies a \"CustomParameterExampleValue\" for providing a sample value for a custom parameter within an HttpRequest annotation.\n\nMore generally, OpenAPI supports defining one or more sample values for each parameter and each (valid media type allowed for a) request or response payload ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#example-object]), as well as a single example for each schema object ([https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#schema-object]).\n\nOpenAPI also supports the example value either being an (inline or referenced) Value, or an ExternalValue, where ExternalValue is an external reference to the literal value in a native (i.e., non-OpenAPI) format. This is done partially to support non-JSON media type values, but can also be useful for referencing external samples. We could support this by defining a base \"Value\" type and inherited \"InlineValue\" or \"ExternalValue\" types.\n\nWe could support this by allowing a new \"ExampleValue\" annotation on a type, parameter, or for a request or response body within an HttpRequest.\n```xml\n<Term Name=\"Example\" Type=\"Core.ExampleValue\" AppliesTo=\"EntityType ComplexType Parameter\"/>\n\n<ComplexType Name=\"ExampleValue\" Abstract=\"true\">\n <Property Name=\"Description\" Type=\"Edm.String\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Description of the example value\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"PrimitiveExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"Value\" Type=\"Edm.PrimitiveType\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Example value for the custom parameter\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"ComplexExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"Value\" Type=\"Edm.ComplexType\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Example value for the custom parameter\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"EntityExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"Value\" Type=\"Edm.EntityType\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Example value for the custom parameter\" />\n </Property>\n</ComplexType>\n\n<ComplexType Name=\"ExternalExampleValue\" BaseType=\"ExampleValue\">\n <Property Name=\"ExternalValue\" Type=\"Edm.String\" Nullable=\"false\">\n <Annotation Term=\"Core.Description\" String=\"Url reference to the value in its literal format\" />\n </Property>\n</ComplexType>\n```\nAnd, within HttpResponse:\n <Property Name=\"Example\" Type=\"Core.ExampleValue\"/>\n\n1) OpenAPI supports the Description as CommonMark syntax ([http://spec.commonmark.org/]) for rich text representation. We could support this as well.\n 2) OpenAPI also includes a short \"Summary\"\n 3) OpenAPI supports multiple examples for request/response bodies and parameters, but not for schema objects (i.e., types). It's unclear how you would relate individual request examples with individual response examples.\n\nImported from [ODATA-1200](https://issues.oasis-open.org/browse/ODATA-1200)",
    "labels": [
      "Vocabularies",
      "CN02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add property SystemQueryOptions to call out supported system query options per request method",
    "body": "In V4.01 we added the possibility to shape the response to POST, PATCH, and PUT requests with system query options.\n\nSupport for this needs to be expressed in some way, see [ODATA-1005](https://issues.oasis-open.org/browse/ODATA-1005).\n\nEasiest way would be to add a property SystemQueryOptions next to CustomQueryOptions.\nType could be a collection of strings naming the query option, or a complex type of Boolean flags telling which of the system query options is supported.\n\nDrawback is of course that this needs to be annotated for each entity set, whereas a \"traditional\" XxxSupport annotation can be attached to the entity container if the underlying engine supports this across all entity sets.\n\nSecond drawback is the overlap with the existing XxxRestrictions/Xxxable flags.\n\n\n\nImported from [ODATA-1199](https://issues.oasis-open.org/browse/ODATA-1199)",
    "labels": [
      "Vocabularies",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "ETag handling deviations from RFC7232 are avoidable if we consider two kinds of ETag (ETag in response header and ETag in response payload)",
    "body": "ETags in response headers should be limited to use for cache validation\n\nETags in response payload (instance annotations) should be limited to use for optimistic concurrency\n\nConflating the two kinds of ETag leads us to difficulties\n\n*In Section 8.2.4 Header If-Match:*\n\n> Services sending ETag headers with weak ETags that only depend on the representation-independent entity state MUST use the weak comparison function because it is sufficient to prevent accidental overwrites. This is a deviation from [RFC7232].\n\nDifficulty: deviation from RFC7232. If we instead required that instance annotation etags be strong etags, and that If-Match only be used (for optimistic concurrency control) with strong etags, we would be compliant with both the draft and final RFC7232 specs. How could it be a strong etag if it depends on the representation-independent entity state? It could be so if we imagine that the representation-independent entity state has some kind of canonical form (which we never actually include in any request/response payload) and that the strong etag is a tag (e.g. version/hash) of that state.\n\n*In Section 8.2.5 Header If-None-Match*\n\n> “As defined in [RFC7232], a client MAY include an If-None-Match header in a request to GET, PUT, PATCH or DELETE. The value of the If-None-Match request header MUST be an ETag value previously retrieved for the resource, or “*”.\n\nDifficulty: apart from when “*” is used (to ensure non-existence of the resource), then the method should be GET and the purpose should be for cache validation. As such, it would seem to be important to use an ETag that came from a response header, not from response payload (in instance annotations).\n\n*In Section 8.3.3 Header ETag*\n\n> A response MAY include an ETag header, see [RFC7232]. Services MUST include this header if they require an ETag to be specified when modifying the resource.\n\nDifficulty: clients may wish to be able to do cache validation as well as optimistic concurrency. Requiring the ETag response header to be specified when modifying the resource doesn’t allow for the possibility that the client wants to use the ETag response header (which might be a content hash) for cache validation (e.g. GET using If-None-Match) and that the client wants to use an ETag from response payload (which might be a version number) for optimistic concurrency (e.g. PATCH using If-Match).\n\n*In Section 11.5.4.1 Invoking an Action*\n\n> To request processing of the action only if the binding parameter value, an entity or collection of entities, is unmodified, the client includes the If-Match header with the latest known ETag value for the entity or collection of entities. The ETag value for a collection as a whole is transported in the ETag header of a collection response.\n\nDifficulty: any ETag response header for a collection as a whole is likely to be only feasibly implemented as a hash of response payload. (At least any such ETag intended for use in cache validation would be such). Then suggesting that it be suitable for If-Match with an action invocation for some kind of optimistic concurrency control is probably not realistically implementable (suppose the collection response was for a subset of properties and the action request is to update some properties that weren’t included in the collection).\n\n### Proposal\n\nNew proposal based on discussion with Matt: *close without action*.\n\nRationale: [https://tools.ietf.org/html/rfc7232#section-3.1] states:\n> An origin server MUST use the strong comparison function when \n> comparing entity-tags for If-Match ([Section 2.3.2](https://tools.ietf.org/html/rfc7232#section-2.3.2)), since the client\n> intends this precondition to prevent the method from being applied if\n> there have been any changes to the _representation data_.\n> \n\nThis is geared towards web servers managing static resources, and is perfectly valid in that context.\n\nThis statement however is not true for (business) applications which track changes to the _underlying data independent from its wire-representation in different formats_. These applications want to prevent accidental changes to the _underlying data_, and for this an ETag only needs to change if the _underlying data_ changes, meaning that different representations of the same underlying data can share the same ETag.\n\nFrom the perspective of RFC7232 these representation-independent \"sufficiently varying\" ETags are weak ETags, which is why we deviate from RFC7232 in this aspect. \nh2. Notes from F2F discussion on 2018-09-28\n- Servers SHOULD use strong Etags for OData entities == \"internal\" Etag transported in @etag\n- Clients SHOULD use @etag for If-Match\n- Servers MUST accept both @etag and the header-etag for If-Match\n- in single-entity responses servers SHOULD send @etag also in etag header\n- If the serializer (especially for JSON) can produce byte-for-byte identical representations of the same underlying data\n- Or if we ignore \"byte-for-byte identical\" and deem \"JSON-equivalent\" sufficient\n\n- Multi-entity response == Collection or Expand\n- Multi-entity response typically does not have etag header\n- MAY have weak etag if caching needs to be supported\n- MAY have strong etag for if-match\n- Collection-response MAY have @etag for if-Match which MAY differ from the header-etag for caching\n- Note: currently no @etag defined for collections in wrapper object, and Hubert uses/needs this\n\nImported from [ODATA-1198](https://issues.oasis-open.org/browse/ODATA-1198)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Chapter 21 Error Response: replace misleading \"code\" values with FOO or BAR",
    "body": "Some readers are misinterpreting the code value \"501\" in the example error response as a MUST for services to echo the HTTP status code, contrary to what the normative spec text says.\n\n### Proposal\n\nUse \"err123\" and \"fourtytwo\" to indicate that this is not the HTTP status code, that it just is a string, \n\nImported from [ODATA-1197](https://issues.oasis-open.org/browse/ODATA-1197)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify update of media streams",
    "body": "Section 8.2.8.7 explicitly forbids return=representation for updating stream property values but allows it for updating media entity streams.\n\nAlso the text does not explicitly state that 204 No Content is the only response for updating stream property values, and that it is the default response for updating media entity streams.\n\n\n### Proposal\n\nAllow preference return=representation for all requests and make clear that the default is \"204 No Content\" for updating both kinds of streams.\n\nImported from [ODATA-1196](https://issues.oasis-open.org/browse/ODATA-1196)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "11.2.6.6: value of $search is search expression, not boolean expression",
    "body": "Section [11.2.6.6 System Query Option $search](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_SystemQueryOptionsearch), last sentence incorrectly says that \n\n??The value of the $search option is a Boolean expression??\n\nIt should say \"search expression\"\n\n### Proposal\n\nRephrase last sentence to\n\n??The value of the `$search` option is a search expression as defined by rule `searchExpr` in *[OData-ABNF]*??\n\nImported from [ODATA-1195](https://issues.oasis-open.org/browse/ODATA-1195)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add term Core.Example to allow including annotation examples in term definitions",
    "body": "While discussing [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099) the idea came up to allow including annotation examples into the term definition, especially useful for structured terms.\n\nSee [https://www.oasis-open.org/committees/download.php/61713/odata-meeting-190_on-20171005-minutes.html#6.2.1,] META 2.\n\nAs [ODATA-1099](https://issues.oasis-open.org/browse/ODATA-1099) is not yet resolved, the term Core.Example is pulled out into this separate issue.\n\n### Proposal\n\nAdd new term\n\n```xml\n<Term Name=\"Example\" Type=\"Core.ExampleType\">\n  <Annotation Term=\"Core.Description\" String=\"A container for annotation examples\" />\n  <Annotation Term=\"Core.Example\">\n    <Record>\n      <Annotation Term=\"Core.Description\"\n        String=\"Note that the value of Core.Example is a record/object containing the annotation examples\" />\n    </Record>\n  </Annotation>\n</Term>\n<ComplexType Name=\"ExampleType\">\n  <Annotation Term=\"Core.Description\" String=\"This type intentionally doesn't have properties, so it can only contain annotation examples\" />\n</ComplexType>\n```\n\nImported from [ODATA-1194](https://issues.oasis-open.org/browse/ODATA-1194)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Automated vocabulary checks indicate some potential issues",
    "body": "See automated analysis output:\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:82 Property Warning: Unspecified Nullable facet defaults to true for property 'Rollup'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Rollup\" DefaultValue=\"MultipleHierarchies\" Type=\"Aggregation.RollupType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:85 Property Warning: Unspecified Nullable facet defaults to true for property 'PropertyRestrictions'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"PropertyRestrictions\" DefaultValue=\"false\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:164 Parameter Warning: Unspecified Nullable facet defaults to true for parameter 'MaxDistance'. An explicit Nullable='true' facet is recommended when null parameter values should be permitted.\n<Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Aggregation.V1.xml:174 Parameter Warning: Unspecified Nullable facet defaults to true for parameter 'MaxDistance'. An explicit Nullable='true' facet is recommended when null parameter values should be permitted.\n<Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:76 Property Warning: Unspecified Nullable facet defaults to true for property 'RequiredScopes'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"RequiredScopes\" Type=\"Collection(Edm.String)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:113 Property Warning: Unspecified Nullable facet defaults to true for property 'Scopes'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Scopes\" Type=\"Collection(Auth.AuthorizationScope)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:90 Property Warning: Unspecified Nullable facet defaults to true for property 'Description'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Description\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:107 Property Warning: Unspecified Nullable facet defaults to true for property 'BearerFormat'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"BearerFormat\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:116 Property Warning: Unspecified Nullable facet defaults to true for property 'RefreshUrl'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"RefreshUrl\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Authorization.V1.xml:158 Property Warning: Unspecified Nullable facet defaults to true for property 'Description'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Description\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:198 Property Warning: Unspecified Nullable facet defaults to true for property 'Supported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:215 Property Warning: Unspecified Nullable facet defaults to true for property 'Countable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Countable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:246 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterFunctions'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:259 Property Warning: Unspecified Nullable facet defaults to true for property 'TopSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"TopSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:262 Property Warning: Unspecified Nullable facet defaults to true for property 'SkipSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SkipSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:265 Property Warning: Unspecified Nullable facet defaults to true for property 'IndexableByKey'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"IndexableByKey\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:314 Property Warning: Unspecified Nullable facet defaults to true for property 'Supported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:317 Property Warning: Unspecified Nullable facet defaults to true for property 'ContinueOnErrorSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ContinueOnErrorSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:320 Property Warning: Unspecified Nullable facet defaults to true for property 'ReferencesInRequestBodiesSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ReferencesInRequestBodiesSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:323 Property Warning: Unspecified Nullable facet defaults to true for property 'ReferencesAcrossChangeSetsSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ReferencesAcrossChangeSetsSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:326 Property Warning: Unspecified Nullable facet defaults to true for property 'EtagReferencesSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"EtagReferencesSupported\" Type=\"Edm.Boolean\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:339 Property Warning: Unspecified Nullable facet defaults to true for property 'Filterable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Filterable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:342 Property Warning: Unspecified Nullable facet defaults to true for property 'RequiresFilter'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"RequiresFilter\" Type=\"Edm.Boolean\" DefaultValue=\"false\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:355 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:408 Property Warning: Unspecified Nullable facet defaults to true for property 'Sortable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Sortable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:426 Property Warning: Unspecified Nullable facet defaults to true for property 'Expandable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Expandable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:432 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:442 Property Warning: Unspecified Nullable facet defaults to true for property 'Searchable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Searchable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:445 Property Warning: Unspecified Nullable facet defaults to true for property 'UnsupportedExpressions'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"UnsupportedExpressions\" Type=\"Capabilities.SearchExpressions\" DefaultValue=\"none\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:481 Property Warning: Unspecified Nullable facet defaults to true for property 'Insertable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Insertable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:487 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:498 Property Warning: Unspecified Nullable facet defaults to true for property 'Supported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Supported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:501 Property Warning: Unspecified Nullable facet defaults to true for property 'ContentIDSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"ContentIDSupported\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:511 Property Warning: Unspecified Nullable facet defaults to true for property 'Updatable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Updatable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:517 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:527 Property Warning: Unspecified Nullable facet defaults to true for property 'Deletable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Deletable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:533 Property Warning: Unspecified Nullable facet defaults to true for property 'MaxLevels'. It is unusual for properties with default values to be nullable. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"MaxLevels\" Type=\"Edm.Int32\" DefaultValue=\"-1\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:546 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterFunctions'. It is unusual to for collection-typed properties to allow null items. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterFunctions\" Type=\"Collection(Edm.String)\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:559 Property Warning: Unspecified Nullable facet defaults to true for property 'TopSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"TopSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:562 Property Warning: Unspecified Nullable facet defaults to true for property 'SkipSupported'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SkipSupported\" Type=\"Core.Tag\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:565 Property Warning: Unspecified Nullable facet defaults to true for property 'Insertable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Insertable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:568 Property Warning: Unspecified Nullable facet defaults to true for property 'Updatable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Updatable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:571 Property Warning: Unspecified Nullable facet defaults to true for property 'Deletable'. It is unusual for boolean-typed properties to allow null values. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Deletable\" Type=\"Edm.Boolean\" DefaultValue=\"true\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:182 Property Warning: Unspecified Nullable facet defaults to true for property 'Id'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Id\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:185 Property Warning: Unspecified Nullable facet defaults to true for property 'UrlTemplate'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"UrlTemplate\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:232 Property Warning: Unspecified Nullable facet defaults to true for property 'Navigability'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Navigability\" Type=\"Capabilities.NavigationType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:240 Property Warning: Unspecified Nullable facet defaults to true for property 'NavigationProperty'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"NavigationProperty\" Type=\"Edm.NavigationPropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:243 Property Warning: Unspecified Nullable facet defaults to true for property 'Navigability'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Navigability\" Type=\"Capabilities.NavigationType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:250 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterRestrictions\" Type=\"Capabilities.FilterRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:253 Property Warning: Unspecified Nullable facet defaults to true for property 'SearchRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:256 Property Warning: Unspecified Nullable facet defaults to true for property 'SortRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SortRestrictions\" Type=\"Capabilities.SortRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:268 Property Warning: Unspecified Nullable facet defaults to true for property 'InsertRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"InsertRestrictions\" Type=\"Capabilities.InsertRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:271 Property Warning: Unspecified Nullable facet defaults to true for property 'DeepInsertSupport'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"DeepInsertSupport\" Type=\"Capabilities.DeepInsertSupportType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:275 Property Warning: Unspecified Nullable facet defaults to true for property 'UpdateRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"UpdateRestrictions\" Type=\"Capabilities.UpdateRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:278 Property Warning: Unspecified Nullable facet defaults to true for property 'DeleteRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"DeleteRestrictions\" Type=\"Capabilities.DeleteRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:361 Property Warning: Unspecified Nullable facet defaults to true for property 'Property'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Property\" Type=\"Edm.PropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:364 Property Warning: Unspecified Nullable facet defaults to true for property 'AllowedExpressions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"AllowedExpressions\" Type=\"Capabilities.FilterExpressionType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:543 Property Warning: Unspecified Nullable facet defaults to true for property 'CollectionProperty'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"CollectionProperty\" Type=\"Edm.PropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:550 Property Warning: Unspecified Nullable facet defaults to true for property 'FilterRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"FilterRestrictions\" Type=\"Capabilities.FilterRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:553 Property Warning: Unspecified Nullable facet defaults to true for property 'SearchRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SearchRestrictions\" Type=\"Capabilities.SearchRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:556 Property Warning: Unspecified Nullable facet defaults to true for property 'SortRestrictions'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"SortRestrictions\" Type=\"Capabilities.SortRestrictionsType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:86 Property Warning: Unspecified Nullable facet defaults to true for property 'Version'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Version\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:89 Property Warning: Unspecified Nullable facet defaults to true for property 'Kind'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Kind\" Type=\"Core.RevisionKind\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:92 Property Warning: Unspecified Nullable facet defaults to true for property 'Description'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Description\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:344 Property Warning: Unspecified Nullable facet defaults to true for property 'Name'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Type=\"Edm.PropertyPath\" Name=\"Name\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:348 Property Warning: Unspecified Nullable facet defaults to true for property 'Alias'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Type=\"Edm.String\" Name=\"Alias\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Core.V1.xml:371 Property Warning: Unspecified Nullable facet defaults to true for property 'DefaultValue'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"DefaultValue\" Type=\"Edm.String\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml:92 Property Warning: Unspecified Nullable facet defaults to true for property 'Value'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"Value\" Type=\"Edm.PrimitiveType\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml:128 Property Warning: Unspecified Nullable facet defaults to true for property 'path'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"path\" Type=\"Edm.NavigationPropertyPath\">...\n\nhttps://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Validation.V1.xml:131 Property Warning: Unspecified Nullable facet defaults to true for property 'target'. An explicit Nullable='true' facet is recommended when null property values should be permitted.\n<Property Name=\"target\" Type=\"Edm.NavigationPropertyPath\">...\n\n### Proposal\n\nCheck all the above, determine correct facet(s), and apply appropriate facets explicitly to all standard vocabularies.\n\n \n\nImported from [ODATA-1193](https://issues.oasis-open.org/browse/ODATA-1193)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities vocabulary: invalid DefaultValue for KeyAsSegmentSupported",
    "body": "https://oasis-tcs.github.io/odata-vocabularies/vocabularies/Org.OData.Capabilities.V1.xml:470 Term Error: Cannot parse default value 'True' of type 'Org.OData.Core.V1.Tag'.\n<Term Name=\"KeyAsSegmentSupported\" Type=\"Core.Tag\" DefaultValue=\"True\" AppliesTo=\"EntityContainer\">...\n\n \n\n### Proposal\n\nChange default value from 'True' to 'true'.\n\n \n\nImported from [ODATA-1192](https://issues.oasis-open.org/browse/ODATA-1192)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make sure that all model elements are annotatable",
    "body": "Annotations were initially designed as a way that we could extend metadata without introducing breaking changes. However, there are cases where model elements are not annotatable, which limits our ability to extend those elements.\n\nFor example, OData-1187 proposes extending navigation property bindings to specify that a particular path is recursive. We'd like to do this as an annotation, to avoid introducing an incompatability with 4.0, but NavigationPropertyBinding elements are (currently) not annotatable.\n\nWe should go through our model elements to identify those that are not currently annotatable, and see if we can come up with a way to make everything annotatable.\n\nHubert had some thoughts about making it easier to annotate model elements in our JSON format.\n\n### Proposal\n\nClose without action, see comment on the small number of non-annotatable model elements and the rationale for that\n\nImported from [ODATA-1191](https://issues.oasis-open.org/browse/ODATA-1191)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Add matchesPattern as a $filter function",
    "body": "\n\n### Proposal\n\nAdd matchesPattern as a $filter function:\n\n \n\nEdm.Boolean matchesPattern(Edm.String,Edm.String)\n\n \n\nThe matchesPattern function returns true if the second parameter string value evaluates to a [*[ECMAScript]*](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#ECMAScript) (JavaScript) regular expression and the result of the first argument string matches that regular expression, using syntax and semantics of [*[ECMAScript]*](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#ECMAScript) regular expressions, otherwise it returns false.\n\nImported from [ODATA-1190](https://issues.oasis-open.org/browse/ODATA-1190)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Conformance: Nullable for collections",
    "body": "Chapter 17 Conformance states:\n\n12.  SHOULD specify the [Nullable](http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/cs01/odata-csdl-json-v4.01-cs01.html#sec_Nullable) facet for collections\n\nThis makes sense in CSDL XML where Nullable defaults to true and collections weren't considered initially.\n\nIn CSDL JSON $Nullable defaults to false for single- and collection-valued properties, so no need to state \n\n### Proposal\n\nRemove conformance statements in CSDL JSON, keep it only in CSDL XML\n\n12.  SHOULD specify the [Nullable](http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/cs01/odata-csdl-json-v4.01-cs01.html#sec_Nullable) facet for collections\n\n14.  MUST specify the [Nullable](http://docs.oasis-open.org/odata/odata-csdl-json/v4.01/cs01/odata-csdl-json-v4.01-cs01.html#sec_Nullable) facet for collections\n\n \n\n \n\nImported from [ODATA-1189](https://issues.oasis-open.org/browse/ODATA-1189)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow using instance annotations in $select and $expand",
    "body": "We already allow using instance annotations in $filter, $orderby, and $compute:\n```\nGET Stuff?$filter=@Core.Messages/any(m:m/severity eq 'error')\n```\n\nThis indirectly allows using instance annotations in $select and $expand:\n```\nGET Stuff?$compute=@Core.Messages as _at_Core_dot_Messages\n         &$select=*,_at_Core_dot_Messages($top=5)\n```\n\nWhich is kind of ugly and loses the canonical name of the instance annotation\n\n\n\n### Proposal\n\nAllow using instance annotations of type (collection of) primitive or complex in $select and instance annotations of type (collection of) entity in $expand.\n\nExample\n```java\nGET Stuff?$select=@Core.Messages($top=5)\n```\nServices can signal this capability to clients with the tagging term `Capabilities.AnnotationValuesInQuerySupported`.\n```xml\n<Term Name=\"AnnotationValuesInQuerySupported\" Type=\"Core.Tag\" DefaultValue=\"True\"\n      Nullable=\"false\" AppliesTo=\"EntityContainer\">\n    <Annotation Term=\"Core.Description\" \n                String=\"Supports annotation values within system query options\" />\n</Term>\n```\n\nAnnotations in $select must be included in response and take precedence over preference header; if $select says to include, and preference says omit, it's still included. preference header can add additional annotations to what is specified in $select.\n\nIn the presence of both include-annotations preference and annotations selected in $select, then preference-applied, if present, reflects the set of annotations added by the preference-applied (not by $select). In the absence of the include-annotations preference header, there should not be an include-annotations in the preference applied.\n\nExplicitly selected (expanded) annotations must appear in the contextUrl as other properties. It is possible to select only annotations, in which case only those selected (expanded) navigations appear in the result. Note that annotations specified in include-annotations do not appear in the context Url, and do not affect the selected/expanded properties.\n\nIt is not valid to $select an entity-valued annotation (because we do not currently define a canonical navigation url for an entity-valued annotation). entity-valued annotations can be included using $expand.\n\nIf the annotation isn't applied to the instance, a null value is returned (same as for dynamic properties).\n\nNote that selecting control information (@odata.type, @odata.navigationLink, etc.) is not allowed.\n\nImported from [ODATA-1188](https://issues.oasis-open.org/browse/ODATA-1188)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "No way to bind nav prop on recursively nested (contained or complex) type",
    "body": "While we are able to bind nav props on nested complex or contained types at an arbitrary level by specifying the path, it's not possible to recursively bind nested nav props.\n Consider the following complex type, containing a navigation property to Country, used within a Customer:\n```xml\n<ComplexType Name=\"Address\">\n  <Property Name=\"PreviousAddress\" Type=\"self.Address\" Nullable=\"true\"/>\n  <NavigationProperty Name=\"Country\" Type=\"self.Country\"/>\n</ComplexType>```\nWe can bind the Country nav on the Address of a Customer:\n```xml\n<EntitySet Name=\"Customers\" EntityType=\"self.Customer\">\n  <NavigationPropertyBinding Path=\"Address/Country\" Target=\"Countries\" />\n</EntitySet>\n```\nWe could also bind the Country on the previous address property of the address of a customer:\n```xml\n<EntitySet Name=\"Customers\" EntityType=\"self.Customer\">\n  <NavigationPropertyBinding Path=\"Address/Country\" Target=\"Countries\" />\n  <NavigationPropertyBinding Path=\"Address/PreviousAddress/Country\" Target=\"Countries\" />\n</EntitySet>\n```\nAnd so on…\n```xml\n<EntitySet Name=\"Customers\" EntityType=\"self.Customer\">\n  <NavigationPropertyBinding Path=\"Address/Country\" Target=\"Countries\" />\n  <NavigationPropertyBinding Path=\"Address/PreviousAddress/Country\" Target=\"Countries\" />\n  <NavigationPropertyBinding Path=\"Address/PreviousAddress/PreviousAddress/Country\" Target=\"Countries\" />\n  ...\n</EntitySet>\n```\nWhat is lacking is a way to specify that all countries returned by the PreviousAddress navigation property (recursively) are contained in a particular entity set.\n The same issue existings if Address is a contained navigation property.\n\n### Proposal\n\nClients can typically assume that binding a recursive navprop path binds recursively.  If we need to later, we can add an entityset/singleton annotation to say it doesn't.\n\nImported from [ODATA-1187](https://issues.oasis-open.org/browse/ODATA-1187)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify names that can appear in annotation of term ApplySupported/Transformations",
    "body": "The list of transformation names in section 6.1 is incomplete.\n\n### Proposal\n\nInstead of explicitly listing the names of all transformations, which are known at the time of writing, refer to them indirectly. Replace the sentence in the first point of section 6.1 with: Allowed values are the names of the standard transformations introduced in section 3 or ...\n\nImported from [ODATA-1186](https://issues.oasis-open.org/browse/ODATA-1186)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Extend transformation nest to multiple sequences",
    "body": "Currently, nest can be used to create an entity with a single containment navigation property holding the result of a transformation sequence:\n\n`nest( cnp, t )` returns\n```java\n[{ <cnp>: [ <result of t applied to input set> ] }]```\nThere are use cases to generalize this and nest the results of _multiple_ transformation sequences at once. Consider, for example, a request to combine the results of two transformations in a single response. Using transformation concat requires an extra computation of a concat index to relate an entity in the result to the corresponding concat argument (see [ODATA-1138](https://issues.oasis-open.org/browse/ODATA-1138)):\n\n`GET ~/Sales?$apply=concat(`\n `   filter(<complex expression 1>)`\n `   ``/groupby((Customer),aggregate(Amount with sum as Total))/compute(1 as concat_index),`\n `   filter(<complex expression 2>)`\n `   /groupby((Customer),aggregate(Amount with sum as Total))/compute(2 as concat_index))`\n\n \n\nIf it makes sense to keep the results of the two transformations separately, they could be retrieved via an extended syntax of the transformation nest:\n\n`GET ~/Sales?$apply=nest(`\n `   filter(<complex expression 1>)`\n `   /groupby((Customer),aggregate(Amount with sum as Total)) as part_1,`\n `   filter(<complex expression 2>)`\n `   /groupby((Customer),aggregate(Amount with sum as Total)) as part_2)`\n\n \n\n### Proposal\n\nThe nest transformation takes a comma-separated list of one or more nest expressions as parameters. A nest expression is a sequence of set transformations followed by a SimpleIdentifier, called an alias (see [OData-CSDL, section 17.2]). This alias MUST NOT collide with names of properties in the input set or with other aliases introduced in the same nest transformation.\n\nThe result set consists of a single entity having one dynamic property per nest expression. The name of the added property is the alias following the as keyword. The value of the property is the result collection of the transformation sequence in the nest expression applied to the input set:\n\n`nest( t_1 as cnp_1, ..., t_N as cnp_N )` returns\n```java\n[{ <cnp_1>: [ <result of t_1 applied to input set> ],\n  ...\n  <cnp_N>: [ <result of t_N applied to input set> ]\n}]\n```\n\nImported from [ODATA-1185](https://issues.oasis-open.org/browse/ODATA-1185)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Singletons to be null",
    "body": "Properties of the Service Document are described by Singletons and EntitySets.\nWhile it is possible to have an empty EntitySet.  It is not currently possible to have an empty (i.e. null) Singleton.  So for a given service document, implementations are required to minimally populate all singletons, regardless of whether or not the implementation actually has a value for that property.\n\n\n### Proposal\n\nThe proposal is to allow a Singleton to be specified as Nullable.\n\nIn clause 13.3 Singleton, add:\n\n*Attribute Nullable*\n The value of Nullable is one of the Boolean literals true or false. Absence of the attribute means false. A value of true specifies that the declaring Singleton MAY have no related entity. If false, instances of the declaring Singleton MUST always have a related entity.\n\nBehavior:\n For 4.01 responses:\n -services return \"nullable\":true for nullable singleton in JSON. absence means not-nullable, as with all other nullable facets in JSON.\n -services return \"nullable=true\" for nullable singleton in XML. Absence of this attribute means not-nullable. note that this is the opposite default as for single-valued navigation properties.\n -services return 204, No Content, for null-valued singletons (just as for null-valued singleton navigation properties).\n For 4.0 responses:\n -services must return \"nullable\":false, or omit the nullable facet, for a singleton in JSON\n -services must not return the nullable attribute for a singleton in XML\n -services must return a representation of the singleton (i.e., an object with only a context Url) or an error (such as 404).\n\nImported from [ODATA-1183](https://issues.oasis-open.org/browse/ODATA-1183)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that transformation topcount keeps the order of the input set",
    "body": "For all transformations topXXX and bottomXXX except topcount it has been specified that they do not change the order of the instances in the input set.\n\n### Proposal\n\nExtend definition of topcount by the statement that it does not change the order of the instances in the input set.\n\nImported from [ODATA-1182](https://issues.oasis-open.org/browse/ODATA-1182)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify $expand=NavSingle/$count and $expand=*/$count",
    "body": "Section 4.8 only defines the /$count segment for collection-valued paths.\n\nSection 5.1.2 does not state a restriction to collection-valued navigation properties for $expand=NavProp/$count and similar paths.\n\nWe could allow /$count for all kinds of paths, returning 1 for single-valued navigation paths to an existing resource, and returning 0 for single-valued navigation paths that would return 204 or 404 without the /$count suffix.\n\nBuilding on that $expand=*/$count could be defined to return the count of related entities for all navigation properties.\n\n### Proposal\n\nWe don't want to allow these requests and their consequences for expressions in general\n\nImported from [ODATA-1181](https://issues.oasis-open.org/browse/ODATA-1181)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Cast between enumeration types and integer types",
    "body": "Enumeration members have an explicit or (only in CSDL XML) implicit numeric value.\n\nSorting and comparison of enumeration members is based in this numeric value.\n\nUnfortunately casting between enumeration types and integer types is not yet defined.\n\n### Proposal\n\nCasting between enumeration types and integer types (of sufficient width) is possible based on the numeric value.\n\nThis cast MUST be explicit, using the cast() function in URLs or the cast expression in CSDL.\n\nCall this out in URL Conventions, section 5.1.1.10.1 [cast](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part2-url-conventions/odata-v4.01-cs01-part2-url-conventions.html#sec_cast).\n\nPreferred wording: Services MAY support casting enumeration members to the underlying numeric values using the explicit cast function.\n\nImported from [ODATA-1180](https://issues.oasis-open.org/browse/ODATA-1180)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enhance orderby $apply-transformation with sorting of undefined properties",
    "body": "Extend $orderby expressions accepted by the orderby transformation with the option to specify how to sort undefined properties.\n\n\nIn general, the demand for being able to specify the position of entities with undefined properties emerges from combining transformation sequences using concat or by applying groupby(rollup(...), ...). A concrete use case is described in more detail in https://www.oasis-open.org/committees/document.php?document_id=62593&wg_abbrev=odata.\n\n### Proposal\n\nDetails are described in the document “Grid-Like Access to Aggregated Data”, sections 4 and 8.1: [https://www.oasis-open.org/committees/document.php?document_id=62593&wg_abbrev=odata]\n\nExcerpt from relevant section 8.1: Extend the expressions that can be passed to the orderby transformation by an optional suffix that, if specified, determines the position of undefined values of properties that have been aggregated away:\n\nWith orderby( <orderbyItem> undefined first ) undefined values of the orderby item come before any defined value. The order among the undefined values is undefined.\n\nWith orderby( <orderbyItem> undefined last ) undefined values of the orderby item come after any defined value. The order among the undefined values is undefined.\n\nImported from [ODATA-1179](https://issues.oasis-open.org/browse/ODATA-1179)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "External targeting for action/function overloads",
    "body": "Section [14.2.2 Target](http://docs.oasis-open.org/odata/odata-csdl-xml/v4.01/cs01/odata-csdl-xml-v4.01-cs01.html#sec_Target) describes which model elements can be annotated via external targeting.\n\nCurrently actions and functions can only be summarily targeted, i.e. the (external) annotation applies to all overloads.\n\n### Proposal\n\nAllow external targeting of individual action/function overload with syntax similar to action/function advertisement in JSON data by optionally appending the overload signature to the action/function name.\n\nThe signature consists of parentheses containing\n- for unbound actions: nothing, just the parentheses\n- for bound actions: the name of the first (binding) parameter type\n- for functions: the comma-separated ordered list of parameter types (including the binding parameter type at the first position for bound overloads)\n\n \n\nExamples:\n```java\nMySchema.MyAction(MySchema.BindingParameterType)\nMySchema.MyFunction(MySchema.BindingParameterType,First.NonBinding.ParameterType,Second.NonBinding.ParameterType)\n```\n\nImported from [ODATA-1178](https://issues.oasis-open.org/browse/ODATA-1178)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Embed \"JSON properties\" in OData JSON requests and responses",
    "body": "Allow defining \"JSON properties\" in OData models, i.e. properties whose value is well-formed JSON, see [OData Extension for JSON Data](https://www.oasis-open.org/committees/download.php/46559/OData%20Extension%20for%20JSON%20Data%20v1.0.doc).\n\nRequirements:\n1. JSON property values are represented \"inline\" in JSON responses, i.e. `\"JSONproperty\":` _<well-formed JSON data>_\n1. Common expressions (e.g. in `$filter)` can address parts of JSON data\n1. JSON properties can specify a JSON Schema that describes/restricts their data values\n\nThis issue addresses the first requirement. The other requirements are addressed in [ODATA-1275](https://issues.oasis-open.org/browse/ODATA-1275)\n\n \n\n### Proposal\n\n\"JSON properties\" are represented in metadata as properties of type `Edm.Stream`, which may be annotated with the existing annotation `Core.AcceptableMediaTypes`, listing `application/json` to specify that the stream property contains JSON.\n\nStreams that are annotated as the `application/json` media type (or one of its subtypes, optionally with format parameters) through `@mediaContentType` instance annotation are represented as native JSON in JSON requests and responses, they are NOT represented as a base64url-encoded string values. (Note: this is similar to what we  do in the [JSON Batch format](http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_BatchRequestsandResponses) for JSON request and response bodies.). The `odata.mediaContentType` control information is only necessary if the embedded JSON happens to be a JSON string, in all other cases it can be heuristically determined that the stream value is JSON. For dynamic JSON properties represented with inline JSON value the `odata.mediaContentType` control information is always necessary to distinguish them from dynamic Edm.Untyped properties.\n\nThe term `Core.AutoExpand` is extended to also apply to (stream) properties, enabling \"JSON properties\" to be implicitly expanded by the service if it is contained in a JSON response. Auto-expanded \"JSON properties\" MAY be part of the default selection, i.e. represented inline if no `$select` query option is specified.\n\nImported from [ODATA-1177](https://issues.oasis-open.org/browse/ODATA-1177)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities: add new term SelectSupport",
    "body": "Similar to other xxxRestrictions add a SelectRestrictions structured term with (for now) a single property Selectable of type Boolean:\n\nExample:\n```xml\n<Annotation Term=\"Capabilities.SelectRestrictions\">\n  <Record>\n    <PropertyValue Property=\"Selectable\" Bool=\"false\" />\n  </Record>\n </Annotation>```\n\n### Proposal\n\nTerm definition:\n```xml\n<Term Name=\"SelectSupport\" Type=\"Capabilities.SelectSupportType\" Nullable=\"false\" AppliesTo=\"EntityContainer EntitySet Singleton\">\n  <Annotation Term=\"Core.Description\" String=\"Support for $select and nested query options within $select\" />\n</Term>\n<ComplexType Name=\"SelectSupportType\">\n  <Property Name=\"Supported\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"true\">\n    <Annotation Term=\"Core.Description\" String=\"Supports $select\" />\n  </Property>\n  <Property Name=\"Expandable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$expand within $select is supported\" />\n  </Property>\n  <Property Name=\"Filterable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$filter within $select is supported\" />\n  </Property>\n  <Property Name=\"Searchable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$search within $select is supported\" />\n  </Property>\n  <Property Name=\"TopSupported\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$top within $select is supported\" />\n  </Property>\n  <Property Name=\"SkipSupported\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$skip within $select is supported\" />\n  </Property>\n  <Property Name=\"ComputeSupported\" Type=\"Core.Tag\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$compute within $select is supported\" />\n  </Property>\n  <Property Name=\"Countable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$count within $select is supported\" />\n  </Property>\n  <Property Name=\"Sortable\" Type=\"Edm.Boolean\" Nullable=\"false\" DefaultValue=\"false\">\n    <Annotation Term=\"Core.Description\" String=\"$orderby within $select is supported\" />\n  </Property>\n</ComplexType>\n```\n \n\nAlso add corresponding property `SelectSupport` to `CollectionPropertyRestrictionsType` and `NavigationPropertyRestrictionsType`.\n\nImported from [ODATA-1176](https://issues.oasis-open.org/browse/ODATA-1176)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Capabilities: allow UpdateRestrictions also for singletons",
    "body": "Modeling a read-only singleton is more straight-forward than modeling a parameterless function and a function import.\n\nAlso the update restriction may be compatibly relaxed in a later schema version, whereas switching from a function+import to a singleton is an incompatible change.\n\nImported from [ODATA-1175](https://issues.oasis-open.org/browse/ODATA-1175)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "JSON CSDL should not require nullable attribute for collections",
    "body": "The conformance section for JSON CSDL includes the requirement that the metadata must specify the nullable attribute for collections. This was inherited from XML CSDL because the default of nullable=true was wrong for collections.\n\nFor JSON CSDL, the default for nullable is false, which makes sense for collections as well, and should not have to be specified.\n\nImported from [ODATA-1174](https://issues.oasis-open.org/browse/ODATA-1174)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "14.4.11: Description of Null",
    "body": "14.4.11 Null says:\nThe null expression returns an untyped null value. The null expression MAY be annotated. The null expression MUST be written with element notation. \n\nTwo issues:\n1) Null relates only to the absence of value, for whatever type of the associated property, parameter, or return.\n\n### Proposal\n\nChange to:\nThe null expression indicates the absence of value.   The null expression MAY be annotated. The null expression MUST be written with element notation.\n\nImported from [ODATA-1173](https://issues.oasis-open.org/browse/ODATA-1173)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "4.5.3: use $schemaversion query option instead of SchemaVersion header",
    "body": "Section 4.5.3 Control Information: type (odata.type) still refers to the SchemaVersion request header that has been replaced with a $schemaversion system query option with [ODATA-994](https://issues.oasis-open.org/browse/ODATA-994).\n\n### Proposal\n\nCurrent text:\n----\nIf the URI references a metadata document (that is, it’s not just a fragment), and refers to a specific version of that metadata, then the object or name/value pair MUST also be annotated with the Core.SchemaVersion annotation, defined in [OData-VocCore], to indicate the version of the metadata document containing the corresponding version of the type. For streamed JSON responses, this annotation MUST immediately follow the type annotation. If the Core.SchemaVersion annotation is present, the Core.SchemaVersion header, defined in [OData-Protocol], SHOULD be used when retrieving the referenced metadata document.\n----\n\nChange to\n----\nIf the URI references a metadata document (that is, it’s not just a fragment), it MAY refer to a specific version of that metadata document using the $schemaversion system query option defined in [OData-Protocol].\n----\n\nThat is: no need for an additional annotation with Core.SchemaVersion, just follow the @odata.type URL.\n\nImported from [ODATA-1172](https://issues.oasis-open.org/browse/ODATA-1172)",
    "labels": [
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consider using matrix parameters for filter segments",
    "body": "In 4.01 CS01, we introduced the ability to insert a filter into a path using a special \"filter path segment\" of the form \n\n   Customers/$filter=@q/myns.action?$@q=Age gt 18\n\n(see https://issues.oasis-open.org/browse/[ODATA-836](https://issues.oasis-open.org/browse/ODATA-836))\n\nIt turns out, the facility to append parameter information to a segment was considered over 20 years ago by Tim Berners-Lee using \"matrix parameters\" (http://www.w3.org/DesignIssues/MatrixURIs.html) -- basically, a matrix parameter is a way to add parameters to a path segment as a series of key-value pairs separated from the path segment with a semi-colon.\n\n4.01 CS01 syntax:\n   Customers/$filter=@q?$@q=name eq 'Smith'\nMatrix parameter syntax:\n   Customers;$filter=@q?$@q=name eq 'Smith'\n\nAdvantages of using matrix parameters:\n1) No possible ambiguity with key-as-segment\n2) Not inventing something new\n3) May already be supported by some systems\n\n\nImported from [ODATA-1171](https://issues.oasis-open.org/browse/ODATA-1171)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Allow @odata.type for isomorphy to CSDL XML",
    "body": "The XML representation of <EnumMember> constant expressions contains the enumeration type name of the enumeration value as a prefix:\n```xml\n<Annotation Term=\"Namespace1_Alias.TermEnum\">\n  <EnumMember>Namespace1_Alias.ENString/String1 Namespace1_Alias.ENString/String3</EnumMember>\n</Annotation>```\nThe JSON representation does not contain the type name:\n```\n\"@com.odata.v4.technical.scenario.TermEnum\": \"String1,String3\"\n```\nThis breaks isomorphy between XML and JSON representation of CSDL.\n\nThe JSON representation was explicitly chosen without type prefix to mirror the JSON Format representation of enumeration values in data payloads.\n\nAllowing an @odata.type control information would both be consistent with JSON Format and establish isomorphy to CSDL XML:\n```\n\"@com.odata.v4.technical.scenario.TermEnum@odata.type\": \"#Namespace1_Alias.ENString\",\n\"@com.odata.v4.technical.scenario.TermEnum\": \"String1,String3\"\n```\nThis should be optional in the normal case, required if you can't deduce the type; (i.e., if the term cannot be resolved for some reason or the type of the term is Edm.Untyped), as in the data payload.\n\n### Proposal\n\nRe-opened 2018-9-27 and revised proposal:\n\nWithin a $metadata document, control information (notably, @odata.type) is used in the same cases it would be used in a standard odata json response:\n\n1) in no metadata, no control information is returned\n\n2) in minimal metadata, control information (@odata.type) is returned for values whose type cannot be determined from metadata and cannot be heuristically determined \n\n3) in full metadata, control information (@odata.type) must be returned for all types that cannot be heuristically determined (including entity or complex types)\n\nImported from [ODATA-1170](https://issues.oasis-open.org/browse/ODATA-1170)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Transformation for nesting the result of another transformation within a single entity",
    "body": "This new feature is motivated by a concrete use case. The current version of the Data Aggregation specification already includes an example for a cross-table and describes how to retrieve its data using transformation groupby in combination with rollup. However, this data is returned as linear collection of entities. For working with data in a grid efficiently, it must be possible to access selected sections of the grid. Details are described in the document “Grid-Like Access to Aggregated Data”, sections 2 and 3: [https://www.oasis-open.org/committees/document.php?document_id=62593&wg_abbrev=odata]\n\n### Proposal\n\nAn OData representation of a grid-like result spanned by multiple axes could be achieved by a new transformation `nest()` that allows to embed data of grid cells as a nested collection of entities representing grid rows. \n\nRelevant excerpt from section 3 in the referenced document: The `nest` transformation has two parameters. The first takes the name of a dynamic containment navigation property, the second is a (chain of) $apply transformations. `nest( cnp, t )` applies transformation chain t to the input set and creates a result set containing a single entity that only contains the navigation property `cnp`, which in turn holds the result collection of t applied to the input set:\n\n\n```json\n{ <cnp>: [ <result of t applied to input set> ] }\n```\n\n\nImported from [ODATA-1169](https://issues.oasis-open.org/browse/ODATA-1169)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify the use of ETags for Avoiding Update Conflicts",
    "body": "[http://docs.oasis-open.org/odata/odata/v4.0/errata03/os/complete/part1-protocol/odata-v4.0-errata03-os-part1-protocol-complete.html#_Data_Modification] states:\n\n11.4.1.1 Use of ETags for Avoiding Update Conflicts\n If an ETag value is specified in an If-Match or If-None-Match header of a Data Modification Request or Action Request, the operation MUST only be invoked if the if-match or if-none-match condition is satisfied.\n\nThe ETag value specified in the if-match or if-none-match request header may be obtained from an ETag header of a response for an individual entity, or may be included for an individual entity in a format-specific manner.\n\nIssue requiring clarification: we carefully need to distinguish between OData’s meaning of “entity = an instance of an entity type\" and HTTP’s meaning of “entity = the thing whose representation is transferred”. ETags (= entity tags) refer to the HTTP meaning, and thus links/references/relationships are “HTTP entities” that can have their own ETags.\n\nAlso clarify:\n- Can a \"HTTP entity\" / \"link entity\" identified by `xxx/$ref` have an ETag?\n- Is the ETag of a \"link entity\" logically independent of the ETags of the linked OData entities at either end?\n- If `xxx` is a collection resource, can the references returned by `GET xxx/$ref` contain `@odata.etag` control information to carry the individual ETag of each \"link entity\"?\n- Are `EntitySet/$ref` and `EntitySet(<key>)/$ref` only accidentally allowed by the ABNF and the prose text in [Protocol 11.2.8: Requesting Entity References](http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingEntityReferences) or are these valid resource paths?\n\n### Proposal\n\nMake clear that EntityCollection/$ref and SingleEntity/$ref are intentionally allowed to return an ETag.\n\nEntityCollection/$ref (where EntityCollection is an entity set or collection-valued navigation path) may have an (own) ETag returned in the ETag header which changes if the list of references changes, i.e. a reference is added or removed.\n\nSingleNavigation/$ref (where SingleNavigation is a single-valued navigation path) may have an ETag which represents the identity of the related entity. If the relationship is changed to point to a different OData entity, the ETag MUST change.\n\nNote: the ETag for an entity reference (i.e. EntitySet(key)/$ref) can never change.\n\nIn JSON, if an object contains an etag (or other control information other than type) then it is a representation of the object, not an entity reference. \n\nso:\n{\"@id\":\"people(1)\"} \nis an entity reference to the resource in the people entity set with the key value 1, where:\n{\"@id\":\"people(1)\",\"@etag\":\"xyz123\"} \nis a minimal representation of the resource (not the reference), just as\n{\"@id\":\"people(1)\",\"name\":\"maggie\"}\nis a minimal representation of the resource.\nSo, if \n{\"@id\":\"people(1)\",\"@etag\":\"xyz123\"} \nis returned, the etag refers to the person (and not the reference) and changes if any properties of the person changes.\n\nImported from [ODATA-1168](https://issues.oasis-open.org/browse/ODATA-1168)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add way to specify which batch formats (if any) are supported by a service",
    "body": "We have annotation terms to specify supported data types and metadata types, but we don't have an annotation term to specify supported batch formats.\n\nThis is particularly important for batch because the client can't just specify an accept header for all formats that it supports, it needs to know what format to send the batch request.\n\nWe could support this by defining a top-level SupportedBatchFormats, along alongside SupportedFormats and SupportedMetadataFormats, or we could put this on our BatchSupportType\n\n### Proposal\n\nAdd a SupportedFormats property to the BatchSupportType:\n\n```xml\n<Property Name=\"SupportedFormats\" Type=\"Collection(Edm.String)\" Nullable=\"false\">\n  <Annotation Term=\"Core.Description\" String=\"Media types of supported formats for $batch\" />\n  <Annotation Term=\"Core.IsMediaType\" />\n  <Annotation Term=\"Validation.AllowedValues\">\n    <Collection>\n      <Record>\n        <PropertyValue Property=\"Value\" String=\"multipart/mixed\" />\n        <Annotation Term=\"Core.Description\"\n          String=\"Multipart Batch Format, see http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_MultipartBatchFormat\" />\n      </Record>\n      <Record>\n        <PropertyValue Property=\"Value\" String=\"application/json\" />\n        <Annotation Term=\"Core.Description\"\n          String=\"JSON Batch Format, see http://docs.oasis-open.org/odata/odata-json-format/v4.01/cs01/odata-json-format-v4.01-cs01.html#sec_BatchRequestsandResponses\" />\n      </Record>\n    </Collection>\n  </Annotation>\n</Property>\n```\n\nImported from [ODATA-1167](https://issues.oasis-open.org/browse/ODATA-1167)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Update JSON references to RFC8259",
    "body": "https://tools.ietf.org/html/rfc8259 obsoletes https://tools.ietf.org/html/rfc7159\n\n### Proposal\n\nUpdate normative references\n\nImported from [ODATA-1166](https://issues.oasis-open.org/browse/ODATA-1166)",
    "labels": [
      "CSDL JSON",
      "JSON Format",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Describe $compute, $expand, and $select via prose text and examples, remove ABNF snippets",
    "body": "Sections 5.1.2 $expand and 5.1.3 $select currently start with ABNF snippets and then explain allowed constructs via prose text and examples.\n\nUnfortunately the ABNF is incorrectly restrictive in some places, see [ODATA-1155](https://issues.oasis-open.org/browse/ODATA-1155), as well as overly lax on other places.\n\n### Proposal\n\nRemove ABNF snippets and make sure that prose text and examples cover all valid alternatives.\n\nFor $compute:\n> The value of $compute is a comma-separated list of compute instructions, each consisting of an expression followed by the keyword as, followed by the name for of computed dynamic property. This name MUST differ from the names of declared or other dynamic properties of the identified resources.\n> \n\ninstead of\n> Following is a (non-normative) snippet from [OData-ABNF] showing the syntax of $compute:\n>  compute = '$compute' EQ computeItem *( COMMA computeItem )\n>  computeItem = commonExpr RWS 'as' RWS computedProperty\n>  computedProperty = odataIdentifier\n> \n\n \n\nFor $expand:\n> The value of $expand is a comma-separated list of expand items. Each expand item is evaluated relative to the retrieved resource being expanded. An expand item is either a path or one of the symbols * or $value.\n> \n> A path consists of segments separated by a forward slash ( / ). Segments are either names of single- or collection-valued complex properties, or type-cast segments consisting of the qualified name of a structured type that is derived from the type identified by the preceding path segment to reach properties defined on the derived type.\n> \n> A path can end with\n> - the name of a stream property to include that stream property,\n> - a star ( * ) to expand all navigation properties of the identified structured instance, optionally followed by /$ref to expand only entity references, or\n> - a navigation property to expand the related entity or entities, optionally followed by a type-cast segment to expand only related entities of that derived type or one of its sub-types.\n> \n\n\ninstead of\n> expand            = '$expand' EQ expandItem *( COMMA expandItem )\n> \n> expandItem        = STAR [ ref / OPEN levels CLOSE ]\n>                    / \"$value\"\n>                    / expandPath\n>                      [ ref   [ OPEN expandRefOption   \n>                             *( SEMI expandRefOption   ) CLOSE ]\n>                      / count [ OPEN expandCountOption\n>                             *( SEMI expandCountOption ) CLOSE ]\n>                      /         OPEN expandOption\n>                             *( SEMI expandOption      ) CLOSE \n>                      ]\n> \n> expandPath        = [ ( qualifiedEntityTypeName\n>                        / qualifiedComplexTypeName \n>                        ) \"/\" ] \n>                      *( ( complexProperty / complexColProperty ) \"/\" \n>                         [ qualifiedComplexTypeName \"/\" ] )\n>                      ( STAR \n>                      / streamProperty\n>                      / navigationProperty [ \"/\" qualifiedEntityTypeName ]\n>                      )\n> \n> expandCountOption = filter\n>                    / search\n> \n> expandRefOption   = expandCountOption\n>                    / orderby\n>                    / skip \n>                    / top \n>                    / inlinecount\n> \n> expandOption      = expandRefOption\n>                    / select \n>                    / expand\n>                    / compute\n>                    / levels\n>                    / aliasAndValue\n> \n\nNote: all other optional segments are covered in the existing text, intermingled with examples\n\nFor $select:\n> \n> The value of $select is a comma-separated list of select items. Each select item is either a path, a qualified schema name followed by a dot ( . ) and a star ( * ), or just a star ( * ).\n> A path consists of segments separated by a forward slash ( / ). Segments are either names of single- or collection-valued complex properties, or type-cast segments consisting of the qualified name of a structured type that is derived from the type identified by the preceding path segment to reach properties defined on the derived type.\n> A path can end with\n> - the name of a structural property of the identified structured instance,\n> - the name of a navigation property to request navigation links,\n> - the qualified name of a bound action,\n> - the qualified name of a bound function to include all matching overloads, or\n> - the qualified name of a bound function followed by parentheses containing the comma-separated lists of non-binding parameters identifying a single overload.\n> \n\n\ninstead of \n> \n> select         = '$select' EQ selectItem *( COMMA selectItem )\n> \n> selectItem     = STAR                \n>                / allOperationsInSchema \n>                / [ ( qualifiedEntityTypeName\n>                    / qualifiedComplexTypeName \n>                    ) \"/\" \n>                  ] \n>                  ( selectProperty\n>                  / qualifiedActionName  \n>                  / qualifiedFunctionName  \n>                  )\n> \n> selectProperty = primitiveProperty  \n>                / primitiveColProperty \n>                  [ OPEN selectOptionPC *( SEMI selectOptionPC ) CLOSE ]\n>                / navigationProperty\n>                / selectPath\n>                  [ OPEN selectOption *( SEMI selectOption ) CLOSE\n>                  / \"/\" selectProperty\n>                  ]\n> \n> selectPath     = ( complexProperty / complexColProperty ) \n>                  [ \"/\" qualifiedComplexTypeName ]\n> \n> selectOptionPC = filter / search / inlinecount / orderby / skip / top\n> \n> selectOption   = selectOptionPC\n>                    / compute / select / expand / aliasAndValue  \n> \n\nNote: all other optional segments are covered in the existing text, intermingled with examples\n\n\nImported from [ODATA-1165](https://issues.oasis-open.org/browse/ODATA-1165)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "List of use cases for canonical functions is incomplete",
    "body": "Section 5.1.1.4 Canonical Functions states “In addition to operators, a set of functions is also defined for use with the $filter and $orderby system query option.”\n\nThe current ABNF also allows their usage in the productions parameterValue and computeItem.\n\n\n### Proposal\n\nThe set of functions can be used anywhere a common expression is applied such as $filter or $orderby.\n\nImported from [ODATA-1164](https://issues.oasis-open.org/browse/ODATA-1164)",
    "labels": [
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "A Case for Common Expressions",
    "body": "Support of case expressions as known from the SQL standard would add to the ad hoc capabilities and support use cases that require such an IF-THEN-ELSE logic.\n\nImagine case( condition_1 : value_1, ..., condition_N : value_N [, else_value] ) would be available as canonical function for common expressions; an omitted else defaults to null. Here are some examples that could be addressed with it:\n\n1. Core OData: Ad-hoc calculations with logic on the current property values:\nExample: Signum(x)\n\nGET ~/XValues?$compute=case(X gt 0 : 1,X lt 0 : -1, 0) as SignumX&$select=X,SignumX\n\n2. Data Aggregation extension: Restricting aggregation to those values that occur in combination with certain groupable property values:\nExample: Comparing company revenues for years 2000 and 2017\n\nGET ~/Sales?$apply=groupby((Company), aggregate(case(Time/Year eq 2000 : Revenue) with sum as TotalRevenue2000, case(Time/Year eq 2017 : Revenue) with sum as TotalRevenue2017))\n\n3. Data Aggregation extension: Defining dynamic groupable properties\nExample: From a collection of incidents with fine-grained state model (e.g., new, assigned, resolved, verified, reopened, closed) retrieve the aggregated count of open and closed incidents:\n\nGET ~/Incidents?$apply=compute(case(Status eq ‘Closed’ : ‘Closed’, ‘Open’) as ProcessingStatus)/groupby((ProcessingStatus), aggregate($count as IncidentCount))\n\n\n### Proposal\n\nThe case function has the following signatures:\n\n`expression case(Edm.Boolean:expression, ..., Edm.Boolean:expression)`\n` expression case(Edm.Boolean:expression, ..., Edm.Boolean:expression,expression)`\n\nEach Edm.Boolean:expression parameter is a tuple separated by a colon, where the first component evaluates to a Boolean value, and the second component may be an expression of any type.\n\nThe case function returns the expression value of the leftmost parameter, whose first component evaluates to true. If none of the parameters match, case returns null, unless the last parameter is an expression, whose value is returned otherwise.\n\nRevised proposal 2018-4-19: The client SHOULD ensure that all parameter expressions are compatible. If all parameter expressions are of the same type, the type of the case expression is of that type. If all parameter expressions are of numeric type, then the type of the case expression is a numeric type capable of representing any of these expressions according to standard type promotion rules.\n\nServices MAY support case expressions containing parameters of incompatible types, in which case the case expression is treated as Edm.Untyped and its value has the type of the parameter expression selected by the case statement.\n\n*Simplified proposal 2018-08-30*: all parameters are expression pairs with a colon, the \"default\" can be achieved by making the last pair `true:expression`.\n\nImported from [ODATA-1163](https://issues.oasis-open.org/browse/ODATA-1163)",
    "labels": [
      "Protocol",
      "URL Conventions",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Fix data type in example model",
    "body": "Example model in section 2.2 introduces the Time property Year of type Number, which is not an Edm type.\n\n### Proposal\n\nReplace Number by Edm.Int16\n\nImported from [ODATA-1162](https://issues.oasis-open.org/browse/ODATA-1162)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify how to process hybrid results of a transformation in subsequent transformations",
    "body": "Examples for transformations producing hybrid results are groupby(rollup()…) and concat(…). The result may contain entities with properties not present in some other entities of the result. The specification does not describe how hybrid results are processed in subsequent transformations of a transformation sequence.\n\n### Proposal\n\nSection 3.16 Evaluating $apply describes in para 2 how properties that have been aggregated away are treated in $filter and $orderby. \nProposal is to add here: In subsequent transformations, they are treated like in $filter as having the null value. \n\n\nImported from [ODATA-1161](https://issues.oasis-open.org/browse/ODATA-1161)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify example 66 in section 7.5",
    "body": "Readers might infer a name clash from the double usage of “Total” for two dynamic result properties created in adjacent transformation sequences passed to concat.\n\n### Proposal\n\nAdd explanation to example: \nThis example also illustrates the special case that dynamic property names may be reused in different transformation sequences passed to concat.\n\nImported from [ODATA-1160](https://issues.oasis-open.org/browse/ODATA-1160)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify context URLs for aggregated result sets",
    "body": "Aggregated result sets created by $apply may include entities with mixed structures, if transformation concat is involved, either directly or indirectly, for example by a groupby(rollup()). \n\nApart from the general rules for context URLs defined in the OData Protocol specification, the Data Aggregation extension lacks a statement how to cope with context URLs for such hybrid result sets.\n\n\n### Proposal\n\nAdd to section 4 “Representation of Aggregated Instances”:\n\nThe context URL describes the superset of properties occurring in entities of the aggregated result set.\n\n\nImported from [ODATA-1159](https://issues.oasis-open.org/browse/ODATA-1159)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Transformations for limiting the number of entities in the result of a $apply transformation ",
    "body": "Transformation concat combines entity collections returned by two or more transformation sequences in a new, concatenated collection.\n\nFor limiting the number of items returned from the overall result collection, today the only way is to use system query options $skip and $top. It is currently not possible to limit the individual result collections of the transformation sequences passed to concat. \n\nThere are use cases requiring this ability. As an example, consider a request asking for (1) the grand total sales amount along with (2) the sales figures for the first 10 customers. Note that (1) may return a collection with more than one entry in case multiple currencies are involved, hence a global $top does not give full control to the client. In the worst case with more than ten currencies, not a single customer sales amount would be returned. If the aggregated result is put into a stable order with the orderby transformation (described in <issue>), this can be avoided with a top transformation: \n\nGET ~/Sales?$apply=\n    concat( groupby( (Currency), Amount with sum as TotalAmount ),\n            groupby( (Customer,Currency), Amount with sum as TotalAmount )\n            /orderby( Customer,Currency )\n            /top( 10 )\n          )\n\nAnother example also involving a skip transformation could be a request fetching sales amounts per customer and month in pages of ten data points per request, complemented with minimum and maximum amounts of the entities on this page. The request for the fourth page would look like:\n\nGET ~/Sales?$apply=\n    groupby( (Customer,Time/Month,Currency), Amount with sum as TotalAmount ),\n    /orderby( Customer,Time/Month,Currency )\n    /skip( 30 )/top( 10 )\n    /concat( \n         identity, \n         aggregate( Amount with min as MinAmount, Amount with max as MaxAmount ) )\n\n\n### Proposal\n\nDefine transformations skip and top:\n- The skip transformation takes a non-negative integer n as argument that excludes the first n entities of the input set. It returns all remaining entities in the same order as they occur in the input set.\n- The top transformation takes a non-negative integer n as argument and returns the first n entities of the input set, if the input set contains more than n entities, otherwise the entire input set. The entities in the result are in the same order as they occur in the input set.\n\nSince both transformations operate on the order of entities in the input set, the client needs to know how to specify meaningful requests involving these two transformations.\n\nThe transformations preceding skip/top in the sequence must first produce a certain order among the entities, and then keep this order stable for the input set of skip/top. Transformations in the first group are the topXXX and bottomXXX transformations, plus the pending orderby transformation ([ODATA-1157](https://issues.oasis-open.org/browse/ODATA-1157)). The second group consists of transformations identity and compute. The ordering constraint has already described for these transformations. Other transformations should not be restricted by such an ordering constraint to retain the current implementation flexibility. For example, an implementation of the filter transformation might involve efficient search structures that do not keep up the input set order.\n\nImported from [ODATA-1158](https://issues.oasis-open.org/browse/ODATA-1158)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Transformation for sorting entities created by a $apply transformation",
    "body": "Transformation concat allows to create result sets from the output sets of two or more transformation sequences passed to concat as arguments.\n\nIf entities of just one of these sequences shall be sorted, or the output sets shall be sorted differently, this cannot be achieved with the system query option $orderby, which always operates on the entire set produced by $apply.\n\nThis leads to the requirement for a dedicated orderby transformation. An example application is described in https://issues.oasis-open.org/browse/[ODATA-1158](https://issues.oasis-open.org/browse/ODATA-1158).\n\n### Proposal\n\nDefine transformation orderby that takes an expression also valid for the $orderby system query option and returns the entities of the input set in the same order $orderby would produce for the given expression.\n\norderby expression of the orderby transformation conforms to same abnf as the system query option; minimal bar is property path expressions (which can include computed properties) with asc/desc.\n\nImported from [ODATA-1157](https://issues.oasis-open.org/browse/ODATA-1157)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Context URL: allow empty parentheses after navigation property",
    "body": "Section 10.9 Collection of Expanded Entities states that\n\nIf the expanded navigation property does not contain a nested $select or $expand, then the expanded property is suffixed with empty parentheses.\n\nThis is currently not allowed by the ABNF\n\n### Proposal\n\nAllow empty parentheses after navigation properties\n\nImported from [ODATA-1156](https://issues.oasis-open.org/browse/ODATA-1156)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "ABNF: allow omitting default namespaces everywhere in the URL",
    "body": "Section 4.4 Default Namespaces states that\n\n    Functions, actions and types in a default namespace can be referenced in URLs with or without namespace or alias qualification.\n\nThis is currently not reflected fully in the ABNF\n\n### Proposal\n\nRelax ABNF to allow omitting namespaces for\n- functions\n- actions\n- type-cast\nin\n- path\n- query options\n\nBut NOT in the context URL.\n\nImported from [ODATA-1155](https://issues.oasis-open.org/browse/ODATA-1155)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify which OData-Version a service should return",
    "body": "Which OData-Version should a server respond if the client specifies a OData-MaxVersion of 4.01 and the service supports both 4.0 and 4.01?\n\n### Proposal\n\nThe service MUST respond with a payload compliant with the greatest supported version of the protocol that is less than or equal to the request's OData-MaxVersion, if specified. \n\nThe same request should return the same response, so in the absence of an odata-maxversion header, the service should return the same payload over time.  \"If OData-MaxVersion is not specified, then the service SHOULD interpret the request as having an OData-MaxVersion equal to the *initial default* version produced by the service\".\n\nClient is allowed to use 4.01 without specifying an OData-Version or OData-MaxVersion of 4.01. If a request has a payload, a compliant client MUST specify the OData-Version of the request body.\n\nIf the client inspects the metadata to determine the service supports 4.01, and requests a maxversion of 4.01, the proposed general rule requires that the service return 4.01 (we can introduce a min version in the future, if required).\n\nRequest and response payloads are independent. The service must honor OData-MaxVersion in a response regardless of the version of the request payload.\n\nCLARIFICATION FROM 2018-5-4: Regarding \"initial default version\"; our intention was that the behavior of the service did not change over time with respect to a client that does not specify an OData-MaxVersion header.\n\nImported from [ODATA-1154](https://issues.oasis-open.org/browse/ODATA-1154)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Core.Immutable: clarify that value can be provided *by client* in insert",
    "body": "There was a little confusion on whether Immutable was a special case of Computed with the guarantee that the value would be computed on insert and then never changed, e.g. a LastChangedAt\n\n### Proposal\n\nClarify that Immutable means that the value can be provided by the client on insert.\n\nImported from [ODATA-1153](https://issues.oasis-open.org/browse/ODATA-1153)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Align Prefer header rule with RFC7240: optional whitespace around commas",
    "body": "The ABNF rule for the Prefer header does not allow optional whitespace around commas although this is explicitly allowed by RFC7240.\n\n### Proposal\n\nAllow optional whitespace around commas as required by RFC7240\n\nImported from [ODATA-1152](https://issues.oasis-open.org/browse/ODATA-1152)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Edm.Stream and Nullable",
    "body": "Can stream properties be nullable?\n\nIf yes, how would a null value be represented?\n- if expanded: \"streamProp\":null\n- if not expanded: \"streamProp@mediaReadLink\":null, i.e. no link?\n\n### Proposal\n\n1) Expanded returns null\n2) Link is always valid, returns 204 if the value is null\n\nRemark:\n1) is consistent with the representation of structural properties of other primitive type and with expanded single-valued navigation properties\n2) is consistent with directly accessing a property that has the null value, directly accessing the raw value of a property that has the null value, and directly accessing a single-valued navigation property that has no entity related\n- http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingIndividualProperties\n- http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingaPropertysRawValueusingval\n- http://docs.oasis-open.org/odata/odata/v4.01/cs01/part1-protocol/odata-v4.01-cs01-part1-protocol.html#sec_RequestingRelatedEntities\n\n\n\nImported from [ODATA-1151](https://issues.oasis-open.org/browse/ODATA-1151)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Case Sensitivity of Property Names, EntitySets, Singletons and Operations",
    "body": "In 4.01 we add support for case-insensitive system query options, operators, built-in functions and keywords.\n\nWe don't explicitly say whether property, entity set, singleton, or operation names are case-sensitive or case-insensitive\n1) In URLs\n2) In payloads\n\nFor response payloads, we should mandate that properties are written out in the case they are advertised.\n\nIn request payloads, should services support matching property names that differ by case (first looking for a case-sensitive match and, failing that, case insensitive?) or treat as dynamic?\n\nWhat about in URLs? if resolution fails to find an exact match, should it look for a(n unambiguous) case-insensitive match, or treat as a dynamic property?\n\nWhat about instance annotations and thus namespaces and aliases?\n\n\n### Proposal\n\nInteroperable clients MUST specify identifiers (in payloads and URLs) in the case they are specified in $metadata.\n\nServices MUST return identifiers (payloads, contextUrl, etc.) in the case defined in $metadata.\n\nServices SHOULD NOT have identifiers within a uniqueness scope that differ only by case.\n\nServices MAY support case-insensitive comparisons of identifiers in URLs and request payloads if no exact match is found, following the existing precedence rules.\n\nImported from [ODATA-1150](https://issues.oasis-open.org/browse/ODATA-1150)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support Delta responses for Singletons",
    "body": "Today we are a bit unclear about whether or not deltas are supported for singletons.  \n\nIn 11.3 Requesting Changes of the Protocol document, we say:\n\"Any GET request to retrieve one or more entities MAY allow change-tracking.\"\n\nHowever, in 15.1 Delta Response of the JSON document we say:\n\"Responses from a delta request are returned as a JSON object. The JSON object MUST contain an array-valued property named value containing all added, changed, or deleted entities, as well as added links or deleted links between entities, and MAY contain additional, unchanged entities.\"\n\nThe wording from the JSON spec makes sense for 4.0, since changes to related entities and links were represented in a flattened result, but with the ability to represent nested related content, it is useful to support a delta payload (GET or PATCH) for requests anchored on a single node.\n\n\n### Proposal\n\nDeltas can be supported for singletons and single-value navigation properties as well as entities and collection-valued navigation properties.\n\nThe context url for a delta against a singleton (or single-valued nav prop) follows the same pattern of appending /$delta to the context url returned by a request against that singleton (or single-valued nav prop).\n\nThe 4.01 JSON payload for a delta request/response rooted in a single object is the single object with nested changes (i.e., propertyName@delta).\n\nWe don't define a 4.0 JSON format for a delta payload for a request/response rooted in a single object.\n\nImported from [ODATA-1149](https://issues.oasis-open.org/browse/ODATA-1149)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "PATCH with nested nav props should not remove omitted resources",
    "body": "In OData 4.0 we explicitly disallowed deep updates (i.e., including related entities in a PUT or PATCH request).  We did allow binding (through the @bind annotation).\n\nIn OData 4.01 we added the ability to do deep updates, but we are inconsistent with how we describe the behavior.\n\nIn the Protocol document we say that the nested content replaces the existing content, removing any related resources not specified in the payload:\n\n11.4.3.1 Update Related Entities When Updating an Entity (Protocol)\n…\nPayloads with an OData-Version header with a value of 4.01 or greater MAY include nested entities and entity references that specify the full set of currently related entities, or a nested delta payload representing the related entities that have been added, removed, or changed.\n\nIf the nested collection is represented identical to an expanded navigation property, then the set of nested entities and entity references specified in a successful update request represents the full set of entities to be related according to that relationship and MUST NOT include added links, deleted links, or deleted entities.\n\nHowever, this is different than the semantics we describe in section 8.5 of the JSON document (taken from 4.0), which says that the bound items are added, and don't affect the existing relationships:\n\n8.5 Bind Operation (JSON)\n…\nFor update operations a bind operation on a collection navigation property adds additional relationships, it does not replace existing relationships, while bind operations on an entity navigation property update the relationship.\n\nIn fact, for a PATCH operation, most people expect that the membership of the collection-valued nav prop is not replaced, but that specified resources are added or updated.\n\nIt would probably be more intuitive to say that PATCH updates the service with the references in the payload, and that PUT must be used in order to do the replace semantics, or @delta can be used to remove (or upsert) individual entries.\n\n\n### Proposal\n\nFor PATCH operations, nested entities should be upserted. Entities not present in the payload should remain untouched.\n\nFor PUT operations, the set of nested entities should represent the full set of entities to be related upon successful completion of the operation. Related entities missing from the payload are removed from the relationship.\n\nImported from [ODATA-1148](https://issues.oasis-open.org/browse/ODATA-1148)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Annotate a function or action as \"availability is advertised per instance\"",
    "body": "Actions and functions are by default available for all instances unless stated otherwise.\n\nOne way to state this is the term Core.OperationAvailable which currently has to evaluate to true or false.\n\nWhat is missing is a way to say \"availability of this operation cannot be determined up-front, please look into the availability advertising in its representation\".\n\n### Proposal\n\nMake term Core.OperationAvailable nullable and treat null as \"unknown up-front, check advertising in representation\"\n\nImported from [ODATA-1147](https://issues.oasis-open.org/browse/ODATA-1147)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that an enumeration type must have at least one member",
    "body": "Deviating from CSDL V4 and CSDL JSON V4.01 the CSDL XML V4.01 document states that [The edm:EnumType element] MAY contain one or more edm:Member elements defining the members of the enumeration type.\n\n### Proposal\n\nChange to \"MUST contain one or more\", same as in CSDL JSON and CSDL V4.\n\nImported from [ODATA-1146](https://issues.oasis-open.org/browse/ODATA-1146)",
    "labels": [
      "CSDL XML",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Align Authorization vocabulary with OpenAPI V3",
    "body": "Our Authorization vocabulary was defined based on Swagger V2.\n\nOpenAPI V3 changes slightly the way authorization is specified.  In particular, it allows defining authorization flows, and then referencing those flows with a required set of scopes for a particular operation.\n\nOData-884 proposes adding the ability to specify the requests (and corresponding responses) associated with an entity set, singleton, etc. As part of this proposal, it makes sense to be able to associate particular flows and required scopes with those requests.  This can be done by:\n1) Adding a Name to the Authorization type in order to reference a particular authorization, and\n2) Adding a \"SecuritySchemes\" property to the HTTPRequest type that is a collection of authorization/scope requirements for invoking this particular request.\n\n### Proposal\n\n1) Add the following property to the Auth.Authorization complex type:\n\n<Property Name=\"Name\" Type=\"Edm.String\">\n  <Annotation Term=\"Core.Description\" String=\"Name that can be used to reference the authorization flow.\"/>\n</Property>\n\n2) Add the following new complex type to the Auth vocabulary:\n<ComplexType Name=\"SecurityScheme\">\n  <Property Name=\"AuthorizationSchemeName\" Type=\"Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"The name of a required authorization scheme\"/>\n  </Property>\n  <Property Name=\"RequiredScopes\" Type=\"Collection(Edm.String\">\n    <Annotation Term=\"Core.Description\" String=\"The names of scopes required from this authorization scheme.\"/>\n  </Property>\n<ComplexType>\n\n3) Add the following property to the new HTTPRequest type proposed in [ODATA-884](https://issues.oasis-open.org/browse/ODATA-884):\n<Property Name=\"SecuritySchemes\" Type=\"Collection(Auth.SecurityScheme)\">\n  <Annotation Term=\"Core.Description\" String=\"At least one of the specified security schemes are required to make the request. This overrides any SecuritySchemes specified on the EntityContainer.\"/>\n</Property> \n\n4) Add the following term that can be applied to an EntityContainer.\n<Term Name=\"SecuritySchemes\" Type=\"Collection(Auth.SecurityScheme)\" AppliesTo=\"EntityContainer\">\n  <Annotation Term=\"Core.Description\" String=\"At least one of the specified security schemes are required to make a request against the service.\"/>\n</Term>\n\n\n\nImported from [ODATA-1145](https://issues.oasis-open.org/browse/ODATA-1145)",
    "labels": [
      "Vocabularies",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow percent-encoded colon in time values in URLs",
    "body": "The ABNF currently does not allow percent-encoded colons in URLs.\nThis is an unnecessary restriction and collides with the habit of many URL libraries to over-eagerly percent-encode everything except ALPHA and DIGIT.\n\n### Proposal\n\nSplit rules for timeOfDay and dateTimeOffset into a URL variant that allows percent-encoded colons, and a variant for message bodies that requires the unencoded colon.\n\nImported from [ODATA-1144](https://issues.oasis-open.org/browse/ODATA-1144)",
    "labels": [
      "ABNF",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Extend the Property metatype to allow a type that is an EntityType.",
    "body": "This proposal extends Property to allow a type declared as an EntityType or Singleton.\nThis is different from a NavigationProperty with ContainsTarget=True, in that the contained entities are not separately addressable;  (either as a property of the EntityContainer or via its key property values and its EntitySet.)\n\nUsing an EntityType in a property declaration is useful when storing the value of an Entity or collection of Entities, such as in a log or event record.\n\n\n### Proposal\n\nClose without action.\n\nFor the \"log\" or \"event record\" use case a containment navigation property can be used. The contained \"clone\" is by definition different from its \"original\".\n\nImported from [ODATA-1143](https://issues.oasis-open.org/browse/ODATA-1143)",
    "labels": [
      "CSDL JSON",
      "CSDL XML",
      "V4.01_CS02",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify MaxDistance is an optional parameter in hierarchy filter functions",
    "body": "Section 6.3.2.1 describes that functions isdescendant and isancestor both include a second parameter for the maximum distance that is ought to be optional. \n\nThe definitions of these functions in the vocabulary describe the parameters as mandatory.\n\n\n### Proposal\n\nExtend the current definitions to make the maximum distance parameters optional by assigning the maximum possible distance by default (additions are enclosed in *):\n\n<Function Name=\"isdescendant\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\">\n-    \n    <Annotation Term=\"Core.OptionalParameter\"> \n      <PropertyValue Property=\"DefaultValue\" Int=\"32767\"/> \n    </Annotation>\n-    \n  </Parameter>\n  <ReturnType Type=\"Edm.Boolean\"/>\n</Function>\n<Function Name=\"isancestor\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\">\n-    \n    <Annotation Term=\"Core.OptionalParameter\"> \n      <PropertyValue Property=\"DefaultValue\" Int=\"32767\"/> \n    </Annotation>\n-    \n  </Parameter>\n  <ReturnType Type=\"Edm.Boolean\"/>\n</Function>\n\nNote that term OptionalParameter has become available in the Core vocabulary with the work on OData version 4.01.\n\nadd to this proposal:\n  - Use Validation.Minimum on the distance parameter\n- Add meaning of distance to description\n\n\nImported from [ODATA-1142](https://issues.oasis-open.org/browse/ODATA-1142)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Upsert: clarify upsert along nullable single-valued navigation path",
    "body": "Section 11.4.4 Upsert an Entity allows upsert request to any URL that identifies a single entity. It then references section 11.4.2 Create an Entity, which only talks about creating entities in a collection.\n\nThis question also arises in the context of \"deep update\" with nested entities for single-valued navigation.\n\n### Proposal\n\nPUT or PATCH to a single-valued navigation property *reference* (i.e., customers/salesperson/$ref) MUST only include the entity id, and changes which entity is referenced by the navigation property.\n\nPUT or PATCH to a single-valued navigation property (i.e., customers/salesperson) performs an update on the currently related resource. If the value of the navigation property is non-null then any key values are ignored and the referenced entity is updated. If the value of the navigation property is null, for a containment relationship a resource is created (since the single-valued navigation path identifies the resource). For a non-containment relationship, PUT or PATCH to a null single-valued navigation property returns an error.\n\nThe same semantics apply to singletons on the entity container, which are semantically contained single value navigation properties.\n\nImported from [ODATA-1141](https://issues.oasis-open.org/browse/ODATA-1141)",
    "labels": [
      "Protocol",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify: contains, startswith, endswith, indexof should all be case-sensitive",
    "body": "To avoid any possible confusion, we should explicitly state that contains, startswith, endswith, and indexof should do case-sensitive string comparisons.\n\nIt's fairly common practice to use TOUPPER or TOLOWER on the operands in order to do case-insensitive comparisons.\n\n\n### Proposal\n\nClarify the string comparison functions do case-insensitive string compares. \n\nImported from [ODATA-1139](https://issues.oasis-open.org/browse/ODATA-1139)",
    "labels": [
      "URL Conventions",
      "V4.01_CS01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Facilitate processing of aggregated results created with concat",
    "body": "The concat transformation creates a potentially heterogeneous result set consisting of entities with different structures.\n\nThe result is a contiguous list of entities without explicit boundaries to separate the result entities created by one concat parameter from the next. In case an OData client needs to know the concat parameter to which a result entity is related, it has to evaluate the result entities with the same or similar logic expressed in the request a second time.\n\nExample:\nUsing the example model from the Data Aggregation extension, consider a request to retrieve sales amounts grouped by customer for two different subsets of sales entities qualified by complex filter expressions:\n\nGET ~/Sales?$apply=concat(\n\t  filter(<complex expression 1>)/groupby((Customer),aggregate(Amount with sum as Total)),\n \t  filter(<complex expression 2>)/groupby((Customer),aggregate(Amount with sum as Total)))\n\nWhich is the last entity in the result collection that matches complex expression 1?\n\n\n### Proposal\n\nNo action as this can be solved by the client e.g. using compute():\n\nGET ~/Sales?$apply=concat( \nfilter(<complex expression 1>)/groupby((Customer),aggregate(Amount with sum as Total))/compute(1 as concat_index), \n \tfilter(<complex expression 2>)/groupby((Customer),aggregate(Amount with sum as Total))/compute(2 as concat_index)) \n\nImported from [ODATA-1138](https://issues.oasis-open.org/browse/ODATA-1138)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Clarify type information for dynamic properties in the aggregated result set",
    "body": "The JSON and Atom format specifications list special cases where a property value does not need to be complemented with type information using the type(odata.type) instance annotation. The current Data Aggregation specification contains several examples with dynamic properties, where the data type is missing, because they don’t fall into this category: Examples 5, 9, 10, 12, 15, 57, 58, 59, 63, 64, and 70 contain one or more dynamic properties of type Edm.Decimal without a corresponding type annotation required by [OData-JSON].\n\n### Proposal\n\nAdd ellipses (…) to all these examples to make clear that the payload is not complete, but omit the extra instance annotations from the JSON payload examples to preserve their readability. \n\nAdd a disclaimer at the end of section 3: “The JSON representation of dynamic properties in the result will include type (odata.type) annotations as additional control information where required by [OData-JSON]. For brevity, such annotations are omitted from the examples in the following sections.”\nRemove this sentence from sections 3.1 and 3.14: “The JSON representation of these dynamic properties will include odata.type annotations where required by [OData-JSON].”\n\n\nImported from [ODATA-1137](https://issues.oasis-open.org/browse/ODATA-1137)",
    "labels": [
      "Data Aggregation",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow hierarchy filter functions for ancestors and descendants to return true for starting node",
    "body": "The current definitions of the two hierarchy filter functions isancestor and isdescendant specify that the functions return true only if the current entity is a strict ancestor/descendant of the given start node.\n\nPractical applications sometimes require the start node to be included in the result. For this purpose, both functions could be extended by an optional Boolean parameter that allows the OData client to specify, if the start node shall be included in the result. With this, the filter expression $it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA',IncludeParent=”true”) could avoid the clumsier $it/Aggregation.isdescendant(Hierarchy='SalesOrgHierarchy',Node='EMEA') or ID eq 'EMEA'\n\n\n### Proposal\n\nTo stay downward compatible with the current spec, the parameter default value must be false.\n\nExtend the current definitions (additions are enclosed in *):\n\n<Function Name=\"isdescendant\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is a descendant of the given parent node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n*\n  <Parameter Name=\"IncludeParent\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.OptionalParameter\">\n      <PropertyValue Property=\"DefaultValue\" String=\"false\"/>\n    </Annotation>\n  </Parameter>\n*\n  <ReturnType Type=\"Edm.Boolean\"/>\n</Function>\n\n<Function Name=\"isancestor\" IsBound=\"true\">\n  <Annotation Term=\"Core.Description\" String=\"Returns true, if and only if the value of the node property of the specified hierarchy is an ancestor of the given child node with a distance of less than or equal to the optionally specified maximum distance\"/>\n  <Parameter Name=\"Entity\" Type=\"Edm.EntityType\" Nullable=\"false\"/>\n  <Parameter Name=\"Hierarchy\" Type=\"Edm.String\" Nullable=\"false\"/>\n  <Parameter Name=\"Node\" Type=\"Edm.PrimitiveType\" Nullable=\"false\"/>\n  <Parameter Name=\"MaxDistance\" Type=\"Edm.Int16\"/>\n  <ReturnType Type=\"Edm.Boolean\"/>\n*\n  <Parameter Name=\"IncludeChild\" Type=\"Edm.Boolean\">\n    <Annotation Term=\"Core.OptionalParameter\">\n      <PropertyValue Property=\"DefaultValue\" String=\"false\"/>\n    </Annotation>\n  </Parameter>\n*\n</Function>\n\nNote that term OptionalParameter has become available in the Core vocabulary with the work on OData version 4.01.\n\nadd to proposal:\n- extend description by explanation of newly added parameter.\n\nImported from [ODATA-1136](https://issues.oasis-open.org/browse/ODATA-1136)",
    "labels": [
      "Data Aggregation",
      "Vocabularies",
      "V4.0_CSD04"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Document use of JSON Schema $schema",
    "body": "JSON recommends specification of the $schema attribute for validation.\nThe specification silently supports this.\nNeed to make this explicit.\n\n\n### Proposal\n\nClose without action\n\nImported from [ODATA-1135](https://issues.oasis-open.org/browse/ODATA-1135)",
    "labels": [
      "CSDL JSON",
      "V4.01_CS02"
    ],
    "assignees": [],
    "state": "closed"
  },
  {
    "title": "Add KeyAsSegmentSupported annotation term to Capabilities vocabulary",
    "body": "In OData 4.01 we introduced semantics around supporting the popular key-as-segment URL syntax, but we have no generic way for clients to know whether or not the service supports this sytnax.\n\n### Proposal\n\nAdd a new boolean term to the capabilities vocabulary, KeyAsSegmentSupported:\n\n<Term Name=\"KeyAsSegmentSupported\" Type=\"Core.Tag\" DefaultValue=\"True\" AppliesTo=\"EntityContainer\"/>\n\nImported from [ODATA-1134](https://issues.oasis-open.org/browse/ODATA-1134)",
    "labels": [
      "Vocabularies",
      "V4.0_CSD02"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Part 1 protocol clause 1.3 Entity is unclear on template usage",
    "body": "The 10.3 Entity clause provides two templates for context URL.  However, it is not clear on which must be used in various situations.\n\n### Proposal\n\nMake template usage clear for the following 6 cases.\n1. Entity set \\{context-url}#\\{entity-set}\n1. Entity set element \\{context-url}#\\{entity-set}/$entity\n1. Contained NavProperty entity set \\{context-url}#\\{entity-set}\n1. Contained Nav Property singleton \\{context-url}#\\{entity-set}/$entity\n1. Contained NavProperty entity set element \\{context-url}#\\{entity-set}/$entity\n1. Other \\{context-url}#\\{type-name}\n\nImported from [ODATA-1133](https://issues.oasis-open.org/browse/ODATA-1133)",
    "labels": [
      "Protocol",
      "V4.01_ERRATA01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]