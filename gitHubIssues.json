[
  {
    "title": "Annotating an Annotation",
    "body": "In OData we can annotate model data, we can annotated instance data, and we can annotated vocabularies. But currently it's not possible to use a Vocabulary term to annotate an annotation. The following is invalid:\n\n<Record Type=\"UI.DataField\">\n              <PropertyValue Property=\"Label\" String=\"A Picture!\" />\n              <PropertyValue Property=\"Value\" Path=\"Product/ImageOfProduct\" >\n                  <Annotation Term=\"UI.IsImageURL\"/>\n                  <Annotation Term=\"UI.HighResolution\"/>\n              </PropertyValue>             \n</Record>\n\nWe want to use the edm:Annotation element as a child of the dynamic expressions edm:PropertyValue, edm:Record, and edm:Collection.\n\n### Proposal\n\nChange Chapter 15 of the CSDL spec in a way, that  the edm:Annotation element can also be used as a child of the dynamic expressions edm:PropertyValue, edm:Record, and edm:Collection.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-284\n\nImported from [ODATA-284](https://issues.oasis-open.org/browse/ODATA-284)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Accept-Charset HTTP Request Header and charset content-type parameter",
    "body": "The Accept-Charset request header is defined by RFC2616 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2 ), so OData services SHOULD take it into account.\n\nOn the other hand some JSON libraries issue requests with Accept: application/json;charset=utf-n, so OData services SHOULD take that into account, too.\n\nSHOULD is a pain for interoperability, so let's specify MUST.\n\nThere are two ways to specify the charset, so we either have to force servers to reject conflicting statements, or define a precedence rule. The latter is friendlier, so we choose it.\n\nRFC2616 is a standard, and appending a format parameter to the media type is just a practice, so the Accept-Charset header takes precedence.\n\nThe actual charset of a JSON payload can be determined from the first four octets (http://tools.ietf.org/html/rfc4627#section-3 ), so the format parameter is not necessary in the Content-Type header, and servers needn't include it. Again choice for servers is bad, so they MUST NOT include it.\n\n\n### Proposal\n\nSpecify in Part 1: Protocol that:\n- The Accept-Charset request header MUST have priority over a charset= format parameter in the Accept header.\n- The charset= format parameter MUST be taken into account if no Accept-Charset header is provided\n\nRevised from 2013-3-21 meeting:\nThe service MUST NOT return a charset=format parameter unless specified in the request.\nSpecify in JSON Format that: \n- The charset=utf-n format parameter is unnecessary in the Content-Type header as the actual encoding can be determined from the first four octets in the response, see http://tools.ietf.org/html/rfc4627#section-3, so services MUST NOT put it in responses unless specified in the request.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48622/odata-meeting-30_on-20130321-minutes.html#odata-283\n\nImported from [ODATA-283](https://issues.oasis-open.org/browse/ODATA-283)",
    "labels": [
      "JSON Format",
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support individual data modification statements within a batch without wrapping in a changeset",
    "body": "Today the body of a batch request consists of multiple statements that are either individual data request statements or data modification statements grouped within a changeset. The semantics of the changeset are that the data modification statements within the changeset are atomic; either they all succeed or all fail. A batch can contain multiple changesets.\n\nIf the batch submitter wants to submit an individual data modification statement it must be wrapped in a changeset, which adds burden on the client and on the server that must then support changesets even if they don't support multiple atomic operations.\n\nA simplification for the client that may better reflect server functionality would be the ability to include individual data modification statements within the batch, outside of a changeset. That way clients wouldn't have to wrap individual data modification requests in a changeset, and a server that didn't support atomic sets of multiple data modification statements wouldn't support changesets.\n\n### Proposal\n\nSupport individual data modification statements within a batch without wrapping in a changeset.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-282\n\nImported from [ODATA-282](https://issues.oasis-open.org/browse/ODATA-282)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Keep second() as integer, introduce FractionalSeconds",
    "body": "[ODATA-215](https://issues.oasis-open.org/browse/ODATA-215) was originally intended to address the apparent overlap between hour, minute, and second functions for datetimeoffset and duration datatypes, and did so by replacing the not-terribly-useful hour/minute/second functions for duration with a totalseconds function.\n\nAlong the way we also noted that we had no way to represent fractional seconds, and so we changed the return type of the second function for datetimeoffset to return a decimal.\n\nUpon further reflection, I think this is inconsistent; the second portion is a separate portion from fractional seconds, just as day is separate from hour is separate from minute is separate from second. I would instead like to keep second() an integer, and introduce a fractionalsecond function that returns the fractional seconds as a decimal value <1.\n\nThis is more consistent, for example, with how SQL and many programming languages handle parts of datetime functions.\n\n### Proposal\n\nkeep second() for datetimeoffset returning an integer, and add a fractionalseconds function that returns a decimal value <1.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-281\n\nImported from [ODATA-281](https://issues.oasis-open.org/browse/ODATA-281)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support cast segment in $expand",
    "body": "In [ODATA-32](https://issues.oasis-open.org/browse/ODATA-32) we added the ability to do things like filtered expands. We also support filtering collections by type using a CAST segment, and should do the same for $expanded properties.\n\nFor example; \n\n    ~Employees/hr.Managers?$expand=DirectReports\n\ntoday returns only those employees that are managers, and their direct reports.\n\n    ~Employees?$expand=hr.Managers/DirectReports\n\ntoday returns all employees and, for those employees that are managers, all of their direct reports.\n\nWe would also support:\n\n    ~Employees/hr.Managers?$expand=DirectReports/hr.Managers\n\nto return only employees that were managers, and only those direct reports that were also managers.\n\nand\n\n    ~Employees?$expand=hr.Managers/DirectReports/hr.Managers\n\nto return all employees and, for each employee that was a manager, only those direct reports that were also managers.\n\n\n\n\n### Proposal\n\nSupport the cast segment appended to the navigation property in $expand.\n\nThe ABNF construction rules would be:\n\nexpandItem   = [ qualifiedEntityTypeName \"/\" ] navigationProperty \n                         [ \"/\" qualifiedEntityTypeName  ]\n                         [ \"(\" expandOption *( SEMI expandOption ) \")\" ]\n                         [ \"/\" qualifiedEntityTypeName  ]\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-280\n\nImported from [ODATA-280](https://issues.oasis-open.org/browse/ODATA-280)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define URL conventions for addressing functions and function imports",
    "body": "Separating Function from FunctionImport with [ODATA-225](https://issues.oasis-open.org/browse/ODATA-225) was a good idea, now we need to define how these two beasts can be addressed in URLs. \n\n### Proposal\n\nFunctions MUST NOT be used at the service root.\n\nFunction imports MUST NOT be used anywhere except at the service root, especially not in query options or path expressions.\n\nChildren of the default entity container MAY be used without qualifiers in URLs.\n\nChildren of any schema in the metadata document MAY be qualified with the alias defined by the Schema element that defines them.\n\nAll Schema elements within a CSDL document MUST have different values for the Alias attribute.\n\nAliases introduced via the Alias attribute of Schema elements are now document-global and can be used in other schemas of the same document without needing a Using element.\n\nUsing elements MUST NOT introduce clashes with aliases defined by other Using elements of the same schema (we forgot to specify this) or with aliases defined by other Schema elements of the same document.\n\n\n\nSee https://www.oasis-open.org/committees/document.php?document_id=48353&wg_abbrev=odata for details.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-279\n\nImported from [ODATA-279](https://issues.oasis-open.org/browse/ODATA-279)",
    "labels": [
      "ABNF",
      "CSDL XML",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Introduce vocabulary expression edm:Url",
    "body": "In mashup scenarios it is often the case that a third party can detect a rule that allows constructing URLs from information provided in an entity that allow navigation to other resources in the web. \nAnnotations allow to express these construction rules, this construction rules can also be seen as \"special navigation properties defined via annotations\".\n\nWe want to annotate these \"special navigagtion properties\" in a such a way, that they can be used in further annotation similar to native navigation properties.\nIn the following example two navigation properties ( to a supplier and to purchase orders ) and one property is annotated at the product entity type; and they are used in a other annotation. This example is currently invalid, because  the <Url> element isn't specified so far.\nComplete annotation file example (it uses https://tools.oasis-open.org/issues/browse/[ODATA-257](https://issues.oasis-open.org/browse/ODATA-257)):\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<edmx:Edmx Version=\"4.0\" xmlns:edmx=\"http://docs.oasis-open.org/odata/ns/edmx/4.0\">\n  <edmx:Reference Url=\"http://biz.org/odata/foobar/ProductService.srv/$metadata\" />\n  <edmx:Reference Url=\"http://example.org:1234/odata/bar/SupplierService.srv/$metadata\" />\n  <edmx:Reference Url=\"http://somewhere.org/odata/foo/Purchasing.srv/$metadata\" />\n  <edmx:DataServices DataServiceVersion=\"4.0\">\n    <Schema xmlns=\"http://docs.oasis-open.org/odata/ns/csdl/4.0\" Namespace=\"AnnotationCrossReference\" Alias=\"ACR\">\n      <Using Namespace=\"com.sap.erp.products\" Alias=\"ServiceA\" />\n      <Using Namespace=\"com.sap.erp.supplier\" Alias=\"ServiceB\" />\n      <Using Namespace=\"com.sap.foo.purchasing\" Alias=\"ServiceC\" />\n\n      <Term Name=\"DataFieldWithNavigation\" Type=\"DataFieldWithNavigationType\" />\n      <ComplexType Name=\"DataFieldWithNavigationType\">\n        <Property Name=\"Label\" Type=\"String\" Nullable=\"true\">\n          <Annotation Term=\"Core.IsLanguageDependent\" />\n        </Property>\n        <Property Name=\"Value\" Type=\"Edm.PrimitiveType\" Nullable=\"false\" />\n        <Property Name=\"NavigationPath\" Type=\"Edm.NavigationPropertyPath\" Nullable=\"false\" />\n      </ComplexType>\n\n\n      <Term Name=\"Supplier\" Type=\"ServiceB.Supplier\" />\n      <Term Name=\"PurchaseOrders\" Type=\"Collection(ServiceC.PurchaseOrder)\" />\n      <Term Name=\"NumberOfPurchaseOrders\" Type=\"Edm.Int32\" />\n\n\n      <Annotations Target=\"ServiceA.Product\">\n        <Annotation Term=\"Supplier\">\n          <Url>\n            <Apply Function=\"odata.fillUriTemplate\">\n              <!-- ... construct path to ServiceB.Supplier -->\n              <String>http://example.org:1234/odata/bar/SupplierService.srv/Suppliers({suppID})</String>\n              <LabeledElement Name=\"suppID\">\n                <Apply Function=\"odata.UriEncode\">\n                  <Path>SupplierId</Path>\n                </Apply>\n              </LabeledElement>\n            </Apply>\n          </Url>\n        </Annotation>\n        <Annotation Term=\"PurchaseOrders\">\n          <Url>\n            <Apply Function=\"odata.fillUriTemplate\">\n              <!-- ... construct path to a ServiceC.EntiySet of entity type PurchaseOrders -->\n              <String>http://somewhere.org/odata/foo/Purchasing.srv/PurchaseOrders?$search={productID}</String>\n              <LabeledElement Name=\"productID\">\n                <Apply Function=\"odata.UriEncode\">\n                  <Path>ProductKey</Path>\n                </Apply>\n              </LabeledElement>\n            </Apply>\n          </Url>\n        </Annotation>\n        <Annotation Term=\"NumberOfPurchaseOrders\">\n          <Url>\n            <Apply Function=\"odata.fillUriTemplate\">\n              <!-- ... construct path an int value -->\n              <String>http://somewhere.org/odata/foo/Purchasing.srv/PurchaseOrders/$count?$search={productID}</String>\n              <LabeledElement Name=\"productID\">\n                <Apply Function=\"odata.UriEncode\">\n                  <Path>ProductKey</Path>\n                </Apply>\n              </LabeledElement>\n            </Apply>\n          </Url>\n        </Annotation>\n\n\n        <Annotation Term=\"DataFieldWithNavigation\" Qualifier=\"FirstDataField\">\n          <Record>\n            <PropertyValue Property=\"Label\" String=\"Supplier\" />\n            <PropertyValue Property=\"Value\" Path=\"@ACR.Supplier/SupplierName\" />\n            <PropertyValue Property=\"NavigationPath\" NavigationPropertyPath=\"@ACR.Supplier\" />\n          </Record>\n        </Annotation>\n\n        <Annotation Term=\"DataFieldWithNavigation\" Qualifier=\"SecondDataField\">\n          <Record>\n            <PropertyValue Property=\"Label\" String=\"Purchase Orders\" />\n            <PropertyValue Property=\"Value\" Path=\"@ACR.NumberOfPurchaseOrders\" />\n            <PropertyValue Property=\"NavigationPath\" NavigationPropertyPath=\"@ACR.PurchaseOrders\" />\n          </Record>\n        </Annotation>\n      </Annotations>\n\n\n    </Schema>\n  </edmx:DataServices>\n</edmx:Edmx>\n\n### Proposal\n\nIntroduce a edm:Url expression as a child of edm:annotation element:\nThe edm:Url expression enables a value to be obtained by sending a GET request to the edm:Url expression value . A Url expression MUST be assigned a value of the type xs:string see [XML-Schema-2], section 3.2.1.\n\nThe response body of the GET request MUST be returned as the result of the edm:Url expression. The edm:Url expression result MUST be  type compatible with the type expected by the surrounding element or expression.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-278\n\nImported from [ODATA-278](https://issues.oasis-open.org/browse/ODATA-278)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove Collation attribute",
    "body": "It is unclear what use cases this attribute has. If I want to sort a string property like a decimal, why not use Edm.Decimal as its type.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/48549/odata-meeting-29_on-20130314-minutes.html#odata-277\n\nImported from [ODATA-277](https://issues.oasis-open.org/browse/ODATA-277)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Fix issues with entity references and rationalize with $links",
    "body": "In adding Entity References in OData-199, we introduced a few issues.\n\nFirst, we said that clients could return just references, in place of the actual entity, by putting $ref in the select clause. We then said it wasn't valid to include navigation properties with $ref in the select, but not other non-navigation properties. This is a bit arbitrary; the only data that needs to be returned an object is its references to other object(s); if links from those related objects are also of interest, they can be requested and retrieved as related links of those objects. Also, it's a bit strange to use $select for something that changes the type of object returned, from an entity to an entity reference; a path expression would be more suitable for this.\n\nSecond, adding a path representation for relationships gives us a way to rationalize/generalize the special semantics around $links that we have today. We can use the $ref path expression to refer to the links that are added/deleted/enumerated, and provide a consistent representation of an entity reference in the payload (rather than have entity references for referring to entities in one case, and a separate URI construct for referring to entities in another case).\n\n### Proposal\n\n1) Remove navigations from entityref\n2) Move $ref to path. entity/$ref returns the reference to the entity; entityCollection/$ref returns the references to members of the collection. \nExamples:\n    Customer(1)/$ref <=get the entityRef for Customer 1\n    Customers/$ref <=get references for customers\n    Customers?$expand=Orders/$ref <=get customers and the refs for their orders\n    Customers?$expand=Orders($filter=Amount>100)/$ref <=get customers and the ref for orders over $100\n    Employees/Managers?$expand=DirectReports/ns.Manager <=get managers and their directs that are managers (this should work, right? Not affected by proposal)\n    Employees/Managers?$expand=DirectReports/ns.Manager($filter=startswith(LastName,'Bak'))/$ref <=get managers and the entity references for directs that are managers and whose last name starts with 'Bak'\n\n3) Replace uri (in atom) and url (in JSON) with odata.entityRef\n4) $links becomes $ref:\n        POST Customers(1)/$links/Orders {\"uri\":\"Orders(1043)\"} => POST Customers(1)/Orders/$ref {\"odata.entityRef\":\"Orders(1043)\"}\n        POST Customers(1)/$links/Orders {\"uri\":\"Orders(1043)\"} => POST Customers(1)/Orders/$ref <m:entityRef>Orders(1043)</m:entityRef>\n        PUT Orders(1043)/$links/Customer {\"uri\":\"Customers(1)\"} => PUT Orders(1043)/Customer/$ref {\"odata.entityRef\":\"Customers(1)\"}\n        PUT Orders(1043)/$links/Customer {\"uri\":\"Customers(1)\"} => PUT Orders(1043)/Customer/$ref <m:entityRef>Customers(1)</m:entityRef>\n        DELETE Customers(1)/$links/Orders(1043) => DELETE Customers(1)/Orders(1043)/$ref\n        DELETE Orders(1043)/$links/Customers(1) => DELETE Orders(1043)/Customer/$ref\n\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-276\n\nImported from [ODATA-276](https://issues.oasis-open.org/browse/ODATA-276)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether binding parameters for actions and functions can be nullable",
    "body": "Bindable actions and functions take an entity or collection of entities as their first parameter. We did not explicitly state that this binding parameter must not be nullable, but it's rather hard to imagine a use case for applying a bindable function or action to \"nothing\".\n\n### Proposal\n\nExplicitly state that they can be nullable\n\nAccepted: https://www.oasis-open.org/committees/download.php/48549/odata-meeting-29_on-20130314-minutes.html#odata-275\n\nImported from [ODATA-275](https://issues.oasis-open.org/browse/ODATA-275)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "OData clients should always use PATCH, deprecate PUT",
    "body": "PUT semantics call for setting to null any properties not specified in the payload. PATCH semantics apply the specified properties but leave unspecified properties unchanged.\n\nSpecifying that clients ALWAYS use PATCH for updates is much safer for round-tripping data. For example, open properties, aggregated values, additive schema changes, and computed projections could all add additional properties to the payload that the client should be able to safely ignore. If the client uses PATCH to update then they do not lose information, but if the client ignores properties and uses PUT to update they will likely lose data in round-tripping.\n\nOData clients should always use PATCH when doing updates.\n\n### Proposal\n\nState that Servers that support update MUST support PATCH, and clients SHOULD always use PATCH to update entities.\n\nServers MAY additionally support PUT, but should be aware of the possibility for data loss in round tripping.\n\nMotion from 2013-3-7: Resolve [ODATA-274](https://issues.oasis-open.org/browse/ODATA-274) as proposed, with the additional clarification from comments that the listed additive changes should be allowed without versioning the service and that clients should be prepared to be resilient to such changes.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-274\n\nImported from [ODATA-274](https://issues.oasis-open.org/browse/ODATA-274)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify whether derived types MUST introduce new properties",
    "body": "The current prose spec requires complex types to define one or more properties even if it inherits from a base type.\nFor entity types that's not required: it is explicitly stated that they only must have at least one property if they do not specify a base type.\n\nThe XML Schema for CSDL does NOT require complex types to have at least one Property child element, which is consistent with entity types\n\n### Proposal\n\nRephrase section 8.1 The edm:ComplexType element to:\n\nThe edm:ComplexType element represents a complex type in an entity model.\nThe complex type MUST declare a SimpleIdentifier value for the Name attribute.\nIf no base type is specified, the edm:ComplexType element MUST contain one or more edm:Property elements describing the properties of the complex type. \nIf a base type is specified, the edm:ComplexType element MAY contain zero or more edm:Property elements describing additional properties of the derived complex type.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-273\n\nImported from [ODATA-273](https://issues.oasis-open.org/browse/ODATA-273)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove FixedLength facet",
    "body": "The prose text erroneously states that FixedLength takes an integer argument specifying the fixed length. In fact it is just a boolean telling that the length specified with the MaxLength attribute is always used.\n\nI wonder whether we really need this. Actually, I think we don't need it.\n\n### Proposal\n\nRemove FixedLength facet\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-272\n\nImported from [ODATA-272](https://issues.oasis-open.org/browse/ODATA-272)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support IsAlwaysBindable through annotation, rather than attribute of function/action",
    "body": "Functions (and Actions) have a complicated set of attributes, some of which don't really specify the function but rather is used for optimizations around when/how it needs to be advertised. In particular, IsAlwaysBindable is an attribute that serialization may use to omit functions from the payload if they are always bindable and can be called following convention. Such information is better suited to an annotation than an attribute.\n\n### Proposal\n\nRemove the IsAlwaysBindable attribute. Do not add annotation. JSON may always omit bindable functions and actions for odata.metadata=minimal/none unless explicitly requested in Select.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48752/odata-meeting-31_on-20130404-minutes.html#odata-271\n\nImported from [ODATA-271](https://issues.oasis-open.org/browse/ODATA-271)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Collections of Edm.PrimitiveType are problematic in JSON",
    "body": "In adding Edm.Primitive as a type specifying \"any primitive type\" we introduced a problem for JSON. We have no way to annotate individual elements of a JSON array, so we have no way of specifying the types of a heterogeneous collection of primitive types. In some cases these might be heuristically determined, but not all. We might consider disallowing collections of Edm.Primitive as being underspecified. In the future it would be non-breaking to add these as long as we solved the primitive types in a json array problem.\n\n### Proposal\n\nDisallow the use of Collection(Edm.Primitive) and Collection(Edm.ComplexType)\n\nAccepted: https://www.oasis-open.org/committees/download.php/48549/odata-meeting-29_on-20130314-minutes.html#odata-270\n\nImported from [ODATA-270](https://issues.oasis-open.org/browse/ODATA-270)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Separate Functions and Actions",
    "body": "In [ODATA-225](https://issues.oasis-open.org/browse/ODATA-225) we moved function definition out of the EntityContainer by introducing a new Function element. We should take this opportunity to clean up the confusion between actions (which may be side-effecting and are not composable) from functions (which must not be side-effecting and may be composable). Previously these were differentiated by an isSideEffecting attribute on the FunctionImport, and depending on whether this was set other attributes (like isComposable) were or were not valid.\n\n### Proposal\n\n-Remove isSideEffecting from edm:Function\n-Add emd:Action with attributes name, returntype, isbindable, isalwaysbindable, entitysetpath (iscomposable doesn't apply to actions)\n-Add edm:ActionImport as child to entitycontainer, with same structure as edm:FunctionImport\n-remove confusing wording around determining whether a function is an action or function depending on iscomposable, and what attribute combinations are valid.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-269\n\nImported from [ODATA-269](https://issues.oasis-open.org/browse/ODATA-269)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Use http://docs.oasis-open.org/odata/ns/edm as the EDM namespace URL",
    "body": "Currently we use \thttp://docs.oasis-open.org/odata/ns/csdl/4.0 as the namespace URL for the EDM namespace.\n\nAs CSDL consists of EDMX plus EDM, it is confusing to have the name of the whole as an infix in the namespace for a part.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-268\n\nImported from [ODATA-268](https://issues.oasis-open.org/browse/ODATA-268)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Qualifier attribute on Annotation elements within an Annotations element that does NOT specify a Qualifier attribute",
    "body": "Currently the Qualifier attribute is only allowed for Annotation elements that are \"inlined\" within their target model element, and forbidden when nested within an Annotations element.\n\nWhile this makes some sense for qualifier values like UI.Device.Slate and UI.Device.Phone, it makes less sense for qualifiers like VCard.Type.Work and VCard.Type.Home. Separating these into several Annotations elements that targets the same model element makes getting the full picture actually harder.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-267\n\nImported from [ODATA-267](https://issues.oasis-open.org/browse/ODATA-267)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Strengthen the requirements for the URL Attribute in edmx:Reference and edmx:AnnotationReference",
    "body": "Currently in sub-chapter 4.4.1 and 4.3.1 of the csdl part 3 specification is stated that \"The URL may be backed by a CSDL document describing the referenced model. Alternatively, the URL may be used to load a well-known model from a different location.\"\n\nIf the URL is NOT backed by  a document, it's impossible for consumer with out -of-band knowledge to find the document.\n\n### Proposal\n\nChange in subchapter 4.4.1 and 4.3.1 of the csdl part 3 specification the sentence \"The URL may be backed by a CSDL document describing the referenced model\" to \"The URL SHOULD be backed by a CSDL document describing the referenced model\". If it's NOT backed, it should be well known.\n\nREMARK: Consumers can load models they already known anyhow from a different location.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48622/odata-meeting-30_on-20130321-minutes.html#odata-266\n\nImported from [ODATA-266](https://issues.oasis-open.org/browse/ODATA-266)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow omitting key properties from PUT and PATCH request bodies and from nested entities in deep-insert requests",
    "body": "\n\n### Proposal\n\nIn PUT and PATCH requests key properties can't be changed, and their immutable value can be derived from the request URL, so they MAY be omitted from the request body.\n\nIn POST requests properties that are marked as \"store generated\", i.e. the server determines their value, MAY be omitted from the request body.\n\nIn deep-insert requests the key properties of nested entities that are tied to key properties of the enclosing entity by a referential constraint MAY be omitted from the request body.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-265\n\nImported from [ODATA-265](https://issues.oasis-open.org/browse/ODATA-265)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow omitting parent key(s) in URLs to contained children",
    "body": "Containment allows specifying \n\n### Proposal\n\nIf a navigation property leading to a related entity type has a partner navigation property that specifies a referential constraint, then those key properties of the related entity that take part in the referential constraint MAY be omitted from URLs.\n\nExample: Order contains OrderItem, key of Order is ID, key of OrderItem is OrderID and ItemNo, with a referential constraint tying the value of the OrderID key property of the OrderItem to the value of the ID property of the Order. Then the following URLs are equivalent:\n\n~/Orders(1)/Items(OrderID=1,ItemNo=2)\n~/Orders(1)/Items(2)\n\nIf the constrained key part is specified then it MUST match the parent.\nIf the key is included in the content it must be ignored.\nThis should apply any time there is a referential constraint\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-264\n\nImported from [ODATA-264](https://issues.oasis-open.org/browse/ODATA-264)",
    "labels": [
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define whether $select=* returns only structural properties or also navigation properties",
    "body": "The URL conventions state that \n\n    If the selectItem is a star, then all properties and navigation properties on the matching resources MUST be returned.\n\nThis conflicts with the JSON format which by default does not return navigation properties and only includes them when odata.metadata=full is requested.\n\nThe recent enhancements to $expand which allows nesting e.g. a $select further reduces the need for $select=*, so it's best to remove it altogether.\n\n### Proposal\n\n$select=* only returns structural properties and excludes navigation properties, actions and functions\n\nAccepted: https://www.oasis-open.org/committees/download.php/48752/odata-meeting-31_on-20130404-minutes.html#odata-263\n\nImported from [ODATA-263](https://issues.oasis-open.org/browse/ODATA-263)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Improve section 10.2.3.8 The $format System Query Option",
    "body": "\n\n### Proposal\n\n- Explicitly state that media types can be used in addition to the shorthand values atom, json, and xml.\n- Explicitly state that parameters like odata.metadata=full can only be appended to the full media type like application/json.\n- Remove last part of section stating that $format can be used in conjunction with $value: this doesn't make sense any more as $value uses the literal form defined in the ABNF, which is now also the literal form used by both Atom and JSON.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-261\n\nImported from [ODATA-261](https://issues.oasis-open.org/browse/ODATA-261)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Make explicit that DELETE on an entity may implicitly change links to and from other entities",
    "body": "There's some confusion of whether invoking DELETE on an entity will also implicitly links to/from other entites, or whether these have to be explicitly removed with operations on /$links/.\n\n### Proposal\n\nSee summary: no need to first modify $links before deleting an entity; server can do that implicitly to preserve its referential constraints.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-260\n\nImported from [ODATA-260](https://issues.oasis-open.org/browse/ODATA-260)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add Annotation Groups to JSON format",
    "body": "Annotation values may vary per entity, so they can be included in the JSON representation if they deviate from the default specified in $metadata.\n\nA common case is that the lifecycle of an entity is decribed by a finite and typically small set of states, and that some or all instance annotations depend on the state only.\n\nSo it would really compress JSON responses if the response could define several named groups of annotation values and refer to them in other entities.\n\nExample: as long as an order item hasn't been shipped, its quantity and delivery address can be updated. Once it has been shipped these properties become read-only. The first order item in state \"shipped\" defines an annotation group named \"Shipped\" that annotates the quantity- and address-related properties as read-only. Subsequent \"shipped\" items only refer to that group without having to repeat all annotations in that group.\n\n### Proposal\n\nDefining this right is tricky. Since this is an incremental optimization I would suggest we defer to a future version.\n\nImported from [ODATA-259](https://issues.oasis-open.org/browse/ODATA-259)",
    "labels": [
      "JSON Format",
      "wontDo"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "not_planned"
  },
  {
    "title": "Advertise function imports in service document",
    "body": "The service document is an entry point for hypermedia-driven clients, so function imports that can be called \"directly from the service root\" should also be advertised.\n\nFunction imports that require a binding parameter don't fall into that category.\n\nIdeally the advertised function imports would require no parameters to be passed, i.e. only have parameters with default values or no parameters at all, so they behave to GET requests similar to named entities and entity sets.\n\nAs in real life we also encounter entity sets that e.g. respond with errors if queried without a sufficiently selective $filter query parameter, I hesitate to make \"only parameters with default values\" a requirement for being advertised.\n\n### Proposal\n\n1. Define a new boolean attribute to FunctionImport called \"IncludeInServiceDocument\", valid only on parameterless functions. If present, with a value of \"True\", the function import is advertised in the service document\n2. Define a new kind \"FunctionImport\", in ATOM and JSON, for exposing parameterless functions\n3. Clarify that the service SHOULD NOT expose entitysets that cannot be navigated using only the supplied href.\n\nExamples:\n\n{\n  \"odata.metadata\": \"http://host/service/$metadata\",\n  \"value\": [\n    { \n      \"name\": \"Orders\",\n      \"kind\": \"EntitySet\"\n      \"url\": \"Orders\"\n    },\n    {\n      \"name\": \"TopProducts\",\n      \"kind\": \"Function\"\n      \"url\": \"TopProducts\"\n    },\n    {\n      \"name\": \"Contoso\",\n      \"kind\": \"Entity\"\n      \"url\": \"Contoso\"\n    }\n  ]\n}\n\nAs approved from 2013-2-21 TC meeting:\nI move to resolve [ODATA-258](https://issues.oasis-open.org/browse/ODATA-258) as proposed with the addition of also advertising children of non-default entity containers, using workspaces in AtomPub and qualified names in JSON\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-258\n\nImported from [ODATA-258](https://issues.oasis-open.org/browse/ODATA-258)",
    "labels": [
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define standard client-side function for filling URL templates (RFC6570)",
    "body": "In mashup scenarios it is often the case that a third party can detect a rule that allows constructing URLs from information provided in an entity that allow navigation to other resources in the web.\n\nAnnotations allow to express these construction rules via the odata.concat client-side function, but that can become tedious if the URL patterns to construct are non-trivial.\n\nRFC6570 (http://tools.ietf.org/html/rfc6570) defines a simple notation for URL templates and a simple set of rules on how to translate the template and a set of variable values into a URL.\n\n### Proposal\n\nDefine a client-side function odata.fillUriTemplate that takes two or more arguments.\n\nThe first argument MUST be of type String and specifies the URL template, the other arguments MUST be LabeledElement expressions that specify the template parameter name and evaluate to the template parameter value.\n\nRFC6570 defines three kinds of template parameters: simple values, lists of values, and key-value maps.\n\nSimple values are represented as LabeledElement expressions that evaluate to a single primitive value. The literal representation of this value according to ODATA-ABNF is used to fill the corresponding template parameter.\n\nLists of values are represented as LabeledElement expressions that evaluate to a collection of primitive values.\n\nKey-value maps are represented as LabeledElement expressions that evaluate to a collection of complex types with two properties that are used in lexicographic order. The first property is used as key, the second property as value.\n\n\nDefine a second client-side function odata.uriEncode that takes one argument of primitive type and returns the URL encoded literal that can be used as a key value in OData URLs or in the query part of OData URLs.\n\n\nExample:\nIn case you KNOW that there are no special characters in Genre names:\n\n<Apply Function=\"odata.fillUriTemplate\">\n  <String>http://odata.netflix.com/v2/Catalog/Genres('{genreName}')</String>\n  <LabeledElement Name=\"genreName\" Path=\"NameOfMovieGenre\" />\n</Apply>\n\n\nExample:\nIf you want to be on the safe side:\n\n<Apply Function=\"odata.fillUriTemplate\">\n  <String>http://odata.netflix.com/v2/Catalog/Genres('{genreName}')</String>\n  <LabeledElement Name=\"genreName\">\n    <Apply Function=\"odata.uriEncode\" >\n      <Path>NameOfMovieGenre</Path>\n    </Apply>\n  </LabeledElement>\n</Apply>\n\nWe also need to make sure we reserve odata. for names of apply functions.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-257\n\nImported from [ODATA-257](https://issues.oasis-open.org/browse/ODATA-257)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify numeric data types",
    "body": "Computer history has provided us with a growing number of numeric data types, and quite a few of them are reflected in Edm primitive types.\n\nInteger types:\n- Byte (0..2^8)\n- SByte\n- Int16\n- Int32\n- Int64\n- Decimal Scale=0\n\nFixed-point types\n- Decimal with VariableScale=\"false\", see [ODATA-76](https://issues.oasis-open.org/browse/ODATA-76)\n\nFloating-point types\n- Decimal with VariableScale=\"true\", see [ODATA-76](https://issues.oasis-open.org/browse/ODATA-76)\n- Single\n- Double\n\nEspecially for defining vocabularies it would be helpful to have an abstract type Edm.Number that can be applied to any of the numeric primitive types.\n\n\n\n### Proposal\n\nClose without action\n\nAccepted: https://www.oasis-open.org/committees/download.php/48549/odata-meeting-29_on-20130314-minutes.html#odata-256\n\nImported from [ODATA-256](https://issues.oasis-open.org/browse/ODATA-256)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Selection of individual properties in [ATOM] should not include property name",
    "body": "Currently, the example in Section 10 of [ATOM] implies that when selecting a single property (i.e., ~Customers('ALFKI')/FirstName), the payload would contain the name of the property in the d: namespace:\n\n    <Title xmlns=\"http://schemas.microsoft.com/ado/2007/08/dataservices\">CEO<Title> \n\nThis implies that what is represented is a property with a given name, which is not the case; what should be represented is the *value* of the property, which is independent of the property itself (and can thus be used, for example, in passing as a parameter to an action). This is also inconsistent with how a function that returns a single property is represented, and is inconsistent with the JSON format (which represents this as a name/value pair with the name \"value\").\n\nWe should specify that an individual property is serialized in ATOM as an element named \"value\" in the odata metadata namespace. \n\n### Proposal\n\nSpecify in Section 10 of [ATOM] that an individual property is serialized as an element named \"value\" in the odata metadata namespace (that may contain metadata:type and metadata:null attributes, following the same rules as the d:<propertyname> element (which should be updated in 5.1.11.1 to include the metadata:null attribute) and correct examples in Section 10 and 11 accordingly.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-254\n\nImported from [ODATA-254](https://issues.oasis-open.org/browse/ODATA-254)",
    "labels": [
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clients should be prepared to handle unadvertised properties",
    "body": "Clients today may see unadvertised properties if a type is marked as open, but open also implies that the client can store properties not defined as part of the type definition.\n\nFor extensibility, services should be allowed to return properties not advertised in metadata without marking the type as open (and implying that the service is capable of persisting properties arbitrary properties). This would allow, for example, $select to contain an expression, aggregations to return aggregated values, etc.\n\nWe need to define the semantics of these unadvertised properties; i.e., must they be reflected back in a PUT (unless they are annotated as read-only) in order to prevent data loss when roundtripping\n\nNote that, for a request against an open type, the client would have no way of knowing if the property were a dynamic property (which would require specifying in PUT to avoid overwriting) or a property defined, i.e., in $select (which should not be specified in a PUT - note that the server cannot ignore these added properties in general because, if the type is marked as open, the server has no way to know how to distinguish between the client echoing back a read-only property (such as a projected expression) and the client attempting to persist a new open property. \n\n### Proposal\n\n1) Define a ReadOnly instance annotation (i.e., as part of our core vocabulary.)\n2) State that clients should be prepared to receive additional properties in an entity/complex type that are not advertised in metadata, even for types not marked as open. Such properties MUST be included in a PUT request in order to avoid data loss, unless they are annotated as read-only in which case they MUST NOT be included.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-253\n\nImported from [ODATA-253](https://issues.oasis-open.org/browse/ODATA-253)",
    "labels": [
      "Protocol",
      "Vocabularies",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify ordering of instance annotations in [ATOM] and [JSON]",
    "body": "annotations logically come as part of the thing that they are annotating. Some annotations are required in order to correctly interpret the thing being annotated (i.e., odata.type), while other annotations may not be available until the thing being annotated is materialized (i.e., odata.nextlink).\n\nIn order to support efficient streaming, OData should define for [ATOM] and (streaming) [JSON] that annotations must immediately precede properties, and must precede or follow entries, links and feeds.\n\n### Proposal\n\nClarify in [ATOM] and (streaming) [JSON] that annotations must immediately precede properties, and must precede or follow entries, links and feeds.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-252\n\nImported from [ODATA-252](https://issues.oasis-open.org/browse/ODATA-252)",
    "labels": [
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify, within [ATOM], that complex types can be annotated",
    "body": "The description of instance annotations in section 8 of [ATOM] states that \"Annotations may be applied to an instance of a feed, entity, property, function, action, or error within an Atom payload.\"\n\nThis statement should include complex types (for example, if an array of complex types is returned from a function).\n\n### Proposal\n\nAdd \"Complex Types\" to the list of things in Section 8 of [ATOM] to which an instance annotation may be applied.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-251\n\nImported from [ODATA-251](https://issues.oasis-open.org/browse/ODATA-251)",
    "labels": [
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "For instance annotations in Atom, \"Annotation\" element, \"Type\", \"Term\" and \"Target\" attributes should be lower case",
    "body": "In the current [ATOM] spec, the \"Annotation\" element, as well as the child \"Type\", \"Term\" and \"Target\" attributes are defined in upper  case. This is inconsistent with other element that we define in the ATOM payload (for example, the metadata:function element with attributes \"metadata\" \"target\" and \"title\", the metadata:error element and its attributes, etc.). \n\n### Proposal\n\nMake the \"Annotation\" element, as well as the \"Type\" \"Term\" and \"Target\" attributes lower case.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-250\n\nImported from [ODATA-250](https://issues.oasis-open.org/browse/ODATA-250)",
    "labels": [
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "\"Kind\" property should be optional for EntitySets in JSON Service Documents",
    "body": "In JSON, service documents are returned as an array containing objects that represent entitysets and named entities, as shown below. By far the most common of these is \"EntitySet\", which is consistent with legacy OData services. We should make the \"kind\" property optional for objects in the service document that represent entity sets.\n\n{\n  \"odata.metadata\": \"http://host/service/$metadata\",\n\"value\": [\n    { \n      \"name\": \"Orders\",\n      \"kind\": \"EntitySet\"\n      \"url\": \"Orders\"\n    },\n    {\n      \"name\": \"OrderDetails\",\n      \"kind\": \"EntitySet\"\n      \"url\": \"OrderDetails\"\n    },\n    {\n      \"name\": \"Contoso\",\n      \"kind\": \"Entity\"\n      \"url\": \"Contoso\"\n    }\n  ]\n}\n\n\n### Proposal\n\nMake the \"kind\" property optional for objects within a JSON Service Document that represent entity sets.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-249\n\nImported from [ODATA-249](https://issues.oasis-open.org/browse/ODATA-249)",
    "labels": [
      "JSON Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define required/optional format(s) for OData",
    "body": "We need to define what format(s), if any, are required for a service to be OData \"Conformant\", and which are optional.\n\nFor example, we could say that JSON is required, and ATOM is optional, meaning a service that supported only ATOM would not be conformant. This would help clients but might prevent some services from being compliant. Also, if we added another format (say, RDF), it would prevent a service from implementing just RDF and claiming conformance.\n\nWe could, fore example, say that a service SHOULD support JSON for maximum interoperability, but not make it required. Or perhaps we can define levels of conformance.\n\n### Proposal\n\nOData services must support ATOM or JSON. In order to comply with the highest level of conformance they must support JSON.\n\nImported from [ODATA-248](https://issues.oasis-open.org/browse/ODATA-248)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "More clearly define extensibility of Formats",
    "body": "The ATOM format already says, in section 15, that additional payload may be returned anywhere supported by Section 6 of [RFC4287], but that extensions must not be in the OData namespaces and should not be required to be understood by the client in order for the payload to be correctly interpreted.\n\nIn ATOM we should be clear that this means that the service may return additional children of the <feed> or <entry> elements, and that it is safe for the client to ignore anything (in any namespace, including the odata namespace) not defined in the version of the payload being returned. This allows for forward compatibility of incremental information without rev'ing the payload version.\n\nIn JSON we should be clear that clients should ignore annotations (in any namespace, including the odata namespace), as well as objects with an odata.kind, that are not defined in the version of the payload being returned.\n\n### Proposal\n\nAdd to [Core] that client should be prepared to handle (and can safely ignore) unknown annotations, including those with the odata prefix but not defined in the current version of the payload.\n\nAdd to [ATOM] that clients should be prepared to handle (and can safely ignore) additional elements or attributes in any namespace, including elements and attributes in the odata namespace and annotations prefixed with odata, that are not defined in the version of the payload being returned.\n\nAdd to [JSON] that clients should be prepared to handle (and safely ignore) annotations in any namespace, including the odata namespace and objects with an odata.kind that are not defined in the version of the payload being returned.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-247\n\nImported from [ODATA-247](https://issues.oasis-open.org/browse/ODATA-247)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "IDs should be dereferenceable URIs",
    "body": "In OData, entity instances have unique ids.\n\nIn addition, ATOM defines selflinks, for refreshing the contents of an entry, and editlinks for updating the contents of an entry. In our JSON format we have said that the self/edit links are only written if they are different from the ID, and the ID is not written if it can be generated from the payload based on conventions (i.e., if the payload contains the key fields, and the service supports the convention for looking indexing a set by key, such as ~/Customers('ALFKI').\n\nIds can also be used in place of entries in navigation links to reduce payload size, in deltas to represent relationships and deleted entries, and can be explicitly selected using $ref.\n\n$links, on the other hand, returns a \"canonical URL\" for the related entity.\n\nIn order to be a better citizen of the Semantic Web, in addition to supporting the types of optimizations that we have in JSON and other uses of ids, we should state that IDs are URIs and recommend to service implementers that those URIs be dereferenceable. Then we can say that the URLs returned by $links are the same as the values returned by $id, etc.\n\n### Proposal\n\nspecify that Ids SHOULD be dereferenceable, and SHOULD match the linkURLs returned by $links\n\nAccepted: https://www.oasis-open.org/committees/download.php/48549/odata-meeting-29_on-20130314-minutes.html#odata-246\n\nImported from [ODATA-246](https://issues.oasis-open.org/browse/ODATA-246)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "any() and all() are missing from Core Part I/Protocol and Core Part 2/URL Conventions",
    "body": "any() and all() are popular functions for filtering a set based on membership of subcollections. These functions are part of the ABNF construction rules but are not described anywhere and do not appear in the list of canonical functions that can be used in $filter/$sort.\n\nFor example:\n    http://host/service.svc/Orders?$filter=OrderLines/any(ol: ol/Quantity gt 10)\n\nreturns Orders that have any Orderlines with a Quantity greater than 10.\n\nand:\n    http://host/service.svc/Orders?$filter=OrderLines/all(ol: ol/Quantity gt 10)\n\nreturns Orders for which all Orderlines have a Quantity greater than 10.\n\n### Proposal\n\nAdd any() and all() to the list of canonical functions, describe and provide examples of their usage.\n\nImported from [ODATA-245](https://issues.oasis-open.org/browse/ODATA-245)",
    "labels": [
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support navigation properties on complex types",
    "body": "Today navigation properties must be direct children of the entity. We should support navigation properties being defined on properties grouped into a complex type. For example:\n\n<ComplexType Name=\"Address\">\n    <Property Name=\"Street\" Type=\"Edm.String\" />\n    <NavigationProperty Name=\"City\" Type=\"MyModel.City\" />\n    <NavigationProperty Name=\"Region\" Type=\"MyModel.Region\" />\n    <NavigationProperty Name=\"Country\" Type=\"MyModel.Country\" />\n</ComplexType>\n\nIf a type <Person> has an Address, then you could express the navigation property binding as:\n\n<EntitySet Name=\"People\" Type=\"Person\">\n    <NavigationPropertyBinding Path=\"Address/City\" EntitySet=\"Cities\"/>\n    <NavigationPropertyBinding Path=\"Address/Region\" EntitySet=\"Regions\"/>\n    <NavigationPropertyBinding Path=\"Address/Country\" EntitySet=\"Countries\"/>\n</EntitySet>\n\n\n### Proposal\n\nSupport defining navigation properties within complex types.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-244\n\nImported from [ODATA-244](https://issues.oasis-open.org/browse/ODATA-244)",
    "labels": [
      "ABNF",
      "CSDL XML",
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Add client preferences for server-driven paging",
    "body": "Currently, the server solely decides whether or not to apply server-driven paging on the result set, and clients are expected to handle next-links returned as part of a partial result. Methods should be introduced to allow clients to adapt this paging mode to their needs.\n\nFirst, if clients could indicate their preference to apply server-driven paging for fetching the result, then the server would have more knowledge about potential subsequent client interactions. The server could leverage it by preparing a result set that remains stable over the different page accesses. This cannot be achieved by client-side paging in any way.\n\nSecond, the client is currently expected to handle next-links as they occur, but cannot control the page size. A preference to specify the maximum number of entries returned in a server page would allow clients to consider boundary conditions of their runtime infrastructure.\n\n\n### Proposal\n\nAdd preference value odata.maxpagesize that takes a positive integer as argument.\nThe client MAY add this preference to GET requests following the next-link with a different page size as specified in previous requests.\nThe server MAY ignore this change of preference.\n\nExample: client wants server to return pages of size 10:\n\nPrefer: odata.maxpagesize=10\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-243\n\nImported from [ODATA-243](https://issues.oasis-open.org/browse/ODATA-243)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Path expressions also for annotations targeting an entity container",
    "body": "This would allow navigation into a named entity or an entity set for terms that provide semantic information spanning more than one named entity or entity set (not that I can think of a use case right now).\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-242\n\nImported from [ODATA-242](https://issues.oasis-open.org/browse/ODATA-242)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Consistently require annotations to be placed at the end of the annotated CSDL element",
    "body": "Currently most CSDL elements allow annotations as the last child elements, while some allow them intermingled with their \"standard\" child elements.\n\nA consistent reading order would be\n\nElement\n - Documentation (0..1)\n - other child elements\n - Annotation (0..unbounded)\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-241](https://issues.oasis-open.org/browse/ODATA-241)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Better describe, and possible extend, expected behavior of dealing with async $batch requests",
    "body": "$batch used to return a 202 accepted to indicate it accepted the $batch request even though it might not have read, let alone processed, all the requests in the batch request. This 202 accepted response conflicted with the use of 202 for asynchronous requests; this has been dealt with in [ODATA-233](https://issues.oasis-open.org/browse/ODATA-233).\n\nSo now we can distinguish between batch requests that are handled synchronously and asynchronously but that brings up the question of, in asynchronous mode, when to return results from a batch request?\n\nSome of the requests/change sets in the batch might take almost no time to process while others might take minutes if not longer. Our proposal for asynchronous requests wraps the result of such an asynchronous request in a message/http response. Would we collect all the results and only return once the complete batch is processed? Or would we start returning results as soon as the result of the first request is available turning the asynchronous request into a synchronous request from that point onwards?\n\nAt a minimum we would have to describe the expected behavior of an asynchronous batch request but we might need to consider adding to what's there already and make it possible to return the results of a batch in chunks (not to confuse with chuck encoding).\n\nA proposal could be to allow the return of a application/http at any time with a 202 accepted and a Location header indicating that the remainder of the response to the batch request is being accepted and dealt with and will be returned later by querying the URL provided in the location just as any other async request. Using the example in section 10.5.3 of the OData Core Part-1 document the response, after handling the first request (and including the new 200 OK response on the $batch), would look like:\n\nHTTP/1.1 200 OK\nDataServiceVersion: 4.0\nContent-Length: ####\nContent-Type: multipart/mixed; boundary=batch_36522ad7-fc75-4b56-8c71-56071383e77b\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\nContent-Type: application/http\nContent-Transfer-Encoding: binary\n\nHTTP/1.1 200 Ok\nContent-Type: application/atom+xml;type=entry\nContent-Length: ###\n\n<AtomPub representation of the Customer entity with EntityKey ALFKI>\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\nContent-Type: application/http\n\nHTTP/1.1 202 Accepted\nRetry-After: ###\nLocation: https://services.odata.org/monitor/12345\n\nAfter which the async pattern continues until the processing has progressed and the remainder of the response is available which in this example presumably would look like:\n\nHTTP/1.1 200 OK\nDataServiceVersion: 4.0\nContent-Length: ####\nContent-Type: multipart/mixed; boundary=batch_36522ad7-fc75-4b56-8c71-56071383e77b\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\nContent-Type: multipart/mixed; boundary=changeset_77162fcd-b8da-41ac-a9f8-9357efbbd621\nContent-Length: ###      \n\n--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd621\nContent-Type: application/http\nContent-Transfer-Encoding: binary\n\nHTTP/1.1 201 Created\nContent-Type: application/atom+xml;type=entry\nLocation: http://host/service.svc/Customer('POIUY')\nContent-Length: ###\n\n<AtomPub representation of a new Customer entity>\n\n--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd621\nContent-Type: application/http\nContent-Transfer-Encoding: binary\n\nHTTP/1.1 204 No Content\nHost: host\n\n\n--changeset_77162fcd-b8da-41ac-a9f8-9357efbbd621--\n\n--batch_36522ad7-fc75-4b56-8c71-56071383e77b\nContent-Type: application/http\nContent-Transfer-Encoding: binary\n\nHTTP/1.1 404 Not Found\nContent-Type: application/xml\nContent-Length: ###\n\n<Error message>\n\nNote that I'd propose that the results of a change-set would never be split up as a result of asynchronous processing of a $batch request (probably don't need to as all request in such a set have to succeed or fail 'together' anyway).\n\n\n### Proposal\n\nThe same async pattern is applied to $batch requests then to normal requests. Once results are ready to be returned the same 200 OK is returned with a content-type header with value application/http. The response body encloses a single multipart/mixed with the respond to the batch request. In contrast with a synchronous $batch request however the server is allowed to return a partial set of the results for those requests in the batch that have been processed thus far, followed by a 202 accepted with a Location header specifying the monitor which the client can use to continue monitoring the progress of executing the remaining requests in the batch.\nNote that changesets are still atomic, and therefore the responses to all requests in a changeset are allways contained in the same, potential partial, response to a $batch request.\n\nImported from [ODATA-240](https://issues.oasis-open.org/browse/ODATA-240)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allowing expressions to be passed as parameters to (super) functions",
    "body": "To be able to use/extend the set of functions that can be used in a $apply query option functions need parameters of type expression, which expression can then be applied to each and every instance in the set they are processing. \nAn very simple example of such a function would:\n\n$apply=GroupBy()/TopN(N=5, Value=Revenue)\n\nWhere 5 is just a number indicating the top N we are interested in but were 'Revenue' is actually an expression referring to the Revenue property of the entity in the set the function is acting upon. A better example in which this becomes more apparent would be:\n\n$apply=GroupBy()/TopN(N=5, Value=Revenue sub Cost)\n\nFor build in functions we can obviously simply define this but currently there is no way of defining a 'custom' function that could implement the same behavior because we can't pass in expressions.\n\nWe then could annotate these functions to signal to tools that they can be used in $apply.\n\n### Proposal\n\nRelax ABNF from\n\nfunctionExprParameter  = functionParameterName EQ ( parameterValue / firstMemberExpr )\n\nto\n\nfunctionExprParameter  = functionParameterName EQ ( parameterValue / commonExpr )\n\nNote: this passes in the result of the expression to the function (not the expression)\n\nImported from [ODATA-239](https://issues.oasis-open.org/browse/ODATA-239)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Restrict values of the Qualifier attribute to QualifiedName values",
    "body": "Qualifiers can appear in property path expressions and may be followed by other path segments, so we must at least forbid the forward slash. \n\nUsing a QualifiedName allows us later to add a mechanism for defining qualifier values, and all other \"names\" in CSDL are QualifiedNames.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-238](https://issues.oasis-open.org/browse/ODATA-238)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Require type usage to always specify a qualified name for types other than the built-in primitive types",
    "body": "The prose text in some places suggests that simple identifiers can be used for type names when the usage is in the same schema as the type definition.\n\nThe schema on the other hand only allows primitive types in the Edm namespace to be used without a qualifier.\n\nAlways providing a qualifier is more expressive, and specifying Alias=\"Self\" on the Schema element seems to be a commonly used convention anyway.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-237\n\nImported from [ODATA-237](https://issues.oasis-open.org/browse/ODATA-237)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define maximum length of namespace names and simple identifiers",
    "body": "Currently the prose specification defines no limit for namespace names, and the CSDL schema definition limits them to 512 characters.\nBoth the prose spec and the schema limit simple identifiers to 479 characters.\n\nApparently the C# compiler accepts only 511 characters for both variable names and namespace names, so 512 is too long for namespaces, and 479 is oddly short for a simple identifier.\n\nJavaScript on the other hand has no limit for variable names.\n\n### Proposal\n\nRestrict length of SimpleIdentifier to 128 and QualifiedName to 511\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-236\n\nImported from [ODATA-236](https://issues.oasis-open.org/browse/ODATA-236)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Limit primitive types allowed as key parts to the \"sufficiently discrete\" types",
    "body": "Currently there's no restriction on which primitive types can be used for key properties; yet Edm.Stream doesn't really make sense, Edm.Binary is dubious, and Edm.Double, Edm.Single, and the Edm.Geo types are problematic when used in keys.\n\n### Proposal\n\nRestrict the allowed types for key properties in section 7.2.1 to:\nEdm.Boolean\nEdm.Byte\nEdm.Date\nEdm.DateTimeOffset\nEdm.Decimal\nEdm.Duration\nEdm.GeographyPoint\nEdm.GeometryPoint\nEdm.Guid\nEdm.Int16\nEdm.Int32\nEdm.Int64\nEdm.SByte\nEdm.String\nEdm.TimeOfDay\n\nWhich means that the following are excluded:\nEdm.Binary\nEdm.Double\nEdm.Geo*\nEdm.Single\nEdm.Stream\n\nAccepted: https://www.oasis-open.org/committees/download.php/48174/odata-meeting-24_on-20130207-minutes.html#odata-235\n\nImported from [ODATA-235](https://issues.oasis-open.org/browse/ODATA-235)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Merge Reference and AnnotationReference element",
    "body": "Currently there are two ways of referring to other EDMX documents: Reference and AnnotationsReference.\n\nTheir purpose is slightly different:\n- Reference brings model elements defined in the referenced document into scope,\n- AnnotationsReference includes annotations from the referenced document into the current document as if they would have been declared \"locally\".\n\nIn some situations we want to include annotation elements as well as refer to them, e.g. point in a UI \"view\" annotation to a vCard annotation and thus express the intent of rendering the vCard information in the UI \"view\".\n\nTo increase readability I'd like to introduce an Alias via a Using element, and It is unclear whether I'd also need a Reference element pointing to the same document in addition to the AnnotationsReference, or whether the AnnotationsReference also brings the referenced document, or just the included annotations, into scope.\n\nWhile we could clarify that in the prose description of these elements, it seems more intuitive to have only one Reference element with an IncludeAnnotations child element instead of an AnnotationsReference element with an Include child element.\n\n### Proposal\n\n- Add IncludeAnnotations child element to the Reference element\n- Remove the AnnotationsReference element and its Include child element\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-234\n\nImported from [ODATA-234](https://issues.oasis-open.org/browse/ODATA-234)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Change $batch response code from 202 Accepted to 200 OK",
    "body": "$batch is currently spec'd to return 202 Accepted. This seems a misuse of 202 and is at odds with our Async proposal.\n\nWe should change $batch to return 200 for the synchronous case and 202 Accepted for the async case.\n\n### Proposal\n\nSpecify that $batch return 200 for the synchronous case and 202 Accepted for the async case.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-233\n\nImported from [ODATA-233](https://issues.oasis-open.org/browse/ODATA-233)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enhance description of normalization procedures (public comment c201301e00001)",
    "body": "The public comment [c201301e00001](https://lists.oasis-open.org/archives/odata-comment/201301/msg00001.html) with title \"Query String parsing in URIs\" indicates, that the description of  normalization procedures in the ABNF Construction Rules can be enhanced.\n\nRFC3986 defines three sets of characters:\n- unreserved = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n- gen-delims = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n- sub-delims = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\" / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n\nOnly characters in these three sets MAY occur in URLs, all other characters MUST be percent-encoded.\n\nRFC3986 defines three steps for URL processing that MUST be performed before percent-decoding:\n1. Split undecoded URL into components scheme, hier-part, query, and fragment at first \":\", then first \"?\", and then first \"#\"\n2. Split undecoded hier-part into authority and path: if hier-part starts with \"//\", then authority is everything after \"//\" and before the next \"/\" or the end of the string, and path is everything that remains (nothing or the next \"/\" and everything after it)\n3. Split undecoded path into path segments at \"/\"\n\nRFC3986 allows that characters in the unreserved set MAY be percent-decoded at any time.\n\nRFC3986 does not specify how to split the query part into subcomponents, nor does it define how to split path segments into subcomponents, so OData needs to define how these are split into OData-specific subcomponents, especially whether this happens before or after percent-decoding characters in the gen-delims and sub-delims sets.\n\nAs pointed out in the public comment we have two areas that require special care:\n- Splitting queries into name-value dictionaries by first splitting at \"&\" and then splitting at the first \"=\" in each part\n- Treatment of the single quote character \"'\" within string literals\n\nThe first is a widely used convention supported by URL parsing tools, and it would be nice to reuse them. These tools also typically percent-decode the parts remaining after the \"&\"/\"=\" splits before handing them back.\n\nThe second is made especially interesting by the fact that Firefox always percent-encodes the single quote as %27.\n\n\n\n\n\n### Proposal\n\nAfter applying the three steps defined by RFC3986 the following four steps are performed:\n\n4. Split query at \"&\" into query options, and each query option at the first \"=\" into query option name and query option value before percent-decoding\n5. Percent-decode path segments, query option names, and query option values\n6. Interpret path segments, query option names, and query option values according to OData rules\n\nOne of these rules is that single quotes within string literals are represented as two consecutive single quotes.\n\nValid URLs:\n~/People('O''Neil')\n~/People(%27O%27%27Neil%27)\n~/People%28%27O%27%27Neil%27%29\n~/OperatingSystems('OS%2F2')\n\nInvalid URLs:\n~/People('O%27Neil')\n~/OperatingSystems('OS/2')\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-232\n\nImported from [ODATA-232](https://issues.oasis-open.org/browse/ODATA-232)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define how to specify enumeration values in annotations",
    "body": "When we fleshed out semantics/syntax/etc. around Enumerations we neglected to define how to reference Enum values in Annotations.\n\n\n### Proposal\n\nAdd EnumMember attribute to <PropertyValue> element for attribute notation and <EnumMember> element as child to <PropertyValue> for element notation.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-231\n\nImported from [ODATA-231](https://issues.oasis-open.org/browse/ODATA-231)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support use of parameter aliases in $filter and $orderby",
    "body": "Today parameter aliases can be used in the path portion of a request, but not the $filter or $orderby operations.\n\nWe would like to add support for parameter aliases in $filter and $orderby, for example:\n  ~Movies?$filter=substringof(Title,@title)&@title='supercomputer'\n or even \n~Movies?$filter=Title eq @title&@title='Wizard of Oz'\n\n\n### Proposal\n\nPropose to make @param a valid common expression that can be used throughout the URL syntax.\n\nThe parameter value must be a primitive value, complex value, or collection value.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-230\n\nImported from [ODATA-230](https://issues.oasis-open.org/browse/ODATA-230)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow annotations to target all model elements",
    "body": "Currently e.g. EnumType Members cannot be annotated, yet e.g. applying a Display.Caption term would be helpful to build user interfaces.\n\nEven more problematic: the Capabilities vocabulary mainly defines terms applicable to entity container, which currently cannot be annotated.\n\n### Proposal\n\nAllow annotations to target also these CSDL elements:\n- EntityContainer\n- Entity\n- Member\n- OnDelete\n- ReferentialConstraint\n- Schema\n- Documentation\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-229\n\nImported from [ODATA-229](https://issues.oasis-open.org/browse/ODATA-229)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify $search for free-text search within a OData Service and specify $search for free-text search within an entityContainer",
    "body": "Exactly the same as in https://tools.oasis-open.org/issues/browse/[ODATA-139](https://issues.oasis-open.org/browse/ODATA-139); the only difference is, that [ODATA-139](https://issues.oasis-open.org/browse/ODATA-139) limits the scope of the $search to a specific entity set. \n\n\n### Proposal\n\nSupport $search on\n (1) Service level (scope of search is the complete service) \n (2) EntityContainer level (scope of search is a specific entityContainer)\n\nSearch query syntax is exactly like in [ODATA-139](https://issues.oasis-open.org/browse/ODATA-139).\n  (1) Example URL  ~/somePath/odata/netbay.svc?$search=foo AND bar\n  (2) Example URL  ~/somePath/odata/netbay.svc/containerName?$search=foo OR bar\n\nThe result is a feed containing entities from that service or container. As there's no common type or entity set on feed level, the entities contain an odata.type and odata.set annotation in JSON responses, and an <atom:category> element and a metadata:set attribute in the <atom:id> in Atom responses.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-228\n\nImported from [ODATA-228](https://issues.oasis-open.org/browse/ODATA-228)",
    "labels": [
      "ABNF",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Support of symbolic names in annotations",
    "body": "An Annotation should be able to use one of a set of pre-defined symbolic names when specifying a value.\nFor example, the value of the \"MovieURL\" Annotation should  be the MediaRessource of the \"Movie\" type (which is a Media Link Entry).\n \n\n### Proposal\n\nDefine the following symbolic names:\nodata.mediaEditLink\nodata.mediaReadLink\nodata.mediaContentType\n\nAllow to use these symbolic names in the path attribute of the annotation element.\n\nThey may also be appended to Named Stream properties, separated by an @ sign: NamedStream@odata.mediaEditLink etc.\n\nExample:\n\n\n<EntityType Name=\"SomeMediaLinkEntryType\" HasStream= \"true\"> \n    <Annotation Term=\"Movie.MovieURL\" Path=\"@odata.mediaReadLink\"/> \n    <Annotation Term=\"Movie.MovieMimeType\" Path=\"@odata.mediaContentType\"/> \n    <Property Name=\"Something\" Type=\"String\">\n    <Property Name=\"SomethingElse\" Type=\"String\"/> \n</EntityType>\n\nAccepted: https://www.oasis-open.org/committees/download.php/48174/odata-meeting-24_on-20130207-minutes.html#odata-227\n\nImported from [ODATA-227](https://issues.oasis-open.org/browse/ODATA-227)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Clarify that the root of the Path attribute of a <PropertyValue> element is rooted at the containing entity ",
    "body": "This is not defined today.\nDefining the root as the containing entity allows specifying, for example, that the language of a particular string is represented by the value of a different property on the same type.\n\n\n### Proposal\n\nClarify as specified in title.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-226\n\nImported from [ODATA-226](https://issues.oasis-open.org/browse/ODATA-226)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define Functions in Schema; reference in Container using FunctionImport.",
    "body": "It is difficult to share functions because they are defined in an entitycontainer.\nFunctions should follow a similar model to Entities; the types should be defined in schema and we should use the entitycontainer to expose them at the container level, or to bind to particular sets within the container.\n\n\n\n### Proposal\n\n-Define a <Function> element used to define the shape of a function in the schema. The function definition defines parameters, return values, and may specify an entitysetpath.\n-Functions defined in the model are available for use by referencing the model. You do not need to \"import them\" into your container\n-The only time you use a functionimport is if you want to expose a function as a top-level function in your entitycontainer, or bind a function to a specific entityset in your entitycontainer. Note that, if the return set is relative to the input set you can define this in the entitysetpath in the <Function> definition of the model, then you don't need to import it unless you want to expose it as a top-level function.\n-The FunctionImport always references a <Function> defined in the schema (similar to how an EntitySet always references an EntityType defined in the schema)\n-Functions should be bindable to primitive or complex types (or sets of primitive or complex types) in addition to entities/sets of entities. \n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-225\n\nImported from [ODATA-225](https://issues.oasis-open.org/browse/ODATA-225)",
    "labels": [
      "ABNF",
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Fill out Capabilities sections of an OData Service",
    "body": "We need to fill out the capabilities section to provide direction to services as to what they are required to support. We can probably define these entirely within [Core] Part I.\n\n### Proposal\n\nStart with https://www.oasis-open.org/committees/download.php/48595/OData%20Service%20Conformance%20Levels.docx and refine during preparation of CSD01\n\nApproved: https://www.oasis-open.org/committees/download.php/48871/odata-meeting-33_on-20130418-minutes.html#odata-224\n\nImported from [ODATA-224](https://issues.oasis-open.org/browse/ODATA-224)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "CSDL XML",
      "Data Aggregation",
      "Extension for JSON Data",
      "JSON Format",
      "Protocol",
      "Temporal",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify Service behavior for not implemented functionality",
    "body": "We need to specify, in each spec, the minimal conformance.\nFor functionality beyond minimal conformance, we need to specify how the service responds when certain support (i.e., certain query options) are not implemented (for example, return Not Implemented status code, with a well defined header or response body describing what is not implemented (perhaps referencing \"codes\" in the capabilities vocabulary, as appropriate?)).\n\n### Proposal\n\nServices MUST return 501 not implemented and SHOULD include a description of the error in an OData error object.\n\nImported from [ODATA-223](https://issues.oasis-open.org/browse/ODATA-223)",
    "labels": [
      "ATOM Format",
      "CSDL XML",
      "Data Aggregation",
      "Extension for JSON Data",
      "JSON Format",
      "Protocol",
      "Temporal",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "free-text search within a property",
    "body": "[ODATA-139](https://issues.oasis-open.org/browse/ODATA-139) introduces free-text search for entities, with syntax \n\n$search=foo AND bar\n\nI suggest that the same search capability be provided for individual properties. Perhaps:\n\n.../Report?$filter=search(Description, \"foo AND bar\")\n\n\n\n### Proposal\n\nAdd filter function search with two string arguments: the first a string to search in, and the second a string containing a search expression using the same syntax as $search:\n\n~/Report?$filter=search(Description, 'foo AND bar')\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-222\n\nNote: was later removed with [ODATA-358](https://issues.oasis-open.org/browse/ODATA-358)\n\nImported from [ODATA-222](https://issues.oasis-open.org/browse/ODATA-222)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Flatten the message element in the JSON Error Represention (Section 4.18 Representing Errors in a Response)",
    "body": "As discussed in meeting#23 on 2013-01-30 in the current revision of [OData JSON Format Version 1.0 Working Draft 01](https://www.oasis-open.org/committees/download.php/48030/odata-json-format-v1.0-wd01-2013-01-25.doc) inside section 4.18 Representing Errors in a Response the type of the message element shoudl be changed as proposed, since the language selected should be a global property of the response as noted in the response headers and derived from the client preferences as noted in the request headers.\n\n### Proposal\n\nInside a JSON Error Message in a Response the message should better be noted as \"message\": \"mesag_value\" instead of \"message\" : { \"lang\": \"lang-code\", \"value: \"message-value\"}\n\nRemove special mentioning of xml:lang in Atom format specification.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48269/odata-meeting-25_on-20130214-minutes.html#odata-221\n\nImported from [ODATA-221](https://issues.oasis-open.org/browse/ODATA-221)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Please consider the restoration of DateTime (without offset)",
    "body": "In odata_1396.ezm (odata digest message), I noted:\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47764/latest/odata-meeting-19_on-20121220-minutes.html\n  was:\n-Remove Edm.DateTime (with no offset).\n...\n\nI am sorry that I was unable to join conference calls to discuss this before it was voted on, but the calls are a little early in the day for me to attend.\n\nIn various other discussions in the ODATA issues list, I think that we established that sometimes it may makes more sense for an object to have a separate field containing time zone name or offset, e.g. see xCal specification section 4.3.5 (http://tools.ietf.org/html/rfc5545#section-3.3.5) has DATE-TIME without offset, and a separate field type of UTC OFFSET for the offset (in OData this could easily be stored as a \"short\" number of minutes, I am not going to propose a separate OData type for UTC offset).\n\nI cannot see a strong rationale for eliminating DateTime (without offset) while adding Date (without offset) and TimeOfDay (without offset). To be clear, I do not mean to suggest eliminating zoneless Date and TimeOfDay.\n\nIt seems reasonable to expect to be able to encapsulate xCal data in OData, without having to map multiple xCal fields (e.g. of types DATE-TIME and UTC OFFSET) into a single OData type (e.g. of type DateTimeOffset).\n\nAlso, bear in mind the enormous number of systems where backend data (with DateTime fields having no offset) may be exposed via OData, not because they are to be \"published to the web for the whole world to see and therefore should be zoned\", but just because OData is the \"flavour of the day\" for integrating backends with newly developed front-end applications. Forcing developers to reinterpret zoneless DateTime data as zoned, as opposed to leaving it unzoned with explicit (or implicit) separate fields indicating zone name or offset, seems rather extreme. We can encourage developers to use DateTimeOffset where appropriate, but without being heavy-handed and eliminating zoneless DateTime.\n\n\n### Proposal\n\nDefer to 5.0\n\nAccepted: https://www.oasis-open.org/committees/download.php/49375/odata-meeting-39_on-20130530-minutes.html#odata-220\n\nImported from [ODATA-220](https://issues.oasis-open.org/browse/ODATA-220)",
    "labels": [
      "Vocabularies"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Detail state and procedures in format agnostic description of In-Stream Error handling",
    "body": "In the current revision of the Work Product [OData Core Part 1: Protocol, Version 1.0](https://www.oasis-open.org/committees/download.php/47547/odata-core-v1.0-wd01-part1-protocol-2012-11-26.doc) in section 9.3 In-Stream Errors the relevant states and procedures might be specified with more rigor without diving into specific formats or usecases. Currently I have no proposal, since I can't answer some questions of understanding (see below), but am willing to provide one, once these questions have been answered.\n\nCurrently section 9.3 \"In-Stream Errors\" reads:\n\"In the case that the service encounters an error after sending a success status to the client, the service MUST generate an in-stream error which SHOULD leave the response malformed. Clients MUST assume that any malformed responses are invalid and results SHOULD be discarded.\n\nThis specification does not prescribe a particular format for such in-stream errors.\"\n\nIn my understanding the sentence: \"[...]the service encounters an error after sending a success status to the client,\" indicates that the HTTP headers (associated with success) have already been sent to the network interface.\n\nThe next part \" the service MUST generate an in-stream error which SHOULD leave the response malformed. \" tries to be format agnostic. Together with the last sentence in the paragraph \"Clients MUST assume that any malformed responses are invalid and results SHOULD be discarded.\n\" I derive from this, that this magical \"in-stream error\"-thingie is completely volatile, since the client MUST assume, that the whole response (any info therein!) are invalid and SHOULD throw it away without further inspection.\n\nThe recipes for $format=json and any xml like the default atom should be \"stop adding to the response body, just flush the pipe. Right?\n\nThe last paragraph (in that light) looks a bit lawyer like (to me).\n\nI also am curious, how the service shall generate an in-stream error, in use cases like:\n \"A Prefer header with a value of return-no-content requests that the service invoke the request but not return content in the response. The service MAY honor this request by returning 204 No Content.\"(8.4.1 The Prefer Header) \n\nor: \n\"A service MAY reply to a Data Modification Request with 202 Accepted, indicating that the request has been accepted but has not yet completed. In this case, the response MUST contain a Location header in addition to a Retry-After header, and the response body MUST be empty.\"(9.1.3 202 Accepted Response Code)\n\nor:\n\"A service may reply to a Data Modification Request with 204 No Content. In this case, the response body\nMUST be empty.\"(9.1.4 204 No Content Response Code)\n\nThese share the body-less response class. So is it expected, that in those cases and where applicable the \"body MUST be empty\" is changed through say adding a character like '<' to the network pipe to invalidate independant of chosen $format (json, xml.*) and replace this by a \"odata malformed body\"? But if so, what about a response to say a GET /Entities(1)/Property/$value ? In these cases it may become impossible to invalidate the response body (say for the default type Edm.String)\n\nMaybe the term In-Stream error also contributes to misunderstandings? Which states of error are included for which HTTP operations? Might some of the latter better be excluded or described in an extra paragraph?\n\nAny feedback, help appreciated.\n\n### Proposal\n\nclarify wording\n\nImported from [ODATA-219](https://issues.oasis-open.org/browse/ODATA-219)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove doubled last paragraph in section 8.5.2 The Preference-Applied Header",
    "body": "In the current revision of the Work Product [OData Core Part 1: Protocol, Version 1.0](https://www.oasis-open.org/committees/download.php/47547/odata-core-v1.0-wd01-part1-protocol-2012-11-26.doc) in section 8.5.2 The Preference-Applied Header the third (and last) paragraph is an exact copy of the second and thus should be removed.\n\n### Proposal\n\nRemove one instance of \"If the service has returned content in response to a request including a Prefer header with a value of return-content, it MAY include a Preference-Applied response header with a value of return- no-content.\" from section 8.5.2 The Preference-Applied Header.\n\nThe second paragraph was intended to describe the no content case, and has been updated (as part of applying OData-110 for the new preference values) to:\n\nIf the service has returned content in response to a request including a Prefer header with a value of return=representation, it MAY include a Preference-Applied response header with a value of return=representation.\n\nIf the service has returned no content in response to a request including a Prefer header with a value of return=minimal, it MAY include a Preference-Applied response header with a value of return=minimal.\n\nImported from [ODATA-218](https://issues.oasis-open.org/browse/ODATA-218)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "property facets in ValueTerm element",
    "body": "Section 13.2, The edm:ValueTerm Element, in CSDL allows a Type attribute, but does not mention property facets. csdl.xsd allows a MaxLength attribute in a ValueTerm element, but not a FixedLength attribute.\n\nAllowed:\n\n<ValueTerm\n   Name=\"ContentType\"\n   Type=\"Edm.String\"\n   MaxLength=\"Max\"\n   Nullable=\"false\" />\n   \nDisallowed:\n\n<ValueTerm\n   Name=\"ContentType\"\n   Type=\"Edm.String\"\n   FixedLength=\"20\"\n   Nullable=\"false\" />\n   \n  \n\n### Proposal\n\nUnify the facet attributes for the elements\n- Function Parameter\n- Property\n- Term\n- TypeDefinition\n\nThe common list of facet attributes is\n- MaxLength\n- Precision\n- Scale\n- SRID\n\nFacets applicable for Function Parameter, Property, and Term\n- Nullable\n- DefaultValue\n\nFacets applicable for Property and TypeDefinition\n- FixedLength\n- Unicode\n- Collation \n\nAccepted: https://www.oasis-open.org/committees/download.php/48174/odata-meeting-24_on-20130207-minutes.html#odata-217\n\nImported from [ODATA-217](https://issues.oasis-open.org/browse/ODATA-217)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow edm:Documentation element in edm:TypeDefinition and edm:Annotations element",
    "body": "Section 3.3, The edm:Documentation Element, in CSDL does not list  edm:TypeDefinition in the model elements that MAY contain a documentation element. The csdl.xsd schema allows an edm:Documentation element in an edm:TypeDefinition element.\n\nThe edm:Annotations element is also missing, and it can make sense to document a group of annotations.\n\n### Proposal\n\nSee summary\n\nImported from [ODATA-216](https://issues.oasis-open.org/browse/ODATA-216)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove hour(), minute() and second() query functions and add corresponding overloads to the hours(), minutes(), and seconds() functions",
    "body": "Both the hour() and hours() function returns an integer, and as the values returned are in the range of 0..23, the plural form of the name is more appropriate.\nSame reasoning for minute() and minutes(), second() and seconds().\n\nBtw., why do second() and seconds() return integers? We allow fractional seconds for DateTimeOffset, Duration, and TimeOfDay.\n\n\n### Proposal\n\nA) Remove the days() hours() minutes() and seconds() function for duration. \nB) Add a totalseconds() function for duration, which is decimal. \nC) Change the existing second() function to return a decimal.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-215\n\nD) Rename gettotaloffsetminutes to totaloffsetminutes and change its return type to Int32 (from Int16).\n\nImported from [ODATA-215](https://issues.oasis-open.org/browse/ODATA-215)",
    "labels": [
      "ABNF",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Find consensus on \"Additional artifacts\"-section of multi component Work Products (and implement accordingly) ",
    "body": "Although some current revisions of components of a main work product still have not filled in the section \"Additional artifacts\" on the title page, others do have first fill-in proposals:  \"[OData Core Part 2: URL Conventions, Version 1.0](https://www.oasis-open.org/committees/download.php/47898/odata-core-v1.0-wd01-part2-url-conventions-2013-01-15.doc)\" and \"[OData Core Part 3: CSDL, Version 1.0](https://www.oasis-open.org/committees/download.php/47899/odata-core-v1.0-wd01-part3-csdl-2013-01-15-RH.doc)\".\n\nThe proposed wording of the \"templates\" as provided by OASIS might irritate the reader, as it says:\n\n\"\"\"\nAdditional artifacts:\n\nThis prose specification is one component of a Work Product which also includes:\n\n- list ...\n\"\"\"\"\nleading to an ever changing list, or a contradiction.\n\nBetter seems to be inicating a list of **all** constituents, where the current component is ammended by the string \"(this document)\". Of course the introductory sentence SHOULD be adapted, to make it consistent.\n\nThe text of the list items should match the title of the document where appilcable.\n\nSo in the case of CSDL, on the one hand it is listed in \"[OData Core Part 2: URL Conventions, Version 1.0](https://www.oasis-open.org/committees/download.php/47898/odata-core-v1.0-wd01-part2-url-conventions-2013-01-15.doc)\" as: \n\" * OData Common Schema Definition Language\" \nwhilst the document itself \"[OData Core Part 3: CSDL, Version 1.0](https://www.oasis-open.org/committees/download.php/47899/odata-core-v1.0-wd01-part3-csdl-2013-01-15-RH.doc)\"is titled (besides the prefix \"OASIS OData Version 1.0 Part 3: \"): \n\"CSDL\". \n\nI hereby suggest to not use our \"invented\" acronyms in top-level places of that kind (titles, other components listing etc.). \nCommon acronyms/abbreviations like eg. ATOM, JSON or ABNF are of course ok, but things like CSDL might need explanation for a potential reader.\n\nFollowing this convention we then only have to ensure in later stages of standardization, that the linkage will remain consistent (w.r.t. formats), i.e. a link to eg. \"csdl.xsd\" MUST be independent from the format (Word, PDF, Html) of the referencing work product component, but eg. one link to the prose document \"OData Common Schema Definition Language\" should keep the navigating client within the format of the referrer. \nSo as an example: Starting from an \"OData Protocol\" PDF document the link should go to the \"OData Common Schema Definition Language\" PDF-document, whilst the HTML version should point to HTML.\n\n\n### Proposal\n\nChange all  \"Additional artifacts\"-sections of multi-component workproducts (where applicable ie. Word-Format!) into content following the pattern:\n\"\"\"\nAdditional artifacts:\n\nThis prose specification is one component of a Work Product which consists of:\n\n- list item 1\n- list item 2 (this document)\n- ...\n- list item N\n\"\"\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/48346/odata-meeting-26_on-20130221-minutes.html#odata-214\n\nImported from [ODATA-214](https://issues.oasis-open.org/browse/ODATA-214)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "CSDL XML",
      "JSON Format",
      "Protocol",
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow all dynamic expressions of the appropriate type within edm:Collection expressions",
    "body": "Currently only the edm:Record dynamic expression is explicitly allowed within edm:Collection expressions. \n\nWe definitely have use cases for the edm:Path dynamic expression, e.g. \n\n<ValueAnnotation Term=\"org.odata.vCard.PhoneNumbers\">\n  <Collection>\n    <Path>ContactData/WorkPhone</Path>\n    <Path>Contactdata/HomePhone</Path>\n  </Collection>\n</ValueAnnotation>\n\n### Proposal\n\nAllow all vocabulary expressions that yield a compatible type as children of edm:Collection expressions.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-213\n\nImported from [ODATA-213](https://issues.oasis-open.org/browse/ODATA-213)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define request body format for Actions in Atom and JSON format specifications",
    "body": "Currently the Protocol specification defines a JSON request body format for invoking an action.\n\nThis would require Atom/XML clients to also implement a JSON serializer, which is an unnecessary burden.\n\nThe request body format is essentially the serialization of a complex type with one property per non-binding parameter, so we can use the already defined XML serialization for complex type instances also for XML action request bodies.\n\nThe request body formats are better described in the respective format specifications and only referenced from the Protocol specification.\n\n### Proposal\n\nRephrase paragraphs 3 and 4 of section 10.4.2.3 Invoking an Action in the Protocol specification to be format-neutral:\n\nIf the invoke request contains any non-binding parameter values, the parameter values MUST be encoded in the format of a complex type instance in the request body.\n\nEach non-binding parameter value specified MUST be encoded in the format of a property of a complex type instance. The name of the property is the name of the parameter. The value is the parameter value which is an instance of the type specified by the parameter in JSON format. Any parameter values not specified in the JSON object MUST be assumed to be null.\n\n\nAdd sections Action Parameters to the Atom and JSON format specification. For the new JSON specification the text will be\n\n4.20 Action Parameters\n\nAction parameter values MUST be encoded in a single JSON object in the request body.\n\nEach non-binding parameter value specified MUST be encoded as a separate name/value pair in this JSON object. The name is the name of the parameter. The value is the parameter value in the JSON representation appropriate for its type. \n\nAny parameter values not specified in the JSON object MUST be assumed to be null.\n\nExample:\n{\n  \"param1\": 42,\n  \"param2\": {\n    \"Street\": \"One Microsoft Way\", \n    \"Zip\": 98052\n  },\n  \"param3\": [ 1, 42, 99 ]\n}\n\n\nThe text for the Atom specification could be\n\n15 Action Parameters\n\nAction parameter values in the request body MUST be encoded as an individual complex scalar value (link to section 10) with the name parameters and no metadata:type attribute.\n\nEach non-binding parameter value specified MUST be encoded as an individual primitive or complex scalar value. The name of the scalar value is the name of the parameter. The value is the parameter value in the XML representation appropriate for its type. \n\nAny parameter values not specified in the request body MUST be assumed to be null.\n\nExample:\n<parameters>\n  <param1>42</param1>\n  <param2 metadata:type=\"Model.Address\">\n    <Street>One Microsoft Way</Street> \n    <Zip>98052</Zip>\n  </param2>\n  <param3>\n    <element>1</element>\n    <element>42</element>\n    <element>99</element>\n  </param3>\n<parameters>\n\nAccepted: https://www.oasis-open.org/committees/download.php/48269/odata-meeting-25_on-20130214-minutes.html#odata-212\n\nImported from [ODATA-212](https://issues.oasis-open.org/browse/ODATA-212)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Correct the sample inside section \"JSON DeltaQuery Result Example\" inside ODQP proposal pages 9/10",
    "body": "Inside the current revision of the proposal for an OData Delta Query Protocol i.e. [OData Delta Query Protocol Design 2012-12-19.docx](https://www.oasis-open.org/committees/download.php/47755/OData%20Delta%20Query%20Protocol%20Design%202012-12-19.docx) the sample inside section \"JSON DeltaQuery Result Example\" is syntactically invalid. A diff to a validating version yields:\n\n\"\"\"\n$> diff -u original_odqp_json-sample.json valid_odqp_json-sample.json\n--- original_odqp_json-sample.json    2013-01-05 14:33:29.000000000 +0100\n+++ valid_odqp_json-sample.json    2013-01-05 14:34:22.000000000 +0100\n@@ -11,7 +11,7 @@\n                     \"odata.type\" : \"odata.deletedLinkEntry\",\n                     \"ref\":\"http://DeltaService.svc/Customers(ALFKI)'\",\n                     \"relationship\":\"Orders\",\n-                    \"related\":http://DeltaService.svc/Orders(10643),\n+                    \"related\":\"http://DeltaService.svc/Orders(10643)\",\n                     \"when\":\"2012-11-07T15:38\",\n                },\n                {\n@@ -36,7 +36,7 @@\n                     \"ShipCountry\":\"Canada\"\n                },\n                {\n-                     \"odata.type\":\"odata.deletedEntry\":\n+                     \"odata.type\":\"odata.deletedEntry\",\n\n\"odata.id\":\"http://DeltaService.svc/Customers('ALFKI')\",\n                      \"when\":\"2012-11-07T15:38\",\n                      \"reason\": \"deleted\",\n\n\"\"\"\n\nI suggest replacing the sample by:\n\"\"\"\n{\n  \"odata.metadata\": \"http://DeltaService.svc/$metadata \",\n  \"odata.deltaLink\": \"http://DeltaService.svc/Customers?$expand=orders&$deltatoken=8015\",\n  \"value\": [\n    {\n      \"odata.type\": \"Northwind.Customer\",\n      \"odata.id\": \"http://DeltaService.svc/Customers('BOTTM')'\",\n      \"ContactName\": \"Susan Halvenstern\"\n    },\n    {\n      \"odata.type\": \"odata.deletedLinkEntry\",\n      \"ref\": \"http://DeltaService.svc/Customers(ALFKI)'\",\n      \"when\": \"2012-11-07T15:38\",\n      \"relationship\": \"Orders\",\n      \"related\": \"http://DeltaService.svc/Orders(10643)\"\n    },\n    {\n      \"odata.type\": \"odata.linkEntry\",\n      \"ref\": \"http://DeltaService.svc/Customers('BOTTM')\",\n      \"relationship\": \"Orders\",\n      \"related\": \"http://DeltaService.svc/Orders(10643)\"\n    },\n    {\n      \"odata.type\": \"odata.linkEntry\",\n      \"ref\": \"http://DeltaService.svc/Orders(10643)\",\n      \"relationship\": \"Customer\",\n      \"related\": \"http://DeltaService.svc/Customers('BOTTM')\"\n    },\n    {\n      \"odata.type\": \"Northwind.Order\",\n      \"ShipName\": \"Bottom-Dollar Markets\",\n      \"ShipPostalCode\": \"T2F 8M4\",\n      \"ShipRegion\": \"BC\",\n      \"ShipCountry\": \"Canada\",\n      \"odata.id\": \"http://DeltaService.svc/Orders(10643)\",\n      \"ShipAddress\": \"23 Tsawassen Blvd.\"\n    },\n    {\n      \"odata.type\": \"odata.deletedEntry\",\n      \"reason\": \"deleted\",\n      \"when\": \"2012-11-07T15:38\",\n      \"odata.id\": \"http://DeltaService.svc/Customers('ALFKI')\"\n    }\n  ]\n}\n\"\"\" \n\n### Proposal\n\nReplace the JSON with the corrected version.\nRewritten as suggested in version 1.3: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47996/OData%20Delta%20Query%20Protocol%20Design%202013-1-23.docx \n\nImported from [ODATA-211](https://issues.oasis-open.org/browse/ODATA-211)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Declare OData object/concept name for tombstone before its usage in Result Maintenance and ATOM format describing sections inside ODQP proposal pages 6 and later",
    "body": "Inside the current revision of the proposal for an OData Delta Query Protocol i.e. [OData Delta Query Protocol Design 2012-12-19.docx](https://www.oasis-open.org/committees/download.php/47755/OData%20Delta%20Query%20Protocol%20Design%202012-12-19.docx) the term tombstone should IMO better be introduced before its first appearance on page 6 (result maintenance and atom format describing sections).\n\nI suggest to do this inside the section \"Delta Responses\" on pages 3 or 4 since it is simply a \"deleted-link\" with a cooler name, right? ... which is part of the response and not the request. \n\nUpdate:\nOld proposal was to \"Define the term tombstone (virtual entity handle for deleted entities) before using it.\"\nFollowing the feedback in a comment by Mike it is now proposed to replace instead (as addressed in upcoming revision).\n\n### Proposal\n\nRemove the use of \"tombstone\" and consistently use \"deleted entry\" to not introduce a new concept just explaining a wording variation.\nChanges applied as proposed: Rewritten as suggested in version 1.3: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47996/OData%20Delta%20Query%20Protocol%20Design%202013-1-23.docx \n\nImported from [ODATA-210](https://issues.oasis-open.org/browse/ODATA-210)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Replace the term store by service and reduce number of triggerpoints in diagrams in section Client Interaction inside ODQP proposal pages 5/6",
    "body": "Inside the current revision of the proposal for an OData Delta Query Protocol i.e. [OData Delta Query Protocol Design 2012-12-19.docx](https://www.oasis-open.org/committees/download.php/47755/OData%20Delta%20Query%20Protocol%20Design%202012-12-19.docx) there might be room for improvement of readability:\n\nIn general I think the two terms \"store\" and \"local store\" might better not be used in parallel as they are in the text in section \"Client Interaction\" on pages 5 and 6.\nI suggest using \"remote store\" instead of \"store\" or where /if  this fact is opaque / or unimportant to the client better use \"service\" instead of \"store\".\n\nWith respect to the two diagrams inside the section Client Interaction i.e. inside the subsection \"Initial Population\" on page 5 and \"Result Maintenance\" on page 6 it would in my opinion be beneficial to replace the label \"Store\" in the \"scoping\" box on the right-hand side with \"Service\".\n\nAlso I think for these very top-level presentation of message/logic flow it might be better not to think of single/multiple page and last page result triggers, but only of not-last and last-page (since the delta link automatically starts at the first page.\n\nThus I recommend changing the \"More than one page?\" 'DecisionDiamond' A) into 'Last page?' (identical to the trigger in the multi page case!) and B) adapt the yes/no \"outcome-positions\" i.e. \"no\" now to the left and \"yes\" to the bottom. This should render the flow much more readable and concentrates on the single trigger to act upon (from a client perspective) i.e. is the current response a last page with a new delta link or not?\n\n\n\n### Proposal\n\nChanges applied: Rewritten as suggested in version 1.3: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47996/OData%20Delta%20Query%20Protocol%20Design%202013-1-23.docx \n\nImported from [ODATA-209](https://issues.oasis-open.org/browse/ODATA-209)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Enhancement of \"flat heterogeneous\" structure definition and reference thereof in section Delta Responses inside ODQP proposal pages 3/4 (and later)",
    "body": "Inside the current revision of the proposal for an OData Delta Query Protocol i.e. [OData Delta Query Protocol Design 2012-12-19.docx](https://www.oasis-open.org/committees/download.php/47755/OData%20Delta%20Query%20Protocol%20Design%202012-12-19.docx) we should be clearer, as what the reader should understand as \"flat, heterogeneous\" in the last list item of section \"Delta Responses\" :?)\n\nIs it in JSON a (one dimensional) vector of maps/dicts ?\n\n\"\"\" ...\nFor delta queries that are tracking changes to a set of related entities (for example, the result of a $expand request), the result includes changes to related entities, as well as added or deleted links, returned in a flat, heterogeneous result.\"\"\" \n\nAs she learns later from the samples for ATOM and JSON on the later pages, it is for ATOM a sequence of elements all children of the feed root element and for JSON a (one dimensional) vector of flat key-value dicts.\n\nI read Mikes issue item in the list following the main text of the document the way, that we also would prfoit from a central definition point of such a term in our collection of work products. This issue focusses on readability at the location the term first enters the stage in the document. \n\n### Proposal\n\nRemoved reference to \"Flattened Hierarchical Result\"; now more precisely describe \"single heterogeneous feed\": Rewritten as suggested in version 1.3: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47996/OData%20Delta%20Query%20Protocol%20Design%202013-1-23.docx \n\nImported from [ODATA-208](https://issues.oasis-open.org/browse/ODATA-208)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rephrasing of section Requesting Delta Links in ODQP proposal page 2",
    "body": "Inside the current revision of the proposal for an OData Delta Query Protocol i.e. [OData Delta Query Protocol Design 2012-12-19.docx](https://www.oasis-open.org/committees/download.php/47755/OData%20Delta%20Query%20Protocol%20Design%202012-12-19.docx) please consider rewriting:\n\"\"\" \nRequesting Delta Links\n\nAn OData client may request that a service return delta links by including a Preference value of odata- request-deltas in the Prefer Header of the request. Services that support deltas should return a delta link, if possible for the request, but may ignore this value. Services may return delta links when this value has not been specified.\n\"\"\"\ninto:\n\"\"\"\nRequesting Delta Links\n\nServices MAY return delta links. An OData client MAY request that a service return delta links by including a Preference value of odata- request-deltas in the Prefer Header of the request. Services that support deltas SHOULD return a delta link, if possible for such a request, but MAY ignore this value. \"\"\" \n\nto ease understanding of main statements and extraction of conformance tests.\n\n### Proposal\n\nRewritten as suggested in version 1.3: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47996/OData%20Delta%20Query%20Protocol%20Design%202013-1-23.docx \n\n\nImported from [ODATA-207](https://issues.oasis-open.org/browse/ODATA-207)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Rephrasing of section Delta Links in ODQP proposal page 1/2",
    "body": "Inside the current revision of the proposal for an OData Delta Query Protocol i.e. [OData Delta Query Protocol Design 2012-12-19.docx](https://www.oasis-open.org/committees/download.php/47755/OData%20Delta%20Query%20Protocol%20Design%202012-12-19.docx) please consider rewriting:\n\"\"\"\nDelta Links\n\nAn OData Service supports result maintenance by including a \"delta link\" url in the last page of results returned from a request for which the service can enumerate changes. This delta link is generated in place of the next link on the last page of the result. It is illegal for a response to contain both a delta link and a next page link.\n\nClients can use this delta link to query the service for changes that have occurred to the result since the initial request.\n\nDelta links are returned only on requests that return a collection of zero or more entities. Requests for individual entities (for example ~/Customers('ALFKI') or property values (for example, ~/Customers('ALFKI')/ContactName) do not include delta links.\"\"\"\n\ninto:\n\"\"\"\nDelta Links\n\nFor any request for which the OData Service can enumerate changes the service SHOULD support result maintenance by including a \"delta link\" url in place of the next link on the last page of results returned.\nA response MAY contain a next page or a delta link, but MUST NOT contain both.\n\nClients can use this delta link to query the service for changes that have occurred to the result since the initial request.\n\nDelta links MUST only be returned upon requests whose responses contain a collection of zero or more entities. Requests for individual entities or property values MUST NOT include delta links. Corresponding examples for such requests are  ~/Customers('ALFKI') and ~/Customers('ALFKI')/ContactName respectively.\"\"\" \n\nto ease understanding of main statements and extraction of conformance tests.\n\n### Proposal\n\nRewritten as suggested in version 1.3: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47996/OData%20Delta%20Query%20Protocol%20Design%202013-1-23.docx\n\nImported from [ODATA-206](https://issues.oasis-open.org/browse/ODATA-206)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Merge TypeAnnotation and ValueAnnotation into Annotation",
    "body": "Currently we can annotate anything using a ValueAnnotation, and ValueTerms can be of any type except EntityType and Collection(EntityType). We  can in addition annotate entity types and complex types with a TypeAnnotation, and these can be of complex type or entity type.\t\t\n\nSo for complex-type annotations we have to choose between a ValueAnnotation using a ValueTerm of that complex type,  or a TypeAnnotation using the complex type directly.\n\t\t\nFrom the expressiveness there's no difference. The value annotation will look like\n\t\t\n\t\t<ValueAnnotation Term=\"MyComplexTerm\">\n\t\t  <Record>\n\t\t    <PropertyValue Name=\"FirstProperty\" String=\"Constant value\" />\n\t\t    <PropertyValue Name=\"SecondProperty\" Path=\"SomePropertyInTheAnnotatedType\" />\n\t\t  </Record>\n\t\t</ValueAnnotation>\n\t\t\nThe type annotation will look like \n\t\t\n\t\t<TypeAnnotation Term=\"MyComplexTerm\">\n\t\t    <PropertyValue Name=\"FirstProperty\" String=\"Constant value\" />\n\t\t    <PropertyValue Name=\"SecondProperty\" Path=\"SomePropertyInTheAnnotatedType\" />\n\t\t</TypeAnnotation>\n\t\t\nThe similarity is striking: just strike the <Record> and replace the prefix \"Value\" with \"Type\".\n\t\t\nIf the annotation on an instance basis deviates from the metadata \"default\", the representation in Atom and JSON is already identical for both cases.\n\t\t\nThe only difference is that with a type annotation the server expresses the opinion that the original instance can be \"cast\" to the annotation's type, while with a value annotation the original instance can be \"projected\" to the annotation's type. \n\t\t\nFrom a data perspective there's no difference between the two, and the \"cast\" versus \"project\" choice is anyway ultimately left to the client. So this difference in opinion can be expressed as an annotation on the term definition.\n\n### Proposal\n\n- Remove TypeAnnotation\n- Rename ValueAnnotation to Annotation\n- Rename ValueTerm to Term and allow it to have any type. \n- Add an optional \"AppliesTo\" attribute to the <Term> element whose value is a whitespace-separated list of model elements to which the annotation may  be applied, including \"Property\", \"EntityType\", \"EntitySet\", \"ComplexType\", or \"Term\".\n- Add a term to the Core vocabulary that allows marking a Term as \"I'd like you to treat this as a type cast\".\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-205\n\nImported from [ODATA-205](https://issues.oasis-open.org/browse/ODATA-205)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define namespace versioning policy for XML namespaces",
    "body": "http://docs.oasis-open.org/specGuidelines/ndr/namingDirectives-v1.3.html#xml-namespaces requires that:\n\nTCs must define a namespace versioning policy for any XML namespace declared in a specification, and must communicate the text expressing such policy to the TC Administrator for incorporation into the appropriate namespace document.\n\nThe requirement refers to http://www.w3.org/TR/webarch/#versioning-xmlns.\n\n\n\n### Proposal\n\nDo NOT include version information in the namespace URL, to allow us to define new elements without the client having to look through different namespaces.\n\nOur versioning policy should be to not introduce new elements to our CSDL/EDM and ATOM data/metadata namespaces that cannot be safely ignored by down-level clients.\n\nRemove DataServiceVersion attribute from edmx:DataServices element; the Version attribute of edmx:Edmx specifies the version of a given CSDL document.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48481/odata-meeting-28_on-20130307-minutes.html#odata-204\n\nImported from [ODATA-204](https://issues.oasis-open.org/browse/ODATA-204)",
    "labels": [
      "CSDL XML",
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Specify Operator Precedence more clearly",
    "body": "Section 5.1.1.5 shows a table for operator precedence but does not explain how to read the table: is it sorted with ascending or descending precedence? Are lines to be treated individually or per group? \n\n### Proposal\n\nBe more explicit, following http://msdn.microsoft.com/en-us/library/dd541587.aspx\n\nPrecedence: grouping,  unary,  multiplicative, then additive, relational and type testing, equality, AND, OR\n\nAccepted: https://www.oasis-open.org/committees/download.php/48005/odata-meeting-22_on-20130124-minutes.html#odata-203\n\nImported from [ODATA-203](https://issues.oasis-open.org/browse/ODATA-203)",
    "labels": [
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Custom Mapping to Atom Elements not defined",
    "body": "Section 9 \"Custom Mapping to Atom Elements\" mentions that property values may be mapped to predefined atom elements or custom content within an entry. It then refers to CSDL, which also doesn't define this mapping.\n\n### Proposal\n\nRemove the dangling reference\n\nAccepted: https://www.oasis-open.org/committees/download.php/48269/odata-meeting-25_on-20130214-minutes.html#odata-202\n\nImported from [ODATA-202](https://issues.oasis-open.org/browse/ODATA-202)",
    "labels": [
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow specifying a list of acceptable media types for media entities and named resource properties",
    "body": "Media entities and named resource properties may in principle link to HTTP resources of any media type. \n\nEspecially for update scenarios it is desirable to specify a list of acceptable media types for a media entity type or a named resource property.\n\n### Proposal\n\nDefine new terms in the Core vocabulary:\n\n<Term Name=\"AcceptableMediaTypes\" Type=\"Collection(String)\" AppliesTo=\"EntityType Property\">\n  <Documentation>\n    <Summary>Lists the MIME types acceptable for the annotated entity type marked with HasStream=\"true\" or the annotated named resource property  </Summary>\n  </Documentation>\n  <Annotation Term=\"Core.IsMediaType\" />\n</Term>\n\n<Term Name=\"MediaType\" Type=\"String\" AppliesTo=\"Property\">\n  <Annotation Term=\"Core.IsMediaType\" />\n  <Annotation Term=\"Core.RequiresType String=\"Edm.Binary\" />  \n</Term>\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-201\n\nImported from [ODATA-201](https://issues.oasis-open.org/browse/ODATA-201)",
    "labels": [
      "CSDL XML",
      "Vocabularies",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Handling of metadata:type attribute",
    "body": "\n\n### Proposal\n\nThe metadata:type attribute is required for properties with types other than Edm.String\n\nAccepted: https://www.oasis-open.org/committees/download.php/48411/odata-meeting-27_on-20130228-minutes.html#odata-200\n\nImported from [ODATA-200](https://issues.oasis-open.org/browse/ODATA-200)",
    "labels": [
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "$expand should be allowed to return only ids for already seen objects",
    "body": "Today, specifying $expand may return the same item multiple times. For example, if the someone is really popular, selecting ~people/$expand=friends may return the same friend for multiple people. This can lead to payload bloat when attempting to select a graph of related entities.\n\nA simple means of compression would be to allow the service to return only the id of related entities that have already been returned within a feed. This would work nicely for existing clients that track incoming entities as they generally already have logic to merge with or simply return previously retrieved objects.\n\nWe might consider a preference to allow the client to request whether or not duplicate ids are returned in full, and pick a default behavior for the service if the client doesn't specify a preference. We could use the defined return=minimal for this; currently this is used in PUT/POST to say don't return results if they haven't changed, but are undefined for a GET operation in OData.\n\n### Proposal\n\nPropose we support Entity References as described in https://www.oasis-open.org/apps/org/workgroup/odata/download.php/48082/latest with a preference of odata.allow-references\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-199\n\nImported from [ODATA-199](https://issues.oasis-open.org/browse/ODATA-199)",
    "labels": [
      "ATOM Format",
      "JSON Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow Type=\"Any\" and Type=\"Collection(Any)\" for NavigationProperty elements",
    "body": "We have encountered several situations where we know at design time that an entity will have an association to another entity (in the same or a different service), but we don't know the exact type of the related entity until run-time.\n\nOne example are notifications about \"events\" for some entity the consumer is interested in. The \"events\" service will be stable over time and may notify about events on business entities that weren't even modeled at the time the \"events\" service was published.\n\nThis is comparable to defining Named Resource Properties with the additional information that the named resource is guaranteed to be an OData entity or a collection of OData entities.\n\n### Proposal\n\nAllow Type=\"Any\" and Type=\"Collection(Any)\" for the NavigationProperty element.\n\nImported from [ODATA-198](https://issues.oasis-open.org/browse/ODATA-198)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define standard functions for edm:Apply element",
    "body": "The edm:Apply expression allows to specify functions that are applied on the client side. \n\nIt would be very helpful to define a standard set of common functions that all client libraries should implement.\n\nOtherwise we end up with a tight coupling of clients and servers because the latter define com.microsoft.Concat and com.sap.Concat.\n\n### Proposal\n\nDefine a standard function for edm:Apply:\n\n- odata.concat with a variable number of primitive-typed arguments that returns a string consisting of the concatenation of the standard serialization (as defined in the ABNF) of all argument values\n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-197\n\nImported from [ODATA-197](https://issues.oasis-open.org/browse/ODATA-197)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove sections 15.2.6 FunctionReference and 15.2.12 ParameterReference",
    "body": "Section 15.2.6 The edm:FunctionReference Expression states that its value is a reference to the return type of a function. This seems to be a leftover from removing model functions.\n\nThe example uses Function=\"org.example.person.GetAge\", which indicates that it points to a model function as it uses the same prefix as the org.example.person.Age value term, which implies that GetAge is defined in a schema (as a model function would have been) and not in an entity container (as a function import must be).\n\nAlso the introduction of Type Definitions now allows giving a name to primitive types with facets, so even primitive return types with facets can now be given a name, reducing the need for referring to implicitly defined types.\n\n\nThe meaning of a ParameterReference as defined in section 15.2.12 is unclear, and the example gives no hints on how to interpret it,\n\n\n\n### Proposal\n\nRemove all references to the following expressions:\n\nEntitySetReference, EnumMemberReference, FunctionReference, ParameterReference, PropertyReference, and ValueTermReference \n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47861/latest/odata-meeting-20_on-20130110-minutes.html\n\nImported from [ODATA-196](https://issues.oasis-open.org/browse/ODATA-196)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Simplify entity set qualification rules for NavigationPropertyBinding",
    "body": "The current draft specified four variants for qualifiying the target entity set for a navigation property binding. Two would be sufficient.\n\n### Proposal\n\nIf the target entity set is not defined in the same entity container as the enclosing EntitySet element, the entity set name must be qualified with the namespace or alias of the schema that defines the entity set, followed by the entity container. \n\nExamples:\n - EntitySet=\"SomeSet\" for an entity set in the same container as the enclosing entity set,\n - EntitySet=\"SomeModel.SomeContainer.SomeSet\" for an entity set in any container of a model in scope.\n \nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-195\n\nImported from [ODATA-195](https://issues.oasis-open.org/browse/ODATA-195)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Inside section 4.1.1 The Version Attribute, the version defined by this spec should be 4.0 and not 1.0 for the EDMX wrapper",
    "body": "The current revision of the workproduct [odata-core-v1.0-wd01-part3-csdl-2012-12-03-RH.doc](https://www.oasis-open.org/committees/download.php/47605/odata-core-v1.0-wd01-part3-csdl-2012-12-03-RH.doc) states inside the section 4.1.1 \"The Version Attribute\" (page 14 of 58), that the version for the EDMX wrapper as defined by \"it\" is 1.0, which should be 4.0 instead, shouldn't it?\n \nIt currently reads: \"This version of the specification defines version 1.0 of the EDMX Wrapper.\"\n\n(I think this is a left over from the contribution content.)\n\n### Proposal\n\nReplace the last sentence of section 4.1.1 \"The Version Attribute\" \"This version of the specification defines version 1.0 of the EDMX Wrapper.\" \nwith \"This version of the specification defines version 4.0 of the EDMX Wrapper.\"\n\nAccepted: https://www.oasis-open.org/committees/download.php/48005/odata-meeting-22_on-20130124-minutes.html#odata-194\n\nImported from [ODATA-194](https://issues.oasis-open.org/browse/ODATA-194)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Allow function imports to return entities from a different service",
    "body": "\n\n### Proposal\n\nAllow the same notation for the EntitySet attribute as in NavigationPropertyBinding, see [ODATA-195](https://issues.oasis-open.org/browse/ODATA-195) \n\nAccepted: https://www.oasis-open.org/committees/download.php/48097/odata-meeting-23_on-20130130_31-F2F-minutes.html#odata-193\n\nImported from [ODATA-193](https://issues.oasis-open.org/browse/ODATA-193)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Define vocabulary term as a replacement for StoreGeneratedPattern attribute",
    "body": "Define a Core or Behavior annotation that tells clients whether the service will choose a value for a given entity type property when creating or updating an entity of that type. Absence of this annotation tells the client that it may alter the (non-key) property.\n\nThis may be an annotation on entity set level.\n\n### Proposal\n\nDefine term StoreGeneratedPattern in the Core vocabulary with an underlying EnumType and members\n- Identity - A value is generated on insert and remains unchanged on update.\n- Computed - A value is generated on both insert and update.\n\nComment: V3 had a third value \"None\", but as this is the normal behavior, absence of the annotation seems sufficient.\n\nAlso, move existing \"Behavior\" terms to Core.\n\nAccepted: https://www.oasis-open.org/committees/download.php/48549/odata-meeting-29_on-20130314-minutes.html#odata-192\n\nImported from [ODATA-192](https://issues.oasis-open.org/browse/ODATA-192)",
    "labels": [
      "Vocabularies",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Create subsections for attributes consistently as appropriate throughout [CSDL] document",
    "body": "In the initial draft leading to the contribution for [CSDL], most attributes were defined in their own subsections beneath the element that contained them, in order to make them more referenceable and discoverable in the index. Some of that convention got lost through multiple writers/editors.\n\n### Proposal\n\nAs discussed in Nov-29-2012 meeting, please look at creating separate subsections for each attribute under the element that contains the attribute, where appropriate, in order to make it easier to look up attributes.\n\nImported from [ODATA-191](https://issues.oasis-open.org/browse/ODATA-191)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove primitive type Edm.Float as a synonym for Edm.Single",
    "body": "Currently the Atom specification and the ABNF list both Edm.Single and Edm.Float as primitive types with the same meaning.\n\n### Proposal\n\nSee summary\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47861/latest/odata-meeting-20_on-20130110-minutes.html\n\nImported from [ODATA-190](https://issues.oasis-open.org/browse/ODATA-190)",
    "labels": [
      "ABNF",
      "ATOM Format",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Remove NavigationPropertyBinding",
    "body": "It is unclear why a client needs the information provided by a NavigationPropertyBinding.\n\nAs it is optional, clients must be able to live without this information anyway.\n\n### Proposal\n\nSee summary.\n\nRejected: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47861/latest/odata-meeting-20_on-20130110-minutes.html\n\nImported from [ODATA-189](https://issues.oasis-open.org/browse/ODATA-189)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Use <Property> element also for NavigationProperty",
    "body": "The syntax of the Property and the NavigationProperty element is almost identical. The only difference is that the Type attribute of a Property MUST NOT specify an entity type, while the NavigationProperty MUST specify an entity type (or a collection of...).\n\n### Proposal\n\nRemove NavigationProperty. \n\nProperty defines a relationship if and only if its Type is an entity type or a collection of an entity type, in which case it MAY have a Partner attribute.\n\nRejected: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47861/latest/odata-meeting-20_on-20130110-minutes.html\n\nImported from [ODATA-188](https://issues.oasis-open.org/browse/ODATA-188)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Need to remove references to associations and associationsets from protocol doc",
    "body": "[ODATA-24](https://issues.oasis-open.org/browse/ODATA-24) simplified relationships by moving association information into navigation properties.\n\nIn applying the changes for [ODATA-24](https://issues.oasis-open.org/browse/ODATA-24), two references in [Core], Part I were missed:\nSection 3, Data Model talks about \"association types\" as being structural types, and section 10.4.1.1, \"Entity Set Path Expressions\" talks about deducing entitysets by backing association sets (needs to be updated to describe navigationpropertybindings). \n\n### Proposal\n\nRemove references to assocations and association sets from [Core].\n\nAccepted: https://www.oasis-open.org/committees/download.php/47919/odata-meeting-21_on-20130117-minutes.html#odata-187\n\nImported from [ODATA-187](https://issues.oasis-open.org/browse/ODATA-187)",
    "labels": [
      "Protocol",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Multiple navigationpropertybindings for the same navigation property should be prohibited",
    "body": "[ODATA-24](https://issues.oasis-open.org/browse/ODATA-24) simplifies relationships by moving association information into the navigation property. The missing piece of information; the entityset in which to find the related entity, is added through a \"navigationpropertybinding\" element within the EntitySet definition.\n\nThere are cases where the entity set of the target entit(ies) may not be known (i.e., containment, or when the targets may come from multiple different entitysets). To address these cases, the navigationpropertybinding was made optional in [ODATA-24](https://issues.oasis-open.org/browse/ODATA-24), to be provided when the target entities came from the same entityset.\n\nThe application of [ODATA-24](https://issues.oasis-open.org/browse/ODATA-24) contemplates an intermediate state, where the target entities may come from a fixed set of multiple entity sets, by allowing multiple navigationpropertybindings for the same navigation property. However, this information doesn't seem very useful, as the client wouldn't know, for any particular instance, which of the multiple entitysets the instance belonged to. Thus, allowing multiple navigationpropertybindings for the same navigation property seems to add unnecessary complexity for little or no added benefit.\n\n### Proposal\n\nDon't allow multiple navigationpropertybindings for a single navigationproperty. Navigationpropertybindings are used only when all related entities are known to come from a single entity set.\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47861/latest/odata-meeting-20_on-20130110-minutes.html\n\nImported from [ODATA-186](https://issues.oasis-open.org/browse/ODATA-186)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Nullable attribute should be required to be false for collection valued navigation properties.",
    "body": "[ODATA-24](https://issues.oasis-open.org/browse/ODATA-24) simplified relationships by moving association information into the navigation property. In doing so, cardinality was represented by the type of the navigation property being either a single entity or a collection of entities. For a single entity, optionality of the entity (i.e., 0 or 1) is represented by a nullable attribute (whose default is false).\n\nFor navigation properties that return collections of entities, nullable=true doesn't make sense; the collection always exists, it may just be empty. Thus, collection-valued navigation properties should either:\n1) always specify nullable=false \n2) explicitly prohibit specifying nullable=true, or\n3) disallow the nullable attribute\n\nNote that there is precedence for the set of valid attributes depending on the type (i.e., in specifying property facets).\n\n### Proposal\n\nprohibit specifying the nullable attribute for collection-valued navigation properties\n\n\nImported from [ODATA-185](https://issues.oasis-open.org/browse/ODATA-185)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "Relationships in CSDL examples should include Partner attribute",
    "body": "In [ODATA-24](https://issues.oasis-open.org/browse/ODATA-24) we simplified how relationships were expressed, removing the concepts of explicit associations and association sets and adding information to the navigation property.\n\nWe added the \"Partner\" attribute to the navigation property, and specified that it SHOULD be used for bi-directional relationships. However, the example in Section 7.3 of the [CSDL] specification, and other places, do not include the partner attribute in bi-directional relationships. \n\n### Proposal\n\nAdd the \"Partner\" attribute to navigation properties representing bi-directional relationships in section 7.3 of [CSDL] and throughout.\n\nImported from [ODATA-184](https://issues.oasis-open.org/browse/ODATA-184)",
    "labels": [
      "CSDL XML",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  },
  {
    "title": "The same navigation property should not be specified in multiple $expands",
    "body": "We should not allow the same navigation property to be specified multiple times in a $expand. This was required for the path syntax but is not required, and offers ambiguity, with the new format (i.e., what if I have two $expands for the same navigation property with different $filters applied?) \n\n### Proposal\n\nExplicitly specify that the same navigation property must not appear more than once in an $expand clause.\n\nAccepted: https://www.oasis-open.org/apps/org/workgroup/odata/download.php/47861/latest/odata-meeting-20_on-20130110-minutes.html\n\nImported from [ODATA-183](https://issues.oasis-open.org/browse/ODATA-183)",
    "labels": [
      "URL Conventions",
      "V4.0_WD01"
    ],
    "assignees": [],
    "state": "closed",
    "state_reason": "completed"
  }
]